<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Technique on Code.Music.Photo</title>
    <link>http://nianze.ml/tags/technique/</link>
    <description>Recent content in Technique on Code.Music.Photo</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Mon, 21 May 2018 18:27:39 -0400</lastBuildDate>
    
	<atom:link href="http://nianze.ml/tags/technique/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>[MECpp]Item-33 Make Non-Leaf Classes Abstract</title>
      <link>http://nianze.ml/2018/05/make-non-leaf-classes-abstract/</link>
      <pubDate>Mon, 21 May 2018 18:27:39 -0400</pubDate>
      
      <guid>http://nianze.ml/2018/05/make-non-leaf-classes-abstract/</guid>
      <description>&lt;p&gt;The general rule: non-leaf classes should be abstract. This will yields dividends in the form of increased reliability, robustness, comprehensibility, and extensibility throughout our software.
&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>[MECpp]Item-32 Program in the Future Tense</title>
      <link>http://nianze.ml/2018/05/program-in-the-future-tense/</link>
      <pubDate>Thu, 17 May 2018 19:26:17 -0400</pubDate>
      
      <guid>http://nianze.ml/2018/05/program-in-the-future-tense/</guid>
      <description>&lt;p&gt;Things change. Future tense thinking increases the reusability of the code we write, enhances its maintainability, makes it more robust, and facilitates gracefully in an environment where change is a certainty.
&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>[MECpp]Item-28 Smart Pointers</title>
      <link>http://nianze.ml/2018/05/smart-pointers/</link>
      <pubDate>Sat, 05 May 2018 16:38:03 -0400</pubDate>
      
      <guid>http://nianze.ml/2018/05/smart-pointers/</guid>
      <description>&lt;p&gt;&lt;em&gt;Smart pointers&lt;/em&gt; are designed to look, act, and feel like built-in pointers, but to offer greater functionality.
&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>[MECpp]Item-27 Requiring or Prohibiting Heap Based Objects</title>
      <link>http://nianze.ml/2018/05/requiring-or-prohibiting-heap-based-objects/</link>
      <pubDate>Tue, 01 May 2018 00:00:00 +0000</pubDate>
      
      <guid>http://nianze.ml/2018/05/requiring-or-prohibiting-heap-based-objects/</guid>
      <description>&lt;p&gt;Techniques for requiring or prohibiting heap-based objects
&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>[MECpp]Item-26 Limiting the Number of Objects of a Class</title>
      <link>http://nianze.ml/2018/04/limiting-the-number-of-objects-of-a-class/</link>
      <pubDate>Tue, 24 Apr 2018 15:03:26 -0400</pubDate>
      
      <guid>http://nianze.ml/2018/04/limiting-the-number-of-objects-of-a-class/</guid>
      <description>&lt;p&gt;Combining object-counting technique with the pseudo-constructors, we can limit the number of objects of a class.
&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>[MECpp]Item-25 Virtualizing Constructors and Non-Member Functions</title>
      <link>http://nianze.ml/2018/04/virtualizing-constructors-and-non-member-functions/</link>
      <pubDate>Mon, 23 Apr 2018 13:30:56 -0400</pubDate>
      
      <guid>http://nianze.ml/2018/04/virtualizing-constructors-and-non-member-functions/</guid>
      <description>&lt;p&gt;Depending on the different input or dynamic types of function parameters, &amp;ldquo;virtualization&amp;rdquo; is a useful technique to construct new objects of different types accordingly, or to conceive of non-member functions whose behavior changes accordingly.
&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>[MECpp]Item-24 Understand the Costs of Virtual Functions, Multiple Inheritance, Virtual Base Classes, and RTTI</title>
      <link>http://nianze.ml/2018/04/costs-of-virtual-functions-multiple-inheritance-virtual-base-classes-and-rtti/</link>
      <pubDate>Fri, 20 Apr 2018 15:32:45 -0400</pubDate>
      
      <guid>http://nianze.ml/2018/04/costs-of-virtual-functions-multiple-inheritance-virtual-base-classes-and-rtti/</guid>
      <description>&lt;p&gt;It&amp;rsquo;s important to have a basic understanding of the cost of some C++ features that can have a noticeable impact on the size of objects and the speed at which member functions execute.
&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>[MECpp]Item-23 Consider Alternative Libraries</title>
      <link>http://nianze.ml/2018/04/consider-alternative-libraries/</link>
      <pubDate>Thu, 19 Apr 2018 13:32:15 -0400</pubDate>
      
      <guid>http://nianze.ml/2018/04/consider-alternative-libraries/</guid>
      <description>&lt;p&gt;Different libraries offering similar functionality often feature different performance trade-offs, so we might be able to remove bottlenecks by replacing one library with another.
&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>[MECpp]Item-22 Consider Using op= Instead of Stand Alone op</title>
      <link>http://nianze.ml/2018/04/consider-using-op-instead-of-stand-alone-op/</link>
      <pubDate>Wed, 18 Apr 2018 14:09:10 -0400</pubDate>
      
      <guid>http://nianze.ml/2018/04/consider-using-op-instead-of-stand-alone-op/</guid>
      <description>&lt;p&gt;Assignment versions of operators (such as &lt;code&gt;operator+=&lt;/code&gt;) tend to be more efficient than stand-alone versions of those operators (e.g., &lt;code&gt;operator+&lt;/code&gt;).
&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>[MECpp]Item-21 Overload to Avoid Implicit Type Conventions</title>
      <link>http://nianze.ml/2018/04/overload-to-avoid-implicit-type-conventions/</link>
      <pubDate>Tue, 17 Apr 2018 15:42:12 -0400</pubDate>
      
      <guid>http://nianze.ml/2018/04/overload-to-avoid-implicit-type-conventions/</guid>
      <description>&lt;p&gt;Overloading to avoid temporaries.
&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>[MECpp]Item-20 Facilitate the Return Value Optimization</title>
      <link>http://nianze.ml/2018/04/facilitate-the-return-value-optimization/</link>
      <pubDate>Mon, 16 Apr 2018 00:00:00 +0000</pubDate>
      
      <guid>http://nianze.ml/2018/04/facilitate-the-return-value-optimization/</guid>
      <description>&lt;p&gt;Take use of the &lt;em&gt;return value optimization&lt;/em&gt; in compilers.
&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>[MECpp]Item-19 Understand the Origin of Temporary Objects</title>
      <link>http://nianze.ml/2018/04/understand-the-origin-of-temporary-objects/</link>
      <pubDate>Fri, 13 Apr 2018 17:06:28 -0400</pubDate>
      
      <guid>http://nianze.ml/2018/04/understand-the-origin-of-temporary-objects/</guid>
      <description>&lt;p&gt;Unnamed non-heap objects are invisible temporary objects in C++.
&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>[MECpp]Item-18 Amortize the Cost of Expected Computations</title>
      <link>http://nianze.ml/2018/04/amortize-the-cost-of-expected-computations/</link>
      <pubDate>Thu, 12 Apr 2018 15:31:55 -0400</pubDate>
      
      <guid>http://nianze.ml/2018/04/amortize-the-cost-of-expected-computations/</guid>
      <description>&lt;p&gt;The old Computer Science story: trade space for time&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:1&#34;&gt;&lt;a href=&#34;#fn:1&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;.
&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>[MECpp]Item-17 Consider Using Lazy Evaluation</title>
      <link>http://nianze.ml/2018/04/consider-using-lazy-evaluation/</link>
      <pubDate>Wed, 11 Apr 2018 14:02:18 -0400</pubDate>
      
      <guid>http://nianze.ml/2018/04/consider-using-lazy-evaluation/</guid>
      <description>&lt;p&gt;The best computations are those we never perform at all.
&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>[MECpp]Item-16 Remember 80-20 Rule</title>
      <link>http://nianze.ml/2018/04/remember-80-20-rule/</link>
      <pubDate>Tue, 10 Apr 2018 13:37:45 -0400</pubDate>
      
      <guid>http://nianze.ml/2018/04/remember-80-20-rule/</guid>
      <description>&lt;p&gt;The 80-20 rule states that 80 percent of a program&amp;rsquo;s resources are used by about 20 percent of the code.
&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>[MECpp]Item-15 Understand the Costs of Exception Handling</title>
      <link>http://nianze.ml/2018/04/understand-the-costs-of-exception-handling/</link>
      <pubDate>Mon, 09 Apr 2018 18:10:06 -0400</pubDate>
      
      <guid>http://nianze.ml/2018/04/understand-the-costs-of-exception-handling/</guid>
      <description>&lt;p&gt;Exception handling has costs, and we pay at least some of them even if we never use the keywords &lt;code&gt;try&lt;/code&gt;, &lt;code&gt;throw&lt;/code&gt;, or &lt;code&gt;catch&lt;/code&gt;.
&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>[MECpp]Item-14 Use Exception Specifications Judiciously</title>
      <link>http://nianze.ml/2018/04/use-exception-specifications-judiciously/</link>
      <pubDate>Sun, 08 Apr 2018 23:51:00 -0400</pubDate>
      
      <guid>http://nianze.ml/2018/04/use-exception-specifications-judiciously/</guid>
      <description>&lt;p&gt;Exception specifications provide a documentation aid and an enforcement mechanism for constraints on exception usage, but they are only partly checked by compilers and they are easy to violate inadvertently.
&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>[MECpp]Item-13 Catch Exceptions by Reference</title>
      <link>http://nianze.ml/2018/04/catch-exceptions-by-reference/</link>
      <pubDate>Thu, 05 Apr 2018 18:57:13 -0400</pubDate>
      
      <guid>http://nianze.ml/2018/04/catch-exceptions-by-reference/</guid>
      <description>&lt;p&gt;If catching by reference, we sidestep the questions about object deletion, avoid slicing exception objects, retain the ability to catch standard exceptions, and limit the number of times exception objects being copied.
&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>[MECpp]Item-12 Understand How Throwing an Exception Differs From Passing a Parameter or Calling a Virtual Function</title>
      <link>http://nianze.ml/2018/04/understand-how-throwing-an-exception-differs-from-passing-a-parameter-or-calling-a-virtual-function/</link>
      <pubDate>Wed, 04 Apr 2018 11:28:07 -0400</pubDate>
      
      <guid>http://nianze.ml/2018/04/understand-how-throwing-an-exception-differs-from-passing-a-parameter-or-calling-a-virtual-function/</guid>
      <description>&lt;p&gt;There are three primary ways in which passing an object to a function or using that object to invoke a virtual function differs from throwing the object as an exception.
&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>[MECpp]Item-11 Prevent Exceptions From Leaving Destructors</title>
      <link>http://nianze.ml/2018/04/prevent-exceptions-from-leaving-destructors/</link>
      <pubDate>Tue, 03 Apr 2018 10:54:39 -0400</pubDate>
      
      <guid>http://nianze.ml/2018/04/prevent-exceptions-from-leaving-destructors/</guid>
      <description>&lt;p&gt;Keep exceptions from propagating out of destructors to prevent C++ calling &lt;code&gt;terminate&lt;/code&gt; during the statck-unwinding part of exception propagation and ensure that every neccessary cleanup is accomplished.
&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>[MECpp]Item-10 Prevent Resource Leaks in Constructors</title>
      <link>http://nianze.ml/2018/04/prevent-resource-leaks-in-constructors/</link>
      <pubDate>Mon, 02 Apr 2018 15:56:25 -0400</pubDate>
      
      <guid>http://nianze.ml/2018/04/prevent-resource-leaks-in-constructors/</guid>
      <description>&lt;p&gt;Replace pointer class members with their corresponding smart pointer objects to fortify the constructors against resource leaks in the presence of exceptions, to eliminate the need to manually deallocate resources in destructors, and to allow &lt;code&gt;const&lt;/code&gt; member pointers to be handled in the smae graceful fashion as non-&lt;code&gt;const&lt;/code&gt; pointers.
&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>[MECpp]Item-9 Use Destructors to Prevent Resource Leaks</title>
      <link>http://nianze.ml/2018/04/use-destructors-to-prevent-resource-leaks/</link>
      <pubDate>Sun, 01 Apr 2018 00:00:00 +0000</pubDate>
      
      <guid>http://nianze.ml/2018/04/use-destructors-to-prevent-resource-leaks/</guid>
      <description>&lt;p&gt;To avoid resource leaks in the presence of exceptions, we can encapsulate resources inside objects.
&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>[MECpp]Item-8 Understand the Different Meanings of New and Delete</title>
      <link>http://nianze.ml/2018/03/understand-the-different-meanings-of-new-and-delete/</link>
      <pubDate>Fri, 30 Mar 2018 17:09:04 -0400</pubDate>
      
      <guid>http://nianze.ml/2018/03/understand-the-different-meanings-of-new-and-delete/</guid>
      <description>&lt;p&gt;The behaviors of &lt;code&gt;new&lt;/code&gt; operator and &lt;code&gt;operator new&lt;/code&gt; is different.
&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>[MECpp]Item-7 Never Overload &#39;&amp;&amp;&#39;, &#39;||&#39;, or &#39;,&#39;</title>
      <link>http://nianze.ml/2018/03/never-overload-and-or-comma-operator/</link>
      <pubDate>Thu, 29 Mar 2018 11:18:24 -0400</pubDate>
      
      <guid>http://nianze.ml/2018/03/never-overload-and-or-comma-operator/</guid>
      <description>&lt;p&gt;If we don&amp;rsquo;t have a good reason for overloading an operator, don&amp;rsquo;t overload it. In the case of &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt;, &lt;code&gt;||&lt;/code&gt;, and &lt;code&gt;,&lt;/code&gt;, it&amp;rsquo;s difficult to have a good reason: we can&amp;rsquo;t make them behave the way they&amp;rsquo;re supposed to.
&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>[MECpp]Item-6 Distinguish Between Prefix and Postfix Forms of Increment and Decrement Operators</title>
      <link>http://nianze.ml/2018/03/distinguish-between-prefix-and-postfix-forms-of-increment-and-decrement-operators/</link>
      <pubDate>Wed, 28 Mar 2018 13:03:10 -0400</pubDate>
      
      <guid>http://nianze.ml/2018/03/distinguish-between-prefix-and-postfix-forms-of-increment-and-decrement-operators/</guid>
      <description>&lt;p&gt;The prefix and postfix forms of increment and decrement operators return &lt;em&gt;different types&lt;/em&gt;: prefix forms return a reference, while postfix forms return a &lt;em&gt;const&lt;/em&gt; object. For efficiency, prefer prefix forms unless the behavior of postfix ones is necessary. To guarantee consistency, implement postfix operators in terms of the prefix operators.
&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>[MECpp]Item-5 Be Wary of User Defined Conversion Functions</title>
      <link>http://nianze.ml/2018/03/be-wary-of-user-defined-conversion-functions/</link>
      <pubDate>Tue, 27 Mar 2018 18:53:56 -0400</pubDate>
      
      <guid>http://nianze.ml/2018/03/be-wary-of-user-defined-conversion-functions/</guid>
      <description>&lt;p&gt;Implicit type conversions usually lead to more harm than good, so don&amp;rsquo;t provide conversion functions unless we&amp;rsquo;re sure we want them.
&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>[MECpp]Item-4 Avoid Gratuitous Default Constructors</title>
      <link>http://nianze.ml/2018/03/avoid-gratuitous-default-constructors/</link>
      <pubDate>Mon, 26 Mar 2018 11:21:08 -0400</pubDate>
      
      <guid>http://nianze.ml/2018/03/avoid-gratuitous-default-constructors/</guid>
      <description>&lt;p&gt;Including meaningless default constructors affects the efficiency of classes, so avoiding them in classes guarantees fully-initialized objects, with the cost of some limits on how such classes can be used.
&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>[MECpp]Item-3 Never Treat Arrays Polymorphically</title>
      <link>http://nianze.ml/2018/03/never-treat-arrays-polymorphically/</link>
      <pubDate>Fri, 23 Mar 2018 18:59:16 -0400</pubDate>
      
      <guid>http://nianze.ml/2018/03/never-treat-arrays-polymorphically/</guid>
      <description>&lt;p&gt;Array operations almost always involve pointer arithmetic, so arrays and polymorphism don&amp;rsquo;t mix.
&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>[MECpp]Item-1 Distinguish Between Pointers and References</title>
      <link>http://nianze.ml/2018/03/distinguish-between-pointers-and-references/</link>
      <pubDate>Thu, 22 Mar 2018 16:47:15 -0400</pubDate>
      
      <guid>http://nianze.ml/2018/03/distinguish-between-pointers-and-references/</guid>
      <description>&lt;p&gt;More effective C++: Use references when we already have something to refer to and never want to refer to anything else, or when implementing operators whose syntactic requires us to do so.
&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Item-52 Write placement delete if you write placement new</title>
      <link>http://nianze.ml/2018/03/write-placement-delete-if-you-write-placement-new/</link>
      <pubDate>Wed, 21 Mar 2018 15:48:12 -0400</pubDate>
      
      <guid>http://nianze.ml/2018/03/write-placement-delete-if-you-write-placement-new/</guid>
      <description>&lt;p&gt;When we write a placement version of &lt;code&gt;operator new&lt;/code&gt;, be sure to write the corresponding placement version of &lt;code&gt;operator delete&lt;/code&gt; to avoid subtle, intermittent memory leaks. When we do so, pay attention not to unintentionally hide the normal versions of &lt;code&gt;new&lt;/code&gt; and &lt;code&gt;delete&lt;/code&gt;
&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Item-51 Adhere to convention when writing new and delete</title>
      <link>http://nianze.ml/2018/03/adhere-to-convention-when-writing-new-and-delete/</link>
      <pubDate>Tue, 20 Mar 2018 14:32:24 -0400</pubDate>
      
      <guid>http://nianze.ml/2018/03/adhere-to-convention-when-writing-new-and-delete/</guid>
      <description>&lt;p&gt;&lt;code&gt;operator new&lt;/code&gt; should contain an infinite loop trying to allocate memory, should call the new-handler if it can&amp;rsquo;t satisfy a memory request, and should handle requests for zero bytes; class-specific versions should handle requests for larger blocks than expected. &lt;code&gt;operator delete&lt;/code&gt; should do nothing if passed a pointer that is null; class specific versions should handle blocks that are larger than expected.
&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Item-50 Understand when it makes sense to replace new and delete</title>
      <link>http://nianze.ml/2018/03/understand-when-it-makes-sense-to-replace-new-and-delete/</link>
      <pubDate>Mon, 19 Mar 2018 10:54:04 -0400</pubDate>
      
      <guid>http://nianze.ml/2018/03/understand-when-it-makes-sense-to-replace-new-and-delete/</guid>
      <description>&lt;p&gt;There are many valid reasons for writing custom versions of &lt;code&gt;new&lt;/code&gt; and &lt;code&gt;delete&lt;/code&gt;, including improving performance, debugging heap usage errors, and collecting heap usage information.
&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Item-49 Understand the behavior of the new handler</title>
      <link>http://nianze.ml/2018/03/understand-the-behavior-of-the-new-handler/</link>
      <pubDate>Fri, 16 Mar 2018 19:52:09 -0400</pubDate>
      
      <guid>http://nianze.ml/2018/03/understand-the-behavior-of-the-new-handler/</guid>
      <description>&lt;p&gt;&lt;code&gt;set-new-handler&lt;/code&gt; allows you to specify a function to be called when memory allocation requests cannot be satisfied.
&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Item-48 Be aware of template metaprogramming</title>
      <link>http://nianze.ml/2018/03/be-aware-of-template-metaprogramming/</link>
      <pubDate>Thu, 15 Mar 2018 23:00:22 -0400</pubDate>
      
      <guid>http://nianze.ml/2018/03/be-aware-of-template-metaprogramming/</guid>
      <description>&lt;p&gt;Template metaprogramming can shift work from runtime to compile-time (thus enabling earlier error dettection and higher runtime performance), can be used to generate custom code based on combinations of policy choices, and can also be used to avoid generating code inappropriate for particular types.
&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Item-47 Use traits classes for information about types</title>
      <link>http://nianze.ml/2018/03/use-traits-classes-for-information-about-types/</link>
      <pubDate>Wed, 14 Mar 2018 18:49:03 -0400</pubDate>
      
      <guid>http://nianze.ml/2018/03/use-traits-classes-for-information-about-types/</guid>
      <description>&lt;p&gt;Implemented by templates and template specializations, traits classes make information about types available during compilation. Combining traints with overloading, it is possible to perform compile-time &lt;code&gt;if...else&lt;/code&gt; tests on types.
&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Item-46 Define non-member function inside templates when type conversions are desired</title>
      <link>http://nianze.ml/2018/03/define-non-member-function-inside-templates-when-type-conversions-are-desired/</link>
      <pubDate>Tue, 13 Mar 2018 12:23:40 -0400</pubDate>
      
      <guid>http://nianze.ml/2018/03/define-non-member-function-inside-templates-when-type-conversions-are-desired/</guid>
      <description>&lt;p&gt;When writing a class template that offers functions related to the template that support implicit type conversions on all parameters, define those functions as friends inside the class template.
&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Item-45 Use member function templates to accept all compatible types</title>
      <link>http://nianze.ml/2018/03/use-member-function-templates-to-accept-all-compatible-types/</link>
      <pubDate>Mon, 12 Mar 2018 20:14:47 -0400</pubDate>
      
      <guid>http://nianze.ml/2018/03/use-member-function-templates-to-accept-all-compatible-types/</guid>
      <description>&lt;p&gt;In order to implicitly convert all compatible types for a template class, we neet not a constructor &lt;em&gt;function&lt;/em&gt; but a constructor &lt;em&gt;template&lt;/em&gt; - &lt;em&gt;member functoin templates&lt;/em&gt; that generate member functions of a class.
&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Item-44 Factor parameter-independent code out of templates</title>
      <link>http://nianze.ml/2018/03/factor-parameter-independent-code-out-of-templates/</link>
      <pubDate>Sat, 10 Mar 2018 20:24:42 -0500</pubDate>
      
      <guid>http://nianze.ml/2018/03/factor-parameter-independent-code-out-of-templates/</guid>
      <description>&lt;p&gt;Templates generate multiple classes and multiple functions, so any template code not dependent on a template parameter (either non-type template parameters or type parameters) causes bloat: eliminate bloat due to non-type template parameters by replacing template parameters with function parameters or class data members; reduce bloat caused from type parameters by sharing implementations for instantiation types with identical binary representations.
&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Item-43 Know how to access names in templatized base classes</title>
      <link>http://nianze.ml/2018/03/know-how-to-access-names-in-templatized-base-classes/</link>
      <pubDate>Fri, 09 Mar 2018 21:48:26 -0500</pubDate>
      
      <guid>http://nianze.ml/2018/03/know-how-to-access-names-in-templatized-base-classes/</guid>
      <description>&lt;p&gt;In derived class templates, refer to names in base class templates via a &lt;code&gt;this-&amp;gt;&lt;/code&gt; prefix, via &lt;code&gt;using&lt;/code&gt; declarations, or via an explicit base class qualification.
&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Item-42 Understand the two meanings of typename</title>
      <link>http://nianze.ml/2018/03/understand-the-two-meanings-of-typename/</link>
      <pubDate>Thu, 08 Mar 2018 19:19:28 -0500</pubDate>
      
      <guid>http://nianze.ml/2018/03/understand-the-two-meanings-of-typename/</guid>
      <description>&lt;p&gt;When declaring template parameters, both &lt;code&gt;class&lt;/code&gt; and &lt;code&gt;typename&lt;/code&gt; are interchangeable. When identifying nested dependent type names, use &lt;code&gt;typename&lt;/code&gt;, except in base class lists or as a base class identifier in a member initialization list.
&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Item-41 Understand inplicit interfaces and compile time polymorphism</title>
      <link>http://nianze.ml/2018/03/understand-inplicit-interfaces-and-compile-time-polymorphism/</link>
      <pubDate>Wed, 07 Mar 2018 14:21:33 -0500</pubDate>
      
      <guid>http://nianze.ml/2018/03/understand-inplicit-interfaces-and-compile-time-polymorphism/</guid>
      <description>&lt;p&gt;Classes support explicit interfaces based on function signatures, as well as runtime polymorphism through virtual functions; templates support implicit interfaces based on valid expressions, as well as compile-time polymorphism through template instantiation and function overloading resolution.
&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Item-40 Use multiple inheritance judiciously</title>
      <link>http://nianze.ml/2018/03/use-multiple-inheritance-judiciously/</link>
      <pubDate>Tue, 06 Mar 2018 17:35:59 -0500</pubDate>
      
      <guid>http://nianze.ml/2018/03/use-multiple-inheritance-judiciously/</guid>
      <description>&lt;p&gt;Being more complex than single inheritance, Multiple inheritance (MI) can lead to ambiguity issues and to the need for virtual inheritance, the latter of which imposes costs in size, speed, and complexity of initialization and assignment, so it&amp;rsquo;s more practical to make &amp;ldquo;empty&amp;rdquo; virtual base classes.
&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Item-39 Use private inheritance judiciously</title>
      <link>http://nianze.ml/2018/03/use-private-inheritance-judiciously/</link>
      <pubDate>Mon, 05 Mar 2018 18:42:43 -0500</pubDate>
      
      <guid>http://nianze.ml/2018/03/use-private-inheritance-judiciously/</guid>
      <description>&lt;p&gt;Private inheritance means is-implemented-in-terms-of. It is usually inferior to composition, but it makes sense when a derived class needs access to protected base members or needs to redefine inherited virtual functions. For library developers who strive to minimize object sizes, it also offers the ability of empty base optimization.
&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Item-38 Model &#39;has-a&#39; or &#39;is-implemented-in-terms-of&#39; through composition</title>
      <link>http://nianze.ml/2018/03/model-has-a-or-is-implemented-in-terms-of-through-composition/</link>
      <pubDate>Sun, 04 Mar 2018 15:49:31 -0500</pubDate>
      
      <guid>http://nianze.ml/2018/03/model-has-a-or-is-implemented-in-terms-of-through-composition/</guid>
      <description>&lt;p&gt;In the application domain, composition means has-a. In the implementation domain, it means is-implemented-in-terms-of.
&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Item-37 Never redefine a function&#39;s inherited default parameter value</title>
      <link>http://nianze.ml/2018/03/never-redefine-a-functions-inherited-default-parameter-value/</link>
      <pubDate>Fri, 02 Mar 2018 21:15:36 -0500</pubDate>
      
      <guid>http://nianze.ml/2018/03/never-redefine-a-functions-inherited-default-parameter-value/</guid>
      <description>&lt;p&gt;Defaul parameter values are statically bound, while virtual function - the only functions we should be overriding - are dynamically bound.
&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Item-36 Never redefine an inherited non-virtaul function</title>
      <link>http://nianze.ml/2018/03/never-redefine-an-inherited-non-virtaul-function/</link>
      <pubDate>Thu, 01 Mar 2018 20:22:17 -0500</pubDate>
      
      <guid>http://nianze.ml/2018/03/never-redefine-an-inherited-non-virtaul-function/</guid>
      <description>&lt;p&gt;A generalized basic rule from item 7.
&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Item-35 Consider Alternatives to Virtual Functions</title>
      <link>http://nianze.ml/2018/02/consider-alternatives-to-virtual-functions/</link>
      <pubDate>Wed, 28 Feb 2018 20:27:02 -0500</pubDate>
      
      <guid>http://nianze.ml/2018/02/consider-alternatives-to-virtual-functions/</guid>
      <description>&lt;p&gt;Alternatives to virtual functions include the NVI idiom (as an example of the Template Method design pattern) and various forms of the Strategy design pattern.
&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Item-34 Differentiate between inheritance of interface and inheritance of implementation</title>
      <link>http://nianze.ml/2018/02/differentiate-inheritance-of-interface-from-inheritance-of-implementation/</link>
      <pubDate>Tue, 27 Feb 2018 20:53:53 -0500</pubDate>
      
      <guid>http://nianze.ml/2018/02/differentiate-inheritance-of-interface-from-inheritance-of-implementation/</guid>
      <description>&lt;p&gt;Inheritance of interface is different from inheritance of implementatino.
&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Item-33 Avoid hiding inherited names</title>
      <link>http://nianze.ml/2018/02/avoid-hiding-inherited-names/</link>
      <pubDate>Mon, 26 Feb 2018 20:18:55 -0500</pubDate>
      
      <guid>http://nianze.ml/2018/02/avoid-hiding-inherited-names/</guid>
      <description>&lt;p&gt;Names in derived classes hide names in base classes, which is not desirable in public inheritance. To fix it, employ &lt;code&gt;using&lt;/code&gt; declarations or forwarding functions to make hidden names visible again.
&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Item-32 Make sure public inheritance models &#34;Is-A&#34;</title>
      <link>http://nianze.ml/2018/02/make-sure-public-inheritance-models-is-a/</link>
      <pubDate>Fri, 23 Feb 2018 12:59:53 -0500</pubDate>
      
      <guid>http://nianze.ml/2018/02/make-sure-public-inheritance-models-is-a/</guid>
      <description>&lt;p&gt;Everything that applies to base classes must also apply to derived classes in public inheritance, for every derived class object &lt;em&gt;is&lt;/em&gt; a base class object.
&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Item-31 Minimize compilation dependencies between files</title>
      <link>http://nianze.ml/2018/02/minimize-compilation-dependencies-between-files/</link>
      <pubDate>Thu, 22 Feb 2018 00:00:00 +0000</pubDate>
      
      <guid>http://nianze.ml/2018/02/minimize-compilation-dependencies-between-files/</guid>
      <description>&lt;p&gt;To minimize compilation dependencies, depend on declarations instead of definitions via techniques such as Handle classes and Interface classes.
&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Item-30 Understand ins and outs of inlining</title>
      <link>http://nianze.ml/2018/02/ins-and-outs-of-inlining/</link>
      <pubDate>Wed, 21 Feb 2018 00:00:00 +0000</pubDate>
      
      <guid>http://nianze.ml/2018/02/ins-and-outs-of-inlining/</guid>
      <description>&lt;p&gt;Limit most inlining to small, frequently called functions to facilitate debugging and binary upgradability, minimize potential code bloat, and maximize the chances of greater program speed.
&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Item-29 Strive for exception-safe code</title>
      <link>http://nianze.ml/2018/02/strive-for-exception-safe-code/</link>
      <pubDate>Tue, 20 Feb 2018 18:23:38 -0500</pubDate>
      
      <guid>http://nianze.ml/2018/02/strive-for-exception-safe-code/</guid>
      <description>&lt;p&gt;Exception-safe functions leak no resources and allow no data structures to become corrupted, even when exceptions are thrown. Such functions offer the basic, strong, and nothrow guarantees.
&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Item-28 Avoid returning handles to object internals</title>
      <link>http://nianze.ml/2018/02/avoid-return-handles-to-obejct-internals/</link>
      <pubDate>Fri, 16 Feb 2018 12:26:14 -0500</pubDate>
      
      <guid>http://nianze.ml/2018/02/avoid-return-handles-to-obejct-internals/</guid>
      <description>&lt;p&gt;Avoid returning handles to object internals to increase encapsulation, help &lt;code&gt;const&lt;/code&gt; member functions act &lt;code&gt;const&lt;/code&gt;, and minimize the creation of dangling handles.
&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Item-27 Minimize_casting</title>
      <link>http://nianze.ml/2018/02/minimize-casting/</link>
      <pubDate>Thu, 15 Feb 2018 17:43:53 -0500</pubDate>
      
      <guid>http://nianze.ml/2018/02/minimize-casting/</guid>
      <description>&lt;p&gt;Avoid casts and develop a cast-free alternative whenever practical, especially &lt;code&gt;dynamic_cast&lt;/code&gt; in performance-sensitive code.
&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Item-26 Postpone variable definitions as long as possible</title>
      <link>http://nianze.ml/2018/02/postpone-variable-definitions/</link>
      <pubDate>Wed, 14 Feb 2018 10:50:18 -0500</pubDate>
      
      <guid>http://nianze.ml/2018/02/postpone-variable-definitions/</guid>
      <description>&lt;p&gt;Postponing variable definitions as long as possible increases program clarity and improves progranm efficiency.
&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Item-25 Consider support for a non-throwing swap</title>
      <link>http://nianze.ml/2018/02/support-for-a-non-throwing-swap/</link>
      <pubDate>Tue, 13 Feb 2018 19:11:15 -0500</pubDate>
      
      <guid>http://nianze.ml/2018/02/support-for-a-non-throwing-swap/</guid>
      <description>&lt;p&gt;When &lt;code&gt;std::swap&lt;/code&gt; would be inefficient for your type,provide a non-throwing &lt;code&gt;swap&lt;/code&gt; member function, a non-member &lt;code&gt;swap&lt;/code&gt; calling the member, and possibly a specialized &lt;code&gt;std::swap&lt;/code&gt; for the case of classes (not templates).
&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Item-24 Declare non-member functions when type conversions should apply to all parameters</title>
      <link>http://nianze.ml/2018/02/when-to-declare-non-member-functions/</link>
      <pubDate>Mon, 12 Feb 2018 22:47:20 -0500</pubDate>
      
      <guid>http://nianze.ml/2018/02/when-to-declare-non-member-functions/</guid>
      <description>&lt;p&gt;If we need type conversions on all parameters to a function including the one pointed to by the &lt;code&gt;this&lt;/code&gt; pointer, the function must be a non-member.
&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Item-23 Prefer non-member non-friend function to member function</title>
      <link>http://nianze.ml/2018/02/prefer-non-member-non-friend-function-to-member-function/</link>
      <pubDate>Sun, 11 Feb 2018 21:33:28 -0500</pubDate>
      
      <guid>http://nianze.ml/2018/02/prefer-non-member-non-friend-function-to-member-function/</guid>
      <description>&lt;p&gt;Prefer non-member non-friend functions to member functions for better encapsulation, packaging flexibility, and functional extensibility.
&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Item-22 Declare data members private</title>
      <link>http://nianze.ml/2018/02/declare-data-members-private/</link>
      <pubDate>Sat, 10 Feb 2018 00:00:00 +0000</pubDate>
      
      <guid>http://nianze.ml/2018/02/declare-data-members-private/</guid>
      <description>&lt;p&gt;Declaring data members &lt;code&gt;private&lt;/code&gt; gives clients syntactically uniform access to data, affords fine-grained access control, allows invariants to be enforced, and offers class authors implementation flexibility.
&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Item-21 Don&#39;t return a reference when we have to return an object</title>
      <link>http://nianze.ml/2018/02/do-not-return-a-ref-when-must-return-an-object/</link>
      <pubDate>Fri, 09 Feb 2018 18:02:23 -0500</pubDate>
      
      <guid>http://nianze.ml/2018/02/do-not-return-a-ref-when-must-return-an-object/</guid>
      <description>&lt;p&gt;Never return a pointer or reference to a local stack object, a refenrence to a heap-allocated object, or a pointer or reference to a local static object if there is a change that more than one such object will be needed (item 4 provides a &amp;ldquo;counter&amp;rdquo; example that is reasonable in single-threaded environments).
&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Item-20 Perfer pass-by-reference-to-const to pass-by-value</title>
      <link>http://nianze.ml/2018/02/perfer-pass-by-reference-to-const/</link>
      <pubDate>Thu, 08 Feb 2018 16:26:33 -0500</pubDate>
      
      <guid>http://nianze.ml/2018/02/perfer-pass-by-reference-to-const/</guid>
      <description>&lt;p&gt;Pass by reference-to-&lt;code&gt;const&lt;/code&gt; is typically more efficient than pass by value and avoids the slicing problem.
&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Item-19 Treat class design as type design</title>
      <link>http://nianze.ml/2018/02/class-design-is-type-design/</link>
      <pubDate>Wed, 07 Feb 2018 13:47:07 -0500</pubDate>
      
      <guid>http://nianze.ml/2018/02/class-design-is-type-design/</guid>
      <description>&lt;p&gt;Before definining a new type, be sure to consider all the issues discussed in this item.
&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Item-18 Make interfaces easy to use correctly and hard to use incorrectly</title>
      <link>http://nianze.ml/2018/02/make-interfaces-easy-to-use-correctly/</link>
      <pubDate>Tue, 06 Feb 2018 19:05:53 -0500</pubDate>
      
      <guid>http://nianze.ml/2018/02/make-interfaces-easy-to-use-correctly/</guid>
      <description>&lt;p&gt;Good interfaces are easy to use correctly and hard to use incorrectly.
&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>2018进度表</title>
      <link>http://nianze.ml/2018/02/2018-roadmap/</link>
      <pubDate>Tue, 06 Feb 2018 11:44:42 -0500</pubDate>
      
      <guid>http://nianze.ml/2018/02/2018-roadmap/</guid>
      <description>&lt;p&gt;马上春节了，来列一下新年计划吧。
&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Item-17 Store newed objects in smart pointers in standalone statements</title>
      <link>http://nianze.ml/2018/02/store-newed-objects-in-smart-pointers-in-standalone-statements/</link>
      <pubDate>Mon, 05 Feb 2018 18:04:38 -0500</pubDate>
      
      <guid>http://nianze.ml/2018/02/store-newed-objects-in-smart-pointers-in-standalone-statements/</guid>
      <description>&lt;p&gt;Failure to do this can lead to subtle resource leaks when exceptions are thrown.
&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Item-16 Use the same form in corresponding uses of new and delete</title>
      <link>http://nianze.ml/2018/02/use-the-same-form-in-matching-new-and-delete/</link>
      <pubDate>Sun, 04 Feb 2018 00:00:00 +0000</pubDate>
      
      <guid>http://nianze.ml/2018/02/use-the-same-form-in-matching-new-and-delete/</guid>
      <description>&lt;p&gt;If you use [] in a &lt;code&gt;new&lt;/code&gt; expression, use [] in the corresponding &lt;code&gt;delete&lt;/code&gt; expression; If not, no [] in the matching &lt;code&gt;delete&lt;/code&gt; expression.
&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Item-15 Provide access to raw resource in resource-managing classes</title>
      <link>http://nianze.ml/2018/02/provide-access-to-raw-rsc/</link>
      <pubDate>Sat, 03 Feb 2018 00:00:00 +0000</pubDate>
      
      <guid>http://nianze.ml/2018/02/provide-access-to-raw-rsc/</guid>
      <description>&lt;p&gt;Each RAII class should offer a way to get at the resource it manages.
&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Item-14 Copy behavior in resource-managing classes</title>
      <link>http://nianze.ml/2018/02/copy-behavior-of-raii/</link>
      <pubDate>Fri, 02 Feb 2018 13:27:32 -0500</pubDate>
      
      <guid>http://nianze.ml/2018/02/copy-behavior-of-raii/</guid>
      <description>&lt;p&gt;Copying an RAII object entails copying the resource it manages, so the copying behavior of the resource determines the copying behavior of the RAII object.
&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Item-13 Use objects to manage resources</title>
      <link>http://nianze.ml/2018/02/use-objects-to-manage-resources/</link>
      <pubDate>Thu, 01 Feb 2018 18:20:10 -0500</pubDate>
      
      <guid>http://nianze.ml/2018/02/use-objects-to-manage-resources/</guid>
      <description>&lt;p&gt;Use RAII objects such as &lt;code&gt;tr1::shared_ptr&lt;/code&gt; and &lt;code&gt;auto_ptr&lt;/code&gt; to prevent resource leaks.
&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Item-12 Copy all parts of an object</title>
      <link>http://nianze.ml/2018/01/copy-all-parts-of-an-object/</link>
      <pubDate>Wed, 31 Jan 2018 18:16:11 -0500</pubDate>
      
      <guid>http://nianze.ml/2018/01/copy-all-parts-of-an-object/</guid>
      <description>&lt;p&gt;Be sure to copy all of an object&amp;rsquo;s data members and all of its base class parts.
&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Item-11 Handle self assignment in operator=</title>
      <link>http://nianze.ml/2018/01/handle-self-assignment/</link>
      <pubDate>Tue, 30 Jan 2018 18:34:01 -0500</pubDate>
      
      <guid>http://nianze.ml/2018/01/handle-self-assignment/</guid>
      <description>&lt;p&gt;Solve self assignment situation in operator= by comparing addresses of source and target objects, careful statement ordering, and copy-and-&lt;code&gt;swap&lt;/code&gt;.
&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Item-10 Have assignment operators return a reference to *this</title>
      <link>http://nianze.ml/2018/01/have-assignment-op-return-a-ref/</link>
      <pubDate>Mon, 29 Jan 2018 18:17:34 -0500</pubDate>
      
      <guid>http://nianze.ml/2018/01/have-assignment-op-return-a-ref/</guid>
      <description>&lt;p&gt;As title suggests.
&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Item-9 不要在构造函数和析构函数中触发虚函数</title>
      <link>http://nianze.ml/2018/01/no-virtual-func-in-ctor-dtor/</link>
      <pubDate>Sat, 27 Jan 2018 21:03:05 -0500</pubDate>
      
      <guid>http://nianze.ml/2018/01/no-virtual-func-in-ctor-dtor/</guid>
      <description>&lt;p&gt;不同于Java或者C#,在C++中构造函数和析构函数里的虚函数不会实现多态的效果。
&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Item-8 Prevent exception from leaving destructor</title>
      <link>http://nianze.ml/2018/01/prevent-exception-from-leaving-dtor/</link>
      <pubDate>Fri, 26 Jan 2018 20:15:48 -0500</pubDate>
      
      <guid>http://nianze.ml/2018/01/prevent-exception-from-leaving-dtor/</guid>
      <description>&lt;p&gt;It is discouraged practice to emit exceptions from destructors.
&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Item-7 Declare destructor virtual in polymorphic base classes</title>
      <link>http://nianze.ml/2018/01/virtual-dtor-in-polymorphic-base-class/</link>
      <pubDate>Thu, 25 Jan 2018 18:04:14 -0500</pubDate>
      
      <guid>http://nianze.ml/2018/01/virtual-dtor-in-polymorphic-base-class/</guid>
      <description>&lt;p&gt;If a class has any virtual functions (for polymorphic purpose), it should have a virtual destructor.
&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Item-6 Disallow unwanted compiler-generated functions</title>
      <link>http://nianze.ml/2018/01/functions-silently-created/</link>
      <pubDate>Wed, 24 Jan 2018 16:18:59 -0500</pubDate>
      
      <guid>http://nianze.ml/2018/01/functions-silently-created/</guid>
      <description>&lt;p&gt;Declare unwanted member functions &lt;em&gt;private&lt;/em&gt; without implementations to disallow functionality automatically provided by compilers.
&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Item-5 What functions C&#43;&#43; silently generates</title>
      <link>http://nianze.ml/2018/01/functions-silently-created/</link>
      <pubDate>Tue, 23 Jan 2018 18:42:07 -0500</pubDate>
      
      <guid>http://nianze.ml/2018/01/functions-silently-created/</guid>
      <description>&lt;p&gt;Compilers may implicitly generate their own versions of default constructor, copy constructor, copy assignment operator, and destructor.
&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Item-4 Initialize objects before they&#39;re used</title>
      <link>http://nianze.ml/2018/01/initialize-before-use/</link>
      <pubDate>Mon, 22 Jan 2018 18:47:54 -0500</pubDate>
      
      <guid>http://nianze.ml/2018/01/initialize-before-use/</guid>
      <description>&lt;p&gt;Since C++ is fickle about initialization, some good coding style is suggested.
&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Item-3 Use const whenever possible</title>
      <link>http://nianze.ml/2018/01/use-const-whenever-possible/</link>
      <pubDate>Fri, 19 Jan 2018 14:31:40 -0500</pubDate>
      
      <guid>http://nianze.ml/2018/01/use-const-whenever-possible/</guid>
      <description>&lt;p&gt;Useful tips on using &lt;code&gt;const&lt;/code&gt; in C++.
&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Item-0 Federation of languages</title>
      <link>http://nianze.ml/2018/01/cpp-is-multiparadigm/</link>
      <pubDate>Thu, 18 Jan 2018 20:01:47 -0500</pubDate>
      
      <guid>http://nianze.ml/2018/01/cpp-is-multiparadigm/</guid>
      <description>&lt;p&gt;C++ is a multiparadigm programming langrage.
&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Item-2 Compare &lt;iostream&gt; to &lt;stdio.h&gt;</title>
      <link>http://nianze.ml/2018/01/tips-on-iostream/</link>
      <pubDate>Wed, 17 Jan 2018 19:14:29 -0500</pubDate>
      
      <guid>http://nianze.ml/2018/01/tips-on-iostream/</guid>
      <description>&lt;p&gt;Some tips about &lt;code&gt;&amp;lt;iostream&amp;gt;&lt;/code&gt;
&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Item-1 Prefer consts, enums and inlines to #defines</title>
      <link>http://nianze.ml/2018/01/start-of-effective-cpp-series/</link>
      <pubDate>Tue, 16 Jan 2018 18:41:58 -0500</pubDate>
      
      <guid>http://nianze.ml/2018/01/start-of-effective-cpp-series/</guid>
      <description>&lt;p&gt;A new (hopefully) daily review on &lt;code&gt;C++&lt;/code&gt;.
&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Machine learning overview</title>
      <link>http://nianze.ml/2018/01/start-of-machine-learning-series/</link>
      <pubDate>Thu, 04 Jan 2018 00:00:00 +0000</pubDate>
      
      <guid>http://nianze.ml/2018/01/start-of-machine-learning-series/</guid>
      <description>&lt;p&gt;My first post in the new &lt;code&gt;machine learning&lt;/code&gt; series.
&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>使用Hugo在GitHub Pages上搭建免费个人网站</title>
      <link>http://nianze.ml/2017/12/personal-site-with-hugo/</link>
      <pubDate>Tue, 26 Dec 2017 00:00:00 +0000</pubDate>
      
      <guid>http://nianze.ml/2017/12/personal-site-with-hugo/</guid>
      <description>&lt;p&gt;This article talks about how to use &lt;a href=&#34;https://gohugo.io/&#34;&gt;Hugo&lt;/a&gt; to build a personal website hosted on &lt;a href=&#34;https://pages.github.com/&#34;&gt;Github Pages&lt;/a&gt;. It also introduces how to find a free custom domain name from &lt;a href=&#34;http://www.freenom.com/&#34;&gt;Freenom&lt;/a&gt; and migrated the DNS server to &lt;a href=&#34;https://www.cloudflare.com/&#34;&gt;CloudFlare&lt;/a&gt; in order to use HTTPs with chosen custom domain name on GitHub Pages.&lt;br /&gt;
本文讲述了如何使用&lt;a href=&#34;https://gohugo.io/&#34;&gt;Hugo&lt;/a&gt;将个人网页托管在&lt;a href=&#34;https://pages.github.com/&#34;&gt;Github Pages&lt;/a&gt;上。同时也介绍了如何在&lt;a href=&#34;http://www.freenom.com/&#34;&gt;Freenom&lt;/a&gt;上找到免费个人域名并利用&lt;a href=&#34;https://www.cloudflare.com/&#34;&gt;CloudFlare&lt;/a&gt;的免费DNS服务在Github Pages上以HTTPs协议加载个人域名。
&lt;/p&gt;</description>
    </item>
    
  </channel>
</rss>