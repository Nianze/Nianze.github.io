

  
    
  


  





  

<!DOCTYPE html>
<html lang="zh-cn">
  <head>
    
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="generator" content="Hugo 0.37.1">
    <meta name="theme" content="Tranquilpeak 0.3.1-BETA">
    <title>[MECpp]Item-29 Reference Counting - 刀心の水|Nzo</title>
    <meta name="author" content="刀心の水|Nzo">
    <meta name="keywords" content=", programming, photography, music, software, blog">

    <link rel="icon" href="http://nianze.ml/favicon.png">
    

    
    <meta name="description" content="Reference counting is technique that allows multiple objects with the same value to share a sinple representation of that value.
">
    <meta property="og:description" content="Reference counting is technique that allows multiple objects with the same value to share a sinple representation of that value.
">
    <meta property="og:type" content="blog">
    <meta property="og:title" content="[MECpp]Item-29 Reference Counting">
    <meta property="og:url" content="/2018/05/reference-counting/">
    <meta property="og:site_name" content="Code.Music.Photo">
    <meta name="twitter:card" content="summary">
    <meta name="twitter:title" content="Code.Music.Photo">
    <meta name="twitter:description" content="Reference counting is technique that allows multiple objects with the same value to share a sinple representation of that value.
">
    
    

    
    

    
      <meta property="og:image" content="http://nianze.ml/images/bio-picture.jpg">
    

    
      <meta property="og:image" content="http://nianze.ml/images/2018/2018-05/2018-05-07.gif">
    
    
    

    

    
    <script src="//cdnjs.cloudflare.com/ajax/libs/jquery/2.1.3/jquery.min.js"></script>
    <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.8.0/highlight.min.js"></script>
    <script src="//cdnjs.cloudflare.com/ajax/libs/fancybox/2.1.4/jquery.fancybox.min.js"></script>
    <script src="//cdnjs.cloudflare.com/ajax/libs/fancybox/2.1.4/helpers/jquery.fancybox-thumbs.min.js"></script>

    
    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css" />
    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/fancybox/2.1.4/jquery.fancybox.css" />
    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/fancybox/2.1.4/helpers/jquery.fancybox-thumbs.min.css" />
    
    
    <link rel="stylesheet" href="http://nianze.ml/css/style-u6mk0ojoywresbx8iepslrmmhl4stuhrsxuwhkpwrkrx7mryjcaimasnk4pi.min.css" />
    
    
      <link rel="stylesheet" href="http://nianze.ml/css/main.css">
    

    
      
<script>
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-71584380-1', 'auto');
ga('send', 'pageview');
</script>

    



    
  </head>

  <body>
        <script>(function(d, s, id) {
    var js, fjs = d.getElementsByTagName(s)[0];
    if (d.getElementById(id)) return;
    js = d.createElement(s); js.id = id;
    js.src = "//connect.facebook.net/en_US/sdk.js#xfbml=1&version=v2.8";
    fjs.parentNode.insertBefore(js, fjs);
    }(document, 'script', 'facebook-jssdk'));</script>

    <div id="blog">
      <header id="header" data-behavior="4">
  <i id="btn-open-sidebar" class="fa fa-lg fa-bars"></i>
  <div class="header-title">
    <a class="header-title-link" href="http://nianze.ml/">刀心の水|Nzo - Code.Music.Photo</a>
  </div>
  
    
      <a class="header-right-picture "
         href="http://nianze.ml/#about">
    
    
    
      
        <img class="header-picture" src="http://nianze.ml/images/bio-picture.jpg" alt="作者的图片" />
      
    
    </a>
  
</header>

      <nav id="sidebar" data-behavior="4">
  <div class="sidebar-container">
    
      <div class="sidebar-profile">
        <a href="http://nianze.ml/#about">
          <img class="sidebar-profile-picture" src="http://nianze.ml/images/bio-picture.jpg" alt="作者的图片" />
        </a>
        <h4 class="sidebar-profile-name">刀心の水|Nzo</h4>
        
          <h5 class="sidebar-profile-bio"><p>虚度廿余岁月浅，略识几行代码源。<br />
闲来随手快门按，黯然独把音韵弹。</p>

<p>A software developer who also love producing music and taking photo.</p>
</h5>
        
      </div>
    
    <ul class="sidebar-buttons">
      
  <li class="sidebar-button">
    
      <a class="sidebar-button-link " href="http://nianze.ml/">
    
      <i class="sidebar-button-icon fa fa-lg fa-home" title='Home'></i>
      
      <span class="sidebar-button-desc" title="Home">首页</span>
    </a>
  </li>

  <li class="sidebar-button">
    
      <a class="sidebar-button-link " href="http://nianze.ml/categories/article">
    
      <i class="sidebar-button-icon fa fa-lg fa-file-text-o" title='Article'></i>
      
      <span class="sidebar-button-desc" title="Article">文章</span>
    </a>
  </li>

  <li class="sidebar-button">
    
      <a class="sidebar-button-link " href="http://nianze.ml/categories/music">
    
      <i class="sidebar-button-icon fa fa-lg fa-music" title='Music'></i>
      
      <span class="sidebar-button-desc" title="Music">音乐</span>
    </a>
  </li>

  <li class="sidebar-button">
    
      <a class="sidebar-button-link " href="http://nianze.ml/categories/photography">
    
      <i class="sidebar-button-icon fa fa-lg fa-camera" title='Photography'></i>
      
      <span class="sidebar-button-desc" title="Photography">摄影</span>
    </a>
  </li>

  <li class="sidebar-button">
    
      <a class="sidebar-button-link " href="http://nianze.ml/categories">
    
      <i class="sidebar-button-icon fa fa-lg fa-bookmark" title='Categories'></i>
      
      <span class="sidebar-button-desc" title="Categories">分类</span>
    </a>
  </li>

  <li class="sidebar-button">
    
      <a class="sidebar-button-link " href="http://nianze.ml/tags">
    
      <i class="sidebar-button-icon fa fa-lg fa-tags" title='Tags'></i>
      
      <span class="sidebar-button-desc" title="Tags">标签</span>
    </a>
  </li>

  <li class="sidebar-button">
    
      <a class="sidebar-button-link " href="http://nianze.ml/archives">
    
      <i class="sidebar-button-icon fa fa-lg fa-archive" title='Archives'></i>
      
      <span class="sidebar-button-desc" title="Archives">归档</span>
    </a>
  </li>

  <li class="sidebar-button">
    
      <a class="sidebar-button-link " href="http://nianze.ml/about">
    
      <i class="sidebar-button-icon fa fa-lg fa-user" title='About'></i>
      
      <span class="sidebar-button-desc" title="About">关于</span>
    </a>
  </li>

    </ul>
    <ul class="sidebar-buttons">
      
  <li class="sidebar-button">
    
      <a class="sidebar-button-link " href="https://www.linkedin.com/in/nianze" target="_blank">
    
      <i class="sidebar-button-icon fa fa-lg fa-linkedin" title='LinkedIn'></i>
      
      <span class="sidebar-button-desc" title="LinkedIn">LinkedIn</span>
    </a>
  </li>

  <li class="sidebar-button">
    
      <a class="sidebar-button-link " href="https://github.com/Nianze" target="_blank">
    
      <i class="sidebar-button-icon fa fa-lg fa-github" title='Github'></i>
      
      <span class="sidebar-button-desc" title="GitHub">GitHub</span>
    </a>
  </li>

  <li class="sidebar-button">
    
      <a class="sidebar-button-link " href="https://www.flickr.com/photos/129774362@N07/" target="_blank">
    
      <i class="sidebar-button-icon fa fa-lg fa-flickr", title='Flickr'></i>
      
      <span class="sidebar-button-desc" title="Flickr">Flickr</span>
    </a>
  </li>

  <li class="sidebar-button">
    
      <a class="sidebar-button-link " href="https://instagram.com/eznain" target="_blank">
    
      <i class="sidebar-button-icon fa fa-lg fa-instagram" title='Instagram'></i>
      
      <span class="sidebar-button-desc" title="Instagram">Instagram</span>
    </a>
  </li>

  <li class="sidebar-button">
    
      <a class="sidebar-button-link " href="https://www.facebook.com/rym.lnz" target="_blank">
    
      <i class="sidebar-button-icon fa fa-lg fa-facebook", title='Facebook'></i>
      
      <span class="sidebar-button-desc" title="Facebook">Facebook</span>
    </a>
  </li>

  <li class="sidebar-button">
    
      <a class="sidebar-button-link " href="https://www.youtube.com/user/daoxinzhishui" target="_blank">
    
      <i class="sidebar-button-icon fa fa-lg fa-youtube", title='YouTube'></i>
      
      <span class="sidebar-button-desc" title="YouTube">YouTube</span>
    </a>
  </li>

  <li class="sidebar-button">
    
      <a class="sidebar-button-link " href="http://weibo.com/daoxinzhishui" target="_blank">
    
      <i class="sidebar-button-icon fa fa-lg fa-weibo", title='Weibo'></i>
      
      <span class="sidebar-button-desc" title="Weibo">Weibo</span>
    </a>
  </li>

  <li class="sidebar-button">
    
      <a class="sidebar-button-link " href="mailto:daoxinzhishui@gmail.com">
    
      <i class="sidebar-button-icon fa fa-lg fa-envelope", title='Email'></i>
      
      <span class="sidebar-button-desc" title="Email">Email</span>
    </a>
  </li>

    </ul>
    <ul class="sidebar-buttons">
      
    </ul>
  </div>
</nav>

      

      <div id="main" data-behavior="4"
        class="
               hasCoverMetaIn
               ">
        <article class="post" itemscope itemType="http://schema.org/BlogPosting">
          
          
            <div class="post-header main-content-wrap text-left">
  
    <h1 class="post-title" itemprop="headline">
      [MECpp]Item-29 Reference Counting
    </h1>
  
  <div class="postShorten-meta post-meta">
  
    <time itemprop="datePublished" datetime="2018-05-07T00:00:00Z">
      
  五月 7, 2018

    </time>
  
  
  
  
    <span>发布在</span>
    
      <a class="category-link" href="http://nianze.ml/categories/article">article</a>, 
    
      <a class="category-link" href="http://nianze.ml/categories/coding">coding</a>
    
  


</div>

</div>
          
          <div class="post-content markdown" itemprop="articleBody">
            <div class="main-content-wrap">
              <p>Reference counting is technique that allows multiple objects with the same value to share a sinple representation of that value.
</p>

<p>Consider a customized naive version of <code>class String;</code>: its assignment operator is implemented in a naive way:</p>

<pre><code class="language-cpp">class String {
public:
    String(const char *value = &quot;&quot;);
    String&amp; operator=(const String&amp; rhs);
    ...
private:
    char *data;
};

String&amp; String::operator=(const String&amp; rhs)
{
    if (this == &amp;rhs) return *this;

    delete[] data;
    data = new char[strlen(rhs.data)+1];
    strcpy(data, rhs.data);
    return *this;
}
</code></pre>

<p>When we write statement <code>a = b = c = d = e = &quot;Hello&quot;;</code> where <code>a</code>, <code>b</code>, <code>c</code>, <code>d</code> and <code>e</code> are all <code>String</code> type, we get five objects, each with the same value &ldquo;Hello&rdquo;:</p>

<pre><code>┌───┐     ┌───────┐   ┌───┐     ┌───────┐
│ a │ --&gt; │ Hello │   │ b │ --&gt; │ Hello │ 
└───┘     └───────┘   └───┘     └───────┘
┌───┐     ┌───────┐   ┌───┐     ┌───────┐
│ c │ --&gt; │ Hello │   │ d │ --&gt; │ Hello │ 
└───┘     └───────┘   └───┘     └───────┘
┌───┐     ┌───────┐
│ e │ --&gt; │ Hello │
└───┘     └───────┘
</code></pre>

<p>Ideally, we&rsquo;d like to change the picture to look like this:</p>

<pre><code>┌───┐    
│ a ├──┐
└───┘  | 
┌───┐  | 
│ c ├──┤
└───┘  | 
┌───┐  |  ┌───────┐
│ e ├──┼─&gt;│ Hello │
└───┘  |  └───────┘
┌───┐  | 
│ e ├──┤
└───┘  │ 
┌───┐  │ 
│ e ├──┘
└───┘    
</code></pre>

<p>In practice, we need to keep track of how many objects are sharing - <em>refering to</em>- a value to make sure the best time to destroy or modify the value &ldquo;Hello&rdquo;, so we need to add <em>reference count</em> into the picuture:</p>

<pre><code>┌───┐    
│ a ├──┐
└───┘  | 
┌───┐  | 
│ c ├──┤
└───┘  | 
┌───┐  |  ┌───┐    ┌───────┐
│ c ├──┼─&gt;│ 5 ├───&gt;│ Hello │
└───┘  |  └───┘    └───────┘
┌───┐  | 
│ d ├──┤
└───┘  │ 
┌───┐  │ 
│ e ├──┘
└───┘    
</code></pre>

<h2 id="implementing-reference-counting">Implementing Reference Counting</h2>

<p>From the picture above, we can see we need one reference count per string <em>value</em>, instead of one per string <em>object</em>. This implies a decoupling between values and reference counts, leading to our first design: nesting a <code>StringValue</code> struct in the private part of <code>String</code> class, so that all the members of <code>String</code> class get full access to this inner data structure, while everybody else get denied (except friends of the class).</p>

<pre><code class="language-cpp">class String {
public:
    ...
private:
    struct StringValue { // holds a reference count and a string value
        size_t refCount;
        char *data;
        StringValue(const char *initValue);
        ~StringValue();
    }
    StringValue *value;        // value of this String
};

String::StringValue::StringValue(const char *initValue)
: refCount(1)
{
    data = new char[strlen(initValue)+1];
    strcpy(data, initValue);
}

String::StringValue::~StringValue()
{
    delete [] data;
}
</code></pre>

<p>The primary purpose of <code>StringValue</code> is to provide a place to associate a particular value with a count of the number of <code>String</code> objects sharing that value, so there&rsquo;s need to define copy constructor or assignment operator for this inner struct, and we provide the manipulation of the <code>refCount</code> field in <code>String</code> class:</p>

<pre><code class="language-cpp">class String {
public:
    String(const char *initValue = &quot;&quot;);
    String(const String&amp; rhs);
    ~String();
    String&amp; operator=(const String&amp; rhs);
    ...
};

String::String(const char *initValue)
: value(new StringValue(initValue))
{}

String::String(const String&amp; rhs)
: value(rhs.value)
{
    ++value-&gt;refCount;
}

String::~String()
{
    if (--value-&gt;refCount == 0) delete value;
}

String&amp; String::operator=(const String&amp; rhs)
{
    if (value == rhs.value) {
        return *this;
    }

    if (--value-&gt;refCount == 0) { // destroy *this's value
        delete value;             // if no one else is using it
    }

    value = rhs.value;
    ++value-&gt;refCount;

    return *this;
}
</code></pre>

<h2 id="copy-on-write">Copy-on-write</h2>

<p>Now comes the troublesome one: an array-bracket operator([]), which allows individual characters within strings to be read and written:</p>

<pre><code class="language-cpp">class String {
public:
    const char&amp; operator[](int index) const;  // for const Strings
    char&amp; operator[](int index); // for non-const Strings
    ...
};
</code></pre>

<p>It&rsquo;s straightforward to implement the const version, because it&rsquo;s a read-only operation:</p>

<pre><code class="language-cpp">const char&amp; String::operator[](int index) const
{
    return value-&gt;data[index]; // here's no sanity checking on index, just like C++ tradition; easy to add though
}
</code></pre>

<p>However, since non-const version of <code>operator[]</code> might be called to write a character, the implementation must consider more scenario to avoid modifying the value of other <code>String</code> objects that happen to be sharing the same <code>StringValue</code> object - since there&rsquo;s no way for C++ compilers to tell us whether a particular use of <code>operator[]</code> is for a read or a write, we must be pessimistic and assume <em>all</em> calls to the non-const <code>operator[]</code> are for writes (Proxy classes casn help us differentiate reads from writes, see MECpp item 30.)</p>

<pre><code class="language-cpp">char&amp; String::operator[](int index)
{
    // if sharing a value with other String obj.
    // break off a separate copy of the value
    if (value-&gt;refCount &gt; 1) {
        --value-&gt;refCount;
        value = new StringValue(value-&gt;data);
    }
    return value-&gt;data[index];
}
</code></pre>

<p>This technique - to share a value with other objects until we have to write on our own copy of the value - is the well-knwon <em>copy-on-write</em>, which is a specific example of <em>lazy evaluation</em> (MECpp item 17), which is a more general approach to efficiency.</p>

<h2 id="pointers-references-and-copy-on-write">Pointers, References, and Copy-on-write</h2>

<p>Consider this code:</p>

<pre><code class="language-cpp">String s1 = &quot;Hello&quot;;
char *p = &amp;s1[1];
Stirng s2 = s1;
</code></pre>

<p>The data structure looks like this:</p>

<pre><code>┌───┐    
│s1 ├──┐  ┌───┐    ┌───────┐
└───┘  ├─&gt;│ 2 ├───&gt;│ Hello │
┌───┐  │  └───┘    └───────┘
│s2 ├──┘              ↑
└───┘                 p
</code></pre>

<p>Now there is a dangerous situation, where pointer <code>p</code> modifies both <code>s1</code> and <code>s2</code>:</p>

<pre><code class="language-cpp">*p = 'x';  // modifies both s1 and s2
</code></pre>

<p>To eliminate the problem, we add a flag to each <code>StringValue</code> object indicating whether that object is shareable. Initially, the flag is set to <code>true</code> (indicating shareable), but turn it off whenever the non-const <code>operator[]</code> is invoked on the value represented by that object (once the flag is set to <code>false</code>, it stays that way forever).</p>

<pre><code class="language-cpp">class String {
public:
    struct StirngValue {
        size_t refCount;
        bool shareable;  // add this line
        char *data;
        ...
    };
    ...
};

String::StringValue::StringValue(const char *initValue)
: refCount(1),
  shareable(true) // add this line
{
    data = new char[strlen(initValue) + 1];
    strcpy(data, initValue);
}

String::String(const String&amp; rhs)
{
    if (rhs.value-&gt;shareable) {  // add this checking
        value = rhs.value;
        ++value-&gt;refCount;
    }
    else {
        value = new StringValue(rhs.value-&gt;data);
    }
}

char&amp; String::operator[](int index)
{
    if (value-&gt;refCount &gt; 1) {
        --value-&gt;refCount;
        value = new StringValue(value-&gt;data);
    }
    value-&gt;shareable = false;  // add this
    return value-&gt;data[index];
}
</code></pre>

<h2 id="a-reference-counting-base-class">A Reference-Counting Base class</h2>

<p>Reference counting is useful for more than just strings, so it&rsquo;s good practice to separate reference counting code in a context-independent manner. This leads us to the design of a base class <code>RCObject</code>. Any class wishing to take advantage of automatic reference counting may inherit from this class. Basically, for general purpose usage, <code>RCObject</code> class should include</p>

<ul>
<li>the reference count, as well as functions for incrementing and decrementing that count.</li>
<li>the code for destroying a value when it is no longer in use (count == 0)</li>
<li>a field that keeps track of whether this value is shareable, as well as functions to query this flag and set it to false</li>
</ul>

<pre><code class="language-cpp">class RCObject {
public:
    RCObject();
    RCObject(const RCObject&amp; rhs);
    RCObject&amp; operator=(const RCObject&amp; rhs);
    virtual ~RCObject() = 0; // virtual shows this class is designed as a base class; pure virtual so that this class should be used only as a base class
    void addReference();
    void removeReference();
    
    void markUnshareable();
    bool isShareable() const;
    bool isShared() const;

private:
    size_t refCount;
    bool shareable;
};
</code></pre>

<pre><code class="language-cpp">RCObject::RCObject()
: refCount(0), shareable(true) {}

RCObject::RCObject(const RCObject&amp;)
: refCount(0), shareable(true) {}

RCObject&amp; RCObject::operator=(const RCObject&amp;)
{ return *this; }

RCObject::~RCObject() {} // pure virtual dtor still need to be impl. see MECpp item 33

void RCObject::addReference() { ++refCount; }

void RCObject::removeReference() 
{ if(--refCount == 0) delete this; }

void RCObject::markUnshareable()
{ shareable = false; }

bool RCObject::isShareable() const
{ return shareable; }

bool RCObject::isShared() const
{ return refCount &gt; 1; }
</code></pre>

<p>In this design, there are a few things worth noting:</p>

<ol>
<li>The <code>refCount</code> is set to 0 in both constructors to simplifies the set up process for the creaters of <code>RCObject</code>s when they set <code>refCount</code> to 1 themselves</li>
<li>Copy constructor sets <code>refCount</code> to 0, because this function is meant to create a new object representing a value, which is always unshared and referenced only by their creator (who will set up <code>refCount</code> properly later).</li>
<li>The assignment operator is unlikely to be called, since <code>RCObject</code> is a base class for a shared <em>value</em> object, which means in a reference counting system, it is usually the object pointing to these base-class objects that are assigned to one another, with only <code>refCount</code> being modified as a result. We don&rsquo;t declare assignment operator <code>private</code>, because there&rsquo;s a chance that someone does have a reason to allow assignment of reference-counted values(e.g., change the string value stored inside <code>StringValue</code> in the example above), so we adopt this &ldquo;do nothing&rdquo; implementation, which is exactly the right thing to do, because the assignment of value objects doesn&rsquo;t affect the reference count of objects pointing to either <code>lhs</code> or <code>rhs</code> of assignment operation: this base-class level assignment is meant to change <code>lhs</code>&rsquo;s value, meaning all the objects pointing to <code>lhs</code> now pointing to a new value.</li>
<li>Here we use <code>delete this;</code> for <code>removeReference</code>, which is safe only if we know that <code>*this</code> is a heap object. In order to ensure this, we might need technichs discussed in MECpp item 27 to restrict <code>RCObject</code> to be created only on the heap<sup class="footnote-ref" id="fnref:1"><a href="#fn:1">1</a></sup>.</li>
</ol>

<p>Now taking advantage of this new reference-counting base class, we modify <code>StringValue</code> to inherit its reference counting capabilities from <code>RCObject</code>:</p>

<pre><code class="language-cpp">class String {
private:
    struct StringValue: public RCObject {
        char *data;
        StringValue(const char *initValue);
        ~StringValue();
    };
...
};

String::StringValue::StringValue(const char *initValue)
{
    data = new char[strlen(initValue) + 1];
    strcpy(data, initValue);
}

String::StringValue::~StringValue()
{
    delete [] data;
}
</code></pre>

<p>After this change, <code>RCObject</code> now provide the manipulation ability of the <code>refCount</code> field, instead of <code>StringValue</code>.</p>

<h2 id="automating-reference-count-manipulations">Automating Reference Count Manipulations</h2>

<p>The <code>RCObject</code> class only gives us a place to store a reference count, as well as the member functions to manipulate the <code>refCount</code> field. However, the <em>calls</em> to these functions must still be mannually inserted in other classes: <code>String</code> copy constructor and assignment operator need to call <code>addReference</code> and <code>removeReference</code> on <code>StringValue</code> objects, which is not good practice for reuse.</p>

<p>To remove such manual works, we introduce <em>smart pointer</em> for help:</p>

<pre><code class="language-cpp">// template class for smart pointers-to-T object. T must
// support the RCObject interface, typically by inheriting from RCObject
template&lt;class T&gt;
class RCPtr {
public:
    RCPtr(T* realPtr = 0);
    RCPtr(const RCPtr&amp; rhs);
    ~RCPtr();

    RCPtr&amp; operator=(const RCPtr&amp; rhs);

    T* operator-&gt;() const;
    T&amp; operator*() const;
private:
    T *pointee;  // dumb pointer this object is emulating
    void init(); // common init. code
};
</code></pre>

<pre><code class="language-cpp">template&lt;class T&gt;
RCPtr&lt;T&gt;::RCPtr(T* realPtr): pointee(realPtr)
{
    init();
}

template&lt;class T&gt;
RCPtr&lt;T&gt;::RCPtr(const RCPtr&amp; rhs): pointee(rhs.pointee)
{
    init();
}

template&lt;class T&gt;
void RCPtr&lt;T&gt;::init()
{
    if (pointee == 0) {
        return;
    }
    if (pointee-&gt;isShareable() == false) {
        pointee = new T(*pointee);
    }
    pointee-&gt;addReference(); // always add a new reference to the value
}

template&lt;class T&gt;
RCPtr&lt;T&gt;&amp; RCPtr&lt;T&gt;::operator=(const RCPtr&amp; rhs)
{
    if (pointee != rhs.pointee)
        T *oldPointee = pointee;
        pointee = rhs.pointee;
        init();  // if possible, share it; else make own copy
        if (oldPointee) {
            oldPointee-&gt;removeReference();
        }
    }
    return *this;
}

template&lt;class T&gt;
RCPtr&lt;T&gt;::~RCPtr()
{
    if (pointee) pointee-&gt;removeReference();
}

template&lt;class T&gt;
T* RCPtr::operator-&gt;() const { return pointee; }

template&lt;class T&gt;
T&amp; RCPtr::operator*() const { return *pointee; }
</code></pre>

<p>There are three assumptions in this implementation:</p>

<ol>
<li><code>T</code> has a deep-copying constructor, because <code>pointee = new T(*pointee);</code> will call <code>T</code>&rsquo;s copy constructor. In the example above, <code>String::StringValue</code> lack such a user-defined copy constructor, and compiler generated default copy constructor will not copy <code>char*</code> string <code>data</code> points to, so we need to add a customized version of copy constructor:
<code>cpp
String::StringValue::StirngValue(const StringValue&amp; rhs)
{
data = new char(strlen(rhs.data) + 1);
strcpy(data, rhs.data);
}
</code></li>
<li>For the same statement calling <code>T</code>&rsquo;s copy constructor, we assume the type of <code>*pointee</code> is <code>T</code> rather than <code>T</code>&rsquo;s derived class. If, however, chances are <code>poinee</code> might point to <code>T</code>&rsquo;s derived class instances, we need to use a virtual copy constructor.</li>
<li><code>T</code> should prove all the functionality that <code>RCObject</code> does, either or not by inheriting from <code>RCObject</code>.</li>
</ol>

<h2 id="puting-everyting-together">Puting Everyting Together</h2>

<pre><code>                     ┌──────────┐  
┌──────────┐         │ RCObject │ 
│  String  │         │  class   │
│  object  │         └──────────┘
│          │              ↑ public inheritance
│ ┌─────┐  │         ┌───────────┐         ┌────────────┐
│ │RCPtr├──┼────────&gt;│StringValue├────────&gt;| Heap Memory|
│ └─────┘  │ pointer │  object   | pointer └────────────┘
└──────────┘         └───────────┘ 
</code></pre>

<p>The class declaration looks like this:</p>

<pre><code class="language-cpp">template&lt;class T&gt;
class RCPtr {
public:
    RCPtr(T* realPtr = 0);
    RCPtr(const RCPtr&amp; rhs);
    RCPtr&amp; operator=(const RCPtr&amp; rhs);
    ~RCPtr();

    T* operator-&gt;() const;
    T&amp; operator*() const;
private:
    T *pointee;
    void init();
};

class RCObject {
public:
    RCObjet();
    RCObject(const RCObject&amp; rhs);
    RCObject&amp; operator=(const RCOBject&amp; rhs);
    virtual ~RCObject() = 0;

    void addReference();
    void removeReference();

    void markUnshareable();
    bool isShareable() const;
    bool isShared() const;
private:
    size_t refCount;
    bool shareable;
};

class String {
public:
    String(const char *value = &quot;&quot;);

    const char&amp; operator[](int index) const;
    char&amp; operator[](int index);
private:
    // class representing string value
    struct StringValue: public RCObject {
        char *data;

        StringValue(const char *initValue);
        StringValue(const StringValue&amp; rhs);
        void init(const char *initValue);
        ~StringValue();
    };
    RCPtr&lt;StringValue&gt; value;
</code></pre>

<p>It is worth to note that we don&rsquo;t need the copy constructor or assignment operator for <code>String</code> anymore: compiler-generated copy constructor for <code>Stirng</code> will automatically call the copy constructor for <code>Stirng</code>&rsquo;s <code>RCPtr</code> member, and the copy constructor for <em>that</em> class will perform all the necessary manipulations of the <code>StringValue</code> object, including its reference count, and the same goes for assignment and destruction. That&rsquo;s why it is called <em>smart</em> pointer.</p>

<p>Now here is all the implementation:</p>

<pre><code class="language-cpp">RCObject::RCObject()
: refCount(0), shareable(true) {}

RCObject::RCObject(const RCObject&amp;)
: refCount(0), shareable(true) {}

RCObject&amp; RCObject::operator=(const RCObject&amp;)
{ return *this; }

RCObject::~RCObject() {}

void RCObject::addReference() { ++refCount; }

void RCObject::removeReference() 
{ if (--refCount == 0) delete this; }

void RCObject::markUnshareable()
{ shareable = false; }

bool RCObject::isShareable() const
{ return shareable; }

bool RCObject::isShared() const
{ return refCount &gt; 1; }
</code></pre>

<pre><code class="language-cpp">template&lt;class T&gt;
void RCPtr&lt;T&gt;::init()
{
    if (pointee == 0) {
        return;
    }
    if (pointee-&gt;isShareable() == false) {
        pointee = new T(*pointee);
    }
    pointee-&gt;addReference(); 
}
template&lt;class T&gt;
RCPtr&lt;T&gt;::RCPtr(T* realPtr): pointee(realPtr)
{ init(); }

template&lt;class T&gt;
RCPtr&lt;T&gt;::RCPtr(const RCPtr&amp; rhs): pointee(rhs.pointee)
{ init(); }


template&lt;class T&gt;
RCPtr&lt;T&gt;&amp; RCPtr&lt;T&gt;::operator=(const RCPtr&amp; rhs)
{
    if (pointee != rhs.pointee)
        T *oldPointee = pointee;
        pointee = rhs.pointee;
        init();  // if possible, share it; else make own copy
        if (oldPointee) {
            oldPointee-&gt;removeReference();
        }
    }
    return *this;
}

template&lt;class T&gt;
RCPtr&lt;T&gt;::~RCPtr()
{ if (pointee) pointee-&gt;removeReference(); }

template&lt;class T&gt;
T* RCPtr::operator-&gt;() const { return pointee; }

template&lt;class T&gt;
T&amp; RCPtr::operator*() const { return *pointee; }
</code></pre>

<pre><code class="language-cpp">void String::StringValue::init(const char *initValue) // ctor and deep copy ctor share this same init function
{
    data = new char[strlen(initValue) + 1];
    strcpy(data, initValue);
}

String::StringValue::StringValue(const char *initValue)
{ init(initValue); }

String::StringValue::StringValue(const StringValue&amp; rhs)
{ init(rhs.data); }

String::StringValue::~StringValue()
{ delete [] data; }
</code></pre>

<pre><code class="language-cpp">String::String(const char *initValue)
: value(new StringValue(initValue)) {}

const char&amp; String::operator[](int index) const
{ return value-&gt;data[index]; }

char&amp; String::operator[](int index)
{
    if (value-&gt;isShared()) {
        value = new StirngValue(value-&gt;data);
    }
    value-&gt;markUnshareable();
    return value-&gt;data[index];
}
</code></pre>

<h2 id="adding-refenrence-counting-to-existing-classes">Adding Refenrence Counting to Existing Classes</h2>

<p>Given some class <code>Widget</code> that&rsquo;s in a library we can&rsquo;t modify, and suppose we want to apply the benefits of reference counting to <code>Widget</code> without being able to inherit <code>Widget</code> from <code>RCObject</code>, we solve the problem with an additional level of indirection by adding a new class <code>CountHolder</code>, which does three jobs:</p>

<ol>
<li>Hold the reference</li>
<li>Inherit from <code>RCObject</code></li>
<li>Contain a pointer to a <code>Widget</code></li>
</ol>

<p>The only thing left to do is just an equivalent smart pointer as <code>RCPtr</code>, and we call it <code>RCIPtr</code>, where &ldquo;I&rdquo; stands for &ldquo;indirect&rdquo;. Thus, we get someting like this:</p>

<pre><code>                     ┌──────────┐  
┌──────────┐         │ RCObject │ 
│ RCWidget │         │  class   │
│  object  │         └──────────┘
│ ┌──────┐ │              ↑ public inheritance
│ |RCIPtr| │         ┌───────────┐         ┌─────────────┐
│ |Object├─┼────────&gt;│CountHolder├────────&gt;|Widget Object|
│ └──────┘ │ pointer │  object   | pointer └─────────────┘
└──────────┘         └───────────┘ 
</code></pre>

<p>Since here <code>CountHolder</code> is just an implementation detial of <code>RCIPtr</code>, we can simply nested it inside <code>RCIPtr</code>, just as how <code>StringValue</code> relates with <code>String</code>.</p>

<pre><code class="language-cpp">template&lt;class T&gt;
class RCIPtr {
public:
    RCIPtr(T* realPtr = 0);
    RCIPtr(const RCIPtr&amp; rhs);
    ~RCIPtr();

    RCIPtr&amp; operator=(const RCIPtr&amp; rhs);

    T* operator-&gt;() const;
    T&amp; operator*() const;

    RCObject&amp; getRCObject();  // give clients access
    { return *counter; }      // isShared, etc.
private:
    struct CountHolder: public RCObject {
        ~CountHolder() { delete pointee; }
        T *pointee;
    };
    CountHolder *counter;
    void init();
};

template&lt;class T&gt;
void RCIPtr&lt;T&gt;::init()
{
    if (counter-&gt;iShareable() == false) {
        T *oldValue = counter-&gt;pointee;
        counter = new CountHolder;
        counter-&gt;pointee = oldValue ? new T(*oldValue) : 0;
    }
    counter-&gt;addReference();
}

template&lt;class T&gt;
RCIPtr&lt;T&gt;::RCIPtr(T* realPtr)
: counter(new CountHolder)
{
    counter-&gt;ponitee = realPtr;
    init();
}

template&lt;class T&gt;
RCIPtr&lt;T&gt;::RCIPtr(const RCIPtr&amp; rhs)
: counter(rhs.counter)
{ init(); }

template&lt;class T&gt;
RCIPtr&lt;T&gt;::~RCIPtr()
{ counter-&gt;removeReference(); }

template&lt;class T&gt;
RCIPtr&lt;T&gt;&amp; RCIPtr&lt;T&gt;::operator=(const RCIPtr&amp; rhs)
{
    if (counter != rhs.counter) {
        counter-&gt;removeReference();
        counter = rhs.counter;
        init();
    }
    return *this;
}

template&lt;class T&gt;
T* RCIPtr&lt;T&gt;::operator-&gt;() const
{ return counter-&gt;pointee; }

template&lt;class T&gt;
T&amp; RCIPtr&lt;T&gt;::operator*() const
{ return *(counter-&gt;pointee); }
</code></pre>

<p>Then, for a library class <code>Widget</code> with following interface:</p>

<pre><code class="language-cpp">class Widget {
public:
    Widget(int size);
    Widget(const Widget&amp; rhs);
    ~Widget();

    Widge&amp; operator=(const Widget&amp; rhs);

    void doThis();
    int showThat() const;
};
</code></pre>

<p>We can implementing wrapper <code>RCWidget</code> by simply forwarding the call through underlying <code>RCIPtr</code> to a <code>Widget</code>object:</p>

<pre><code class="language-cpp">class RCWidget {
public:
    RCWidget(int size): value(new Widget(size)) {}

    void doThis()
    {
        if (value.getRCObject().isShared()) {
            value = new Widget(*value);
        }
        value-&gt;doThis();
    }
    int showThat() const { return value-&gt;showThat(); }
private:
    RCIPtr&lt;Widget&gt; value;
};
</code></pre>

<p>As with <code>Stirng</code> class, there&rsquo;s no need to write copy constructor, assignment operator, or destructor, because the default versions do the right thing.</p>
<div class="footnotes">

<hr />

<ol>
<li id="fn:1">In this example, we guarantee the value objects should be created only via <code>new</code> by declaring <code>StringValue</code> as <code>private</code> in <code>String</code>, so only <code>String</code> can create <code>StringValue</code> objects and the auther of the <code>String</code> class is able to ensure all such objects are allocated via <code>new</code>.
 <a class="footnote-return" href="#fnref:1"><sup>[return]</sup></a></li>
</ol>
</div>
              
            </div>
          </div>
          <div id="post-footer" class="post-footer main-content-wrap">
            
              
                
                
                  <div class="post-footer-tags">
                    <span class="text-color-light text-small">标签</span><br/>
                    
  <a class="tag tag--primary tag--small" href="http://nianze.ml//tags/technique/">technique</a>

  <a class="tag tag--primary tag--small" href="http://nianze.ml//tags/cpp/">cpp</a>

                  </div>
                
              
            
            <div class="post-actions-wrap">
  <nav>
    <ul class="post-actions post-action-nav">
      
        <li class="post-action">
          
            <a class="post-action-btn btn btn--default tooltip--top" href="http://nianze.ml/2018/05/proxy-classes/" data-tooltip="[MECpp]Item-30 Proxy Classes">
          
            <i class="fa fa-angle-left"></i>
            <span class="hide-xs hide-sm text-small icon-ml">下一篇</span>
          </a>
        </li>
        <li class="post-action">
          
            <a class="post-action-btn btn btn--default tooltip--top" href="http://nianze.ml/2018/05/smart-pointers/" data-tooltip="[MECpp]Item-28 Smart Pointers">
          
            <span class="hide-xs hide-sm text-small icon-mr">上一篇</span>
            <i class="fa fa-angle-right"></i>
          </a>
        </li>
      
    </ul>
  </nav>
  <ul class="post-actions post-action-share">
    

      <li class="post-action hide-xs">
        <div class="fb-share-button"
          data-href="http://nianze.ml/2018/05/reference-counting/"
          data-layout="button_count">
        </div>
      </li>

      <li class="post-action hide-lg hide-md hide-sm">
        <a class="post-action-btn btn btn--default btn-open-shareoptions" href="#btn-open-shareoptions">
          <i class="fa fa-share-alt"></i>
        </a>
      </li>
      <li class="post-action hide-xs">
        <a class="post-action-btn btn btn--default" target="new" href="https://plus.google.com/share?url=http%3a%2f%2fnianze.ml%2f2018%2f05%2freference-counting%2f">
          <i class="fa fa-google-plus"></i>
        </a>
      </li>
      <li class="post-action hide-xs">
        <a class="post-action-btn btn btn--default" target="new" href="https://twitter.com/intent/tweet?text=http%3a%2f%2fnianze.ml%2f2018%2f05%2freference-counting%2f">
          <i class="fa fa-twitter"></i>
        </a>
      </li>

    
    
      <li class="post-action">
        <a class="post-action-btn btn btn--default" href="#disqus_thread">
          <i class="fa fa-comment-o"></i>
        </a>
      </li>
    
    <li class="post-action">
      
        <a class="post-action-btn btn btn--default" href="#">
      
        <i class="fa fa-list"></i>
      </a>
    </li>
  </ul>
</div>


            
              
                <div id="disqus_thread"></div>
<script>




var disqus_config = function () {
this.page.url = "http://nianze.ml/2018/05/reference-counting/";  
this.page.identifier = "[MECpp]Item-29 Reference Counting"; 
};

(function() { 
var d = document, s = d.createElement('script');
s.src = 'https://robinhu.disqus.com/embed.js';
s.setAttribute('data-timestamp', +new Date());
(d.head || d.body).appendChild(s);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>

              
            
          </div>
        </article>
        <footer id="footer" class="main-content-wrap">
  <span class="copyrights">
    &copy; 2018 刀心の水|Nzo. All Rights Reserved
  </span>
</footer>

      </div>
      <div id="bottom-bar" class="post-bottom-bar" data-behavior="4">
        <div class="post-actions-wrap">
  <nav>
    <ul class="post-actions post-action-nav">
      
        <li class="post-action">
          
            <a class="post-action-btn btn btn--default tooltip--top" href="http://nianze.ml/2018/05/proxy-classes/" data-tooltip="[MECpp]Item-30 Proxy Classes">
          
            <i class="fa fa-angle-left"></i>
            <span class="hide-xs hide-sm text-small icon-ml">下一篇</span>
          </a>
        </li>
        <li class="post-action">
          
            <a class="post-action-btn btn btn--default tooltip--top" href="http://nianze.ml/2018/05/smart-pointers/" data-tooltip="[MECpp]Item-28 Smart Pointers">
          
            <span class="hide-xs hide-sm text-small icon-mr">上一篇</span>
            <i class="fa fa-angle-right"></i>
          </a>
        </li>
      
    </ul>
  </nav>
  <ul class="post-actions post-action-share">
    

      <li class="post-action hide-xs">
        <div class="fb-share-button"
          data-href="http://nianze.ml/2018/05/reference-counting/"
          data-layout="button_count">
        </div>
      </li>

      <li class="post-action hide-lg hide-md hide-sm">
        <a class="post-action-btn btn btn--default btn-open-shareoptions" href="#btn-open-shareoptions">
          <i class="fa fa-share-alt"></i>
        </a>
      </li>
      <li class="post-action hide-xs">
        <a class="post-action-btn btn btn--default" target="new" href="https://plus.google.com/share?url=http%3a%2f%2fnianze.ml%2f2018%2f05%2freference-counting%2f">
          <i class="fa fa-google-plus"></i>
        </a>
      </li>
      <li class="post-action hide-xs">
        <a class="post-action-btn btn btn--default" target="new" href="https://twitter.com/intent/tweet?text=http%3a%2f%2fnianze.ml%2f2018%2f05%2freference-counting%2f">
          <i class="fa fa-twitter"></i>
        </a>
      </li>

    
    
      <li class="post-action">
        <a class="post-action-btn btn btn--default" href="#disqus_thread">
          <i class="fa fa-comment-o"></i>
        </a>
      </li>
    
    <li class="post-action">
      
        <a class="post-action-btn btn btn--default" href="#">
      
        <i class="fa fa-list"></i>
      </a>
    </li>
  </ul>
</div>


      </div>
      <div id="share-options-bar" class="share-options-bar" data-behavior="4">
  <ul class="share-options">
    <li class="share-option">
      <a class="share-option-btn" target="new" href="https://plus.google.com/share?url=http%3a%2f%2fnianze.ml%2f2018%2f05%2freference-counting%2f">
        <i class="fa fa-google-plus"></i><span></span>
      </a>
    </li>
    <li class="share-option">
      <a class="share-option-btn" target="new" href="https://www.facebook.com/sharer/sharer.php?app_id=1906806182974656&u=http%3a%2f%2fnianze.ml%2f2018%2f05%2freference-counting%2f">
        <i class="fa fa-facebook-official"></i><span></span>
      </a>
    </li>
    <li class="share-option">
      <a class="share-option-btn" target="new" href="https://twitter.com/intent/tweet?text=http%3a%2f%2fnianze.ml%2f2018%2f05%2freference-counting%2f">
        <i class="fa fa-twitter"></i><span></span>
      </a>
    </li>
  </ul>
</div>
<div id="share-options-mask" class="share-options-mask"></div>
    </div>
    
    <div id="about">
  <div id="about-card">
    <div id="about-btn-close">
      <i class="fa fa-remove"></i>
    </div>
    
      <img id="about-card-picture" src="http://nianze.ml/images/bio-picture.jpg" alt="作者的图片" />
    
    <h4 id="about-card-name">刀心の水|Nzo</h4>
    
      <div id="about-card-bio"><p>虚度廿余岁月浅，略识几行代码源。<br />
闲来随手快门按，黯然独把音韵弹。</p>

<p>A software developer who also love producing music and taking photo.</p>
</div>
    
    
      <div id="about-card-job">
        <i class="fa fa-briefcase"></i>
        <br/>
        Software Developer
      </div>
    
    
      <div id="about-card-location">
        <i class="fa fa-map-marker"></i>
        <br/>
        New York City
      </div>
    
  </div>
</div>

    <div id="algolia-search-modal" class="modal-container">
  <div class="modal">
    <div class="modal-header">
      <span class="close-button"><i class="fa fa-close"></i></span>
      <a href="https://algolia.com" target="_blank" class="searchby-algolia text-color-light link-unstyled">
        <span class="searchby-algolia-text text-color-light text-small">by</span>
        <img class="searchby-algolia-logo" src="https://www.algolia.com/static_assets/images/press/downloads/algolia-light.svg">
      </a>
      <i class="search-icon fa fa-search"></i>
      <form id="algolia-search-form">
        <input type="text" id="algolia-search-input" name="search"
          class="form-control input--large search-input" placeholder="搜索" />
      </form>
    </div>
    <div class="modal-body">
      <div class="no-result text-color-light text-center"></div>
      <div class="results">
        
        
          <div class="media">
            
            <div class="media-body">
              <a class="link-unstyled" href="http://nianze.ml/2018/07/prefer-auto-to-explicit-type-declarations/">
                <h3 class="media-heading">[EMCpp]Item-5 Prefer Auto to Explicit Type Declarations</h3>
              </a>
              <span class="media-meta">
                <span class="media-date text-small">
                  Jul 7, 2018
                </span>
              </span>
              <div class="media-content hide-xs font-merryweather"><p>Despite some pitfalls described in EMCpp item 2 and 6, <code>auto</code> variables are preferred for they must be initialized, are generally immune to type mismatches that can lead to portability or efficiency problems, can ease the process of refactoring, and typically require less typing than variables with explicitly specified types.
</p></div>
            </div>
            <div style="clear:both;"></div>
            <hr>
          </div>
        
          <div class="media">
            
            <div class="media-body">
              <a class="link-unstyled" href="http://nianze.ml/2018/07/know-how-to-view-deduced-types/">
                <h3 class="media-heading">[EMCpp]Item-4 Know How to View Deduced Types</h3>
              </a>
              <span class="media-meta">
                <span class="media-date text-small">
                  Jul 7, 2018
                </span>
              </span>
              <div class="media-content hide-xs font-merryweather"><p>Deduced types can often be seen using IDE editors, compiler error messages, and the Boost TypeIndex library, but the results of some tools may be neither helpful nor accurate.
</p></div>
            </div>
            <div style="clear:both;"></div>
            <hr>
          </div>
        
          <div class="media">
            
            <div class="media-body">
              <a class="link-unstyled" href="http://nianze.ml/2018/07/understand-decltype/">
                <h3 class="media-heading">[EMCpp]Item-3 Understand Decltype</h3>
              </a>
              <span class="media-meta">
                <span class="media-date text-small">
                  Jul 7, 2018
                </span>
              </span>
              <div class="media-content hide-xs font-merryweather"><p><code>decltype</code> almost always yields the type of a variable or expression without any modifications. For lvalue expressions of type T other than names, <code>decltype</code> always reports a type of T&amp;.
</p></div>
            </div>
            <div style="clear:both;"></div>
            <hr>
          </div>
        
          <div class="media">
            
            <div class="media-body">
              <a class="link-unstyled" href="http://nianze.ml/2018/07/understand-auto-type-deduction/">
                <h3 class="media-heading">[EMCpp]Item-2 Understand Auto Type Deduction</h3>
              </a>
              <span class="media-meta">
                <span class="media-date text-small">
                  Jul 7, 2018
                </span>
              </span>
              <div class="media-content hide-xs font-merryweather"><p><code>auto</code> type deduction is usually the same as template type deduction, with an exception in the case of braced initializer. Also, in C++14, as a function return type or a lambda parameter, <code>auto</code> implies template type deduction instead of <code>auto</code> type deduction.
</p></div>
            </div>
            <div style="clear:both;"></div>
            <hr>
          </div>
        
          <div class="media">
            
            <div class="media-body">
              <a class="link-unstyled" href="http://nianze.ml/2018/07/understand-template-type-deduction/">
                <h3 class="media-heading">[EMCpp]Item-1 Understand Template Type Deduction</h3>
              </a>
              <span class="media-meta">
                <span class="media-date text-small">
                  Jul 7, 2018
                </span>
              </span>
              <div class="media-content hide-xs font-merryweather"><p>There are three sets of rules for type deduction in modern C++: one for function templates, one for <code>auto</code>, and one for <code>decltype</code>. Without a solid understanding of how deduction operates, effective programming in modern C++ is all but impossible.
</p></div>
            </div>
            <div style="clear:both;"></div>
            <hr>
          </div>
        
          <div class="media">
            
            <div class="media-body">
              <a class="link-unstyled" href="http://nianze.ml/2018/07/a-brif-review-of-dynamo/">
                <h3 class="media-heading">A Brif Review of Dynamo</h3>
              </a>
              <span class="media-meta">
                <span class="media-date text-small">
                  Jul 7, 2018
                </span>
              </span>
              <div class="media-content hide-xs font-merryweather"><p>As a highly available and scalable distributed data store, the design principles of Dynamo features high availability for writes (via reconciliation during reads), incremental scalability (consistent hashing), symmetry, decentralization, and heterogeneity (via virtual nodes).
</p></div>
            </div>
            <div style="clear:both;"></div>
            <hr>
          </div>
        
          <div class="media">
            
            <div class="media-body">
              <a class="link-unstyled" href="http://nianze.ml/2018/06/a-sip-of-leica-m9/">
                <h3 class="media-heading">徕卡M9初体验</h3>
              </a>
              <span class="media-meta">
                <span class="media-date text-small">
                  Jun 6, 2018
                </span>
              </span>
              <div class="media-content hide-xs font-merryweather"><p>他们说徕卡调教过的那块柯达CCD自带德味，我不信，心想用卡西欧自拍神器理论上也能后期出那味道来。
</p></div>
            </div>
            <div style="clear:both;"></div>
            <hr>
          </div>
        
          <div class="media">
            
            <div class="media-body">
              <a class="link-unstyled" href="http://nianze.ml/2018/06/a-simple-calculation/">
                <h3 class="media-heading">一个油腻中年大叔在儿童节的胡思乱想</h3>
              </a>
              <span class="media-meta">
                <span class="media-date text-small">
                  Jun 6, 2018
                </span>
              </span>
              <div class="media-content hide-xs font-merryweather"><p>张爱玲说，出名要趁早。
</p></div>
            </div>
            <div style="clear:both;"></div>
            <hr>
          </div>
        
          <div class="media">
            
            <div class="media-body">
              <a class="link-unstyled" href="http://nianze.ml/2018/05/music-generation-archive/">
                <h3 class="media-heading">A simple archive for music generation</h3>
              </a>
              <span class="media-meta">
                <span class="media-date text-small">
                  May 5, 2018
                </span>
              </span>
              <div class="media-content hide-xs font-merryweather"><p>A random collection of recent works on music generation.
</p></div>
            </div>
            <div style="clear:both;"></div>
            <hr>
          </div>
        
          <div class="media">
            
            <div class="media-body">
              <a class="link-unstyled" href="http://nianze.ml/2018/05/understand-how-to-combine-c---and-c-in-the-same-program/">
                <h3 class="media-heading">[MECpp]Item-34 Understand How to Combine C&#43;&#43; and C in the Same Program</h3>
              </a>
              <span class="media-meta">
                <span class="media-date text-small">
                  May 5, 2018
                </span>
              </span>
              <div class="media-content hide-xs font-merryweather"><p>There are five points worth noting if we want to mix C++ and C in the same program.
</p></div>
            </div>
            <div style="clear:both;"></div>
            <hr>
          </div>
        
      </div>
    </div>
    <div class="modal-footer">
      <p class="results-count text-medium"
         data-message-zero=""
         data-message-one=""
         data-message-other="">
         127 posts found
      </p>
    </div>
  </div>
</div>
    
  
    
    <div id="cover" style="background-image:url('http://nianze.ml/images/cover-v1.2.0.jpg');"></div>
  


    



<script src="http://nianze.ml/js/script-wl33z0n6ocaypepiqrazthtivfrliqijej4rq8ek8gvrv1awftmgjuv8k4zc.min.js"></script>

<script>
$(document).ready(function() {
  hljs.configure({ classPrefix: '', useBR: false });
  $('pre.code-highlight').each(function(i, block) {
    var code = "";
    hljs.highlightAuto(block.innerText).value.split(/\r\n|\r|\n/).forEach(function(line) {
      code += "<span class=\"line\">" + line + "</span><br>";
    });
    if (code.length > 0) {
      block.innerHTML = code;
    }
  });
  $('pre > code').each(function(i, block) {
    $(this).addClass('codeblock');
    hljs.highlightBlock(block);
  });
});
</script>

  
    
      <script>
        var disqus_config = function () {
          this.page.url = 'http:\/\/nianze.ml\/2018\/05\/reference-counting\/';
          
            this.page.identifier = '\/2018\/05\/reference-counting\/'
          
        };
        (function() {
          
          
          if (window.location.hostname == "localhost") {
            return;
          }
          var d = document, s = d.createElement('script');
          var disqus_shortname = 'daoxinzhishui';
          s.src = '//' + disqus_shortname + '.disqus.com/embed.js';

          s.setAttribute('data-timestamp', +new Date());
          (d.head || d.body).appendChild(s);
        })();
      </script>
    
  





    
  </body>
</html>

