<!DOCTYPE html>
<html lang="en-us">
  <head>
    
    <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="author" content="刀心の水">
<meta name="keywords" content=", visual, music, technology">
<meta name="description" content="Smart pointers are designed to look, act, and feel like built-in pointers, but to offer greater functionality.">


<meta property="og:description" content="Smart pointers are designed to look, act, and feel like built-in pointers, but to offer greater functionality.">
<meta property="og:type" content="article">
<meta property="og:title" content="[MECpp]Item-28 Smart Pointers">
<meta name="twitter:title" content="[MECpp]Item-28 Smart Pointers">
<meta property="og:url" content="http://nianze.tk/2018/05/smart-pointers/">
<meta property="twitter:url" content="http://nianze.tk/2018/05/smart-pointers/">
<meta property="og:site_name" content="Be creative">
<meta property="og:description" content="Smart pointers are designed to look, act, and feel like built-in pointers, but to offer greater functionality.">
<meta name="twitter:description" content="Smart pointers are designed to look, act, and feel like built-in pointers, but to offer greater functionality.">
<meta property="og:locale" content="en-us">

  
    <meta property="article:published_time" content="2018-05-05T16:38:03">
  
  
    <meta property="article:modified_time" content="2018-05-05T16:38:03">
  
  
  
    
      <meta property="article:section" content="technology">
    
      <meta property="article:section" content="coding">
    
  
  
    
      <meta property="article:tag" content="technique">
    
      <meta property="article:tag" content="cpp">
    
  


<meta name="twitter:card" content="summary">







  <meta property="og:image" content="http://nianze.tk/images/2018/2018-05/2018-05-05.gif">
  <meta property="twitter:image" content="http://nianze.tk/images/2018/2018-05/2018-05-05.gif">





  <meta property="og:image" content="http://nianze.tk/images/bw.JPG">
  <meta property="twitter:image" content="http://nianze.tk/images/bw.JPG">


    <title>[MECpp]Item-28 Smart Pointers</title>

    <link rel="icon" href="http://nianze.tk/favicon.png">
    

    

    <link rel="canonical" href="http://nianze.tk/2018/05/smart-pointers/">

    
    <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.6.3/css/all.css" integrity="sha384-UHRtZLI+pbxtHCWp1t77Bi1L4ZtiqrqD80Kn4Z8NTSRyMA2Fd33n5dQ8lWUE00s/" crossorigin="anonymous">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/2.1.4/jquery.fancybox.min.css" integrity="sha256-vuXZ9LGmmwtjqFX1F+EKin1ThZMub58gKULUyf0qECk=" crossorigin="anonymous" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/2.1.4/helpers/jquery.fancybox-thumbs.min.css" integrity="sha256-SEa4XYAHihTcEP1f5gARTB2K26Uk8PsndQYHQC1f4jU=" crossorigin="anonymous" />
    
    
    <link rel="stylesheet" href="http://nianze.tk/css/style-nnm2spxvve8onlujjlegkkytaehyadd4ksxc1hyzzq9a2wvtrgbljqyulomn.min.css" />
    
    
      
        <link rel="stylesheet" href="http://nianze.tk/css/main.css">
      
    
      
        <link rel="stylesheet" href="http://nianze.tk/css/loader.css">
      
    

    
      
<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
	(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
	m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
	})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
	ga('create', 'UA-71584380-1', 'auto');
	
	ga('send', 'pageview');
}
</script>

    
    
  </head>

  <body id="container">
    <div id="blog">
      <header id="header" data-behavior="4">
  <i id="btn-open-sidebar" class="fas fa-bars"></i>
  <div class="header-title">
    <a class="header-title-link" href="http://nianze.tk/">Be creative</a>
  </div>
  
    
      <a class="header-right-picture "
         href="http://nianze.tk/#about">
    
    
    
      
        <img class="header-picture" src="http://nianze.tk/images/bw.JPG" alt="Author&#39;s picture" />
      
    
    </a>
  
</header>

      <nav id="sidebar" data-behavior="4">
  <div class="sidebar-container">
    
      <div class="sidebar-profile">
        <a href="http://nianze.tk/#about">
          <img class="sidebar-profile-picture" src="http://nianze.tk/images/bw.JPG" alt="Author&#39;s picture" />
        </a>
        <h4 class="sidebar-profile-name">刀心の水</h4>
        
          <h5 class="sidebar-profile-bio"><p>虚度廿余岁月浅，略识几行代码源。<br />
闲来随手快门按，怆然独把音韵弹。</p>

<p>Pain is inevitable.<br />
Suffering is optional.</p>
</h5>
        
      </div>
    
    <ul class="sidebar-buttons">
      
  <li class="sidebar-button">
    
      <a class="sidebar-button-link " href="http://nianze.tk/">
    
      <i class="sidebar-button-icon fas fa-home" title='Home'></i>
      
      <span class="sidebar-button-desc">Home</span>
    </a>
  </li>

  <li class="sidebar-button">
    
      <a class="sidebar-button-link " href="http://nianze.tk/categories/thoughts">
    
      <i class="sidebar-button-icon fas fa-lightbulb" title='Thoughts'></i>
      
      <span class="sidebar-button-desc">Thoughts</span>
    </a>
  </li>

  <li class="sidebar-button">
    
      <a class="sidebar-button-link " href="http://nianze.tk/categories/technology">
    
      <i class="sidebar-button-icon fas fa-code" title='Technology'></i>
      
      <span class="sidebar-button-desc">Technology</span>
    </a>
  </li>

  <li class="sidebar-button">
    
      <a class="sidebar-button-link " href="http://nianze.tk/categories/music">
    
      <i class="sidebar-button-icon fas fa-music" title='Music'></i>
      
      <span class="sidebar-button-desc">Music</span>
    </a>
  </li>

  <li class="sidebar-button">
    
      <a class="sidebar-button-link " href="http://nianze.tk/categories/visual">
    
      <i class="sidebar-button-icon fas fa-palette" title='Visual'></i>
      
      <span class="sidebar-button-desc">Visual</span>
    </a>
  </li>

  <li class="sidebar-button">
    
      <a class="sidebar-button-link " href="http://nianze.tk/categories">
    
      <i class="sidebar-button-icon fas fa-bookmark" title='Categories'></i>
      
      <span class="sidebar-button-desc">Categories</span>
    </a>
  </li>

  <li class="sidebar-button">
    
      <a class="sidebar-button-link " href="http://nianze.tk/tags">
    
      <i class="sidebar-button-icon fas fa-tags" title='Tags'></i>
      
      <span class="sidebar-button-desc">Tags</span>
    </a>
  </li>

  <li class="sidebar-button">
    
      <a class="sidebar-button-link " href="http://nianze.tk/archives">
    
      <i class="sidebar-button-icon fas fa-archive" title='Archives'></i>
      
      <span class="sidebar-button-desc">Archives</span>
    </a>
  </li>

  <li class="sidebar-button">
    
      <a class="sidebar-button-link " href="http://nianze.tk/about">
    
      <i class="sidebar-button-icon fas fa-user" title='About'></i>
      
      <span class="sidebar-button-desc">About</span>
    </a>
  </li>


    </ul>
    <ul class="sidebar-buttons">
      
  <li class="sidebar-button">
    
      <a class="sidebar-button-link " href="https://www.linkedin.com/in/nianze" target="_blank" rel="noopener">
    
      <i class="sidebar-button-icon fab fa-linkedin" title='LinkedIn'></i>
      
      <span class="sidebar-button-desc">LinkedIn</span>
    </a>
  </li>

  <li class="sidebar-button">
    
      <a class="sidebar-button-link " href="https://github.com/Nianze" target="_blank" rel="noopener">
    
      <i class="sidebar-button-icon fab fa-github" title='Github'></i>
      
      <span class="sidebar-button-desc">GitHub</span>
    </a>
  </li>

  <li class="sidebar-button">
    
      <a class="sidebar-button-link " href="https://www.flickr.com/photos/129774362@N07/" target="_blank" rel="noopener">
    
      <i class="sidebar-button-icon fab fa-flickr", title='Flickr'></i>
      
      <span class="sidebar-button-desc">Flickr</span>
    </a>
  </li>

  <li class="sidebar-button">
    
      <a class="sidebar-button-link " href="https://instagram.com/eznain" target="_blank" rel="noopener">
    
      <i class="sidebar-button-icon fab fa-instagram" title='Instagram'></i>
      
      <span class="sidebar-button-desc">Instagram</span>
    </a>
  </li>

  <li class="sidebar-button">
    
      <a class="sidebar-button-link " href="https://www.facebook.com/rym.lnz" target="_blank" rel="noopener">
    
      <i class="sidebar-button-icon fab fa-facebook", title='Facebook'></i>
      
      <span class="sidebar-button-desc">Facebook</span>
    </a>
  </li>

  <li class="sidebar-button">
    
      <a class="sidebar-button-link " href="https://twitter.com/daoxinzhishui" target="_blank" rel="noopener">
    
      <i class="sidebar-button-icon fab fa-twitter", title='Twitter'></i>
      
      <span class="sidebar-button-desc">Twitter</span>
    </a>
  </li>

  <li class="sidebar-button">
    
      <a class="sidebar-button-link " href="https://www.youtube.com/user/daoxinzhishui" target="_blank" rel="noopener">
    
      <i class="sidebar-button-icon fab fa-youtube", title='YouTube'></i>
      
      <span class="sidebar-button-desc">YouTube</span>
    </a>
  </li>

  <li class="sidebar-button">
    
      <a class="sidebar-button-link " href="mailto:daoxinzhishui@gmail.com" target="_blank" rel="noopener">
    
      <i class="sidebar-button-icon fas fa-envelope", title='Email'></i>
      
      <span class="sidebar-button-desc">Email</span>
    </a>
  </li>

  <li class="sidebar-button">
    
      <a class="sidebar-button-link " href="http://nianze.tk/post/index.xml">
    
      <i class="sidebar-button-icon fas fa-rss-square", title='RSS'></i>
      
      <span class="sidebar-button-desc">RSS</span>
    </a>
  </li>


    </ul>
    <ul class="sidebar-buttons">
      

    </ul>
  </div>
</nav>

      

      <div id="main" data-behavior="4"
        class="
               hasCoverMetaIn
               ">
        <article class="post" itemscope itemType="http://schema.org/BlogPosting">
          
          
            <div class="post-header main-content-wrap text-left">
  
    <h1 class="post-title" itemprop="headline">
      [MECpp]Item-28 Smart Pointers
    </h1>
  
  
  <div class="postShorten-meta post-meta">
    
      <time itemprop="datePublished" datetime="2018-05-05T16:38:03-04:00">
        
  May 5, 2018

      </time>
    
    
  
  
    <span>in</span>
    
      <a class="category-link" href="http://nianze.tk/categories/technology">technology</a>, 
    
      <a class="category-link" href="http://nianze.tk/categories/coding">coding</a>
    
  

  </div>

</div>
          
          <div class="post-content markdown" itemprop="articleBody">
            <div class="main-content-wrap">
              <p><em>Smart pointers</em> are designed to look, act, and feel like built-in pointers, but to offer greater functionality.</p>

<h1 id="table-of-contents">Table of Contents</h1><nav id="TableOfContents">
<ul>
<li><a href="#advantages-of-smart-pointers">Advantages of smart pointers</a>
<ul>
<li><a href="#using-smart-pointer-in-client-perspective">Using smart pointer in client perspective</a></li>
</ul></li>
<li><a href="#construction-assignment-and-destruction-of-smart-pointers">Construction, assignment, and destruction of smart pointers</a>
<ul>
<li><a href="#1-pass-by-reference-to-const">1. Pass by reference to const</a></li>
<li><a href="#2-unconventional-copy-constructor-and-assignment-operator">2. Unconventional copy constructor and assignment operator</a></li>
<li><a href="#3-no-ownership-testing-in-desturctor">3. No ownership testing in desturctor</a></li>
</ul></li>
<li><a href="#implementing-the-dereferencing-operators">Implementing the dereferencing operators</a>
<ul>
<li><a href="#operator"><code>operator*</code></a></li>
<li><a href="#operator-1"><code>operator-&gt;</code></a></li>
</ul></li>
<li><a href="#testing-smart-pointers-for-nullness">Testing smart pointers for nullness</a></li>
<li><a href="#converting-smart-pointers-to-dumb-pointers">Converting smart pointers to dumb pointers</a></li>
<li><a href="#smart-pointers-and-inheritance-based-type-conversions">Smart pointers and inheritance-based type conversions</a>
<ul>
<li><a href="#manually-adding-implicit-conversion-operator">Manually adding implicit conversion operator</a></li>
<li><a href="#generating-conversion-operators-via-member-templates">Generating conversion operators via member templates</a></li>
</ul></li>
<li><a href="#smart-pointers-and-const">Smart pointers and const</a></li>
</ul>
</nav>

<h1 id="advantages-of-smart-pointers">Advantages of smart pointers</h1>

<p>With the help of smart pointers, we gain control over the following aspects of pointer behavior:</p>

<ol>
<li>Construction and destrucrtion (default value, reference counting, etc)</li>
<li>Copying and assignment (deep copy, not allowed to copy, etc)</li>
<li>Dereferencing (lazy fetching, etc)</li>
</ol>

<h2 id="using-smart-pointer-in-client-perspective">Using smart pointer in client perspective</h2>

<p>Consider a distributed system in which some objects are local and some are remote. We can use smart pointer to manage the local and remote objects handling in order to offer such an illusion that all objects appear to be located in the same place.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">T</span><span style="color:#f92672">&gt;</span>            <span style="color:#75715e">// template for smart ptrs
</span><span style="color:#75715e"></span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">DBPtr</span> {                <span style="color:#75715e">// to obj. in a distributed DB
</span><span style="color:#75715e"></span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
	DBPtr(T <span style="color:#f92672">*</span>realPtr <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>);   <span style="color:#75715e">// create a smart ptr to a DB obj given a local dumb pointer
</span><span style="color:#75715e"></span>	DBPtr(DataBaseID id);    <span style="color:#75715e">// create a smart ptr to a DB obj given its unique DB identifier
</span><span style="color:#75715e"></span>	...                      <span style="color:#75715e">// other smart ptr functions
</span><span style="color:#75715e"></span>};

<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Tuple</span> { <span style="color:#75715e">// class for database tuples
</span><span style="color:#75715e"></span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
	...
	<span style="color:#66d9ef">void</span> displayEditDialog();  <span style="color:#75715e">// present a graphical dialog box allowing a user to edit the typle
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">isValid</span>() <span style="color:#66d9ef">const</span>;  <span style="color:#75715e">// return whether *this passes validity check
</span><span style="color:#75715e"></span>};

<span style="color:#75715e">// class template for making log entries whenever a T object is modified
</span><span style="color:#75715e"></span><span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">T</span><span style="color:#f92672">&gt;</span>
<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">LogEntry</span> {
<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
	LogEntry(<span style="color:#66d9ef">const</span> T<span style="color:#f92672">&amp;</span> objectToBeModified);
	<span style="color:#f92672">~</span>LogEntry();
};

<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">editTuple</span>(DBPtr<span style="color:#f92672">&lt;</span>Tuple<span style="color:#f92672">&gt;</span><span style="color:#f92672">&amp;</span> pt)
{
	LogEnty<span style="color:#f92672">&lt;</span>Tuple<span style="color:#f92672">&gt;</span> entry(<span style="color:#f92672">*</span>pt); <span style="color:#75715e">// make log entry for this editing operation
</span><span style="color:#75715e"></span>	<span style="color:#75715e">// repeatedly display edit dialog until valid values are provided
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">do</span> {
		pt<span style="color:#f92672">-</span><span style="color:#f92672">&gt;</span>displayEditDialog();
	} <span style="color:#66d9ef">while</span> (pt<span style="color:#f92672">-</span><span style="color:#f92672">&gt;</span>isValid() <span style="color:#f92672">=</span><span style="color:#f92672">=</span> false)
}
</code></pre></div>
<p>The tuple to ber edited inside <code>editTuple</code> may be physically located on a remote machine, but the programmer writing <code>editTuple</code> need not be converned with such matters. Wrapped by objects, all kinds of tuples are accessed through smart pointers, which act just like built-in pointers (except for how they&rsquo;re declared).</p>

<p>Notice the use of <code>LogEntry</code> object here is to take the advantage of <code>LogEntry</code>&rsquo;s constructor and destructor to begin and end the log entry, which is more robust in the face of exceptions than explicitly calling functions (MECpp item 9).</p>

<p>In a word, clients of smart pointers are <em>supposed</em> to be able to treat them as dumb pointers.</p>

<h1 id="construction-assignment-and-destruction-of-smart-pointers">Construction, assignment, and destruction of smart pointers</h1>

<p>Construction of a smart pointer is usually straightforward: locate an object to point to, then make the smart pointer&rsquo;s internal dumb pointer point there. If no object can be located, set the internal pointer to 0 or signal an error (by throwing an exception).</p>

<p>However, the issue of <em>ownership</em> makes it complicated to implement a smart pointer&rsquo;s copy constructor, assignment operator(s), and destructor: depending on wheter a smart pointer <em>owns</em> the object it points to, should it delete the object when the smart pointer itself is destroyed?</p>

<ul>
<li><p>if we just copied the internal dumb pointer in copy constructor and call <code>delete</code> in destructor, we end up with two smart pointers pointing to the same object, resulting to multiple deletes, which is undefined behavior.</p></li>

<li><p>if we create a new copy of what was pointed to by calling <code>new</code> in the copy constructor, we may have to face an unacceptable performance hit for the creation (and later destruction) of the new object. Further more, we wouldn&rsquo;t know what type of object to create, because a smart pointer of type <code>T</code> might point to an object of a type derived from <code>T</code>. Virtual constructors can help solve this problem, but it seems inappropriate to require their use in a general-purpose smart pointer class.</p></li>
</ul>

<p>The problem would vanish if we prohibit copying and assignment, but a more flexible solution was adopted by the <code>auto_ptr</code> template from the standard C++ library: object ownership is <em>transferred</em> when an <code>auto_ptr</code> is copied or assigned:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">T</span><span style="color:#f92672">&gt;</span>
<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">auto_ptr</span> {
<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
	auto_ptr(T <span style="color:#f92672">*</span>ptr <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>)<span style="color:#f92672">:</span> pointee(ptr) {}
	auto_ptr(auto_ptr<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span><span style="color:#f92672">&amp;</span> rhs);  <span style="color:#75715e">// copy constructor
</span><span style="color:#75715e"></span>	auto_ptr<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span><span style="color:#f92672">&amp;</span> <span style="color:#66d9ef">operator</span><span style="color:#f92672">=</span>(auto_ptr<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span><span style="color:#f92672">&amp;</span> rhs); <span style="color:#75715e">// assignment operator
</span><span style="color:#75715e"></span>	<span style="color:#f92672">~</span>auto_ptr<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span>() { <span style="color:#66d9ef">delete</span> pointee; }
<span style="color:#66d9ef">private</span><span style="color:#f92672">:</span>
	T <span style="color:#f92672">*</span>pointee;
};

<span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">T</span><span style="color:#f92672">&gt;</span>
auto_ptr<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span><span style="color:#f92672">:</span><span style="color:#f92672">:</span>auto_ptr(auto_ptr<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span><span style="color:#f92672">&amp;</span> rhs)
{
	pointee <span style="color:#f92672">=</span> rhs.pointee;
	rhs.pointee <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
}

<span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">T</span><span style="color:#f92672">&gt;</span>
auto_ptr<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span><span style="color:#f92672">&amp;</span> auto_ptr<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span><span style="color:#f92672">:</span><span style="color:#f92672">:</span><span style="color:#66d9ef">operator</span><span style="color:#f92672">=</span>(auto_ptr<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span><span style="color:#f92672">&amp;</span> rhs)
{
	<span style="color:#66d9ef">if</span> (<span style="color:#66d9ef">this</span> <span style="color:#f92672">=</span><span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>rhs)
		<span style="color:#66d9ef">return</span> <span style="color:#f92672">*</span><span style="color:#66d9ef">this</span>;
	<span style="color:#66d9ef">delete</span> pointee;

	pointee <span style="color:#f92672">=</span> rhs.pointee;
	rhs.pointee <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;

	<span style="color:#66d9ef">return</span> <span style="color:#f92672">*</span><span style="color:#66d9ef">this</span>;
}
</code></pre></div>
<p>For this design, there are three points woth noting:</p>

<h2 id="1-pass-by-reference-to-const">1. Pass by reference to const</h2>

<p>Because object ownership is transferred when <code>auto_ptr</code>&rsquo;s copy constructor is called, passing <code>auto_ptr</code>s by value is often a very bad idea:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">printTreeNode</span>(ostream<span style="color:#f92672">&amp;</span> s, auto_ptr<span style="color:#f92672">&lt;</span>TreeNode<span style="color:#f92672">&gt;</span> p)
{ s <span style="color:#f92672">&lt;</span><span style="color:#f92672">&lt;</span> <span style="color:#f92672">*</span>p; }

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>()
{
	auto_ptr<span style="color:#f92672">&lt;</span>TreeNode<span style="color:#f92672">&gt;</span> ptn(<span style="color:#66d9ef">new</span> TreeNode);
	...
	printTreeNode(cout, ptn);  <span style="color:#75715e">// pass auto_ptr by value
</span><span style="color:#75715e"></span>}
</code></pre></div>
<p>When <code>printTreeNode</code>&rsquo;s parameter <code>p</code> is initialized by calling <code>auto_ptr</code>&rsquo;s copy constructor, ownership of the object pointed to by <code>ptn</code> is transferred to <code>p</code>. After <code>printTreeNode</code> finishes execution, <code>p</code> goes out of scope and its destructor deletes what it points to, so <code>ptn</code> no longer points to anything (its underlying dumb pointer is null). This is rarely what we want to do.</p>

<p>Instead, pass-by-reference-to-const:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">// this function behaves much more intuitively
</span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">printTreeNode</span>(ostream<span style="color:#f92672">&amp;</span> s, <span style="color:#66d9ef">const</span> auto_ptr<span style="color:#f92672">&lt;</span>TreeNode<span style="color:#f92672">&gt;</span><span style="color:#f92672">&amp;</span> p)
{ s <span style="color:#f92672">&lt;</span><span style="color:#f92672">&lt;</span> <span style="color:#f92672">*</span>p; }
</code></pre></div>
<p>Since this is pass by reference, no constructor is called to initialize <code>p</code>, and <code>ptn</code> retains ownership of the object it points after function execution.</p>

<h2 id="2-unconventional-copy-constructor-and-assignment-operator">2. Unconventional copy constructor and assignment operator</h2>

<p>Normally the copy constructor and assignment operator take <code>const</code> parameters during the copy or the assignment. However, <code>auto_ptr</code> objects are modified if they are copied or are the source of an assignment, so we don&rsquo;t declare <code>const</code> here for the copy constructor and assignment operator in <code>auto_ptr</code>.</p>

<h2 id="3-no-ownership-testing-in-desturctor">3. No ownership testing in desturctor</h2>

<p>An <code>auto_ptr</code> always owns what it points to, so there is no need for the ownership test in destructor. However, a smart pointers that employs reference counting (MECpp item 29) must adjust a reference count before detrmining whether it has the right to delete what it points to, so their destructor often looks like this:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp">tempalte<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">T</span><span style="color:#f92672">&gt;</span>
SmartPtr<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span><span style="color:#f92672">:</span><span style="color:#f92672">:</span><span style="color:#f92672">~</span>SmartPtr()
{
	<span style="color:#66d9ef">if</span> (<span style="color:#f92672">*</span><span style="color:#66d9ef">this</span> owns <span style="color:#f92672">*</span>pointee) {
		<span style="color:#66d9ef">delete</span> pointee;
	}
}
</code></pre></div>
<h1 id="implementing-the-dereferencing-operators">Implementing the dereferencing operators</h1>

<h2 id="operator"><code>operator*</code></h2>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">T</span><span style="color:#f92672">&gt;</span>
T<span style="color:#f92672">&amp;</span> SmartPtr<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span><span style="color:#f92672">:</span><span style="color:#f92672">:</span><span style="color:#66d9ef">operator</span><span style="color:#f92672">*</span>() <span style="color:#66d9ef">const</span>
{
	perform <span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">smart pointer</span><span style="color:#e6db74">&#34;</span> processing;
	<span style="color:#66d9ef">return</span> <span style="color:#f92672">*</span>pointee;	
}
</code></pre></div>
<p>A few things woth noting:</p>

<ol>
<li>The &ldquo;smart pointer&rdquo; processing does whatever is needed to initialize or otherwise make <code>pointee</code> valid. For example, if lazy fetching is being used (MECpp item 17), the process may conjure up a new object for <code>pointee</code> to point to.</li>
<li>The <code>operator*</code> returns a <em>reference</em> to the pointed-to object, instead of an <em>object</em>. This is for concerns of both correctness and efficiency.

<ul>
<li>Correctness: if returning an <em>object</em>, this is possible for <em>slicing problem</em> - see MECpp item 13 - where a <code>T</code> object is returned instead of an actual derived class object that is expected.</li>
<li>Efficiency: there is no need to construcrt a temporary object (MECpp 19), so returning a reference is more efficient.</li>
</ul></li>
<li>The result of dereferencing a null pointer is undefined, so we are free to do anything we want if <code>operator*</code> is invoked with a null smart pointer. (i.e., throw an exception, call <code>abort</code>, etc)</li>
</ol>

<h2 id="operator-1"><code>operator-&gt;</code></h2>

<p>When we call <code>operator-&gt;</code> in the statement <code>pt-&gt;displayEditDialog();</code>, the compilers treat it as:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp">(pt.<span style="color:#66d9ef">operator</span><span style="color:#f92672">-</span><span style="color:#f92672">&gt;</span>())<span style="color:#f92672">-</span><span style="color:#f92672">&gt;</span>displayEditDialog();
</code></pre></div>
<p>This means it must be legal to apply the member-selection operator(-&gt;) to whatever <code>operator-&gt;</code> returns, leading to only two options:</p>

<ul>
<li>a dumb pointer to an object</li>
<li>another smart pointer object</li>
</ul>

<p>Most of the time we want to return an ordinary dumb pointer, so the implementation for <code>operator-&gt;</code> is:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">T</span><span style="color:#f92672">&gt;</span>
T<span style="color:#f92672">*</span> SmartPtr<span style="color:#f92672">:</span><span style="color:#f92672">:</span><span style="color:#66d9ef">operator</span><span style="color:#f92672">-</span><span style="color:#f92672">&gt;</span>() <span style="color:#66d9ef">const</span>
{
	perform <span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">smart pointer</span><span style="color:#e6db74">&#34;</span> processing
	<span style="color:#66d9ef">return</span> pointee;
}
</code></pre></div>
<p>Note that since this function returns a pointer, virtual function calls via <code>operator-&gt;</code> will behave the way they&rsquo;re supposed to.</p>

<h1 id="testing-smart-pointers-for-nullness">Testing smart pointers for nullness</h1>

<p>So far we can not do the following operation to find out if a smart pointer is null:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp">SmartPtr<span style="color:#f92672">&lt;</span>TreeNode<span style="color:#f92672">&gt;</span> ptn;
...
<span style="color:#66d9ef">if</span> (ptn <span style="color:#f92672">=</span><span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>) ... <span style="color:#75715e">// error!
</span><span style="color:#75715e"></span><span style="color:#66d9ef">if</span> (ptn) ...      <span style="color:#75715e">// error!
</span><span style="color:#75715e"></span><span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>ptn) ...     <span style="color:#75715e">// error!
</span></code></pre></div>
<p>If we want to make smart pointer act like dumb pointers when testing for nullness, an additional <code>isNull</code> member function will not be ideal solution. We may be attempted to provide an implicit conversion operator: <code>operator void*()</code>, but this will also introduce the draback of letting function calls succeed that most programmers would expect to fail (see MECpp item 5). In particular, it allows comparisons of smart pointers of completely different types:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp">SmartPtr<span style="color:#f92672">&lt;</span>Apple<span style="color:#f92672">&gt;</span> pa;
SmartPtr<span style="color:#f92672">&lt;</span>Orange<span style="color:#f92672">&gt;</span> po;
...
<span style="color:#66d9ef">if</span> (pa <span style="color:#f92672">=</span><span style="color:#f92672">=</span> po) ... <span style="color:#75715e">// this compiles!
</span></code></pre></div>
<p>This compiles because both smart pointers can be implicitly converted into <code>void*</code> pointers, and there is a built-in comparison function for built-in pointers. Similarly, even if we advocate conversion to <code>const void*</code> or <code>bool</code>, neither of these variations eliminates the problem of allowing mixed-type comparisons. There is simply too much conversion freedom in this wild solution.</p>

<p>There is a middle middle ground that allows us to offer a reasonable syntactic form for testing for nullness while minimizing the chances of accidentally comparing smart pointers of of different types. That is to overload <code>operator!</code> to return true if and only if the smart pointer on which it&rsquo;s invoked is null:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">T</span><span style="color:#f92672">&gt;</span>
<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">SmartPtr</span> {
<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
	...
	<span style="color:#66d9ef">bool</span> <span style="color:#66d9ef">operator</span><span style="color:#f92672">!</span>() <span style="color:#66d9ef">const</span>; <span style="color:#75715e">// returns true if and only if the smart ptr is null
</span><span style="color:#75715e"></span>};
</code></pre></div>
<p>This will lead to:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>ptn) ...  <span style="color:#75715e">// fine
</span><span style="color:#75715e"></span><span style="color:#66d9ef">if</span> (ptn <span style="color:#f92672">=</span><span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>)  ...  <span style="color:#75715e">// still an error
</span><span style="color:#75715e"></span><span style="color:#66d9ef">if</span> (ptn) ...  <span style="color:#75715e">// still an error
</span></code></pre></div>
<p>And the only risk for mixed-type comparisons is statements such as this:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp">...
<span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>pa <span style="color:#f92672">=</span><span style="color:#f92672">=</span> <span style="color:#f92672">!</span>po) ...  <span style="color:#75715e">// this still compiles
</span></code></pre></div>
<p>Fortunately, programmers usually don&rsquo;t write code like this.</p>

<h1 id="converting-smart-pointers-to-dumb-pointers">Converting smart pointers to dumb pointers</h1>

<p>When a dump pointer is expected for some lagacy libraries (say <code>normalize(Tuple *pt);</code>), we can not simply call the library function with a smart pointer-to-<code>Tuple</code>, because there is no way to convert a <code>DBPtr&lt;Tuple&gt;</code> to a <code>Tuple*</code>. We can make it work by doing this:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp">normalize(<span style="color:#f92672">&amp;</span><span style="color:#f92672">*</span>pt);  <span style="color:#75715e">// gross, but legal
</span></code></pre></div>
<p>but apparently this is not elegant.</p>

<p>A dangerous solution will be to add to the smart pointer-to-T template an implicit conversion operator to a dumb pointer-to-T:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">T</span><span style="color:#f92672">&gt;</span>
<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">DBPtr</span>{
<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>	
	...
	<span style="color:#66d9ef">operator</span> T<span style="color:#f92672">*</span>() { <span style="color:#66d9ef">return</span> pointee; }
	...
};

DBPtr<span style="color:#f92672">&lt;</span>Tuple<span style="color:#f92672">&gt;</span> pt;
...
normalize(pt);  <span style="color:#75715e">// this now works
</span><span style="color:#75715e"></span><span style="color:#66d9ef">if</span> (pt <span style="color:#f92672">=</span><span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>) ...  <span style="color:#75715e">// fine, too
</span><span style="color:#75715e"></span><span style="color:#66d9ef">if</span> (pt) ... <span style="color:#75715e">// fine, too
</span><span style="color:#75715e"></span><span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>pt) ...  <span style="color:#75715e">// fine, too
</span></code></pre></div>
<p>However, as stated in MECpp item 5, there&rsquo;s dark side to such conversion function: it&rsquo;s so easy for clients to get access to dumb pointers that they bypass all the smart behavior (such as reference-counting ability) our pointer-like objects designed to provide, which will almost certainly lead to disaster (such as bookkeeping errors that corrupt the reference-counting data structures):</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">processTuple</span>(DBPtr<span style="color:#f92672">&lt;</span>Tuple<span style="color:#f92672">&gt;</span><span style="color:#f92672">&amp;</span> pt)
{
	Tuple <span style="color:#f92672">*</span>rawTuplePtr <span style="color:#f92672">=</span> pt;  <span style="color:#75715e">// convert DBPtr&lt;Tuple&gt; to Tuple*
</span><span style="color:#75715e"></span>	use rawTuplePtr to modify the tuple;
}
</code></pre></div>
<p>Besides, even we provide such implicit conversion operator, our smart pointer will never be truly interchangeable with the dumb pointer: the conversion from a smart pointer to a dumb pointer is a user-defined conversion, and compilers are forbidden from applying more than one user-defined conversion at a time. Following example shows this difference, where conversion from <code>DBPtr&lt;Tuple&gt;</code> to <code>TupleAccessors</code> calls for two user-defined conversions (1. <code>DBTpr&lt;Tuple&gt;</code> -&gt; <code>Tuple*</code>; 2. <code>Tuple*</code> -&gt; <code>TupleAccessors</code>), which are prohibited by the language:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">TupleAccessors</span> {
<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
	TupleAccessors(<span style="color:#66d9ef">const</span> Tuple <span style="color:#f92672">*</span>pt); <span style="color:#75715e">// this ctor also acts as a type-conversion operator
</span><span style="color:#75715e"></span>	...
};
TupleAccessors <span style="color:#a6e22e">merge</span>(<span style="color:#66d9ef">const</span> TupleAccessors<span style="color:#f92672">&amp;</span> ta1, <span style="color:#66d9ef">const</span> TupleAccessors<span style="color:#f92672">&amp;</span> ta2);
...
Tuple <span style="color:#f92672">*</span>pt1, <span style="color:#f92672">*</span>pt2;
merge(pt1, pt2);  <span style="color:#75715e">// fine, both pointers are converted to TupleAccessors objects
</span><span style="color:#75715e"></span>...
DBPtr<span style="color:#f92672">&lt;</span>Tuple<span style="color:#f92672">&gt;</span> smart_pt1, smart_pt2;
merge(smart_pt1, smart_pt2);  <span style="color:#75715e">// error! no way to convert smart_pt1 and smart_pt2 to TupleAccessors implicitly
</span></code></pre></div>
<p>Moreover, implicit conversion functino makes it possible to let evil statement compile, which will almost certainly break our program later<sup class="footnote-ref" id="fnref:1"><a href="#fn:1">1</a></sup>:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp">DBPtr<span style="color:#f92672">&lt;</span>Tuple<span style="color:#f92672">&gt;</span> pt <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Tuple;
...
<span style="color:#66d9ef">delete</span> pt;  <span style="color:#75715e">// this compiles
</span></code></pre></div>
<p>All in all, keep in mind the bottom line: don&rsquo;t provide implicit conversion operators to dumb pointers unless there is a compelling reason to do so.</p>

<h1 id="smart-pointers-and-inheritance-based-type-conversions">Smart pointers and inheritance-based type conversions</h1>

<p>Given the following public inheritance hierarchy:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">MusicProduct</span> {
<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
	MusicProduct(<span style="color:#66d9ef">const</span> string<span style="color:#f92672">&amp;</span> title);
	<span style="color:#66d9ef">virtual</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">play</span>() <span style="color:#66d9ef">const</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
	<span style="color:#66d9ef">virtual</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">displayTitle</span>() <span style="color:#66d9ef">const</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
};
<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Cassette</span><span style="color:#f92672">:</span> <span style="color:#66d9ef">public</span> MusicProduct {
<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
	Cassette(<span style="color:#66d9ef">const</span> string<span style="color:#f92672">&amp;</span> title);
	<span style="color:#66d9ef">virtual</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">play</span>() <span style="color:#66d9ef">const</span>;
	vitual <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">displayTitle</span>() <span style="color:#66d9ef">const</span>;
	...
};
<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">CD</span><span style="color:#f92672">:</span> <span style="color:#66d9ef">public</span> MusicProduct {
<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
	CD(<span style="color:#66d9ef">const</span> string<span style="color:#f92672">&amp;</span> title);
	<span style="color:#66d9ef">virtual</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">play</span>() <span style="color:#66d9ef">const</span>;
	<span style="color:#66d9ef">virtual</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">displayTitle</span>() <span style="color:#66d9ef">const</span>;
	...
};
</code></pre></div>
<p>It is expected that the virtual function will work properly with dumb pointers:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">displayAndPlay</span>(<span style="color:#66d9ef">const</span> MusicProduct<span style="color:#f92672">*</span> pmp, <span style="color:#66d9ef">int</span> numTimes)
{
	<span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;</span><span style="color:#f92672">=</span> numTimes; <span style="color:#f92672">+</span><span style="color:#f92672">+</span>i)
	{
		pmp<span style="color:#f92672">-</span><span style="color:#f92672">&gt;</span>displayTitle();
		pmp<span style="color:#f92672">-</span><span style="color:#f92672">&gt;</span>play();
	}
}

Cassette <span style="color:#f92672">*</span>funMusic <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Cassette(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">Alapalooza</span><span style="color:#e6db74">&#34;</span>);
CD <span style="color:#f92672">*</span>nightmareMusic <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> CD(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">Disco Hits of the 70s</span><span style="color:#e6db74">&#34;</span>);

displayAndPlay(funMusic, <span style="color:#ae81ff">10</span>);
displayAndPlay(nightmareMusic, <span style="color:#ae81ff">0</span>);
</code></pre></div>
<p>However, as far as compilers are converned, <code>SmartPtr&lt;CD&gt;</code>, <code>SmartPtr&lt;Cassette&gt;</code>, and <code>SmartPtr&lt;MusicProduct&gt;</code> are three seperate classes without any relationship to one another, so if we pass an object of type <code>SmartPtr&lt;CD&gt;</code> into a function with signature <code>void displayAndPlay(const SmartPtr&lt;MusicProduct&gt;, int)</code>, there will be error.</p>

<h2 id="manually-adding-implicit-conversion-operator">Manually adding implicit conversion operator</h2>

<p>A naive solution: adding into each smart pointer class an implicit type conversion operator. Take <code>SmartPtr&lt;Cassette&gt;</code> for example:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">SmartPtr</span><span style="color:#f92672">&lt;</span>Cassette<span style="color:#f92672">&gt;</span> {
<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
	<span style="color:#66d9ef">operator</span> SmartPtr<span style="color:#f92672">&lt;</span>MusicProduct<span style="color:#f92672">&gt;</span>()
	{ <span style="color:#66d9ef">return</span> SmartPtr<span style="color:#f92672">&lt;</span>MusicProduct<span style="color:#f92672">&gt;</span>(pointee); }
	...
};
</code></pre></div>
<p>Yet there are two drawbacks in this design:</p>

<ol>
<li>manually adding the necessary implicit type conversion operators specializes the <code>SmartPtr</code> class instantiations, which defeats the purpose of templates</li>
<li>too many conversion operators to add - given a deep inheritance hierarchy, we must provide a conversion operator for <em>each</em> base class from that object directly or indirectly inherits (again, compilers are prohibited from employing more than one user-defined type conversion function at a time.)</li>
</ol>

<h2 id="generating-conversion-operators-via-member-templates">Generating conversion operators via member templates</h2>

<p>The right way to take is to take advantage of <em>member function templates</em> (or just <em>member templates</em>):</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">T</span><span style="color:#f92672">&gt;</span>
<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">SmartPtr</span> {
<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
	SmartPtr(T<span style="color:#f92672">*</span> realPtr <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>);
	T<span style="color:#f92672">*</span> <span style="color:#66d9ef">operator</span><span style="color:#f92672">-</span><span style="color:#f92672">&gt;</span>() <span style="color:#66d9ef">const</span>;
	T<span style="color:#f92672">*</span> <span style="color:#66d9ef">operator</span><span style="color:#f92672">*</span>() <span style="color:#66d9ef">const</span>;

	<span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">newType</span><span style="color:#f92672">&gt;</span>      <span style="color:#75715e">// template function for
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">operator</span> SmartPtr<span style="color:#f92672">&lt;</span>newType<span style="color:#f92672">&gt;</span>() <span style="color:#75715e">// implicit conversion ops.
</span><span style="color:#75715e"></span>	{
		<span style="color:#66d9ef">return</span> SmartPtr<span style="color:#f92672">&lt;</span>newType<span style="color:#f92672">&gt;</span>(pointee);
	}
};
</code></pre></div>
<p>Here&rsquo;s what happens:</p>

<ul>
<li>Compiler needs to convert a smart pointer-to-<code>T</code> object into a smart pointer-to-base-class-of-<code>T</code></li>
<li>Compiler checks the class definition for <code>SmartPtr&lt;T&gt;</code> to see if the requisite conversion operator is declared -&gt; it is not</li>
<li>Compiler then checks to see if there&rsquo;s a member function template it can instantiate that would perform the wanted conversion -&gt; it finds a template</li>
<li>Compiler instantiates the template with <code>newType</code> bound to the base class of <code>T</code></li>
<li>Given this instantiated member function, compiler finds it legal to pass the dumb pointer <code>pointee</code> to the constructor for the smart pointer-to-base-of-<code>T</code>, because <code>T</code>-type <code>pointee</code> is legal to be converted into a pointer to its (public or protected) base classes</li>
<li>The code compiles -&gt; the implicit conversion from smart pointer-to-<code>T</code> to smart pointer-to-base-of-<code>T</code> succeeds</li>
</ul>

<p>Note that this implicit conversion will succeed for <em>any</em> legal implicit conversion between pointer types: if (and only if) a dumb pointer type <code>T1*</code> can be implicitly converted to another pointer type <code>T2*</code>, we can implicitly convert a smart pointer-to-<code>T1</code> to a smart pointer-to-<code>T2</code>.</p>

<p>However, there&rsquo;s still a drawback: suppose following augmented <code>MusicProduct</code> hierarchy:</p>
<pre><code>                  ┌──────────────┐
 				  │ MusicProduct │
                  └──────────────┘
   					  ↗     ↖ 
             ┌──────────┐      ┌────┐
             │ Cassette │      │ CD │
             └──────────┘      └────┘
                   ↑
             ┌───────────┐
             │ CasSingle │
             └───────────┘</code></pre><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">T</span><span style="color:#f92672">&gt;</span>      <span style="color:#75715e">// as above, including member tempate
</span><span style="color:#75715e"></span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">SmartPtr</span> {...};

<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">displayAndPlay</span>(<span style="color:#66d9ef">const</span> SmartPtr<span style="color:#f92672">&lt;</span>MusicProduct<span style="color:#f92672">&gt;</span><span style="color:#f92672">&amp;</span> pmp, <span style="color:#66d9ef">int</span> howMany);
<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">displayAndPaly</span>(<span style="color:#66d9ef">const</span> SmartPtr<span style="color:#f92672">&lt;</span>Cassette<span style="color:#f92672">&gt;</span><span style="color:#f92672">&amp;</span> pc, <span style="color:#66d9ef">int</span> howMany);

SamrtPtr<span style="color:#f92672">&lt;</span>CasSingle<span style="color:#f92672">&gt;</span> dumbMusic(<span style="color:#66d9ef">new</span> CasSingle(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">Achy Breaky Heart</span><span style="color:#e6db74">&#34;</span>));
displayAndPlay(dumbMusic, <span style="color:#ae81ff">1</span>);  <span style="color:#75715e">// error!
</span></code></pre></div>
<p>When invoking <code>displayAndPlay</code> with a <code>SmartPtr&lt;CasSingle&gt;</code>, according to the inheritance hierarchy, we may expect the <code>SmartPtr&lt;Cassette&gt;</code> function to be chosen, because <code>CasSingle</code> inherits directly from <code>Casssette</code> and only indirectly from <code>MusicProduct</code>. However, it will only work in the case of dumb pointers. For our smart pointers, as far as C++ compilers are concerned, both calls to conversion functions here are equally good (the conversion from <code>SmartPtr&lt;CasSingle&gt;</code> to <code>SmartPtr&lt;Cassette&gt;</code> is no better than the conversion to <code>SmartPtr&lt;MusicProduct&gt;</code>), leading to an error of ambiguous call to <code>displayAndPlay</code>. The best we can do, then, is to use casts (MECpp item 2) in this ambiguous case.</p>

<h1 id="smart-pointers-and-const">Smart pointers and const</h1>

<p>To mimic the flexibility of constness in terms of smart pointers, we use follwoing ways to create four combinations of <code>const</code> and non-<code>const</code> objects and pointers:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp">CD <span style="color:#a6e22e">goodCD</span>(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">Flood</span><span style="color:#e6db74">&#34;</span>);
SmartPtr<span style="color:#f92672">&lt;</span>CD<span style="color:#f92672">&gt;</span> p;  <span style="color:#75715e">// non-const object, non-const pointer
</span><span style="color:#75715e"></span>SmartPtr<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">const</span> CD<span style="color:#f92672">&gt;</span> p;  <span style="color:#75715e">// const object, non-const pointer
</span><span style="color:#75715e"></span><span style="color:#66d9ef">const</span> SmartPtr<span style="color:#f92672">&lt;</span>CD<span style="color:#f92672">&gt;</span> p <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>goodCD;  <span style="color:#75715e">// non-const object, const pointer
</span><span style="color:#75715e"></span><span style="color:#66d9ef">const</span> SmartPtr<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">const</span> CD<span style="color:#f92672">&gt;</span> p <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>goodCD;  <span style="color:#75715e">// const object, const pointer
</span></code></pre></div>
<p>Moreover, we can use the member templates technique shown above for automatically generating the implicit type conversion operators from <code>SmartPtr&lt;CD&gt;</code> to <code>SmartPtr&lt;const CD&gt;</code> - this technique works anytime the corresponding conversion for dumb pointers would work， and conversions involving <code>const</code> are no exception.</p>
<div class="footnotes">

<hr />

<ol>
<li id="fn:1">It is possible that, after <code>delete pt;</code>, <code>pt</code>&rsquo;s destructor (or some true owner of <code>pt</code>) will invoke <code>delete pt;</code> for a second time, and double deletion yields undefined behavior.
 <a class="footnote-return" href="#fnref:1"><sup>[return]</sup></a></li>
</ol>
</div>
              
            </div>
          </div>
          <div id="post-footer" class="post-footer main-content-wrap">
            
              
                
                
                  <div class="post-footer-tags">
                    <span class="text-color-light text-small">TAGGED IN</span><br/>
                    
  <a class="tag tag--primary tag--small" href="http://nianze.tk/tags/technique/">technique</a>

  <a class="tag tag--primary tag--small" href="http://nianze.tk/tags/cpp/">cpp</a>

                  </div>
                
              
            
            <div class="post-actions-wrap">
  
      <nav >
        <ul class="post-actions post-action-nav">
          
            <li class="post-action">
              
                <a class="post-action-btn btn btn--default tooltip--top" href="http://nianze.tk/2018/05/reference-counting/" data-tooltip="[MECpp]Item-29 Reference Counting">
              
                  <i class="fas fa-angle-left"></i>
                  <span class="hide-xs hide-sm text-small icon-ml">NEXT</span>
                </a>
            </li>
            <li class="post-action">
              
                <a class="post-action-btn btn btn--default tooltip--top" href="http://nianze.tk/2018/05/requiring-or-prohibiting-heap-based-objects/" data-tooltip="[MECpp]Item-27 Requiring or Prohibiting Heap Based Objects">
              
                  <span class="hide-xs hide-sm text-small icon-mr">PREVIOUS</span>
                  <i class="fas fa-angle-right"></i>
                </a>
            </li>
          
        </ul>
      </nav>
    <ul class="post-actions post-action-share" >
      
        <li class="post-action hide-lg hide-md hide-sm">
          <a class="post-action-btn btn btn--default btn-open-shareoptions" href="#btn-open-shareoptions">
            <i class="fas fa-share-alt"></i>
          </a>
        </li>
        
          <li class="post-action hide-xs">
            <a class="post-action-btn btn btn--default" target="new" href="https://www.facebook.com/sharer/sharer.php?u=http://nianze.tk/2018/05/smart-pointers/">
              <i class="fab fa-facebook-f"></i>
            </a>
          </li>
        
          <li class="post-action hide-xs">
            <a class="post-action-btn btn btn--default" target="new" href="https://twitter.com/intent/tweet?text=http://nianze.tk/2018/05/smart-pointers/">
              <i class="fab fa-twitter"></i>
            </a>
          </li>
        
          <li class="post-action hide-xs">
            <a class="post-action-btn btn btn--default" target="new" href="https://plus.google.com/share?url=http://nianze.tk/2018/05/smart-pointers/">
              <i class="fab fa-google-plus-g"></i>
            </a>
          </li>
        
      
      
        <li class="post-action">
          <a class="post-action-btn btn btn--default" href="#utteranc_thread" data-tooltip="Comments">
            <i class="fas fa-comment-dots"></i>
          </a>
        </li>
      
      <li class="post-action">
        
          <a class="post-action-btn btn btn--default" href="#table-of-contents" data-tooltip="Table of Contents">
            <i class="fas fa-list"></i>
        
          </a>
      </li>
    </ul>
  
</div>

            
              
                <div id="utteranc_thread">
  <script src="https://utteranc.es/client.js"
    repo= "Nianze/personal-site-comments"
    issue-term="pathname"
    theme="github-light"
    label="✨comment 💬"
    crossorigin="anonymous"
    async>
  </script>
</div>
              
            
          </div>
        </article>
        <footer id="footer" class="main-content-wrap">
  <span class="copyrights">
    &copy; 2019 刀心の水. All Rights Reserved
  </span>
</footer>

      </div>
      <div id="bottom-bar" class="post-bottom-bar" data-behavior="4">
        <div class="post-actions-wrap">
  
      <nav >
        <ul class="post-actions post-action-nav">
          
            <li class="post-action">
              
                <a class="post-action-btn btn btn--default tooltip--top" href="http://nianze.tk/2018/05/reference-counting/" data-tooltip="[MECpp]Item-29 Reference Counting">
              
                  <i class="fas fa-angle-left"></i>
                  <span class="hide-xs hide-sm text-small icon-ml">NEXT</span>
                </a>
            </li>
            <li class="post-action">
              
                <a class="post-action-btn btn btn--default tooltip--top" href="http://nianze.tk/2018/05/requiring-or-prohibiting-heap-based-objects/" data-tooltip="[MECpp]Item-27 Requiring or Prohibiting Heap Based Objects">
              
                  <span class="hide-xs hide-sm text-small icon-mr">PREVIOUS</span>
                  <i class="fas fa-angle-right"></i>
                </a>
            </li>
          
        </ul>
      </nav>
    <ul class="post-actions post-action-share" >
      
        <li class="post-action hide-lg hide-md hide-sm">
          <a class="post-action-btn btn btn--default btn-open-shareoptions" href="#btn-open-shareoptions">
            <i class="fas fa-share-alt"></i>
          </a>
        </li>
        
          <li class="post-action hide-xs">
            <a class="post-action-btn btn btn--default" target="new" href="https://www.facebook.com/sharer/sharer.php?u=http://nianze.tk/2018/05/smart-pointers/">
              <i class="fab fa-facebook-f"></i>
            </a>
          </li>
        
          <li class="post-action hide-xs">
            <a class="post-action-btn btn btn--default" target="new" href="https://twitter.com/intent/tweet?text=http://nianze.tk/2018/05/smart-pointers/">
              <i class="fab fa-twitter"></i>
            </a>
          </li>
        
          <li class="post-action hide-xs">
            <a class="post-action-btn btn btn--default" target="new" href="https://plus.google.com/share?url=http://nianze.tk/2018/05/smart-pointers/">
              <i class="fab fa-google-plus-g"></i>
            </a>
          </li>
        
      
      
        <li class="post-action">
          <a class="post-action-btn btn btn--default" href="#utteranc_thread" data-tooltip="Comments">
            <i class="fas fa-comment-dots"></i>
          </a>
        </li>
      
      <li class="post-action">
        
          <a class="post-action-btn btn btn--default" href="#table-of-contents" data-tooltip="Table of Contents">
            <i class="fas fa-list"></i>
        
          </a>
      </li>
    </ul>
  
</div>

      </div>
      <div id="share-options-bar" class="share-options-bar" data-behavior="4">
  <i id="btn-close-shareoptions" class="fas fa-times"></i>
  <ul class="share-options">
    
      <li class="share-option">
        <a class="share-option-btn" target="new" href="https://www.facebook.com/sharer/sharer.php?u=http%3A%2F%2Fnianze.tk%2F2018%2F05%2Fsmart-pointers%2F">
          <i class="fa fa-facebook-f"></i><span>Share on Facebook</span>
        </a>
      </li>
    
      <li class="share-option">
        <a class="share-option-btn" target="new" href="https://twitter.com/intent/tweet?text=http%3A%2F%2Fnianze.tk%2F2018%2F05%2Fsmart-pointers%2F">
          <i class="fa fa-twitter"></i><span>Share on Twitter</span>
        </a>
      </li>
    
      <li class="share-option">
        <a class="share-option-btn" target="new" href="https://plus.google.com/share?url=http%3A%2F%2Fnianze.tk%2F2018%2F05%2Fsmart-pointers%2F">
          <i class="fa fa-google-plus-g"></i><span>Share on Google&#43;</span>
        </a>
      </li>
    
  </ul>
</div>
<div id="share-options-mask" class="share-options-mask"></div>
    </div>
    
    <div id="about">
  <div id="about-card">
    <div id="about-btn-close">
      <i class="fas fa-times"></i>
    </div>
    
      <img id="about-card-picture" src="http://nianze.tk/images/bw.JPG" alt="Author&#39;s picture" />
    
    <h4 id="about-card-name">刀心の水</h4>
    
      <div id="about-card-bio"><p>虚度廿余岁月浅，略识几行代码源。<br />
闲来随手快门按，怆然独把音韵弹。</p>

<p>Pain is inevitable.<br />
Suffering is optional.</p>
</div>
    
    
      <div id="about-card-job">
        <i class="fas fa-laptop-code"></i>
        <br/>
        Developer
      </div>
    
    
      <div id="about-card-location">
        <i class="fas fa-map-marked-alt"></i>
        <br/>
        New York
      </div>
    
  </div>
</div>

    

    
  
    
      
      <div id="cover" style="background-image:url('http://nianze.tk/images/reservoir.jpg');"></div>
    
  


    
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/2.2.4/jquery.min.js" integrity="sha256-BbhdlvQf/xTY9gja0Dq3HiwQF8LaCRTXxZKRutelT44=" crossorigin="anonymous"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js" integrity="sha256-/BfiIkHlHoVihZdc6TFuj7MmJ0TWcWsMXkeDFwhi0zw=" crossorigin="anonymous"></script>

<script src="https://cdnjs.cloudflare.com/ajax/libs/fancybox/2.1.7/js/jquery.fancybox.min.js" integrity="sha256-GEAnjcTqVP+vBp3SSc8bEDQqvWAZMiHyUSIorrWwH50=" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery.imagesloaded/3.2.0/imagesloaded.pkgd.min.js"></script>


<script src="http://nianze.tk/js/script-qi9wbxp2ya2j6p7wx1i6tgavftewndznf4v0hy2gvivk1rxgc3lm7njqb6bz.min.js"></script>


  
    <script src="http://nianze.tk/js/loader.js"></script>
  

<script lang="javascript">
window.onload = updateMinWidth;
window.onresize = updateMinWidth;
document.getElementById("sidebar").addEventListener("transitionend", updateMinWidth);
function updateMinWidth() {
  var sidebar = document.getElementById("sidebar");
  var main = document.getElementById("main");
  main.style.minWidth = "";
  var w1 = getComputedStyle(main).getPropertyValue("min-width");
  var w2 = getComputedStyle(sidebar).getPropertyValue("width");
  var w3 = getComputedStyle(sidebar).getPropertyValue("left");
  main.style.minWidth = `calc(${w1} - ${w2} - ${w3})`;
}
</script>

<script>
$(document).ready(function() {
  hljs.configure({ classPrefix: '', useBR: false });
  $('pre.code-highlight > code, pre > code').each(function(i, block) {
    if (!$(this).hasClass('codeblock')) {
      $(this).addClass('codeblock');
    }
    hljs.highlightBlock(block);
  });
});
</script>





    
  </body>
</html>

