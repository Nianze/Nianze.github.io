<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on Code.Music.Photo</title>
    <link>http://nianze.ml/post/</link>
    <description>Recent content in Posts on Code.Music.Photo</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Sun, 08 Jul 2018 13:32:48 -0400</lastBuildDate>
    
	<atom:link href="http://nianze.ml/post/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>[EMCpp]Item-6 Use the Explicitly Typed Initializer Idiom when auto deduces undesired types</title>
      <link>http://nianze.ml/2018/07/use-the-explicitly-typed-initializer-idiom-when-auto-deduces-undesired-types/</link>
      <pubDate>Sun, 08 Jul 2018 13:32:48 -0400</pubDate>
      
      <guid>http://nianze.ml/2018/07/use-the-explicitly-typed-initializer-idiom-when-auto-deduces-undesired-types/</guid>
      <description>&lt;p&gt;“Invisible” proxy types can cause &lt;code&gt;auto&lt;/code&gt; to deduce the undesired type for an initializing expression, so we can adopt explicitly typed initializer idiom to force &lt;code&gt;auto&lt;/code&gt; to deduce what we want.
&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>[EMCpp]Item-5 Prefer Auto to Explicit Type Declarations</title>
      <link>http://nianze.ml/2018/07/prefer-auto-to-explicit-type-declarations/</link>
      <pubDate>Sat, 07 Jul 2018 13:33:06 -0400</pubDate>
      
      <guid>http://nianze.ml/2018/07/prefer-auto-to-explicit-type-declarations/</guid>
      <description>&lt;p&gt;Despite some pitfalls described in EMCpp item 2 and 6, &lt;code&gt;auto&lt;/code&gt; variables are preferred for they must be initialized, are generally immune to type mismatches that can lead to portability or efficiency problems, can ease the process of refactoring, and typically require less typing than variables with explicitly specified types.
&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>[EMCpp]Item-4 Know How to View Deduced Types</title>
      <link>http://nianze.ml/2018/07/know-how-to-view-deduced-types/</link>
      <pubDate>Fri, 06 Jul 2018 10:08:00 -0400</pubDate>
      
      <guid>http://nianze.ml/2018/07/know-how-to-view-deduced-types/</guid>
      <description>&lt;p&gt;Deduced types can often be seen using IDE editors, compiler error messages, and the Boost TypeIndex library, but the results of some tools may be neither helpful nor accurate.
&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>[EMCpp]Item-3 Understand Decltype</title>
      <link>http://nianze.ml/2018/07/understand-decltype/</link>
      <pubDate>Thu, 05 Jul 2018 18:59:39 -0400</pubDate>
      
      <guid>http://nianze.ml/2018/07/understand-decltype/</guid>
      <description>&lt;p&gt;&lt;code&gt;decltype&lt;/code&gt; almost always yields the type of a variable or expression without any modifications. For lvalue expressions of type T other than names, &lt;code&gt;decltype&lt;/code&gt; always reports a type of T&amp;amp;.
&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>[EMCpp]Item-2 Understand Auto Type Deduction</title>
      <link>http://nianze.ml/2018/07/understand-auto-type-deduction/</link>
      <pubDate>Tue, 03 Jul 2018 10:07:13 -0400</pubDate>
      
      <guid>http://nianze.ml/2018/07/understand-auto-type-deduction/</guid>
      <description>&lt;p&gt;&lt;code&gt;auto&lt;/code&gt; type deduction is usually the same as template type deduction, with an exception in the case of braced initializer. Also, in C++14, as a function return type or a lambda parameter, &lt;code&gt;auto&lt;/code&gt; implies template type deduction instead of &lt;code&gt;auto&lt;/code&gt; type deduction.
&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>[EMCpp]Item-1 Understand Template Type Deduction</title>
      <link>http://nianze.ml/2018/07/understand-template-type-deduction/</link>
      <pubDate>Mon, 02 Jul 2018 22:44:34 -0400</pubDate>
      
      <guid>http://nianze.ml/2018/07/understand-template-type-deduction/</guid>
      <description>&lt;p&gt;There are three sets of rules for type deduction in modern C++: one for function templates, one for &lt;code&gt;auto&lt;/code&gt;, and one for &lt;code&gt;decltype&lt;/code&gt;. Without a solid understanding of how deduction operates, effective programming in modern C++ is all but impossible.
&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>A Brif Review of Dynamo</title>
      <link>http://nianze.ml/2018/07/a-brif-review-of-dynamo/</link>
      <pubDate>Sun, 01 Jul 2018 23:03:34 -0400</pubDate>
      
      <guid>http://nianze.ml/2018/07/a-brif-review-of-dynamo/</guid>
      <description>&lt;p&gt;As a highly available and scalable distributed data store, the design principles of Dynamo features high availability for writes (via reconciliation during reads), incremental scalability (consistent hashing), symmetry, decentralization, and heterogeneity (via virtual nodes).
&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>徕卡M9初体验</title>
      <link>http://nianze.ml/2018/06/a-sip-of-leica-m9/</link>
      <pubDate>Sat, 02 Jun 2018 21:39:34 -0400</pubDate>
      
      <guid>http://nianze.ml/2018/06/a-sip-of-leica-m9/</guid>
      <description>&lt;p&gt;他们说徕卡调教过的那块柯达CCD自带德味，我不信，心想用卡西欧自拍神器理论上也能后期出那味道来。
&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>一个油腻中年大叔在儿童节的胡思乱想</title>
      <link>http://nianze.ml/2018/06/a-simple-calculation/</link>
      <pubDate>Fri, 01 Jun 2018 00:00:00 +0000</pubDate>
      
      <guid>http://nianze.ml/2018/06/a-simple-calculation/</guid>
      <description>&lt;p&gt;张爱玲说，出名要趁早。
&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>A simple archive for music generation</title>
      <link>http://nianze.ml/2018/05/music-generation-archive/</link>
      <pubDate>Thu, 31 May 2018 16:07:41 -0400</pubDate>
      
      <guid>http://nianze.ml/2018/05/music-generation-archive/</guid>
      <description>&lt;p&gt;A random collection of recent works on music generation.
&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>[MECpp]Item-34 Understand How to Combine C&#43;&#43; and C in the Same Program</title>
      <link>http://nianze.ml/2018/05/understand-how-to-combine-c---and-c-in-the-same-program/</link>
      <pubDate>Wed, 23 May 2018 18:38:10 -0400</pubDate>
      
      <guid>http://nianze.ml/2018/05/understand-how-to-combine-c---and-c-in-the-same-program/</guid>
      <description>&lt;p&gt;There are five points worth noting if we want to mix C++ and C in the same program.
&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>[MECpp]Item-33 Make Non-Leaf Classes Abstract</title>
      <link>http://nianze.ml/2018/05/make-non-leaf-classes-abstract/</link>
      <pubDate>Mon, 21 May 2018 18:27:39 -0400</pubDate>
      
      <guid>http://nianze.ml/2018/05/make-non-leaf-classes-abstract/</guid>
      <description>&lt;p&gt;The general rule: non-leaf classes should be abstract. This will yields dividends in the form of increased reliability, robustness, comprehensibility, and extensibility throughout our software.
&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>[MECpp]Item-32 Program in the Future Tense</title>
      <link>http://nianze.ml/2018/05/program-in-the-future-tense/</link>
      <pubDate>Thu, 17 May 2018 19:26:17 -0400</pubDate>
      
      <guid>http://nianze.ml/2018/05/program-in-the-future-tense/</guid>
      <description>&lt;p&gt;Things change. Future tense thinking increases the reusability of the code we write, enhances its maintainability, makes it more robust, and facilitates gracefully in an environment where change is a certainty.
&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>[MECpp]Item-31 Making Functions Virtual With Respect to More Than One Object</title>
      <link>http://nianze.ml/2018/05/making-functions-virtual-with-respect-to-more-than-one-object/</link>
      <pubDate>Fri, 11 May 2018 00:00:00 +0000</pubDate>
      
      <guid>http://nianze.ml/2018/05/making-functions-virtual-with-respect-to-more-than-one-object/</guid>
      <description>&lt;p&gt;A virtual function call is termed a &amp;ldquo;message dispatch.&amp;rdquo; A call that acts virtual on multiple parameters is called &lt;em&gt;multiple dispatch&lt;/em&gt;, which is not directly supported in C++. Several resolutions exist, but none is without its disadvantages.
&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>[MECpp]Item-30 Proxy Classes</title>
      <link>http://nianze.ml/2018/05/proxy-classes/</link>
      <pubDate>Wed, 09 May 2018 00:00:00 +0000</pubDate>
      
      <guid>http://nianze.ml/2018/05/proxy-classes/</guid>
      <description>&lt;p&gt;Objects that stand for other objects are often called &lt;em&gt;proxy objects&lt;/em&gt; (or &lt;em&gt;surrogates&lt;/em&gt;), and the classes that give rise to proxy objects are often called &lt;em&gt;proxy classes&lt;/em&gt;, which is useful for implementing multidimensional arrays, differentiating lvalue/rvalue, and suppressing implicit conversions.
&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>[MECpp]Item-29 Reference Counting</title>
      <link>http://nianze.ml/2018/05/reference-counting/</link>
      <pubDate>Mon, 07 May 2018 00:00:00 +0000</pubDate>
      
      <guid>http://nianze.ml/2018/05/reference-counting/</guid>
      <description>&lt;p&gt;Reference counting is technique that allows multiple objects with the same value to share a sinple representation of that value.
&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>[MECpp]Item-28 Smart Pointers</title>
      <link>http://nianze.ml/2018/05/smart-pointers/</link>
      <pubDate>Sat, 05 May 2018 16:38:03 -0400</pubDate>
      
      <guid>http://nianze.ml/2018/05/smart-pointers/</guid>
      <description>&lt;p&gt;&lt;em&gt;Smart pointers&lt;/em&gt; are designed to look, act, and feel like built-in pointers, but to offer greater functionality.
&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>[MECpp]Item-27 Requiring or Prohibiting Heap Based Objects</title>
      <link>http://nianze.ml/2018/05/requiring-or-prohibiting-heap-based-objects/</link>
      <pubDate>Tue, 01 May 2018 00:00:00 +0000</pubDate>
      
      <guid>http://nianze.ml/2018/05/requiring-or-prohibiting-heap-based-objects/</guid>
      <description>&lt;p&gt;Techniques for requiring or prohibiting heap-based objects
&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>搬了个家</title>
      <link>http://nianze.ml/2018/04/relocation-to-m2/</link>
      <pubDate>Sun, 29 Apr 2018 00:00:00 +0000</pubDate>
      
      <guid>http://nianze.ml/2018/04/relocation-to-m2/</guid>
      <description>&lt;p&gt;搬一次家，掉一层皮
&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>一个大坑</title>
      <link>http://nianze.ml/2018/04/a-big-step/</link>
      <pubDate>Wed, 25 Apr 2018 21:44:06 -0400</pubDate>
      
      <guid>http://nianze.ml/2018/04/a-big-step/</guid>
      <description>&lt;p&gt;我有一个大胆的想法。
&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>[MECpp]Item-26 Limiting the Number of Objects of a Class</title>
      <link>http://nianze.ml/2018/04/limiting-the-number-of-objects-of-a-class/</link>
      <pubDate>Tue, 24 Apr 2018 15:03:26 -0400</pubDate>
      
      <guid>http://nianze.ml/2018/04/limiting-the-number-of-objects-of-a-class/</guid>
      <description>&lt;p&gt;Combining object-counting technique with the pseudo-constructors, we can limit the number of objects of a class.
&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>[MECpp]Item-25 Virtualizing Constructors and Non-Member Functions</title>
      <link>http://nianze.ml/2018/04/virtualizing-constructors-and-non-member-functions/</link>
      <pubDate>Mon, 23 Apr 2018 13:30:56 -0400</pubDate>
      
      <guid>http://nianze.ml/2018/04/virtualizing-constructors-and-non-member-functions/</guid>
      <description>&lt;p&gt;Depending on the different input or dynamic types of function parameters, &amp;ldquo;virtualization&amp;rdquo; is a useful technique to construct new objects of different types accordingly, or to conceive of non-member functions whose behavior changes accordingly.
&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>[米津玄师]Lemon</title>
      <link>http://nianze.ml/2018/04/lemon/</link>
      <pubDate>Sun, 22 Apr 2018 14:10:15 -0400</pubDate>
      
      <guid>http://nianze.ml/2018/04/lemon/</guid>
      <description>&lt;p&gt;Unnatural里每次片尾曲神插入时都让人心头一颤。。。不愧是除了生孩子什么都会的ハチ
谨以此曲献给米津玄師。嗯，以及石原里美🙂
&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>[MECpp]Item-24 Understand the Costs of Virtual Functions, Multiple Inheritance, Virtual Base Classes, and RTTI</title>
      <link>http://nianze.ml/2018/04/costs-of-virtual-functions-multiple-inheritance-virtual-base-classes-and-rtti/</link>
      <pubDate>Fri, 20 Apr 2018 15:32:45 -0400</pubDate>
      
      <guid>http://nianze.ml/2018/04/costs-of-virtual-functions-multiple-inheritance-virtual-base-classes-and-rtti/</guid>
      <description>&lt;p&gt;It&amp;rsquo;s important to have a basic understanding of the cost of some C++ features that can have a noticeable impact on the size of objects and the speed at which member functions execute.
&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>[MECpp]Item-23 Consider Alternative Libraries</title>
      <link>http://nianze.ml/2018/04/consider-alternative-libraries/</link>
      <pubDate>Thu, 19 Apr 2018 13:32:15 -0400</pubDate>
      
      <guid>http://nianze.ml/2018/04/consider-alternative-libraries/</guid>
      <description>&lt;p&gt;Different libraries offering similar functionality often feature different performance trade-offs, so we might be able to remove bottlenecks by replacing one library with another.
&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>[MECpp]Item-22 Consider Using op= Instead of Stand Alone op</title>
      <link>http://nianze.ml/2018/04/consider-using-op-instead-of-stand-alone-op/</link>
      <pubDate>Wed, 18 Apr 2018 14:09:10 -0400</pubDate>
      
      <guid>http://nianze.ml/2018/04/consider-using-op-instead-of-stand-alone-op/</guid>
      <description>&lt;p&gt;Assignment versions of operators (such as &lt;code&gt;operator+=&lt;/code&gt;) tend to be more efficient than stand-alone versions of those operators (e.g., &lt;code&gt;operator+&lt;/code&gt;).
&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>[MECpp]Item-21 Overload to Avoid Implicit Type Conventions</title>
      <link>http://nianze.ml/2018/04/overload-to-avoid-implicit-type-conventions/</link>
      <pubDate>Tue, 17 Apr 2018 15:42:12 -0400</pubDate>
      
      <guid>http://nianze.ml/2018/04/overload-to-avoid-implicit-type-conventions/</guid>
      <description>&lt;p&gt;Overloading to avoid temporaries.
&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>[MECpp]Item-20 Facilitate the Return Value Optimization</title>
      <link>http://nianze.ml/2018/04/facilitate-the-return-value-optimization/</link>
      <pubDate>Mon, 16 Apr 2018 00:00:00 +0000</pubDate>
      
      <guid>http://nianze.ml/2018/04/facilitate-the-return-value-optimization/</guid>
      <description>&lt;p&gt;Take use of the &lt;em&gt;return value optimization&lt;/em&gt; in compilers.
&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>[MECpp]Item-19 Understand the Origin of Temporary Objects</title>
      <link>http://nianze.ml/2018/04/understand-the-origin-of-temporary-objects/</link>
      <pubDate>Fri, 13 Apr 2018 17:06:28 -0400</pubDate>
      
      <guid>http://nianze.ml/2018/04/understand-the-origin-of-temporary-objects/</guid>
      <description>&lt;p&gt;Unnamed non-heap objects are invisible temporary objects in C++.
&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>[MECpp]Item-18 Amortize the Cost of Expected Computations</title>
      <link>http://nianze.ml/2018/04/amortize-the-cost-of-expected-computations/</link>
      <pubDate>Thu, 12 Apr 2018 15:31:55 -0400</pubDate>
      
      <guid>http://nianze.ml/2018/04/amortize-the-cost-of-expected-computations/</guid>
      <description>&lt;p&gt;The old Computer Science story: trade space for time&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:1&#34;&gt;&lt;a href=&#34;#fn:1&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;.
&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>[MECpp]Item-17 Consider Using Lazy Evaluation</title>
      <link>http://nianze.ml/2018/04/consider-using-lazy-evaluation/</link>
      <pubDate>Wed, 11 Apr 2018 14:02:18 -0400</pubDate>
      
      <guid>http://nianze.ml/2018/04/consider-using-lazy-evaluation/</guid>
      <description>&lt;p&gt;The best computations are those we never perform at all.
&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>[MECpp]Item-16 Remember 80-20 Rule</title>
      <link>http://nianze.ml/2018/04/remember-80-20-rule/</link>
      <pubDate>Tue, 10 Apr 2018 13:37:45 -0400</pubDate>
      
      <guid>http://nianze.ml/2018/04/remember-80-20-rule/</guid>
      <description>&lt;p&gt;The 80-20 rule states that 80 percent of a program&amp;rsquo;s resources are used by about 20 percent of the code.
&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>[MECpp]Item-15 Understand the Costs of Exception Handling</title>
      <link>http://nianze.ml/2018/04/understand-the-costs-of-exception-handling/</link>
      <pubDate>Mon, 09 Apr 2018 18:10:06 -0400</pubDate>
      
      <guid>http://nianze.ml/2018/04/understand-the-costs-of-exception-handling/</guid>
      <description>&lt;p&gt;Exception handling has costs, and we pay at least some of them even if we never use the keywords &lt;code&gt;try&lt;/code&gt;, &lt;code&gt;throw&lt;/code&gt;, or &lt;code&gt;catch&lt;/code&gt;.
&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>[MECpp]Item-14 Use Exception Specifications Judiciously</title>
      <link>http://nianze.ml/2018/04/use-exception-specifications-judiciously/</link>
      <pubDate>Sun, 08 Apr 2018 23:51:00 -0400</pubDate>
      
      <guid>http://nianze.ml/2018/04/use-exception-specifications-judiciously/</guid>
      <description>&lt;p&gt;Exception specifications provide a documentation aid and an enforcement mechanism for constraints on exception usage, but they are only partly checked by compilers and they are easy to violate inadvertently.
&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>[MECpp]Item-13 Catch Exceptions by Reference</title>
      <link>http://nianze.ml/2018/04/catch-exceptions-by-reference/</link>
      <pubDate>Thu, 05 Apr 2018 18:57:13 -0400</pubDate>
      
      <guid>http://nianze.ml/2018/04/catch-exceptions-by-reference/</guid>
      <description>&lt;p&gt;If catching by reference, we sidestep the questions about object deletion, avoid slicing exception objects, retain the ability to catch standard exceptions, and limit the number of times exception objects being copied.
&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>[MECpp]Item-12 Understand How Throwing an Exception Differs From Passing a Parameter or Calling a Virtual Function</title>
      <link>http://nianze.ml/2018/04/understand-how-throwing-an-exception-differs-from-passing-a-parameter-or-calling-a-virtual-function/</link>
      <pubDate>Wed, 04 Apr 2018 11:28:07 -0400</pubDate>
      
      <guid>http://nianze.ml/2018/04/understand-how-throwing-an-exception-differs-from-passing-a-parameter-or-calling-a-virtual-function/</guid>
      <description>&lt;p&gt;There are three primary ways in which passing an object to a function or using that object to invoke a virtual function differs from throwing the object as an exception.
&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>[MECpp]Item-11 Prevent Exceptions From Leaving Destructors</title>
      <link>http://nianze.ml/2018/04/prevent-exceptions-from-leaving-destructors/</link>
      <pubDate>Tue, 03 Apr 2018 10:54:39 -0400</pubDate>
      
      <guid>http://nianze.ml/2018/04/prevent-exceptions-from-leaving-destructors/</guid>
      <description>&lt;p&gt;Keep exceptions from propagating out of destructors to prevent C++ calling &lt;code&gt;terminate&lt;/code&gt; during the statck-unwinding part of exception propagation and ensure that every neccessary cleanup is accomplished.
&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>[MECpp]Item-10 Prevent Resource Leaks in Constructors</title>
      <link>http://nianze.ml/2018/04/prevent-resource-leaks-in-constructors/</link>
      <pubDate>Mon, 02 Apr 2018 15:56:25 -0400</pubDate>
      
      <guid>http://nianze.ml/2018/04/prevent-resource-leaks-in-constructors/</guid>
      <description>&lt;p&gt;Replace pointer class members with their corresponding smart pointer objects to fortify the constructors against resource leaks in the presence of exceptions, to eliminate the need to manually deallocate resources in destructors, and to allow &lt;code&gt;const&lt;/code&gt; member pointers to be handled in the smae graceful fashion as non-&lt;code&gt;const&lt;/code&gt; pointers.
&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Vocaloid调教初始：空奏列车</title>
      <link>http://nianze.ml/2018/04/kuusou-ressha/</link>
      <pubDate>Sun, 01 Apr 2018 00:00:00 +0000</pubDate>
      
      <guid>http://nianze.ml/2018/04/kuusou-ressha/</guid>
      <description>&lt;p&gt;首次尝试调教星尘。
&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>[MECpp]Item-9 Use Destructors to Prevent Resource Leaks</title>
      <link>http://nianze.ml/2018/04/use-destructors-to-prevent-resource-leaks/</link>
      <pubDate>Sun, 01 Apr 2018 00:00:00 +0000</pubDate>
      
      <guid>http://nianze.ml/2018/04/use-destructors-to-prevent-resource-leaks/</guid>
      <description>&lt;p&gt;To avoid resource leaks in the presence of exceptions, we can encapsulate resources inside objects.
&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>[MECpp]Item-8 Understand the Different Meanings of New and Delete</title>
      <link>http://nianze.ml/2018/03/understand-the-different-meanings-of-new-and-delete/</link>
      <pubDate>Fri, 30 Mar 2018 17:09:04 -0400</pubDate>
      
      <guid>http://nianze.ml/2018/03/understand-the-different-meanings-of-new-and-delete/</guid>
      <description>&lt;p&gt;The behaviors of &lt;code&gt;new&lt;/code&gt; operator and &lt;code&gt;operator new&lt;/code&gt; is different.
&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>[MECpp]Item-7 Never Overload &#39;&amp;&amp;&#39;, &#39;||&#39;, or &#39;,&#39;</title>
      <link>http://nianze.ml/2018/03/never-overload-and-or-comma-operator/</link>
      <pubDate>Thu, 29 Mar 2018 11:18:24 -0400</pubDate>
      
      <guid>http://nianze.ml/2018/03/never-overload-and-or-comma-operator/</guid>
      <description>&lt;p&gt;If we don&amp;rsquo;t have a good reason for overloading an operator, don&amp;rsquo;t overload it. In the case of &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt;, &lt;code&gt;||&lt;/code&gt;, and &lt;code&gt;,&lt;/code&gt;, it&amp;rsquo;s difficult to have a good reason: we can&amp;rsquo;t make them behave the way they&amp;rsquo;re supposed to.
&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>[MECpp]Item-6 Distinguish Between Prefix and Postfix Forms of Increment and Decrement Operators</title>
      <link>http://nianze.ml/2018/03/distinguish-between-prefix-and-postfix-forms-of-increment-and-decrement-operators/</link>
      <pubDate>Wed, 28 Mar 2018 13:03:10 -0400</pubDate>
      
      <guid>http://nianze.ml/2018/03/distinguish-between-prefix-and-postfix-forms-of-increment-and-decrement-operators/</guid>
      <description>&lt;p&gt;The prefix and postfix forms of increment and decrement operators return &lt;em&gt;different types&lt;/em&gt;: prefix forms return a reference, while postfix forms return a &lt;em&gt;const&lt;/em&gt; object. For efficiency, prefer prefix forms unless the behavior of postfix ones is necessary. To guarantee consistency, implement postfix operators in terms of the prefix operators.
&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>[MECpp]Item-5 Be Wary of User Defined Conversion Functions</title>
      <link>http://nianze.ml/2018/03/be-wary-of-user-defined-conversion-functions/</link>
      <pubDate>Tue, 27 Mar 2018 18:53:56 -0400</pubDate>
      
      <guid>http://nianze.ml/2018/03/be-wary-of-user-defined-conversion-functions/</guid>
      <description>&lt;p&gt;Implicit type conversions usually lead to more harm than good, so don&amp;rsquo;t provide conversion functions unless we&amp;rsquo;re sure we want them.
&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>[MECpp]Item-4 Avoid Gratuitous Default Constructors</title>
      <link>http://nianze.ml/2018/03/avoid-gratuitous-default-constructors/</link>
      <pubDate>Mon, 26 Mar 2018 11:21:08 -0400</pubDate>
      
      <guid>http://nianze.ml/2018/03/avoid-gratuitous-default-constructors/</guid>
      <description>&lt;p&gt;Including meaningless default constructors affects the efficiency of classes, so avoiding them in classes guarantees fully-initialized objects, with the cost of some limits on how such classes can be used.
&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>[MECpp]Item-3 Never Treat Arrays Polymorphically</title>
      <link>http://nianze.ml/2018/03/never-treat-arrays-polymorphically/</link>
      <pubDate>Fri, 23 Mar 2018 18:59:16 -0400</pubDate>
      
      <guid>http://nianze.ml/2018/03/never-treat-arrays-polymorphically/</guid>
      <description>&lt;p&gt;Array operations almost always involve pointer arithmetic, so arrays and polymorphism don&amp;rsquo;t mix.
&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>[MECpp]Item-1 Distinguish Between Pointers and References</title>
      <link>http://nianze.ml/2018/03/distinguish-between-pointers-and-references/</link>
      <pubDate>Thu, 22 Mar 2018 16:47:15 -0400</pubDate>
      
      <guid>http://nianze.ml/2018/03/distinguish-between-pointers-and-references/</guid>
      <description>&lt;p&gt;More effective C++: Use references when we already have something to refer to and never want to refer to anything else, or when implementing operators whose syntactic requires us to do so.
&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Item-52 Write placement delete if you write placement new</title>
      <link>http://nianze.ml/2018/03/write-placement-delete-if-you-write-placement-new/</link>
      <pubDate>Wed, 21 Mar 2018 15:48:12 -0400</pubDate>
      
      <guid>http://nianze.ml/2018/03/write-placement-delete-if-you-write-placement-new/</guid>
      <description>&lt;p&gt;When we write a placement version of &lt;code&gt;operator new&lt;/code&gt;, be sure to write the corresponding placement version of &lt;code&gt;operator delete&lt;/code&gt; to avoid subtle, intermittent memory leaks. When we do so, pay attention not to unintentionally hide the normal versions of &lt;code&gt;new&lt;/code&gt; and &lt;code&gt;delete&lt;/code&gt;
&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Item-51 Adhere to convention when writing new and delete</title>
      <link>http://nianze.ml/2018/03/adhere-to-convention-when-writing-new-and-delete/</link>
      <pubDate>Tue, 20 Mar 2018 14:32:24 -0400</pubDate>
      
      <guid>http://nianze.ml/2018/03/adhere-to-convention-when-writing-new-and-delete/</guid>
      <description>&lt;p&gt;&lt;code&gt;operator new&lt;/code&gt; should contain an infinite loop trying to allocate memory, should call the new-handler if it can&amp;rsquo;t satisfy a memory request, and should handle requests for zero bytes; class-specific versions should handle requests for larger blocks than expected. &lt;code&gt;operator delete&lt;/code&gt; should do nothing if passed a pointer that is null; class specific versions should handle blocks that are larger than expected.
&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Item-50 Understand when it makes sense to replace new and delete</title>
      <link>http://nianze.ml/2018/03/understand-when-it-makes-sense-to-replace-new-and-delete/</link>
      <pubDate>Mon, 19 Mar 2018 10:54:04 -0400</pubDate>
      
      <guid>http://nianze.ml/2018/03/understand-when-it-makes-sense-to-replace-new-and-delete/</guid>
      <description>&lt;p&gt;There are many valid reasons for writing custom versions of &lt;code&gt;new&lt;/code&gt; and &lt;code&gt;delete&lt;/code&gt;, including improving performance, debugging heap usage errors, and collecting heap usage information.
&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Item-49 Understand the behavior of the new handler</title>
      <link>http://nianze.ml/2018/03/understand-the-behavior-of-the-new-handler/</link>
      <pubDate>Fri, 16 Mar 2018 19:52:09 -0400</pubDate>
      
      <guid>http://nianze.ml/2018/03/understand-the-behavior-of-the-new-handler/</guid>
      <description>&lt;p&gt;&lt;code&gt;set-new-handler&lt;/code&gt; allows you to specify a function to be called when memory allocation requests cannot be satisfied.
&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Item-48 Be aware of template metaprogramming</title>
      <link>http://nianze.ml/2018/03/be-aware-of-template-metaprogramming/</link>
      <pubDate>Thu, 15 Mar 2018 23:00:22 -0400</pubDate>
      
      <guid>http://nianze.ml/2018/03/be-aware-of-template-metaprogramming/</guid>
      <description>&lt;p&gt;Template metaprogramming can shift work from runtime to compile-time (thus enabling earlier error dettection and higher runtime performance), can be used to generate custom code based on combinations of policy choices, and can also be used to avoid generating code inappropriate for particular types.
&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Item-47 Use traits classes for information about types</title>
      <link>http://nianze.ml/2018/03/use-traits-classes-for-information-about-types/</link>
      <pubDate>Wed, 14 Mar 2018 18:49:03 -0400</pubDate>
      
      <guid>http://nianze.ml/2018/03/use-traits-classes-for-information-about-types/</guid>
      <description>&lt;p&gt;Implemented by templates and template specializations, traits classes make information about types available during compilation. Combining traints with overloading, it is possible to perform compile-time &lt;code&gt;if...else&lt;/code&gt; tests on types.
&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Item-46 Define non-member function inside templates when type conversions are desired</title>
      <link>http://nianze.ml/2018/03/define-non-member-function-inside-templates-when-type-conversions-are-desired/</link>
      <pubDate>Tue, 13 Mar 2018 12:23:40 -0400</pubDate>
      
      <guid>http://nianze.ml/2018/03/define-non-member-function-inside-templates-when-type-conversions-are-desired/</guid>
      <description>&lt;p&gt;When writing a class template that offers functions related to the template that support implicit type conversions on all parameters, define those functions as friends inside the class template.
&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Item-45 Use member function templates to accept all compatible types</title>
      <link>http://nianze.ml/2018/03/use-member-function-templates-to-accept-all-compatible-types/</link>
      <pubDate>Mon, 12 Mar 2018 20:14:47 -0400</pubDate>
      
      <guid>http://nianze.ml/2018/03/use-member-function-templates-to-accept-all-compatible-types/</guid>
      <description>&lt;p&gt;In order to implicitly convert all compatible types for a template class, we neet not a constructor &lt;em&gt;function&lt;/em&gt; but a constructor &lt;em&gt;template&lt;/em&gt; - &lt;em&gt;member functoin templates&lt;/em&gt; that generate member functions of a class.
&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Item-44 Factor parameter-independent code out of templates</title>
      <link>http://nianze.ml/2018/03/factor-parameter-independent-code-out-of-templates/</link>
      <pubDate>Sat, 10 Mar 2018 20:24:42 -0500</pubDate>
      
      <guid>http://nianze.ml/2018/03/factor-parameter-independent-code-out-of-templates/</guid>
      <description>&lt;p&gt;Templates generate multiple classes and multiple functions, so any template code not dependent on a template parameter (either non-type template parameters or type parameters) causes bloat: eliminate bloat due to non-type template parameters by replacing template parameters with function parameters or class data members; reduce bloat caused from type parameters by sharing implementations for instantiation types with identical binary representations.
&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Item-43 Know how to access names in templatized base classes</title>
      <link>http://nianze.ml/2018/03/know-how-to-access-names-in-templatized-base-classes/</link>
      <pubDate>Fri, 09 Mar 2018 21:48:26 -0500</pubDate>
      
      <guid>http://nianze.ml/2018/03/know-how-to-access-names-in-templatized-base-classes/</guid>
      <description>&lt;p&gt;In derived class templates, refer to names in base class templates via a &lt;code&gt;this-&amp;gt;&lt;/code&gt; prefix, via &lt;code&gt;using&lt;/code&gt; declarations, or via an explicit base class qualification.
&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Item-42 Understand the two meanings of typename</title>
      <link>http://nianze.ml/2018/03/understand-the-two-meanings-of-typename/</link>
      <pubDate>Thu, 08 Mar 2018 19:19:28 -0500</pubDate>
      
      <guid>http://nianze.ml/2018/03/understand-the-two-meanings-of-typename/</guid>
      <description>&lt;p&gt;When declaring template parameters, both &lt;code&gt;class&lt;/code&gt; and &lt;code&gt;typename&lt;/code&gt; are interchangeable. When identifying nested dependent type names, use &lt;code&gt;typename&lt;/code&gt;, except in base class lists or as a base class identifier in a member initialization list.
&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Item-41 Understand inplicit interfaces and compile time polymorphism</title>
      <link>http://nianze.ml/2018/03/understand-inplicit-interfaces-and-compile-time-polymorphism/</link>
      <pubDate>Wed, 07 Mar 2018 14:21:33 -0500</pubDate>
      
      <guid>http://nianze.ml/2018/03/understand-inplicit-interfaces-and-compile-time-polymorphism/</guid>
      <description>&lt;p&gt;Classes support explicit interfaces based on function signatures, as well as runtime polymorphism through virtual functions; templates support implicit interfaces based on valid expressions, as well as compile-time polymorphism through template instantiation and function overloading resolution.
&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Item-40 Use multiple inheritance judiciously</title>
      <link>http://nianze.ml/2018/03/use-multiple-inheritance-judiciously/</link>
      <pubDate>Tue, 06 Mar 2018 17:35:59 -0500</pubDate>
      
      <guid>http://nianze.ml/2018/03/use-multiple-inheritance-judiciously/</guid>
      <description>&lt;p&gt;Being more complex than single inheritance, Multiple inheritance (MI) can lead to ambiguity issues and to the need for virtual inheritance, the latter of which imposes costs in size, speed, and complexity of initialization and assignment, so it&amp;rsquo;s more practical to make &amp;ldquo;empty&amp;rdquo; virtual base classes.
&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Item-39 Use private inheritance judiciously</title>
      <link>http://nianze.ml/2018/03/use-private-inheritance-judiciously/</link>
      <pubDate>Mon, 05 Mar 2018 18:42:43 -0500</pubDate>
      
      <guid>http://nianze.ml/2018/03/use-private-inheritance-judiciously/</guid>
      <description>&lt;p&gt;Private inheritance means is-implemented-in-terms-of. It is usually inferior to composition, but it makes sense when a derived class needs access to protected base members or needs to redefine inherited virtual functions. For library developers who strive to minimize object sizes, it also offers the ability of empty base optimization.
&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Item-38 Model &#39;has-a&#39; or &#39;is-implemented-in-terms-of&#39; through composition</title>
      <link>http://nianze.ml/2018/03/model-has-a-or-is-implemented-in-terms-of-through-composition/</link>
      <pubDate>Sun, 04 Mar 2018 15:49:31 -0500</pubDate>
      
      <guid>http://nianze.ml/2018/03/model-has-a-or-is-implemented-in-terms-of-through-composition/</guid>
      <description>&lt;p&gt;In the application domain, composition means has-a. In the implementation domain, it means is-implemented-in-terms-of.
&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Item-37 Never redefine a function&#39;s inherited default parameter value</title>
      <link>http://nianze.ml/2018/03/never-redefine-a-functions-inherited-default-parameter-value/</link>
      <pubDate>Fri, 02 Mar 2018 21:15:36 -0500</pubDate>
      
      <guid>http://nianze.ml/2018/03/never-redefine-a-functions-inherited-default-parameter-value/</guid>
      <description>&lt;p&gt;Defaul parameter values are statically bound, while virtual function - the only functions we should be overriding - are dynamically bound.
&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Item-36 Never redefine an inherited non-virtaul function</title>
      <link>http://nianze.ml/2018/03/never-redefine-an-inherited-non-virtaul-function/</link>
      <pubDate>Thu, 01 Mar 2018 20:22:17 -0500</pubDate>
      
      <guid>http://nianze.ml/2018/03/never-redefine-an-inherited-non-virtaul-function/</guid>
      <description>&lt;p&gt;A generalized basic rule from item 7.
&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Item-35 Consider Alternatives to Virtual Functions</title>
      <link>http://nianze.ml/2018/02/consider-alternatives-to-virtual-functions/</link>
      <pubDate>Wed, 28 Feb 2018 20:27:02 -0500</pubDate>
      
      <guid>http://nianze.ml/2018/02/consider-alternatives-to-virtual-functions/</guid>
      <description>&lt;p&gt;Alternatives to virtual functions include the NVI idiom (as an example of the Template Method design pattern) and various forms of the Strategy design pattern.
&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Item-34 Differentiate between inheritance of interface and inheritance of implementation</title>
      <link>http://nianze.ml/2018/02/differentiate-inheritance-of-interface-from-inheritance-of-implementation/</link>
      <pubDate>Tue, 27 Feb 2018 20:53:53 -0500</pubDate>
      
      <guid>http://nianze.ml/2018/02/differentiate-inheritance-of-interface-from-inheritance-of-implementation/</guid>
      <description>&lt;p&gt;Inheritance of interface is different from inheritance of implementatino.
&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Item-33 Avoid hiding inherited names</title>
      <link>http://nianze.ml/2018/02/avoid-hiding-inherited-names/</link>
      <pubDate>Mon, 26 Feb 2018 20:18:55 -0500</pubDate>
      
      <guid>http://nianze.ml/2018/02/avoid-hiding-inherited-names/</guid>
      <description>&lt;p&gt;Names in derived classes hide names in base classes, which is not desirable in public inheritance. To fix it, employ &lt;code&gt;using&lt;/code&gt; declarations or forwarding functions to make hidden names visible again.
&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Item-32 Make sure public inheritance models &#34;Is-A&#34;</title>
      <link>http://nianze.ml/2018/02/make-sure-public-inheritance-models-is-a/</link>
      <pubDate>Fri, 23 Feb 2018 12:59:53 -0500</pubDate>
      
      <guid>http://nianze.ml/2018/02/make-sure-public-inheritance-models-is-a/</guid>
      <description>&lt;p&gt;Everything that applies to base classes must also apply to derived classes in public inheritance, for every derived class object &lt;em&gt;is&lt;/em&gt; a base class object.
&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Item-31 Minimize compilation dependencies between files</title>
      <link>http://nianze.ml/2018/02/minimize-compilation-dependencies-between-files/</link>
      <pubDate>Thu, 22 Feb 2018 00:00:00 +0000</pubDate>
      
      <guid>http://nianze.ml/2018/02/minimize-compilation-dependencies-between-files/</guid>
      <description>&lt;p&gt;To minimize compilation dependencies, depend on declarations instead of definitions via techniques such as Handle classes and Interface classes.
&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Item-30 Understand ins and outs of inlining</title>
      <link>http://nianze.ml/2018/02/ins-and-outs-of-inlining/</link>
      <pubDate>Wed, 21 Feb 2018 00:00:00 +0000</pubDate>
      
      <guid>http://nianze.ml/2018/02/ins-and-outs-of-inlining/</guid>
      <description>&lt;p&gt;Limit most inlining to small, frequently called functions to facilitate debugging and binary upgradability, minimize potential code bloat, and maximize the chances of greater program speed.
&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Item-29 Strive for exception-safe code</title>
      <link>http://nianze.ml/2018/02/strive-for-exception-safe-code/</link>
      <pubDate>Tue, 20 Feb 2018 18:23:38 -0500</pubDate>
      
      <guid>http://nianze.ml/2018/02/strive-for-exception-safe-code/</guid>
      <description>&lt;p&gt;Exception-safe functions leak no resources and allow no data structures to become corrupted, even when exceptions are thrown. Such functions offer the basic, strong, and nothrow guarantees.
&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Item-28 Avoid returning handles to object internals</title>
      <link>http://nianze.ml/2018/02/avoid-return-handles-to-obejct-internals/</link>
      <pubDate>Fri, 16 Feb 2018 12:26:14 -0500</pubDate>
      
      <guid>http://nianze.ml/2018/02/avoid-return-handles-to-obejct-internals/</guid>
      <description>&lt;p&gt;Avoid returning handles to object internals to increase encapsulation, help &lt;code&gt;const&lt;/code&gt; member functions act &lt;code&gt;const&lt;/code&gt;, and minimize the creation of dangling handles.
&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Item-27 Minimize_casting</title>
      <link>http://nianze.ml/2018/02/minimize-casting/</link>
      <pubDate>Thu, 15 Feb 2018 17:43:53 -0500</pubDate>
      
      <guid>http://nianze.ml/2018/02/minimize-casting/</guid>
      <description>&lt;p&gt;Avoid casts and develop a cast-free alternative whenever practical, especially &lt;code&gt;dynamic_cast&lt;/code&gt; in performance-sensitive code.
&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Item-26 Postpone variable definitions as long as possible</title>
      <link>http://nianze.ml/2018/02/postpone-variable-definitions/</link>
      <pubDate>Wed, 14 Feb 2018 10:50:18 -0500</pubDate>
      
      <guid>http://nianze.ml/2018/02/postpone-variable-definitions/</guid>
      <description>&lt;p&gt;Postponing variable definitions as long as possible increases program clarity and improves progranm efficiency.
&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Item-25 Consider support for a non-throwing swap</title>
      <link>http://nianze.ml/2018/02/support-for-a-non-throwing-swap/</link>
      <pubDate>Tue, 13 Feb 2018 19:11:15 -0500</pubDate>
      
      <guid>http://nianze.ml/2018/02/support-for-a-non-throwing-swap/</guid>
      <description>&lt;p&gt;When &lt;code&gt;std::swap&lt;/code&gt; would be inefficient for your type,provide a non-throwing &lt;code&gt;swap&lt;/code&gt; member function, a non-member &lt;code&gt;swap&lt;/code&gt; calling the member, and possibly a specialized &lt;code&gt;std::swap&lt;/code&gt; for the case of classes (not templates).
&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Item-24 Declare non-member functions when type conversions should apply to all parameters</title>
      <link>http://nianze.ml/2018/02/when-to-declare-non-member-functions/</link>
      <pubDate>Mon, 12 Feb 2018 22:47:20 -0500</pubDate>
      
      <guid>http://nianze.ml/2018/02/when-to-declare-non-member-functions/</guid>
      <description>&lt;p&gt;If we need type conversions on all parameters to a function including the one pointed to by the &lt;code&gt;this&lt;/code&gt; pointer, the function must be a non-member.
&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Item-23 Prefer non-member non-friend function to member function</title>
      <link>http://nianze.ml/2018/02/prefer-non-member-non-friend-function-to-member-function/</link>
      <pubDate>Sun, 11 Feb 2018 21:33:28 -0500</pubDate>
      
      <guid>http://nianze.ml/2018/02/prefer-non-member-non-friend-function-to-member-function/</guid>
      <description>&lt;p&gt;Prefer non-member non-friend functions to member functions for better encapsulation, packaging flexibility, and functional extensibility.
&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Item-22 Declare data members private</title>
      <link>http://nianze.ml/2018/02/declare-data-members-private/</link>
      <pubDate>Sat, 10 Feb 2018 00:00:00 +0000</pubDate>
      
      <guid>http://nianze.ml/2018/02/declare-data-members-private/</guid>
      <description>&lt;p&gt;Declaring data members &lt;code&gt;private&lt;/code&gt; gives clients syntactically uniform access to data, affords fine-grained access control, allows invariants to be enforced, and offers class authors implementation flexibility.
&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Item-21 Don&#39;t return a reference when we have to return an object</title>
      <link>http://nianze.ml/2018/02/do-not-return-a-ref-when-must-return-an-object/</link>
      <pubDate>Fri, 09 Feb 2018 18:02:23 -0500</pubDate>
      
      <guid>http://nianze.ml/2018/02/do-not-return-a-ref-when-must-return-an-object/</guid>
      <description>&lt;p&gt;Never return a pointer or reference to a local stack object, a refenrence to a heap-allocated object, or a pointer or reference to a local static object if there is a change that more than one such object will be needed (item 4 provides a &amp;ldquo;counter&amp;rdquo; example that is reasonable in single-threaded environments).
&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Item-20 Perfer pass-by-reference-to-const to pass-by-value</title>
      <link>http://nianze.ml/2018/02/perfer-pass-by-reference-to-const/</link>
      <pubDate>Thu, 08 Feb 2018 16:26:33 -0500</pubDate>
      
      <guid>http://nianze.ml/2018/02/perfer-pass-by-reference-to-const/</guid>
      <description>&lt;p&gt;Pass by reference-to-&lt;code&gt;const&lt;/code&gt; is typically more efficient than pass by value and avoids the slicing problem.
&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Item-19 Treat class design as type design</title>
      <link>http://nianze.ml/2018/02/class-design-is-type-design/</link>
      <pubDate>Wed, 07 Feb 2018 13:47:07 -0500</pubDate>
      
      <guid>http://nianze.ml/2018/02/class-design-is-type-design/</guid>
      <description>&lt;p&gt;Before definining a new type, be sure to consider all the issues discussed in this item.
&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Item-18 Make interfaces easy to use correctly and hard to use incorrectly</title>
      <link>http://nianze.ml/2018/02/make-interfaces-easy-to-use-correctly/</link>
      <pubDate>Tue, 06 Feb 2018 19:05:53 -0500</pubDate>
      
      <guid>http://nianze.ml/2018/02/make-interfaces-easy-to-use-correctly/</guid>
      <description>&lt;p&gt;Good interfaces are easy to use correctly and hard to use incorrectly.
&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>2018进度表</title>
      <link>http://nianze.ml/2018/02/2018-roadmap/</link>
      <pubDate>Tue, 06 Feb 2018 11:44:42 -0500</pubDate>
      
      <guid>http://nianze.ml/2018/02/2018-roadmap/</guid>
      <description>&lt;p&gt;马上春节了，来列一下新年计划吧。
&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Item-17 Store newed objects in smart pointers in standalone statements</title>
      <link>http://nianze.ml/2018/02/store-newed-objects-in-smart-pointers-in-standalone-statements/</link>
      <pubDate>Mon, 05 Feb 2018 18:04:38 -0500</pubDate>
      
      <guid>http://nianze.ml/2018/02/store-newed-objects-in-smart-pointers-in-standalone-statements/</guid>
      <description>&lt;p&gt;Failure to do this can lead to subtle resource leaks when exceptions are thrown.
&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Item-16 Use the same form in corresponding uses of new and delete</title>
      <link>http://nianze.ml/2018/02/use-the-same-form-in-matching-new-and-delete/</link>
      <pubDate>Sun, 04 Feb 2018 00:00:00 +0000</pubDate>
      
      <guid>http://nianze.ml/2018/02/use-the-same-form-in-matching-new-and-delete/</guid>
      <description>&lt;p&gt;If you use [] in a &lt;code&gt;new&lt;/code&gt; expression, use [] in the corresponding &lt;code&gt;delete&lt;/code&gt; expression; If not, no [] in the matching &lt;code&gt;delete&lt;/code&gt; expression.
&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Item-15 Provide access to raw resource in resource-managing classes</title>
      <link>http://nianze.ml/2018/02/provide-access-to-raw-rsc/</link>
      <pubDate>Sat, 03 Feb 2018 00:00:00 +0000</pubDate>
      
      <guid>http://nianze.ml/2018/02/provide-access-to-raw-rsc/</guid>
      <description>&lt;p&gt;Each RAII class should offer a way to get at the resource it manages.
&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Item-14 Copy behavior in resource-managing classes</title>
      <link>http://nianze.ml/2018/02/copy-behavior-of-raii/</link>
      <pubDate>Fri, 02 Feb 2018 13:27:32 -0500</pubDate>
      
      <guid>http://nianze.ml/2018/02/copy-behavior-of-raii/</guid>
      <description>&lt;p&gt;Copying an RAII object entails copying the resource it manages, so the copying behavior of the resource determines the copying behavior of the RAII object.
&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Item-13 Use objects to manage resources</title>
      <link>http://nianze.ml/2018/02/use-objects-to-manage-resources/</link>
      <pubDate>Thu, 01 Feb 2018 18:20:10 -0500</pubDate>
      
      <guid>http://nianze.ml/2018/02/use-objects-to-manage-resources/</guid>
      <description>&lt;p&gt;Use RAII objects such as &lt;code&gt;tr1::shared_ptr&lt;/code&gt; and &lt;code&gt;auto_ptr&lt;/code&gt; to prevent resource leaks.
&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Item-12 Copy all parts of an object</title>
      <link>http://nianze.ml/2018/01/copy-all-parts-of-an-object/</link>
      <pubDate>Wed, 31 Jan 2018 18:16:11 -0500</pubDate>
      
      <guid>http://nianze.ml/2018/01/copy-all-parts-of-an-object/</guid>
      <description>&lt;p&gt;Be sure to copy all of an object&amp;rsquo;s data members and all of its base class parts.
&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Item-11 Handle self assignment in operator=</title>
      <link>http://nianze.ml/2018/01/handle-self-assignment/</link>
      <pubDate>Tue, 30 Jan 2018 18:34:01 -0500</pubDate>
      
      <guid>http://nianze.ml/2018/01/handle-self-assignment/</guid>
      <description>&lt;p&gt;Solve self assignment situation in operator= by comparing addresses of source and target objects, careful statement ordering, and copy-and-&lt;code&gt;swap&lt;/code&gt;.
&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Item-10 Have assignment operators return a reference to *this</title>
      <link>http://nianze.ml/2018/01/have-assignment-op-return-a-ref/</link>
      <pubDate>Mon, 29 Jan 2018 18:17:34 -0500</pubDate>
      
      <guid>http://nianze.ml/2018/01/have-assignment-op-return-a-ref/</guid>
      <description>&lt;p&gt;As title suggests.
&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Item-9 不要在构造函数和析构函数中触发虚函数</title>
      <link>http://nianze.ml/2018/01/no-virtual-func-in-ctor-dtor/</link>
      <pubDate>Sat, 27 Jan 2018 21:03:05 -0500</pubDate>
      
      <guid>http://nianze.ml/2018/01/no-virtual-func-in-ctor-dtor/</guid>
      <description>&lt;p&gt;不同于Java或者C#,在C++中构造函数和析构函数里的虚函数不会实现多态的效果。
&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>人间不值得。。。吗？</title>
      <link>http://nianze.ml/2018/01/worth-it-or-not/</link>
      <pubDate>Sun, 28 Jan 2018 00:00:00 +0000</pubDate>
      
      <guid>http://nianze.ml/2018/01/worth-it-or-not/</guid>
      <description>&lt;p&gt;看了最近那期《十三邀》&lt;a href=&#34;https://v.qq.com/x/page/v0025csa5a9.html&#34;&gt;许知远&lt;/a&gt;对话&lt;a href=&#34;https://v.qq.com/x/page/j0025rf9fow.html&#34;&gt;李诞&lt;/a&gt;。有点意思。
&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Item-8 Prevent exception from leaving destructor</title>
      <link>http://nianze.ml/2018/01/prevent-exception-from-leaving-dtor/</link>
      <pubDate>Fri, 26 Jan 2018 20:15:48 -0500</pubDate>
      
      <guid>http://nianze.ml/2018/01/prevent-exception-from-leaving-dtor/</guid>
      <description>&lt;p&gt;It is discouraged practice to emit exceptions from destructors.
&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Item-7 Declare destructor virtual in polymorphic base classes</title>
      <link>http://nianze.ml/2018/01/virtual-dtor-in-polymorphic-base-class/</link>
      <pubDate>Thu, 25 Jan 2018 18:04:14 -0500</pubDate>
      
      <guid>http://nianze.ml/2018/01/virtual-dtor-in-polymorphic-base-class/</guid>
      <description>&lt;p&gt;If a class has any virtual functions (for polymorphic purpose), it should have a virtual destructor.
&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Item-6 Disallow unwanted compiler-generated functions</title>
      <link>http://nianze.ml/2018/01/functions-silently-created/</link>
      <pubDate>Wed, 24 Jan 2018 16:18:59 -0500</pubDate>
      
      <guid>http://nianze.ml/2018/01/functions-silently-created/</guid>
      <description>&lt;p&gt;Declare unwanted member functions &lt;em&gt;private&lt;/em&gt; without implementations to disallow functionality automatically provided by compilers.
&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Item-5 What functions C&#43;&#43; silently generates</title>
      <link>http://nianze.ml/2018/01/functions-silently-created/</link>
      <pubDate>Tue, 23 Jan 2018 18:42:07 -0500</pubDate>
      
      <guid>http://nianze.ml/2018/01/functions-silently-created/</guid>
      <description>&lt;p&gt;Compilers may implicitly generate their own versions of default constructor, copy constructor, copy assignment operator, and destructor.
&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Item-4 Initialize objects before they&#39;re used</title>
      <link>http://nianze.ml/2018/01/initialize-before-use/</link>
      <pubDate>Mon, 22 Jan 2018 18:47:54 -0500</pubDate>
      
      <guid>http://nianze.ml/2018/01/initialize-before-use/</guid>
      <description>&lt;p&gt;Since C++ is fickle about initialization, some good coding style is suggested.
&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>紫羅蘭永恆花園</title>
      <link>http://nianze.ml/2018/01/violet-snow/</link>
      <pubDate>Sun, 21 Jan 2018 23:25:09 -0500</pubDate>
      
      <guid>http://nianze.ml/2018/01/violet-snow/</guid>
      <description>&lt;p&gt;想いを綴る、愛を知るために。
&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Item-3 Use const whenever possible</title>
      <link>http://nianze.ml/2018/01/use-const-whenever-possible/</link>
      <pubDate>Fri, 19 Jan 2018 14:31:40 -0500</pubDate>
      
      <guid>http://nianze.ml/2018/01/use-const-whenever-possible/</guid>
      <description>&lt;p&gt;Useful tips on using &lt;code&gt;const&lt;/code&gt; in C++.
&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Item-0 Federation of languages</title>
      <link>http://nianze.ml/2018/01/cpp-is-multiparadigm/</link>
      <pubDate>Thu, 18 Jan 2018 20:01:47 -0500</pubDate>
      
      <guid>http://nianze.ml/2018/01/cpp-is-multiparadigm/</guid>
      <description>&lt;p&gt;C++ is a multiparadigm programming langrage.
&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Item-2 Compare &lt;iostream&gt; to &lt;stdio.h&gt;</title>
      <link>http://nianze.ml/2018/01/tips-on-iostream/</link>
      <pubDate>Wed, 17 Jan 2018 19:14:29 -0500</pubDate>
      
      <guid>http://nianze.ml/2018/01/tips-on-iostream/</guid>
      <description>&lt;p&gt;Some tips about &lt;code&gt;&amp;lt;iostream&amp;gt;&lt;/code&gt;
&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Item-1 Prefer consts, enums and inlines to #defines</title>
      <link>http://nianze.ml/2018/01/start-of-effective-cpp-series/</link>
      <pubDate>Tue, 16 Jan 2018 18:41:58 -0500</pubDate>
      
      <guid>http://nianze.ml/2018/01/start-of-effective-cpp-series/</guid>
      <description>&lt;p&gt;A new (hopefully) daily review on &lt;code&gt;C++&lt;/code&gt;.
&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>当谈论有趣时，我在谈论什么</title>
      <link>http://nianze.ml/2018/01/creation-is-fun/</link>
      <pubDate>Wed, 10 Jan 2018 00:00:00 +0000</pubDate>
      
      <guid>http://nianze.ml/2018/01/creation-is-fun/</guid>
      <description>&lt;p&gt;Dull guys are all the same, while cool souls each have their own shine.&lt;br /&gt;
无趣的灵魂都是相同的，有趣的灵魂各有各的不同
&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Machine learning overview</title>
      <link>http://nianze.ml/2018/01/start-of-machine-learning-series/</link>
      <pubDate>Thu, 04 Jan 2018 00:00:00 +0000</pubDate>
      
      <guid>http://nianze.ml/2018/01/start-of-machine-learning-series/</guid>
      <description>&lt;p&gt;My first post in the new &lt;code&gt;machine learning&lt;/code&gt; series.
&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Coco(寻梦环游记)随想</title>
      <link>http://nianze.ml/2018/01/coco/</link>
      <pubDate>Wed, 03 Jan 2018 00:00:00 +0000</pubDate>
      
      <guid>http://nianze.ml/2018/01/coco/</guid>
      <description>&lt;p&gt;观看Coco之后的一些随想。
&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>使用Hugo在GitHub Pages上搭建免费个人网站</title>
      <link>http://nianze.ml/2017/12/personal-site-with-hugo/</link>
      <pubDate>Tue, 26 Dec 2017 00:00:00 +0000</pubDate>
      
      <guid>http://nianze.ml/2017/12/personal-site-with-hugo/</guid>
      <description>&lt;p&gt;This article talks about how to use &lt;a href=&#34;https://gohugo.io/&#34;&gt;Hugo&lt;/a&gt; to build a personal website hosted on &lt;a href=&#34;https://pages.github.com/&#34;&gt;Github Pages&lt;/a&gt;. It also introduces how to find a free custom domain name from &lt;a href=&#34;http://www.freenom.com/&#34;&gt;Freenom&lt;/a&gt; and migrated the DNS server to &lt;a href=&#34;https://www.cloudflare.com/&#34;&gt;CloudFlare&lt;/a&gt; in order to use HTTPs with chosen custom domain name on GitHub Pages.&lt;br /&gt;
本文讲述了如何使用&lt;a href=&#34;https://gohugo.io/&#34;&gt;Hugo&lt;/a&gt;将个人网页托管在&lt;a href=&#34;https://pages.github.com/&#34;&gt;Github Pages&lt;/a&gt;上。同时也介绍了如何在&lt;a href=&#34;http://www.freenom.com/&#34;&gt;Freenom&lt;/a&gt;上找到免费个人域名并利用&lt;a href=&#34;https://www.cloudflare.com/&#34;&gt;CloudFlare&lt;/a&gt;的免费DNS服务在Github Pages上以HTTPs协议加载个人域名。
&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>一些近况</title>
      <link>http://nianze.ml/2017/12/return-to-my-blog/</link>
      <pubDate>Fri, 22 Dec 2017 00:00:00 +0000</pubDate>
      
      <guid>http://nianze.ml/2017/12/return-to-my-blog/</guid>
      <description>&lt;p&gt;重新回归搁置了近一年的博客，开始新的企划。
&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>宾得KP实测心得</title>
      <link>http://nianze.ml/2017/05/pentax-kp/</link>
      <pubDate>Mon, 08 May 2017 00:00:00 +0000</pubDate>
      
      <guid>http://nianze.ml/2017/05/pentax-kp/</guid>
      <description>&lt;p&gt;复古情怀向中端单反宾得KP开箱体验与实测心得。
&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>宾得K70开箱</title>
      <link>http://nianze.ml/2017/01/pentax-k70/</link>
      <pubDate>Tue, 17 Jan 2017 00:00:00 +0000</pubDate>
      
      <guid>http://nianze.ml/2017/01/pentax-k70/</guid>
      <description>&lt;p&gt;高性价比中低端单反宾得K70开箱及像素位移模式简单测试。
&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Binary search review</title>
      <link>http://nianze.ml/2016/12/binary-search-review/</link>
      <pubDate>Thu, 29 Dec 2016 00:00:00 +0000</pubDate>
      
      <guid>http://nianze.ml/2016/12/binary-search-review/</guid>
      <description>&lt;p&gt;Detailed review on binary search.
&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Alien dictionary</title>
      <link>http://nianze.ml/2016/11/alien-dictionary/</link>
      <pubDate>Sat, 26 Nov 2016 00:00:00 +0000</pubDate>
      
      <guid>http://nianze.ml/2016/11/alien-dictionary/</guid>
      <description>&lt;p&gt;Build a graph to solve alien dictionary problem via DFS/BFS.
&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Task schedule - greedy algorithm</title>
      <link>http://nianze.ml/2016/11/task-schedule/</link>
      <pubDate>Mon, 14 Nov 2016 00:00:00 +0000</pubDate>
      
      <guid>http://nianze.ml/2016/11/task-schedule/</guid>
      <description>&lt;p&gt;Use greedy algorigthm to solve task scheduleing problem.
&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>LinkedList reversing</title>
      <link>http://nianze.ml/2016/11/linkedlist-reversing/</link>
      <pubDate>Fri, 11 Nov 2016 00:00:00 +0000</pubDate>
      
      <guid>http://nianze.ml/2016/11/linkedlist-reversing/</guid>
      <description>&lt;p&gt;Summary on LinkedList reversing.
&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Substring type problem&#39;s template</title>
      <link>http://nianze.ml/2016/11/substring-template/</link>
      <pubDate>Tue, 08 Nov 2016 00:00:00 +0000</pubDate>
      
      <guid>http://nianze.ml/2016/11/substring-template/</guid>
      <description>&lt;p&gt;Two pointer template to solve substring problem.
&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Remove Invalid Parentheses</title>
      <link>http://nianze.ml/2016/11/invalid-parentheses/</link>
      <pubDate>Sun, 06 Nov 2016 00:00:00 +0000</pubDate>
      
      <guid>http://nianze.ml/2016/11/invalid-parentheses/</guid>
      <description>&lt;p&gt;Several ways to remove invalid parentheses problem.
&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Convert Char to String in Java</title>
      <link>http://nianze.ml/2016/11/char-to-string/</link>
      <pubDate>Wed, 02 Nov 2016 00:00:00 +0000</pubDate>
      
      <guid>http://nianze.ml/2016/11/char-to-string/</guid>
      <description>&lt;p&gt;Convert Char to String.
&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>When use Dueque</title>
      <link>http://nianze.ml/2016/10/dueque/</link>
      <pubDate>Sun, 30 Oct 2016 00:00:00 +0000</pubDate>
      
      <guid>http://nianze.ml/2016/10/dueque/</guid>
      <description>&lt;p&gt;Deque vs. LinkedList vs. Stack
&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Valid tree</title>
      <link>http://nianze.ml/2016/10/valid-tree/</link>
      <pubDate>Sat, 29 Oct 2016 00:00:00 +0000</pubDate>
      
      <guid>http://nianze.ml/2016/10/valid-tree/</guid>
      <description>&lt;p&gt;DFS, BFS and Union-find comparison.
&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Binary search basic</title>
      <link>http://nianze.ml/2016/08/binary-search/</link>
      <pubDate>Fri, 05 Aug 2016 00:00:00 +0000</pubDate>
      
      <guid>http://nianze.ml/2016/08/binary-search/</guid>
      <description>&lt;p&gt;What should be noted when doing binary search.
&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Spirited away</title>
      <link>http://nianze.ml/2016/02/spirited-away/</link>
      <pubDate>Mon, 15 Feb 2016 00:00:00 +0000</pubDate>
      
      <guid>http://nianze.ml/2016/02/spirited-away/</guid>
      <description>&lt;p&gt;东风夜放花千树，更吹落、星如雨。&lt;br /&gt;
宝马雕车香满路。凤箫声动，玉壶光转，一夜鱼龙舞。
&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>New semester is coming</title>
      <link>http://nianze.ml/2016/01/new-semester/</link>
      <pubDate>Mon, 25 Jan 2016 00:00:00 +0000</pubDate>
      
      <guid>http://nianze.ml/2016/01/new-semester/</guid>
      <description>&lt;p&gt;As the new semester approaches, I finished two more clarinet covers
&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>填个去年的坑</title>
      <link>http://nianze.ml/2016/01/return-of-monkey-king/</link>
      <pubDate>Fri, 08 Jan 2016 00:00:00 +0000</pubDate>
      
      <guid>http://nianze.ml/2016/01/return-of-monkey-king/</guid>
      <description>&lt;p&gt;简单尝试下中文歌曲的翻录（既然是中文歌了我就用中文来写好啦）
&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>New year cover - Aesthetic</title>
      <link>http://nianze.ml/2016/01/aesthetic/</link>
      <pubDate>Fri, 01 Jan 2016 00:00:00 +0000</pubDate>
      
      <guid>http://nianze.ml/2016/01/aesthetic/</guid>
      <description>&lt;p&gt;My new year&amp;rsquo;s first cover is for Hiroyuki Sawano!
&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>End of my first semester in Cornell</title>
      <link>http://nianze.ml/2015/12/end-of-semester/</link>
      <pubDate>Sat, 12 Dec 2015 00:00:00 +0000</pubDate>
      
      <guid>http://nianze.ml/2015/12/end-of-semester/</guid>
      <description>&lt;p&gt;A mark on the end of my first semester in Cornell.
&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Halloween celebration</title>
      <link>http://nianze.ml/2015/11/halloween-celebration/</link>
      <pubDate>Sun, 01 Nov 2015 00:00:00 +0000</pubDate>
      
      <guid>http://nianze.ml/2015/11/halloween-celebration/</guid>
      <description>&lt;p&gt;A small piece of music to celebrating the Halloween.
&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Early collection of clarinet cover</title>
      <link>http://nianze.ml/2015/07/clarinet-cover-collection/</link>
      <pubDate>Tue, 28 Jul 2015 00:00:00 +0000</pubDate>
      
      <guid>http://nianze.ml/2015/07/clarinet-cover-collection/</guid>
      <description>&lt;p&gt;Some of my early clarinet cover is collected here in this article.
&lt;/p&gt;</description>
    </item>
    
  </channel>
</rss>