<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on Be creative</title>
    <link>http://nianze.tk/post/</link>
    <description>Recent content in Posts on Be creative</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sun, 24 Nov 2019 10:19:01 -0500</lastBuildDate>
    
        <atom:link href="http://nianze.tk/post/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>[Weekly-30] 2019.11.24</title>
      <link>http://nianze.tk/2019/11/2019-11-24-weekly-visual-project/</link>
      <pubDate>Sun, 24 Nov 2019 10:19:01 -0500</pubDate>
      
      <guid>http://nianze.tk/2019/11/2019-11-24-weekly-visual-project/</guid>
      <description>&lt;p&gt;Weekly visual project - 2019/11/24

&lt;!--toc--&gt;&lt;/p&gt;

&lt;h1 id=&#34;the-street&#34;&gt;The street&lt;/h1&gt;

&lt;p&gt;

 
  
  
  
  
    
  
    
      
    
  

&lt;div class=&#34;figure fig-100&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2019/11/24/aisle.JPG&#34; title=&#34;↑aisle&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2019/11/24/thumbnail/aisle.JPG&#34;  alt=&#34;↑aisle&#34;&gt;
  
    &lt;/a&gt;
  
   
    &lt;span class=&#34;caption&#34;&gt;↑aisle&lt;/span&gt;
  
&lt;/div&gt;



 
  
  
  
  
    
  
    
      
    
  

&lt;div class=&#34;figure fig-100&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2019/11/24/fish%20market.JPG&#34; title=&#34;↑fish market&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2019/11/24/thumbnail/fish%20market.JPG&#34;  alt=&#34;↑fish market&#34;&gt;
  
    &lt;/a&gt;
  
   
    &lt;span class=&#34;caption&#34;&gt;↑fish market&lt;/span&gt;
  
&lt;/div&gt;



 
  
  
  
  
    
  
    
      
    
  

&lt;div class=&#34;figure fig-100&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2019/11/24/truckman.JPG&#34; title=&#34;↑truckman&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2019/11/24/thumbnail/truckman.JPG&#34;  alt=&#34;↑truckman&#34;&gt;
  
    &lt;/a&gt;
  
   
    &lt;span class=&#34;caption&#34;&gt;↑truckman&lt;/span&gt;
  
&lt;/div&gt;
&lt;/p&gt;

&lt;h1 id=&#34;the-subway&#34;&gt;The subway&lt;/h1&gt;

&lt;p&gt;

 
  
  
  
  
    
  
    
      
    
  

&lt;div class=&#34;figure fig-100&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2019/11/24/enjoy.JPG&#34; title=&#34;↑enjoy&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2019/11/24/thumbnail/enjoy.JPG&#34;  alt=&#34;↑enjoy&#34;&gt;
  
    &lt;/a&gt;
  
   
    &lt;span class=&#34;caption&#34;&gt;↑enjoy&lt;/span&gt;
  
&lt;/div&gt;



 
  
  
  
  
    
  
    
      
    
  

&lt;div class=&#34;figure fig-100&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2019/11/24/stare.JPG&#34; title=&#34;↑stare&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2019/11/24/thumbnail/stare.JPG&#34;  alt=&#34;↑stare&#34;&gt;
  
    &lt;/a&gt;
  
   
    &lt;span class=&#34;caption&#34;&gt;↑stare&lt;/span&gt;
  
&lt;/div&gt;



 
  
  
  
  
    
  
    
      
    
  

&lt;div class=&#34;figure fig-100&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2019/11/24/wait.JPG&#34; title=&#34;↑wait&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2019/11/24/thumbnail/wait.JPG&#34;  alt=&#34;↑wait&#34;&gt;
  
    &lt;/a&gt;
  
   
    &lt;span class=&#34;caption&#34;&gt;↑wait&lt;/span&gt;
  
&lt;/div&gt;
&lt;/p&gt;

&lt;h1 id=&#34;the-shadow&#34;&gt;The shadow&lt;/h1&gt;

&lt;p&gt;

 
  
  
  
  
    
  
    
      
    
  

&lt;div class=&#34;figure fig-100&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2019/11/24/shadow1.JPG&#34; title=&#34;↑shadow1&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2019/11/24/thumbnail/shadow1.JPG&#34;  alt=&#34;↑shadow1&#34;&gt;
  
    &lt;/a&gt;
  
   
    &lt;span class=&#34;caption&#34;&gt;↑shadow1&lt;/span&gt;
  
&lt;/div&gt;



 
  
  
  
  
    
  
    
      
    
  

&lt;div class=&#34;figure fig-100&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2019/11/24/shadow2.JPG&#34; title=&#34;↑shadow2&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2019/11/24/thumbnail/shadow2.JPG&#34;  alt=&#34;↑shadow2&#34;&gt;
  
    &lt;/a&gt;
  
   
    &lt;span class=&#34;caption&#34;&gt;↑shadow2&lt;/span&gt;
  
&lt;/div&gt;



 
  
  
  
  
    
  
    
      
    
  

&lt;div class=&#34;figure fig-100&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2019/11/24/shadow3.JPG&#34; title=&#34;↑shadow3&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2019/11/24/thumbnail/shadow3.JPG&#34;  alt=&#34;↑shadow3&#34;&gt;
  
    &lt;/a&gt;
  
   
    &lt;span class=&#34;caption&#34;&gt;↑shadow3&lt;/span&gt;
  
&lt;/div&gt;
&lt;/p&gt;

&lt;h1 id=&#34;the-children&#34;&gt;The children&lt;/h1&gt;

&lt;p&gt;

 
  
  
  
  
    
  
    
      
    
  

&lt;div class=&#34;figure fig-100&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2019/11/24/hand%20in%20hand%201.JPG&#34; title=&#34;↑hand in hand 1&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2019/11/24/thumbnail/hand%20in%20hand%201.JPG&#34;  alt=&#34;↑hand in hand 1&#34;&gt;
  
    &lt;/a&gt;
  
   
    &lt;span class=&#34;caption&#34;&gt;↑hand in hand 1&lt;/span&gt;
  
&lt;/div&gt;



 
  
  
  
  
    
  
    
      
    
  

&lt;div class=&#34;figure fig-100&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2019/11/24/hand%20in%20hand%202.JPG&#34; title=&#34;↑hand in hand 2&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2019/11/24/thumbnail/hand%20in%20hand%202.JPG&#34;  alt=&#34;↑hand in hand 2&#34;&gt;
  
    &lt;/a&gt;
  
   
    &lt;span class=&#34;caption&#34;&gt;↑hand in hand 2&lt;/span&gt;
  
&lt;/div&gt;



 
  
  
  
  
    
  
    
      
    
  

&lt;div class=&#34;figure fig-100&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2019/11/24/hand%20in%20hand%203.JPG&#34; title=&#34;↑hand in hand 3&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2019/11/24/thumbnail/hand%20in%20hand%203.JPG&#34;  alt=&#34;↑hand in hand 3&#34;&gt;
  
    &lt;/a&gt;
  
   
    &lt;span class=&#34;caption&#34;&gt;↑hand in hand 3&lt;/span&gt;
  
&lt;/div&gt;
&lt;/p&gt;

&lt;h1 id=&#34;the-pigeon&#34;&gt;The pigeon&lt;/h1&gt;



 
  
  
  
  
    
  
    
      
    
  

&lt;div class=&#34;figure fig-100&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2019/11/24/pigeon.JPG&#34; title=&#34;↑pigeon&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2019/11/24/thumbnail/pigeon.JPG&#34;  alt=&#34;↑pigeon&#34;&gt;
  
    &lt;/a&gt;
  
   
    &lt;span class=&#34;caption&#34;&gt;↑pigeon&lt;/span&gt;
  
&lt;/div&gt;


&lt;h1 id=&#34;the-excerpt&#34;&gt;The excerpt&lt;/h1&gt;

&lt;blockquote&gt;
&lt;p&gt;I have always looked upon the task of a scientist as bearing the responsibility for persuading his contemporaries of the cogency and validity of his thinking. He isn’t entitled to a warm reception. He has to earn it, whether by the skill of his exposition, the novelty of his ideas, or what.&lt;br /&gt;
Excerpt From: George Stigler&lt;/p&gt;
&lt;/blockquote&gt;</description>
    </item>
    
    <item>
      <title>[Weekly-29] 2019.11.16</title>
      <link>http://nianze.tk/2019/11/2019-11-16-weekly-visual-project/</link>
      <pubDate>Sat, 16 Nov 2019 13:47:17 -0500</pubDate>
      
      <guid>http://nianze.tk/2019/11/2019-11-16-weekly-visual-project/</guid>
      <description>&lt;p&gt;Weekly visual project - 2019/11/16

&lt;!--toc--&gt;&lt;/p&gt;

&lt;h1 id=&#34;the-street&#34;&gt;The street&lt;/h1&gt;

&lt;p&gt;

 
  
  
  
  
    
  
    
      
    
  

&lt;div class=&#34;figure fig-100&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2019/11/16/construction.JPG&#34; title=&#34;↑construction.JPG&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2019/11/16/thumbnail/construction.JPG&#34;  alt=&#34;↑construction.JPG&#34;&gt;
  
    &lt;/a&gt;
  
   
    &lt;span class=&#34;caption&#34;&gt;↑construction.JPG&lt;/span&gt;
  
&lt;/div&gt;



 
  
  
  
  
    
  
    
      
    
  

&lt;div class=&#34;figure fig-100&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2019/11/16/coupe.JPG&#34; title=&#34;↑coupe.JPG&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2019/11/16/thumbnail/coupe.JPG&#34;  alt=&#34;↑coupe.JPG&#34;&gt;
  
    &lt;/a&gt;
  
   
    &lt;span class=&#34;caption&#34;&gt;↑coupe.JPG&lt;/span&gt;
  
&lt;/div&gt;



 
  
  
  
  
    
  
    
      
    
  

&lt;div class=&#34;figure fig-100&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2019/11/16/gesture.JPG&#34; title=&#34;↑gesture.JPG&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2019/11/16/thumbnail/gesture.JPG&#34;  alt=&#34;↑gesture.JPG&#34;&gt;
  
    &lt;/a&gt;
  
   
    &lt;span class=&#34;caption&#34;&gt;↑gesture.JPG&lt;/span&gt;
  
&lt;/div&gt;
&lt;/p&gt;

&lt;p&gt;

 
  
  
  
  
    
  
    
      
    
  

&lt;div class=&#34;figure fig-100&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2019/11/16/milk.JPG&#34; title=&#34;↑milk.JPG&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2019/11/16/thumbnail/milk.JPG&#34;  alt=&#34;↑milk.JPG&#34;&gt;
  
    &lt;/a&gt;
  
   
    &lt;span class=&#34;caption&#34;&gt;↑milk.JPG&lt;/span&gt;
  
&lt;/div&gt;



 
  
  
  
  
    
  
    
      
    
  

&lt;div class=&#34;figure fig-100&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2019/11/16/scooter.JPG&#34; title=&#34;↑scooter.JPG&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2019/11/16/thumbnail/scooter.JPG&#34;  alt=&#34;↑scooter.JPG&#34;&gt;
  
    &lt;/a&gt;
  
   
    &lt;span class=&#34;caption&#34;&gt;↑scooter.JPG&lt;/span&gt;
  
&lt;/div&gt;
&lt;/p&gt;

&lt;p&gt;

 
  
  
  
  
    
  
    
      
    
  

&lt;div class=&#34;figure fig-100&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2019/11/16/building.JPG&#34; title=&#34;↑building.JPG&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2019/11/16/thumbnail/building.JPG&#34;  alt=&#34;↑building.JPG&#34;&gt;
  
    &lt;/a&gt;
  
   
    &lt;span class=&#34;caption&#34;&gt;↑building.JPG&lt;/span&gt;
  
&lt;/div&gt;



 
  
  
  
  
    
  
    
      
    
  

&lt;div class=&#34;figure fig-100&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2019/11/16/sunset.JPG&#34; title=&#34;↑sunset.JPG&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2019/11/16/thumbnail/sunset.JPG&#34;  alt=&#34;↑sunset.JPG&#34;&gt;
  
    &lt;/a&gt;
  
   
    &lt;span class=&#34;caption&#34;&gt;↑sunset.JPG&lt;/span&gt;
  
&lt;/div&gt;
&lt;/p&gt;

&lt;h1 id=&#34;the-excerpt&#34;&gt;The excerpt&lt;/h1&gt;

&lt;blockquote&gt;
&lt;p&gt;The point is, a great deal of our limited supply of attention is committed to the tasks of surviving from one day to the next. Over an entire lifetime, the amount of attention left over for learning a symbolic domain—such as music or physics—is a fraction of this already small amount.&lt;br /&gt;
Excerpt From: Mihaly Csikszentmihalyi. &amp;ldquo;Creativity.&amp;rdquo;&lt;/p&gt;
&lt;/blockquote&gt;</description>
    </item>
    
    <item>
      <title>[Weekly-28] 2019.11.09</title>
      <link>http://nianze.tk/2019/11/2019-11-09-weekly-visual-project/</link>
      <pubDate>Sat, 09 Nov 2019 12:02:11 -0500</pubDate>
      
      <guid>http://nianze.tk/2019/11/2019-11-09-weekly-visual-project/</guid>
      <description>&lt;p&gt;Weekly visual project - 2019/11/09

&lt;!--toc--&gt;&lt;/p&gt;

&lt;h1 id=&#34;the-street&#34;&gt;The street&lt;/h1&gt;

&lt;p&gt;

 
  
  
  
  
    
  
    
      
    
  

&lt;div class=&#34;figure fig-50&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2019/11/09/lying%20down.JPG&#34; title=&#34;↑lying down&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2019/11/09/thumbnail/lying%20down.JPG&#34;  alt=&#34;↑lying down&#34;&gt;
  
    &lt;/a&gt;
  
   
    &lt;span class=&#34;caption&#34;&gt;↑lying down&lt;/span&gt;
  
&lt;/div&gt;



 
  
  
  
  
    
  
    
      
    
  

&lt;div class=&#34;figure fig-50&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2019/11/09/reflection.JPG&#34; title=&#34;↑reflection&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2019/11/09/thumbnail/reflection.JPG&#34;  alt=&#34;↑reflection&#34;&gt;
  
    &lt;/a&gt;
  
   
    &lt;span class=&#34;caption&#34;&gt;↑reflection&lt;/span&gt;
  
&lt;/div&gt;



 
  
  
  
  
    
  
    
      
    
  

&lt;div class=&#34;figure fig-100&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2019/11/09/shoot.JPG&#34; title=&#34;↑shoot&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2019/11/09/thumbnail/shoot.JPG&#34;  alt=&#34;↑shoot&#34;&gt;
  
    &lt;/a&gt;
  
   
    &lt;span class=&#34;caption&#34;&gt;↑shoot&lt;/span&gt;
  
&lt;/div&gt;



 
  
  
  
  
    
  
    
      
    
  

&lt;div class=&#34;figure fig-100&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2019/11/09/golden%20bike.JPG&#34; title=&#34;↑golden bike&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2019/11/09/thumbnail/golden%20bike.JPG&#34;  alt=&#34;↑golden bike&#34;&gt;
  
    &lt;/a&gt;
  
   
    &lt;span class=&#34;caption&#34;&gt;↑golden bike&lt;/span&gt;
  
&lt;/div&gt;



 
  
  
  
  
    
  
    
      
    
  

&lt;div class=&#34;figure fig-100&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2019/11/09/stick.JPG&#34; title=&#34;↑stick&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2019/11/09/thumbnail/stick.JPG&#34;  alt=&#34;↑stick&#34;&gt;
  
    &lt;/a&gt;
  
   
    &lt;span class=&#34;caption&#34;&gt;↑stick&lt;/span&gt;
  
&lt;/div&gt;
&lt;/p&gt;

&lt;h1 id=&#34;the-market&#34;&gt;The market&lt;/h1&gt;

&lt;p&gt;

 
  
  
  
  
    
  
    
      
    
  

&lt;div class=&#34;figure fig-100&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2019/11/09/goat%20milk%20soap.JPG&#34; title=&#34;↑goat milk soap&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2019/11/09/thumbnail/goat%20milk%20soap.JPG&#34;  alt=&#34;↑goat milk soap&#34;&gt;
  
    &lt;/a&gt;
  
   
    &lt;span class=&#34;caption&#34;&gt;↑goat milk soap&lt;/span&gt;
  
&lt;/div&gt;



 
  
  
  
  
    
  
    
      
    
  

&lt;div class=&#34;figure fig-100&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2019/11/09/grapes.JPG&#34; title=&#34;↑grapes&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2019/11/09/thumbnail/grapes.JPG&#34;  alt=&#34;↑grapes&#34;&gt;
  
    &lt;/a&gt;
  
   
    &lt;span class=&#34;caption&#34;&gt;↑grapes&lt;/span&gt;
  
&lt;/div&gt;



 
  
  
  
  
    
  
    
      
    
  

&lt;div class=&#34;figure fig-100&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2019/11/09/romanesco%20broccoli.JPG&#34; title=&#34;↑romanesco broccoli&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2019/11/09/thumbnail/romanesco%20broccoli.JPG&#34;  alt=&#34;↑romanesco broccoli&#34;&gt;
  
    &lt;/a&gt;
  
   
    &lt;span class=&#34;caption&#34;&gt;↑romanesco broccoli&lt;/span&gt;
  
&lt;/div&gt;



 
  
  
  
  
    
  
    
      
    
  

&lt;div class=&#34;figure fig-100&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2019/11/09/yellow%20pepper.JPG&#34; title=&#34;↑yellow pepper&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2019/11/09/thumbnail/yellow%20pepper.JPG&#34;  alt=&#34;↑yellow pepper&#34;&gt;
  
    &lt;/a&gt;
  
   
    &lt;span class=&#34;caption&#34;&gt;↑yellow pepper&lt;/span&gt;
  
&lt;/div&gt;
&lt;/p&gt;

&lt;h1 id=&#34;the-animal&#34;&gt;The animal&lt;/h1&gt;

&lt;p&gt;

 
  
  
  
  
    
  
    
      
    
  

&lt;div class=&#34;figure fig-100&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2019/11/09/jump.JPG&#34; title=&#34;↑jump&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2019/11/09/thumbnail/jump.JPG&#34;  alt=&#34;↑jump&#34;&gt;
  
    &lt;/a&gt;
  
   
    &lt;span class=&#34;caption&#34;&gt;↑jump&lt;/span&gt;
  
&lt;/div&gt;



 
  
  
  
  
    
  
    
      
    
  

&lt;div class=&#34;figure fig-100&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2019/11/09/dog1.JPG&#34; title=&#34;↑dog1&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2019/11/09/thumbnail/dog1.JPG&#34;  alt=&#34;↑dog1&#34;&gt;
  
    &lt;/a&gt;
  
   
    &lt;span class=&#34;caption&#34;&gt;↑dog1&lt;/span&gt;
  
&lt;/div&gt;



 
  
  
  
  
    
  
    
      
    
  

&lt;div class=&#34;figure fig-100&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2019/11/09/dog2.JPG&#34; title=&#34;↑dog2&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2019/11/09/thumbnail/dog2.JPG&#34;  alt=&#34;↑dog2&#34;&gt;
  
    &lt;/a&gt;
  
   
    &lt;span class=&#34;caption&#34;&gt;↑dog2&lt;/span&gt;
  
&lt;/div&gt;
&lt;/p&gt;

&lt;h1 id=&#34;the-excerpt&#34;&gt;The excerpt&lt;/h1&gt;

&lt;blockquote&gt;
&lt;p&gt;从前一直有人认为痴心者见悦于痴心者，以后会有人认知痴心者见悦于明哲者，明哲，是痴心已去的意思，这种失却是被褫夺的被割绝的，痴心与生俱来，明哲当然是后天的事。明哲仅仅是亮度较高的忧郁。&lt;br /&gt;
Excerpt From: 木心. &amp;ldquo;九月初九.&amp;rdquo;&lt;/p&gt;
&lt;/blockquote&gt;</description>
    </item>
    
    <item>
      <title>[Weekly-27] 2019.11.02</title>
      <link>http://nianze.tk/2019/11/2019-11-02-weekly-visual-project/</link>
      <pubDate>Sat, 02 Nov 2019 18:47:05 -0400</pubDate>
      
      <guid>http://nianze.tk/2019/11/2019-11-02-weekly-visual-project/</guid>
      <description>&lt;p&gt;Weekly visual project - 2019/11/02

&lt;!--toc--&gt;&lt;/p&gt;

&lt;h1 id=&#34;the-street&#34;&gt;The street&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;shot by [iPhone X]&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;

 
  
  
  
  
    
  
    
      
    
  

&lt;div class=&#34;figure fig-100&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2019/11/02/leaves.JPG&#34; title=&#34;↑leaves&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2019/11/02/thumbnail/leaves.JPG&#34;  alt=&#34;↑leaves&#34;&gt;
  
    &lt;/a&gt;
  
   
    &lt;span class=&#34;caption&#34;&gt;↑leaves&lt;/span&gt;
  
&lt;/div&gt;



 
  
  
  
  
    
  
    
      
    
  

&lt;div class=&#34;figure fig-100&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2019/11/02/oh.JPG&#34; title=&#34;↑oh&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2019/11/02/thumbnail/oh.JPG&#34;  alt=&#34;↑oh&#34;&gt;
  
    &lt;/a&gt;
  
   
    &lt;span class=&#34;caption&#34;&gt;↑oh&lt;/span&gt;
  
&lt;/div&gt;



 
  
  
  
  
    
  
    
      
    
  

&lt;div class=&#34;figure fig-100&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2019/11/02/reflection.JPG&#34; title=&#34;↑grape tree&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2019/11/02/thumbnail/reflection.JPG&#34;  alt=&#34;↑grape tree&#34;&gt;
  
    &lt;/a&gt;
  
   
    &lt;span class=&#34;caption&#34;&gt;↑grape tree&lt;/span&gt;
  
&lt;/div&gt;
&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;shot by [Leica M9|Zeiss 50mm f/1.5]&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;

 
  
  
  
  
    
  
    
      
    
  

&lt;div class=&#34;figure fig-100&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2019/11/02/charging.JPG&#34; title=&#34;↑charging&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2019/11/02/thumbnail/charging.JPG&#34;  alt=&#34;↑charging&#34;&gt;
  
    &lt;/a&gt;
  
   
    &lt;span class=&#34;caption&#34;&gt;↑charging&lt;/span&gt;
  
&lt;/div&gt;



 
  
  
  
  
    
  
    
      
    
  

&lt;div class=&#34;figure fig-100&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2019/11/02/coffee.JPG&#34; title=&#34;↑coffee&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2019/11/02/thumbnail/coffee.JPG&#34;  alt=&#34;↑coffee&#34;&gt;
  
    &lt;/a&gt;
  
   
    &lt;span class=&#34;caption&#34;&gt;↑coffee&lt;/span&gt;
  
&lt;/div&gt;



 
  
  
  
  
    
  
    
      
    
  

&lt;div class=&#34;figure fig-100&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2019/11/02/selfie.JPG&#34; title=&#34;↑selfie&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2019/11/02/thumbnail/selfie.JPG&#34;  alt=&#34;↑selfie&#34;&gt;
  
    &lt;/a&gt;
  
   
    &lt;span class=&#34;caption&#34;&gt;↑selfie&lt;/span&gt;
  
&lt;/div&gt;



 
  
  
  
  
    
  
    
      
    
  

&lt;div class=&#34;figure fig-100&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2019/11/02/subway.JPG&#34; title=&#34;↑subway&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2019/11/02/thumbnail/subway.JPG&#34;  alt=&#34;↑subway&#34;&gt;
  
    &lt;/a&gt;
  
   
    &lt;span class=&#34;caption&#34;&gt;↑subway&lt;/span&gt;
  
&lt;/div&gt;
&lt;/p&gt;

&lt;h1 id=&#34;the-market&#34;&gt;The market&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;shot by [Leica M9|Zeiss 50mm f/1.5]&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;

 
  
  
  
  
    
  
    
      
    
  

&lt;div class=&#34;figure fig-100&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2019/11/02/bear.JPG&#34; title=&#34;↑bear&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2019/11/02/thumbnail/bear.JPG&#34;  alt=&#34;↑bear&#34;&gt;
  
    &lt;/a&gt;
  
   
    &lt;span class=&#34;caption&#34;&gt;↑bear&lt;/span&gt;
  
&lt;/div&gt;



 
  
  
  
  
    
  
    
      
    
  

&lt;div class=&#34;figure fig-100&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2019/11/02/cranberry.JPG&#34; title=&#34;↑cranberry&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2019/11/02/thumbnail/cranberry.JPG&#34;  alt=&#34;↑cranberry&#34;&gt;
  
    &lt;/a&gt;
  
   
    &lt;span class=&#34;caption&#34;&gt;↑cranberry&lt;/span&gt;
  
&lt;/div&gt;



 
  
  
  
  
    
  
    
      
    
  

&lt;div class=&#34;figure fig-100&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2019/11/02/eggs.JPG&#34; title=&#34;↑eggs&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2019/11/02/thumbnail/eggs.JPG&#34;  alt=&#34;↑eggs&#34;&gt;
  
    &lt;/a&gt;
  
   
    &lt;span class=&#34;caption&#34;&gt;↑eggs&lt;/span&gt;
  
&lt;/div&gt;



 
  
  
  
  
    
  
    
      
    
  

&lt;div class=&#34;figure fig-100&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2019/11/02/grapes.JPG&#34; title=&#34;↑grapes&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2019/11/02/thumbnail/grapes.JPG&#34;  alt=&#34;↑grapes&#34;&gt;
  
    &lt;/a&gt;
  
   
    &lt;span class=&#34;caption&#34;&gt;↑grapes&lt;/span&gt;
  
&lt;/div&gt;
&lt;/p&gt;

&lt;h1 id=&#34;the-excerpt&#34;&gt;The excerpt&lt;/h1&gt;

&lt;blockquote&gt;
&lt;p&gt;也许你要问：为什么艺术家一定要有所牺牲呢？&lt;br /&gt;
这一问者，大抵不太愿意牺牲，因为还没弄清艺术是怎么回事，怕白白牺牲——我可以彻底地说：艺术本来也只是一个梦，不过比权势的梦、财富的梦、情欲的梦，更美一些，更持久一些，艺术，是个最好的梦。&lt;br /&gt;
我们有共享的心理诉求。你画完一张得意的画，第一个念头就是给谁看。人一定是这样的。权势、财富，只有炫耀，不能共享，一共享，就对立了，一半财富权力给了你了。情欲呢，是两个人的事，不能有第三者。比下来，艺术是可以共享的。天性优美，才华高超，可以放在政治上、商业上、爱情上，但都会失败，失算，过气——放在艺术上最好。&lt;br /&gt;
Excerpt From: 木心. &amp;ldquo;文学回忆录.&amp;rdquo;&lt;/p&gt;
&lt;/blockquote&gt;</description>
    </item>
    
    <item>
      <title>[Weekly-26] 2019.10.26</title>
      <link>http://nianze.tk/2019/10/2019-10-26-weekly-visual-project/</link>
      <pubDate>Sat, 26 Oct 2019 22:20:11 -0400</pubDate>
      
      <guid>http://nianze.tk/2019/10/2019-10-26-weekly-visual-project/</guid>
      <description>&lt;p&gt;Weekly visual project - 2019/10/26&lt;/p&gt;

&lt;p&gt;
&lt;!--toc--&gt;&lt;/p&gt;

&lt;h1 id=&#34;the-street&#34;&gt;The street&lt;/h1&gt;

&lt;p&gt;

 
  
  
  
  
    
  
    
      
    
  

&lt;div class=&#34;figure fig-100&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2019/10/26/hang.JPG&#34; title=&#34;↑hang&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2019/10/26/thumbnail/hang.JPG&#34;  alt=&#34;↑hang&#34;&gt;
  
    &lt;/a&gt;
  
   
    &lt;span class=&#34;caption&#34;&gt;↑hang&lt;/span&gt;
  
&lt;/div&gt;



 
  
  
  
  
    
  
    
      
    
  

&lt;div class=&#34;figure fig-100&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2019/10/26/stare.JPG&#34; title=&#34;↑stare&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2019/10/26/thumbnail/stare.JPG&#34;  alt=&#34;↑stare&#34;&gt;
  
    &lt;/a&gt;
  
   
    &lt;span class=&#34;caption&#34;&gt;↑stare&lt;/span&gt;
  
&lt;/div&gt;



 
  
  
  
  
    
  
    
      
    
  

&lt;div class=&#34;figure fig-100&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2019/10/26/up.JPG&#34; title=&#34;↑up&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2019/10/26/thumbnail/up.JPG&#34;  alt=&#34;↑up&#34;&gt;
  
    &lt;/a&gt;
  
   
    &lt;span class=&#34;caption&#34;&gt;↑up&lt;/span&gt;
  
&lt;/div&gt;



 
  
  
  
  
    
  
    
      
    
  

&lt;div class=&#34;figure fig-100&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2019/10/26/wait.JPG&#34; title=&#34;↑wait&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2019/10/26/thumbnail/wait.JPG&#34;  alt=&#34;↑wait&#34;&gt;
  
    &lt;/a&gt;
  
   
    &lt;span class=&#34;caption&#34;&gt;↑wait&lt;/span&gt;
  
&lt;/div&gt;
&lt;/p&gt;

&lt;h1 id=&#34;the-nature&#34;&gt;The nature&lt;/h1&gt;

&lt;p&gt;

 
  
  
  
  
    
  
    
      
    
  

&lt;div class=&#34;figure fig-100&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2019/10/26/stable.JPG&#34; title=&#34;↑stable&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2019/10/26/thumbnail/stable.JPG&#34;  alt=&#34;↑stable&#34;&gt;
  
    &lt;/a&gt;
  
   
    &lt;span class=&#34;caption&#34;&gt;↑stable&lt;/span&gt;
  
&lt;/div&gt;



 
  
  
  
  
    
  
    
      
    
  

&lt;div class=&#34;figure fig-100&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2019/10/26/reservoir.JPG&#34; title=&#34;↑reservoir&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2019/10/26/thumbnail/reservoir.JPG&#34;  alt=&#34;↑reservoir&#34;&gt;
  
    &lt;/a&gt;
  
   
    &lt;span class=&#34;caption&#34;&gt;↑reservoir&lt;/span&gt;
  
&lt;/div&gt;
&lt;/p&gt;

&lt;h1 id=&#34;the-excerpt&#34;&gt;The excerpt&lt;/h1&gt;

&lt;blockquote&gt;
&lt;p&gt;所以为人之道，第一念，就是明白：人是要死的。
生活是什么？生活是死前的一段过程。凭这个，凭这样一念，就产生了宗教、哲学、文化、艺术。可是宗教、哲学、文化、艺术，又是要死的——太阳，将会冷却，地球在太阳系毁灭之前，就要出现冰河期，人类无法生存。可是末日看来还远，教堂、博物馆、美术馆、图书馆，煞有介事，庄严肃穆，昔在今在永在的样子——其实都是毁灭前的景观。
我是怀着悲伤的眼光，看着不知悲伤的事物。&lt;br /&gt;
Excerpt From: 木心. &amp;ldquo;文学回忆录.&amp;rdquo;&lt;/p&gt;
&lt;/blockquote&gt;</description>
    </item>
    
    <item>
      <title>[Weekly-25] 2019.10.19</title>
      <link>http://nianze.tk/2019/10/2019-10-19-weekly-visual-project/</link>
      <pubDate>Sat, 19 Oct 2019 14:04:18 -0400</pubDate>
      
      <guid>http://nianze.tk/2019/10/2019-10-19-weekly-visual-project/</guid>
      <description>&lt;p&gt;Weekly visual project - 2019/10/19

&lt;!--toc--&gt;&lt;/p&gt;

&lt;h1 id=&#34;the-street&#34;&gt;The street&lt;/h1&gt;

&lt;p&gt;

 
  
  
  
  
    
  
    
      
    
  

&lt;div class=&#34;figure fig-100&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2019/10/19/fire%20hydrant.JPG&#34; title=&#34;↑fire hydrant&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2019/10/19/thumbnail/fire%20hydrant.JPG&#34;  alt=&#34;↑fire hydrant&#34;&gt;
  
    &lt;/a&gt;
  
   
    &lt;span class=&#34;caption&#34;&gt;↑fire hydrant&lt;/span&gt;
  
&lt;/div&gt;



 
  
  
  
  
    
  
    
      
    
  

&lt;div class=&#34;figure fig-100&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2019/10/19/newspaper.JPG&#34; title=&#34;↑newspaper&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2019/10/19/thumbnail/newspaper.JPG&#34;  alt=&#34;↑newspaper&#34;&gt;
  
    &lt;/a&gt;
  
   
    &lt;span class=&#34;caption&#34;&gt;↑newspaper&lt;/span&gt;
  
&lt;/div&gt;



 
  
  
  
  
    
  
    
      
    
  

&lt;div class=&#34;figure fig-100&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2019/10/19/sword.JPG&#34; title=&#34;↑sword&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2019/10/19/thumbnail/sword.JPG&#34;  alt=&#34;↑sword&#34;&gt;
  
    &lt;/a&gt;
  
   
    &lt;span class=&#34;caption&#34;&gt;↑sword&lt;/span&gt;
  
&lt;/div&gt;



 
  
  
  
  
    
  
    
      
    
  

&lt;div class=&#34;figure fig-100&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2019/10/19/morning.JPG&#34; title=&#34;↑morning&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2019/10/19/thumbnail/morning.JPG&#34;  alt=&#34;↑morning&#34;&gt;
  
    &lt;/a&gt;
  
   
    &lt;span class=&#34;caption&#34;&gt;↑morning&lt;/span&gt;
  
&lt;/div&gt;
&lt;/p&gt;

&lt;h1 id=&#34;the-subway&#34;&gt;The subway&lt;/h1&gt;

&lt;p&gt;

 
  
  
  
  
    
  
    
      
    
  

&lt;div class=&#34;figure fig-100&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2019/10/19/father&amp;amp;son.JPG&#34; title=&#34;↑father&amp;amp;son&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2019/10/19/thumbnail/father&amp;amp;son.JPG&#34;  alt=&#34;↑father&amp;amp;son&#34;&gt;
  
    &lt;/a&gt;
  
   
    &lt;span class=&#34;caption&#34;&gt;↑father&amp;amp;son&lt;/span&gt;
  
&lt;/div&gt;



 
  
  
  
  
    
  
    
      
    
  

&lt;div class=&#34;figure fig-100&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2019/10/19/shoes.JPG&#34; title=&#34;↑shoes&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2019/10/19/thumbnail/shoes.JPG&#34;  alt=&#34;↑shoes&#34;&gt;
  
    &lt;/a&gt;
  
   
    &lt;span class=&#34;caption&#34;&gt;↑shoes&lt;/span&gt;
  
&lt;/div&gt;



 
  
  
  
  
    
  
    
      
    
  

&lt;div class=&#34;figure fig-100&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2019/10/19/stairs.JPG&#34; title=&#34;↑stairs&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2019/10/19/thumbnail/stairs.JPG&#34;  alt=&#34;↑stairs&#34;&gt;
  
    &lt;/a&gt;
  
   
    &lt;span class=&#34;caption&#34;&gt;↑stairs&lt;/span&gt;
  
&lt;/div&gt;
&lt;/p&gt;

&lt;h1 id=&#34;the-excerpt&#34;&gt;The excerpt&lt;/h1&gt;

&lt;blockquote&gt;
&lt;p&gt;想到尼采反理性，元凶一直追到苏格拉底。钦佩极了。大智者。可是病源、病根早就找到了，谁也开不出药方。
不靠理性，靠什么抗衡理性？&lt;br /&gt;
一筹莫展。病入膏肓。和理性相克的东西，几乎没有。不能说是感性、本能、暴力。都不能。能与理性对立，介乎理性之上的东西，几乎没有。只有在音乐中，准确地说，在某些段落、章节中，介于理性之上。&lt;br /&gt;
希腊雕像，也有这东西，在理性之上。&lt;br /&gt;
Excerpt From: 木心. &amp;ldquo;文学回忆录.&amp;rdquo;&lt;/p&gt;
&lt;/blockquote&gt;</description>
    </item>
    
    <item>
      <title>[Weekly-24] 2019.10.13</title>
      <link>http://nianze.tk/2019/10/2019-10-13-weekly-visual-project/</link>
      <pubDate>Sun, 13 Oct 2019 11:31:07 -0400</pubDate>
      
      <guid>http://nianze.tk/2019/10/2019-10-13-weekly-visual-project/</guid>
      <description>&lt;p&gt;Weekly visual project - 2019/10/13

&lt;!--toc--&gt;&lt;/p&gt;

&lt;h1 id=&#34;the-street&#34;&gt;The street&lt;/h1&gt;

&lt;p&gt;

 
  
  
  
  
    
  
    
      
    
  

&lt;div class=&#34;figure fig-100&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2019/10/13/brother.JPG&#34; title=&#34;↑brother&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2019/10/13/thumbnail/brother.JPG&#34;  alt=&#34;↑brother&#34;&gt;
  
    &lt;/a&gt;
  
   
    &lt;span class=&#34;caption&#34;&gt;↑brother&lt;/span&gt;
  
&lt;/div&gt;



 
  
  
  
  
    
  
    
      
    
  

&lt;div class=&#34;figure fig-100&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2019/10/13/happy.JPG&#34; title=&#34;↑happy&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2019/10/13/thumbnail/happy.JPG&#34;  alt=&#34;↑happy&#34;&gt;
  
    &lt;/a&gt;
  
   
    &lt;span class=&#34;caption&#34;&gt;↑happy&lt;/span&gt;
  
&lt;/div&gt;



 
  
  
  
  
    
  
    
      
    
  

&lt;div class=&#34;figure fig-100&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2019/10/13/help.JPG&#34; title=&#34;↑help&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2019/10/13/thumbnail/help.JPG&#34;  alt=&#34;↑help&#34;&gt;
  
    &lt;/a&gt;
  
   
    &lt;span class=&#34;caption&#34;&gt;↑help&lt;/span&gt;
  
&lt;/div&gt;



 
  
  
  
  
    
  
    
      
    
  

&lt;div class=&#34;figure fig-100&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2019/10/13/rice.JPG&#34; title=&#34;↑rice&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2019/10/13/thumbnail/rice.JPG&#34;  alt=&#34;↑rice&#34;&gt;
  
    &lt;/a&gt;
  
   
    &lt;span class=&#34;caption&#34;&gt;↑rice&lt;/span&gt;
  
&lt;/div&gt;



 
  
  
  
  
    
  
    
      
    
  

&lt;div class=&#34;figure fig-100&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2019/10/13/wine.JPG&#34; title=&#34;↑wine&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2019/10/13/thumbnail/wine.JPG&#34;  alt=&#34;↑wine&#34;&gt;
  
    &lt;/a&gt;
  
   
    &lt;span class=&#34;caption&#34;&gt;↑wine&lt;/span&gt;
  
&lt;/div&gt;



 
  
  
  
  
    
  
    
      
    
  

&lt;div class=&#34;figure fig-100&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2019/10/13/stairs.JPG&#34; title=&#34;↑stairs&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2019/10/13/thumbnail/stairs.JPG&#34;  alt=&#34;↑stairs&#34;&gt;
  
    &lt;/a&gt;
  
   
    &lt;span class=&#34;caption&#34;&gt;↑stairs&lt;/span&gt;
  
&lt;/div&gt;
&lt;/p&gt;

&lt;h1 id=&#34;the-excerpt&#34;&gt;The excerpt&lt;/h1&gt;

&lt;blockquote&gt;
&lt;p&gt;&amp;ldquo;群众的眼睛是雪亮的。&amp;rdquo;群众是没有眼睛的。群众还没有记忆。&lt;br /&gt;
Excerpt From: 木心. &amp;ldquo;文学回忆录.&amp;rdquo;&lt;/p&gt;
&lt;/blockquote&gt;</description>
    </item>
    
    <item>
      <title>[Weekly-23] 2019.10.06</title>
      <link>http://nianze.tk/2019/10/2019-10-06-weekly-visual-project/</link>
      <pubDate>Sun, 06 Oct 2019 11:41:56 -0400</pubDate>
      
      <guid>http://nianze.tk/2019/10/2019-10-06-weekly-visual-project/</guid>
      <description>&lt;p&gt;Weekly visual project - 2019/10/06

&lt;!--toc--&gt;&lt;/p&gt;

&lt;h1 id=&#34;the-street&#34;&gt;The street&lt;/h1&gt;



 
  
  
  
  
    
  
    
      
    
  

&lt;div class=&#34;figure fig-100&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2019/10/06/coffee.JPG&#34; title=&#34;↑coffee&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2019/10/06/thumbnail/coffee.JPG&#34;  alt=&#34;↑coffee&#34;&gt;
  
    &lt;/a&gt;
  
   
    &lt;span class=&#34;caption&#34;&gt;↑coffee&lt;/span&gt;
  
&lt;/div&gt;


&lt;p&gt;

 
  
  
  
  
    
  
    
      
    
  

&lt;div class=&#34;figure fig-50&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2019/10/06/crosswalk.JPG&#34; title=&#34;↑crosswalk&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2019/10/06/thumbnail/crosswalk.JPG&#34;  alt=&#34;↑crosswalk&#34;&gt;
  
    &lt;/a&gt;
  
   
    &lt;span class=&#34;caption&#34;&gt;↑crosswalk&lt;/span&gt;
  
&lt;/div&gt;



 
  
  
  
  
    
  
    
      
    
  

&lt;div class=&#34;figure fig-50&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2019/10/06/walk.JPG&#34; title=&#34;↑walk&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2019/10/06/thumbnail/walk.JPG&#34;  alt=&#34;↑walk&#34;&gt;
  
    &lt;/a&gt;
  
   
    &lt;span class=&#34;caption&#34;&gt;↑walk&lt;/span&gt;
  
&lt;/div&gt;
&lt;/p&gt;

&lt;p&gt;

 
  
  
  
  
    
  
    
      
    
  

&lt;div class=&#34;figure fig-100&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2019/10/06/girl.JPG&#34; title=&#34;↑girl&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2019/10/06/thumbnail/girl.JPG&#34;  alt=&#34;↑girl&#34;&gt;
  
    &lt;/a&gt;
  
   
    &lt;span class=&#34;caption&#34;&gt;↑girl&lt;/span&gt;
  
&lt;/div&gt;



 
  
  
  
  
    
  
    
      
    
  

&lt;div class=&#34;figure fig-100&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2019/10/06/kiss.JPG&#34; title=&#34;↑kiss&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2019/10/06/thumbnail/kiss.JPG&#34;  alt=&#34;↑kiss&#34;&gt;
  
    &lt;/a&gt;
  
   
    &lt;span class=&#34;caption&#34;&gt;↑kiss&lt;/span&gt;
  
&lt;/div&gt;



 
  
  
  
  
    
  
    
      
    
  

&lt;div class=&#34;figure fig-100&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2019/10/06/skateboarder.JPG&#34; title=&#34;↑skateboarder&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2019/10/06/thumbnail/skateboarder.JPG&#34;  alt=&#34;↑skateboarder&#34;&gt;
  
    &lt;/a&gt;
  
   
    &lt;span class=&#34;caption&#34;&gt;↑skateboarder&lt;/span&gt;
  
&lt;/div&gt;
&lt;/p&gt;

&lt;h1 id=&#34;the-pigeon&#34;&gt;The pigeon&lt;/h1&gt;

&lt;p&gt;

 
  
  
  
  
    
  
    
      
    
  

&lt;div class=&#34;figure fig-100&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2019/10/06/pigeon.JPG&#34; title=&#34;↑pigeon&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2019/10/06/thumbnail/pigeon.JPG&#34;  alt=&#34;↑pigeon&#34;&gt;
  
    &lt;/a&gt;
  
   
    &lt;span class=&#34;caption&#34;&gt;↑pigeon&lt;/span&gt;
  
&lt;/div&gt;



 
  
  
  
  
    
  
    
      
    
  

&lt;div class=&#34;figure fig-100&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2019/10/06/pigeons.JPG&#34; title=&#34;↑pigeons&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2019/10/06/thumbnail/pigeons.JPG&#34;  alt=&#34;↑pigeons&#34;&gt;
  
    &lt;/a&gt;
  
   
    &lt;span class=&#34;caption&#34;&gt;↑pigeons&lt;/span&gt;
  
&lt;/div&gt;
&lt;/p&gt;

&lt;h1 id=&#34;the-dog&#34;&gt;The dog&lt;/h1&gt;

&lt;p&gt;

 
  
  
  
  
    
  
    
      
    
  

&lt;div class=&#34;figure fig-100&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2019/10/06/dog1.JPG&#34; title=&#34;↑dog1&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2019/10/06/thumbnail/dog1.JPG&#34;  alt=&#34;↑dog1&#34;&gt;
  
    &lt;/a&gt;
  
   
    &lt;span class=&#34;caption&#34;&gt;↑dog1&lt;/span&gt;
  
&lt;/div&gt;



 
  
  
  
  
    
  
    
      
    
  

&lt;div class=&#34;figure fig-100&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2019/10/06/dog2.JPG&#34; title=&#34;↑dog2&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2019/10/06/thumbnail/dog2.JPG&#34;  alt=&#34;↑dog2&#34;&gt;
  
    &lt;/a&gt;
  
   
    &lt;span class=&#34;caption&#34;&gt;↑dog2&lt;/span&gt;
  
&lt;/div&gt;
&lt;/p&gt;

&lt;h1 id=&#34;the-excerpt&#34;&gt;The excerpt&lt;/h1&gt;

&lt;blockquote&gt;
&lt;p&gt;伍尔芙说，莎士比亚、托尔斯泰，都是双性人，比常人不知丰富多少。&lt;br /&gt;
托尔斯泰长篇《战争与和平》曾有七稿之多，放纵潜意识跑马，最后仍以意识控制定稿。&lt;br /&gt;
梦和艺术是两回事。疯子和艺术家是两种人。&lt;br /&gt;
梦是散乱的、不自觉的，艺术是完整的、自觉的。疯子是破坏的，天才是创造的。艺术家的意识及潜意识要特别平衡。&lt;br /&gt;
意识要加强，增加知识，经历，逻辑，善于推理，训练记忆——如何训练潜意识？&lt;br /&gt;
扩大兴趣范围，“智者，是对一切都发生惊奇的人”。放纵你的好奇的行为，享受官能之乐，对一切要抱着豁达大度，对世界万物抱着“无可无不可”的态度。都有兴趣，但别迷恋。&lt;br /&gt;
一句话：明哲而痴心。&lt;br /&gt;
再一句话：痴心而保持明哲。&lt;br /&gt;
还有一张底牌：意识是神性的，潜意识是魔性的，两者相加，即人性。&lt;br /&gt;
Excerpt From: 木心. “文学回忆录.”&lt;/p&gt;
&lt;/blockquote&gt;</description>
    </item>
    
    <item>
      <title>[Weekly-22] 2019.09.28</title>
      <link>http://nianze.tk/2019/09/2019-09-28-weekly-visual-project/</link>
      <pubDate>Sat, 28 Sep 2019 15:32:27 -0400</pubDate>
      
      <guid>http://nianze.tk/2019/09/2019-09-28-weekly-visual-project/</guid>
      <description>&lt;p&gt;Weekly visual project - 2019/09/28

&lt;!--toc--&gt;&lt;/p&gt;

&lt;h1 id=&#34;the-street&#34;&gt;The street&lt;/h1&gt;

&lt;p&gt;

 
  
  
  
  
    
  
    
      
    
  

&lt;div class=&#34;figure fig-100&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2019/09/28/ask.JPG&#34; title=&#34;↑ask&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2019/09/28/thumbnail/ask.JPG&#34;  alt=&#34;↑ask&#34;&gt;
  
    &lt;/a&gt;
  
   
    &lt;span class=&#34;caption&#34;&gt;↑ask&lt;/span&gt;
  
&lt;/div&gt;



 
  
  
  
  
    
  
    
      
    
  

&lt;div class=&#34;figure fig-100&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2019/09/28/crossline.jpg&#34; title=&#34;↑crossline&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2019/09/28/thumbnail/crossline.jpg&#34;  alt=&#34;↑crossline&#34;&gt;
  
    &lt;/a&gt;
  
   
    &lt;span class=&#34;caption&#34;&gt;↑crossline&lt;/span&gt;
  
&lt;/div&gt;



 
  
  
  
  
    
  
    
      
    
  

&lt;div class=&#34;figure fig-100&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2019/09/28/crowd.JPG&#34; title=&#34;↑crowd&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2019/09/28/thumbnail/crowd.JPG&#34;  alt=&#34;↑crowd&#34;&gt;
  
    &lt;/a&gt;
  
   
    &lt;span class=&#34;caption&#34;&gt;↑crowd&lt;/span&gt;
  
&lt;/div&gt;



 
  
  
  
  
    
  
    
      
    
  

&lt;div class=&#34;figure fig-100&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2019/09/28/fruits.JPG&#34; title=&#34;↑fruits&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2019/09/28/thumbnail/fruits.JPG&#34;  alt=&#34;↑fruits&#34;&gt;
  
    &lt;/a&gt;
  
   
    &lt;span class=&#34;caption&#34;&gt;↑fruits&lt;/span&gt;
  
&lt;/div&gt;



 
  
  
  
  
    
  
    
      
    
  

&lt;div class=&#34;figure fig-100&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2019/09/28/girls.JPG&#34; title=&#34;↑girls&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2019/09/28/thumbnail/girls.JPG&#34;  alt=&#34;↑girls&#34;&gt;
  
    &lt;/a&gt;
  
   
    &lt;span class=&#34;caption&#34;&gt;↑girls&lt;/span&gt;
  
&lt;/div&gt;



 
  
  
  
  
    
  
    
      
    
  

&lt;div class=&#34;figure fig-100&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2019/09/28/reflection.jpg&#34; title=&#34;↑reflection&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2019/09/28/thumbnail/reflection.jpg&#34;  alt=&#34;↑reflection&#34;&gt;
  
    &lt;/a&gt;
  
   
    &lt;span class=&#34;caption&#34;&gt;↑reflection&lt;/span&gt;
  
&lt;/div&gt;



 
  
  
  
  
    
  
    
      
    
  

&lt;div class=&#34;figure fig-100&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2019/09/28/subway.JPG&#34; title=&#34;↑subway&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2019/09/28/thumbnail/subway.JPG&#34;  alt=&#34;↑subway&#34;&gt;
  
    &lt;/a&gt;
  
   
    &lt;span class=&#34;caption&#34;&gt;↑subway&lt;/span&gt;
  
&lt;/div&gt;
&lt;/p&gt;

&lt;h1 id=&#34;the-food&#34;&gt;The food&lt;/h1&gt;

&lt;p&gt;

 
  
  
  
  
    
  
    
      
    
  

&lt;div class=&#34;figure fig-100&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2019/09/28/bee&amp;amp;bread.jpg&#34; title=&#34;↑bee&amp;amp;bread&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2019/09/28/thumbnail/bee&amp;amp;bread.jpg&#34;  alt=&#34;↑bee&amp;amp;bread&#34;&gt;
  
    &lt;/a&gt;
  
   
    &lt;span class=&#34;caption&#34;&gt;↑bee&amp;amp;bread&lt;/span&gt;
  
&lt;/div&gt;



 
  
  
  
  
    
  
    
      
    
  

&lt;div class=&#34;figure fig-100&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2019/09/28/carrots.JPG&#34; title=&#34;↑carrots&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2019/09/28/thumbnail/carrots.JPG&#34;  alt=&#34;↑carrots&#34;&gt;
  
    &lt;/a&gt;
  
   
    &lt;span class=&#34;caption&#34;&gt;↑carrots&lt;/span&gt;
  
&lt;/div&gt;



 
  
  
  
  
    
  
    
      
    
  

&lt;div class=&#34;figure fig-100&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2019/09/28/mashroom.jpg&#34; title=&#34;↑mashroom&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2019/09/28/thumbnail/mashroom.jpg&#34;  alt=&#34;↑mashroom&#34;&gt;
  
    &lt;/a&gt;
  
   
    &lt;span class=&#34;caption&#34;&gt;↑mashroom&lt;/span&gt;
  
&lt;/div&gt;



 
  
  
  
  
    
  
    
      
    
  

&lt;div class=&#34;figure fig-100&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2019/09/28/icecream.JPG&#34; title=&#34;↑icecream&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2019/09/28/thumbnail/icecream.JPG&#34;  alt=&#34;↑icecream&#34;&gt;
  
    &lt;/a&gt;
  
   
    &lt;span class=&#34;caption&#34;&gt;↑icecream&lt;/span&gt;
  
&lt;/div&gt;
&lt;/p&gt;

&lt;h1 id=&#34;the-excerpt&#34;&gt;The excerpt&lt;/h1&gt;

&lt;blockquote&gt;
&lt;p&gt;战前，立体派诗人很活跃（从绘画的立体派过来），有阿波利奈尔（Guillaume Apollinaire）、雅各布（Max Jacob）、萨尔蒙（André Salmon）。
他们是立体派中坚，他们有他们的道理：过去的艺术是模仿，现在要创造。阿波利奈尔有名言：当人要模仿步行时，创造了车轮，而车轮不是一条腿。超现实主义是这样出现的。
这固然是高明的诡辩，但我要和他吵：向来的艺术，并非真是只在模拟，他们也超写实，是隐的超写实，现在不过是显的超写实。因为纯粹的写实从来没有成为艺术。&lt;br /&gt;
Excerpt From: 木心. “文学回忆录.”&lt;/p&gt;
&lt;/blockquote&gt;</description>
    </item>
    
    <item>
      <title>[Weekly-21] 2019.09.21</title>
      <link>http://nianze.tk/2019/09/2019-09-21-weekly-visual-project/</link>
      <pubDate>Sat, 21 Sep 2019 11:11:59 -0400</pubDate>
      
      <guid>http://nianze.tk/2019/09/2019-09-21-weekly-visual-project/</guid>
      <description>&lt;p&gt;Weekly visual project - 2019/09/21

&lt;!--toc--&gt;&lt;/p&gt;

&lt;h1 id=&#34;the-street&#34;&gt;The street&lt;/h1&gt;

&lt;p&gt;

 
  
  
  
  
    
  
    
      
    
  

&lt;div class=&#34;figure fig-50&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2019/09/21/bike.JPG&#34; title=&#34;↑bike&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2019/09/21/thumbnail/bike.JPG&#34;  alt=&#34;↑bike&#34;&gt;
  
    &lt;/a&gt;
  
   
    &lt;span class=&#34;caption&#34;&gt;↑bike&lt;/span&gt;
  
&lt;/div&gt;



 
  
  
  
  
    
  
    
      
    
  

&lt;div class=&#34;figure fig-50&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2019/09/21/bikes.JPG&#34; title=&#34;↑bikes&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2019/09/21/thumbnail/bikes.JPG&#34;  alt=&#34;↑bikes&#34;&gt;
  
    &lt;/a&gt;
  
   
    &lt;span class=&#34;caption&#34;&gt;↑bikes&lt;/span&gt;
  
&lt;/div&gt;



 
  
  
  
  
    
  
    
      
    
  

&lt;div class=&#34;figure fig-100&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2019/09/21/cleaner.JPG&#34; title=&#34;↑cleaner&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2019/09/21/thumbnail/cleaner.JPG&#34;  alt=&#34;↑cleaner&#34;&gt;
  
    &lt;/a&gt;
  
   
    &lt;span class=&#34;caption&#34;&gt;↑cleaner&lt;/span&gt;
  
&lt;/div&gt;



 
  
  
  
  
    
  
    
      
    
  

&lt;div class=&#34;figure fig-100&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2019/09/21/pigeons.JPG&#34; title=&#34;↑pigeons&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2019/09/21/thumbnail/pigeons.JPG&#34;  alt=&#34;↑pigeons&#34;&gt;
  
    &lt;/a&gt;
  
   
    &lt;span class=&#34;caption&#34;&gt;↑pigeons&lt;/span&gt;
  
&lt;/div&gt;



 
  
  
  
  
    
  
    
      
    
  

&lt;div class=&#34;figure fig-100&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2019/09/21/reflection.JPG&#34; title=&#34;↑reflection&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2019/09/21/thumbnail/reflection.JPG&#34;  alt=&#34;↑reflection&#34;&gt;
  
    &lt;/a&gt;
  
   
    &lt;span class=&#34;caption&#34;&gt;↑reflection&lt;/span&gt;
  
&lt;/div&gt;



 
  
  
  
  
    
  
    
      
    
  

&lt;div class=&#34;figure fig-100&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2019/09/21/rooftop.JPG&#34; title=&#34;↑rooftop&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2019/09/21/thumbnail/rooftop.JPG&#34;  alt=&#34;↑rooftop&#34;&gt;
  
    &lt;/a&gt;
  
   
    &lt;span class=&#34;caption&#34;&gt;↑rooftop&lt;/span&gt;
  
&lt;/div&gt;
&lt;/p&gt;

&lt;h1 id=&#34;the-children&#34;&gt;The children&lt;/h1&gt;

&lt;p&gt;

 
  
  
  
  
    
  
    
      
    
  

&lt;div class=&#34;figure fig-100&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2019/09/21/scooter.JPG&#34; title=&#34;↑scooter&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2019/09/21/thumbnail/scooter.JPG&#34;  alt=&#34;↑scooter&#34;&gt;
  
    &lt;/a&gt;
  
   
    &lt;span class=&#34;caption&#34;&gt;↑scooter&lt;/span&gt;
  
&lt;/div&gt;



 
  
  
  
  
    
  
    
      
    
  

&lt;div class=&#34;figure fig-100&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2019/09/21/girl&amp;amp;car.JPG&#34; title=&#34;↑girl&amp;amp;car&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2019/09/21/thumbnail/girl&amp;amp;car.JPG&#34;  alt=&#34;↑girl&amp;amp;car&#34;&gt;
  
    &lt;/a&gt;
  
   
    &lt;span class=&#34;caption&#34;&gt;↑girl&amp;amp;car&lt;/span&gt;
  
&lt;/div&gt;



 
  
  
  
  
    
  
    
      
    
  

&lt;div class=&#34;figure fig-100&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2019/09/21/mom&amp;amp;chidren.JPG&#34; title=&#34;↑mom&amp;amp;chidren&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2019/09/21/thumbnail/mom&amp;amp;chidren.JPG&#34;  alt=&#34;↑mom&amp;amp;chidren&#34;&gt;
  
    &lt;/a&gt;
  
   
    &lt;span class=&#34;caption&#34;&gt;↑mom&amp;amp;chidren&lt;/span&gt;
  
&lt;/div&gt;
&lt;/p&gt;

&lt;h1 id=&#34;the-black-white&#34;&gt;The black &amp;amp; white&lt;/h1&gt;

&lt;p&gt;

 
  
  
  
  
    
  
    
      
    
  

&lt;div class=&#34;figure fig-100&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2019/09/21/subway.JPG&#34; title=&#34;↑subway&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2019/09/21/thumbnail/subway.JPG&#34;  alt=&#34;↑subway&#34;&gt;
  
    &lt;/a&gt;
  
   
    &lt;span class=&#34;caption&#34;&gt;↑subway&lt;/span&gt;
  
&lt;/div&gt;



 
  
  
  
  
    
  
    
      
    
  

&lt;div class=&#34;figure fig-100&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2019/09/21/window.JPG&#34; title=&#34;↑window&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2019/09/21/thumbnail/window.JPG&#34;  alt=&#34;↑window&#34;&gt;
  
    &lt;/a&gt;
  
   
    &lt;span class=&#34;caption&#34;&gt;↑window&lt;/span&gt;
  
&lt;/div&gt;
&lt;/p&gt;

&lt;h1 id=&#34;the-excerpt&#34;&gt;The excerpt&lt;/h1&gt;

&lt;blockquote&gt;
&lt;p&gt;文学家个人的命运和文学史的大命运，往往不一致。要注意个人的作品，不要随文学大流，大流总是庸俗的。小时候母亲教导我：“人多的地方不要去。”那是指偶尔容许我带仆人出门玩玩。现在想来，意味广大深长。在世界上，在历史中，人多的地方真是不去为妙。&lt;br /&gt;
Excerpt From: 木心. “文学回忆录.”&lt;/p&gt;
&lt;/blockquote&gt;</description>
    </item>
    
    <item>
      <title>[Weekly-20] 2019.09.15</title>
      <link>http://nianze.tk/2019/09/2019-09-15-weekly-visual-project/</link>
      <pubDate>Sun, 15 Sep 2019 00:00:00 +0000</pubDate>
      
      <guid>http://nianze.tk/2019/09/2019-09-15-weekly-visual-project/</guid>
      <description>&lt;p&gt;Weekly visual project - 2019/09/15&lt;/p&gt;

&lt;p&gt;
&lt;!--toc--&gt;&lt;/p&gt;

&lt;h1 id=&#34;the-street&#34;&gt;The street&lt;/h1&gt;

&lt;p&gt;

 
  
  
  
  
    
  
    
      
    
  

&lt;div class=&#34;figure fig-50&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2019/09/15/boy&amp;amp;statue.JPG&#34; title=&#34;↑boy&amp;amp;statue&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2019/09/15/thumbnail/boy&amp;amp;statue.JPG&#34;  alt=&#34;↑boy&amp;amp;statue&#34;&gt;
  
    &lt;/a&gt;
  
   
    &lt;span class=&#34;caption&#34;&gt;↑boy&amp;amp;statue&lt;/span&gt;
  
&lt;/div&gt;



 
  
  
  
  
    
  
    
      
    
  

&lt;div class=&#34;figure fig-50&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2019/09/15/smile.JPG&#34; title=&#34;↑smile&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2019/09/15/thumbnail/smile.JPG&#34;  alt=&#34;↑smile&#34;&gt;
  
    &lt;/a&gt;
  
   
    &lt;span class=&#34;caption&#34;&gt;↑smile&lt;/span&gt;
  
&lt;/div&gt;



 
  
  
  
  
    
  
    
      
    
  

&lt;div class=&#34;figure fig-100&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2019/09/15/teddy.JPG&#34; title=&#34;↑teddy&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2019/09/15/thumbnail/teddy.JPG&#34;  alt=&#34;↑teddy&#34;&gt;
  
    &lt;/a&gt;
  
   
    &lt;span class=&#34;caption&#34;&gt;↑teddy&lt;/span&gt;
  
&lt;/div&gt;



 
  
  
  
  
    
  
    
      
    
  

&lt;div class=&#34;figure fig-100&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2019/09/15/tri.JPG&#34; title=&#34;↑tri&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2019/09/15/thumbnail/tri.JPG&#34;  alt=&#34;↑tri&#34;&gt;
  
    &lt;/a&gt;
  
   
    &lt;span class=&#34;caption&#34;&gt;↑tri&lt;/span&gt;
  
&lt;/div&gt;



 
  
  
  
  
    
  
    
      
    
  

&lt;div class=&#34;figure fig-100&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2019/09/15/wft.JPG&#34; title=&#34;↑wft&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2019/09/15/thumbnail/wft.JPG&#34;  alt=&#34;↑wft&#34;&gt;
  
    &lt;/a&gt;
  
   
    &lt;span class=&#34;caption&#34;&gt;↑wft&lt;/span&gt;
  
&lt;/div&gt;



 
  
  
  
  
    
  
    
      
    
  

&lt;div class=&#34;figure fig-100&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2019/09/15/widow.JPG&#34; title=&#34;↑widow&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2019/09/15/thumbnail/widow.JPG&#34;  alt=&#34;↑widow&#34;&gt;
  
    &lt;/a&gt;
  
   
    &lt;span class=&#34;caption&#34;&gt;↑widow&lt;/span&gt;
  
&lt;/div&gt;
&lt;/p&gt;

&lt;h1 id=&#34;the-excerpt&#34;&gt;The excerpt&lt;/h1&gt;

&lt;blockquote&gt;
&lt;p&gt;什么是悲观主义？我以为就是“透”观主义。不要着眼于“悲”，要着眼于“观”——万事万物都会过去的，人是要死的，欲望永远不能满足，太阳底下无新事……这就是悲观。悲观主义是一个态度，是一个勇敢的人的态度。&lt;br /&gt;
得不到快乐，很快乐，这就是悲观主义。如此就有自知之明，知人之明，知物之明，知世之明。&lt;br /&gt;
一切都无可奈何，难过的，但是透彻。&lt;br /&gt;
Excerpt From: 木心. “文学回忆录.”&lt;/p&gt;
&lt;/blockquote&gt;</description>
    </item>
    
    <item>
      <title>[Weekly-19] 2019.09.07</title>
      <link>http://nianze.tk/2019/09/2019-09-07-visual-project/</link>
      <pubDate>Sat, 07 Sep 2019 09:27:41 -0400</pubDate>
      
      <guid>http://nianze.tk/2019/09/2019-09-07-visual-project/</guid>
      <description>&lt;p&gt;Weekly visual project - 2019/09/07

&lt;!--toc--&gt;&lt;/p&gt;

&lt;h1 id=&#34;the-street&#34;&gt;The street&lt;/h1&gt;

&lt;p&gt;

 
  
  
  
  
    
  
    
      
    
  

&lt;div class=&#34;figure fig-50&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2019/09/07/walk.JPG&#34; title=&#34;↑Walk&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2019/09/07/thumbnail/walk.JPG&#34;  alt=&#34;↑Walk&#34;&gt;
  
    &lt;/a&gt;
  
   
    &lt;span class=&#34;caption&#34;&gt;↑Walk&lt;/span&gt;
  
&lt;/div&gt;



 
  
  
  
  
    
  
    
      
    
  

&lt;div class=&#34;figure fig-50&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2019/09/07/biker.JPG&#34; title=&#34;↑Biker&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2019/09/07/thumbnail/biker.JPG&#34;  alt=&#34;↑Biker&#34;&gt;
  
    &lt;/a&gt;
  
   
    &lt;span class=&#34;caption&#34;&gt;↑Biker&lt;/span&gt;
  
&lt;/div&gt;



 
  
  
  
  
    
  
    
      
    
  

&lt;div class=&#34;figure fig-100&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2019/09/07/fruit.JPG&#34; title=&#34;↑Fruit&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2019/09/07/thumbnail/fruit.JPG&#34;  alt=&#34;↑Fruit&#34;&gt;
  
    &lt;/a&gt;
  
   
    &lt;span class=&#34;caption&#34;&gt;↑Fruit&lt;/span&gt;
  
&lt;/div&gt;



 
  
  
  
  
    
  
    
      
    
  

&lt;div class=&#34;figure fig-100&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2019/09/07/reflection.JPG&#34; title=&#34;↑Reflection&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2019/09/07/thumbnail/reflection.JPG&#34;  alt=&#34;↑Reflection&#34;&gt;
  
    &lt;/a&gt;
  
   
    &lt;span class=&#34;caption&#34;&gt;↑Reflection&lt;/span&gt;
  
&lt;/div&gt;



 
  
  
  
  
    
  
    
      
    
  

&lt;div class=&#34;figure fig-50&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2019/09/07/lv.JPG&#34; title=&#34;↑LV and pigeon&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2019/09/07/thumbnail/lv.JPG&#34;  alt=&#34;↑LV and pigeon&#34;&gt;
  
    &lt;/a&gt;
  
   
    &lt;span class=&#34;caption&#34;&gt;↑LV and pigeon&lt;/span&gt;
  
&lt;/div&gt;



 
  
  
  
  
    
  
    
      
    
  

&lt;div class=&#34;figure fig-50&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2019/09/07/sax.JPG&#34; title=&#34;↑Sax&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2019/09/07/thumbnail/sax.JPG&#34;  alt=&#34;↑Sax&#34;&gt;
  
    &lt;/a&gt;
  
   
    &lt;span class=&#34;caption&#34;&gt;↑Sax&lt;/span&gt;
  
&lt;/div&gt;


 
  
  
  
  
    
      
    
  
    
  

 
  
  
  
  
    
  

&lt;div class=&#34;figure &#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;&#34; &gt;
  
    &lt;/a&gt;
  
  
&lt;/div&gt;

  &lt;div style=&#34;clear:both;&#34;&gt;&lt;/div&gt;
&lt;/p&gt;

&lt;h1 id=&#34;the-dog&#34;&gt;The dog&lt;/h1&gt;

&lt;p&gt;

 
  
  
  
  
    
  
    
      
    
  

&lt;div class=&#34;figure fig-100&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2019/09/07/stare.JPG&#34; title=&#34;↑Stare&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2019/09/07/thumbnail/stare.JPG&#34;  alt=&#34;↑Stare&#34;&gt;
  
    &lt;/a&gt;
  
   
    &lt;span class=&#34;caption&#34;&gt;↑Stare&lt;/span&gt;
  
&lt;/div&gt;



 
  
  
  
  
    
  
    
      
    
  

&lt;div class=&#34;figure fig-100&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2019/09/07/stare2.JPG&#34; title=&#34;↑Stare&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2019/09/07/thumbnail/stare2.JPG&#34;  alt=&#34;↑Stare&#34;&gt;
  
    &lt;/a&gt;
  
   
    &lt;span class=&#34;caption&#34;&gt;↑Stare&lt;/span&gt;
  
&lt;/div&gt;
&lt;/p&gt;

&lt;h1 id=&#34;the-excerpt&#34;&gt;The excerpt&lt;/h1&gt;

&lt;blockquote&gt;
&lt;p&gt;艺术没有进化可言，我们读前辈的书（看画、听音乐），应有三种态度：设想在他们的时代鉴赏；据于自己的时代鉴赏；推理未来的时代鉴赏。
举例：希腊雕像（胜利女神），那是三种鉴赏态度都能完全完满肯定。之外，莎士比亚的诗剧、莫扎特的乐曲，也是昔在、今在、永在。&lt;br /&gt;
Excerpt From: 木心. “文学回忆录.”&lt;/p&gt;
&lt;/blockquote&gt;</description>
    </item>
    
    <item>
      <title>[Weekly-18] 2019.08.31</title>
      <link>http://nianze.tk/2019/08/2019-08-31-visual-project/</link>
      <pubDate>Sat, 31 Aug 2019 20:41:58 -0400</pubDate>
      
      <guid>http://nianze.tk/2019/08/2019-08-31-visual-project/</guid>
      <description>&lt;p&gt;Weekly visual project - 2019/08/31

&lt;!-- toc --&gt;&lt;/p&gt;

&lt;h1 id=&#34;the-elevator&#34;&gt;The elevator&lt;/h1&gt;

&lt;p&gt;

 
  
  
  
  
    
  
    
      
    
  

&lt;div class=&#34;figure fig-100&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2019/08/31/elevator1.JPG&#34; title=&#34;↑Elevator1&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2019/08/31/thumbnail/elevator1.JPG&#34;  alt=&#34;↑Elevator1&#34;&gt;
  
    &lt;/a&gt;
  
   
    &lt;span class=&#34;caption&#34;&gt;↑Elevator1&lt;/span&gt;
  
&lt;/div&gt;



 
  
  
  
  
    
  
    
      
    
  

&lt;div class=&#34;figure fig-100&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2019/08/31/elevator2.JPG&#34; title=&#34;↑Elevator2&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2019/08/31/thumbnail/elevator2.JPG&#34;  alt=&#34;↑Elevator2&#34;&gt;
  
    &lt;/a&gt;
  
   
    &lt;span class=&#34;caption&#34;&gt;↑Elevator2&lt;/span&gt;
  
&lt;/div&gt;
&lt;/p&gt;

&lt;h1 id=&#34;the-kid&#34;&gt;The kid&lt;/h1&gt;

&lt;p&gt;

 
  
  
  
  
    
  
    
      
    
  

&lt;div class=&#34;figure fig-100&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2019/08/31/stare.JPG&#34; title=&#34;↑Stare&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2019/08/31/thumbnail/stare.JPG&#34;  alt=&#34;↑Stare&#34;&gt;
  
    &lt;/a&gt;
  
   
    &lt;span class=&#34;caption&#34;&gt;↑Stare&lt;/span&gt;
  
&lt;/div&gt;



 
  
  
  
  
    
  
    
      
    
  

&lt;div class=&#34;figure fig-100&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2019/08/31/memory.JPG&#34; title=&#34;↑Memory&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2019/08/31/thumbnail/memory.JPG&#34;  alt=&#34;↑Memory&#34;&gt;
  
    &lt;/a&gt;
  
   
    &lt;span class=&#34;caption&#34;&gt;↑Memory&lt;/span&gt;
  
&lt;/div&gt;
&lt;/p&gt;

&lt;h1 id=&#34;the-emotion&#34;&gt;The emotion&lt;/h1&gt;

&lt;p&gt;

 
  
  
  
  
    
  
    
      
    
  

&lt;div class=&#34;figure fig-100&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2019/08/31/happy.JPG&#34; title=&#34;↑Happy&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2019/08/31/thumbnail/happy.JPG&#34;  alt=&#34;↑Happy&#34;&gt;
  
    &lt;/a&gt;
  
   
    &lt;span class=&#34;caption&#34;&gt;↑Happy&lt;/span&gt;
  
&lt;/div&gt;



 
  
  
  
  
    
  
    
      
    
  

&lt;div class=&#34;figure fig-100&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2019/08/31/point.JPG&#34; title=&#34;↑Angry&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2019/08/31/thumbnail/point.JPG&#34;  alt=&#34;↑Angry&#34;&gt;
  
    &lt;/a&gt;
  
   
    &lt;span class=&#34;caption&#34;&gt;↑Angry&lt;/span&gt;
  
&lt;/div&gt;
&lt;/p&gt;

&lt;h1 id=&#34;the-street&#34;&gt;The street&lt;/h1&gt;

&lt;p&gt;

 
  
  
  
  
    
  
    
      
    
  

&lt;div class=&#34;figure fig-100&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2019/08/31/door.JPG&#34; title=&#34;↑Front Door&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2019/08/31/thumbnail/door.JPG&#34;  alt=&#34;↑Front Door&#34;&gt;
  
    &lt;/a&gt;
  
   
    &lt;span class=&#34;caption&#34;&gt;↑Front Door&lt;/span&gt;
  
&lt;/div&gt;



 
  
  
  
  
    
  
    
      
    
  

&lt;div class=&#34;figure fig-100&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2019/08/31/church.JPG&#34; title=&#34;↑Church&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2019/08/31/thumbnail/church.JPG&#34;  alt=&#34;↑Church&#34;&gt;
  
    &lt;/a&gt;
  
   
    &lt;span class=&#34;caption&#34;&gt;↑Church&lt;/span&gt;
  
&lt;/div&gt;
&lt;/p&gt;

&lt;h1 id=&#34;the-excerpt&#34;&gt;The excerpt&lt;/h1&gt;

&lt;blockquote&gt;
&lt;p&gt;人生多少事，只能“虽不能至，心向往之”。人的幸福，其实就到心向往之的地步。整个音乐就是心向往之的境界，是拿不到的东西。&lt;br /&gt;
Excerpt From: 木心. “文学回忆录.”&lt;/p&gt;
&lt;/blockquote&gt;</description>
    </item>
    
    <item>
      <title>[Weekly-17] 2019.08.25</title>
      <link>http://nianze.tk/2019/08/2019-08-25-visual-project/</link>
      <pubDate>Sun, 25 Aug 2019 00:00:00 +0000</pubDate>
      
      <guid>http://nianze.tk/2019/08/2019-08-25-visual-project/</guid>
      <description>&lt;p&gt;Weekly visual project - 2019/08/25

&lt;!-- toc --&gt;&lt;/p&gt;

&lt;h1 id=&#34;the-street&#34;&gt;The street&lt;/h1&gt;

&lt;p&gt;

 
  
  
  
  
    
  
    
      
    
  

&lt;div class=&#34;figure fig-100&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2019/08/25/ask.JPG&#34; title=&#34;↑Ask&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2019/08/25/thumbnail/ask.JPG&#34;  alt=&#34;↑Ask&#34;&gt;
  
    &lt;/a&gt;
  
   
    &lt;span class=&#34;caption&#34;&gt;↑Ask&lt;/span&gt;
  
&lt;/div&gt;



 
  
  
  
  
    
  
    
      
    
  

&lt;div class=&#34;figure fig-50&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2019/08/25/gadgets.JPG&#34; title=&#34;↑Gadgets&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2019/08/25/thumbnail/gadgets.JPG&#34;  alt=&#34;↑Gadgets&#34;&gt;
  
    &lt;/a&gt;
  
   
    &lt;span class=&#34;caption&#34;&gt;↑Gadgets&lt;/span&gt;
  
&lt;/div&gt;



 
  
  
  
  
    
  
    
      
    
  

&lt;div class=&#34;figure fig-50&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2019/08/25/memory.JPG&#34; title=&#34;↑Memory&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2019/08/25/thumbnail/memory.JPG&#34;  alt=&#34;↑Memory&#34;&gt;
  
    &lt;/a&gt;
  
   
    &lt;span class=&#34;caption&#34;&gt;↑Memory&lt;/span&gt;
  
&lt;/div&gt;



 
  
  
  
  
    
  
    
      
    
  

&lt;div class=&#34;figure fig-50&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2019/08/25/cans.JPG&#34; title=&#34;↑Cans&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2019/08/25/thumbnail/cans.JPG&#34;  alt=&#34;↑Cans&#34;&gt;
  
    &lt;/a&gt;
  
   
    &lt;span class=&#34;caption&#34;&gt;↑Cans&lt;/span&gt;
  
&lt;/div&gt;



 
  
  
  
  
    
  
    
      
    
  

&lt;div class=&#34;figure fig-50&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2019/08/25/rain.JPG&#34; title=&#34;↑Rain&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2019/08/25/thumbnail/rain.JPG&#34;  alt=&#34;↑Rain&#34;&gt;
  
    &lt;/a&gt;
  
   
    &lt;span class=&#34;caption&#34;&gt;↑Rain&lt;/span&gt;
  
&lt;/div&gt;



 
  
  
  
  
    
  
    
      
    
  

&lt;div class=&#34;figure fig-100&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2019/08/25/reflection.JPG&#34; title=&#34;↑Reflection&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2019/08/25/thumbnail/reflection.JPG&#34;  alt=&#34;↑Reflection&#34;&gt;
  
    &lt;/a&gt;
  
   
    &lt;span class=&#34;caption&#34;&gt;↑Reflection&lt;/span&gt;
  
&lt;/div&gt;



 
  
  
  
  
    
  
    
      
    
  

&lt;div class=&#34;figure fig-100&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2019/08/25/think.JPG&#34; title=&#34;↑Think&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2019/08/25/thumbnail/think.JPG&#34;  alt=&#34;↑Think&#34;&gt;
  
    &lt;/a&gt;
  
   
    &lt;span class=&#34;caption&#34;&gt;↑Think&lt;/span&gt;
  
&lt;/div&gt;
&lt;/p&gt;

&lt;h1 id=&#34;the-excerpt&#34;&gt;The excerpt&lt;/h1&gt;

&lt;blockquote&gt;
&lt;p&gt;希望大家——规模大一点小一点，速度快一点慢一点，都无妨——超越自己。三年前的你，是你现在的学生，你可以教训那个从前的自己。&lt;br /&gt;
停课两个月，小别两个月，临别赠言——超越自己。&lt;br /&gt;
Excerpt From: 木心. “文学回忆录.”&lt;/p&gt;
&lt;/blockquote&gt;</description>
    </item>
    
    <item>
      <title>[Weekly-16] 2019.08.18</title>
      <link>http://nianze.tk/2019/08/2019-08-18-visual-project/</link>
      <pubDate>Sun, 18 Aug 2019 20:20:21 -0400</pubDate>
      
      <guid>http://nianze.tk/2019/08/2019-08-18-visual-project/</guid>
      <description>&lt;p&gt;Weekly visual project - 2019/08/18

&lt;!-- toc --&gt;&lt;/p&gt;

&lt;h1 id=&#34;the-street&#34;&gt;The street&lt;/h1&gt;

&lt;p&gt;

 
  
  
  
  
    
  
    
      
    
  

&lt;div class=&#34;figure fig-100&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2019/08/18/bikes.JPG&#34; title=&#34;↑Bikes&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2019/08/18/thumbnail/bikes.JPG&#34;  alt=&#34;↑Bikes&#34;&gt;
  
    &lt;/a&gt;
  
   
    &lt;span class=&#34;caption&#34;&gt;↑Bikes&lt;/span&gt;
  
&lt;/div&gt;



 
  
  
  
  
    
  
    
      
    
  

&lt;div class=&#34;figure fig-50&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2019/08/18/cube1.JPG&#34; title=&#34;↑Cube1&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2019/08/18/thumbnail/cube1.JPG&#34;  alt=&#34;↑Cube1&#34;&gt;
  
    &lt;/a&gt;
  
   
    &lt;span class=&#34;caption&#34;&gt;↑Cube1&lt;/span&gt;
  
&lt;/div&gt;



 
  
  
  
  
    
  
    
      
    
  

&lt;div class=&#34;figure fig-50&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2019/08/18/cube2.JPG&#34; title=&#34;↑Cube2&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2019/08/18/thumbnail/cube2.JPG&#34;  alt=&#34;↑Cube2&#34;&gt;
  
    &lt;/a&gt;
  
   
    &lt;span class=&#34;caption&#34;&gt;↑Cube2&lt;/span&gt;
  
&lt;/div&gt;



 
  
  
  
  
    
  
    
      
    
  

&lt;div class=&#34;figure fig-50&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2019/08/18/ice_cream2.JPG&#34; title=&#34;↑Sundaes&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2019/08/18/thumbnail/ice_cream2.JPG&#34;  alt=&#34;↑Sundaes&#34;&gt;
  
    &lt;/a&gt;
  
   
    &lt;span class=&#34;caption&#34;&gt;↑Sundaes&lt;/span&gt;
  
&lt;/div&gt;



 
  
  
  
  
    
  
    
      
    
  

&lt;div class=&#34;figure fig-50&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2019/08/18/ice_cream1.JPG&#34; title=&#34;↑Cones&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2019/08/18/thumbnail/ice_cream1.JPG&#34;  alt=&#34;↑Cones&#34;&gt;
  
    &lt;/a&gt;
  
   
    &lt;span class=&#34;caption&#34;&gt;↑Cones&lt;/span&gt;
  
&lt;/div&gt;



 
  
  
  
  
    
  
    
      
    
  

&lt;div class=&#34;figure fig-100&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2019/08/18/windows.JPG&#34; title=&#34;↑Windows&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2019/08/18/thumbnail/windows.JPG&#34;  alt=&#34;↑Windows&#34;&gt;
  
    &lt;/a&gt;
  
   
    &lt;span class=&#34;caption&#34;&gt;↑Windows&lt;/span&gt;
  
&lt;/div&gt;
&lt;/p&gt;

&lt;h1 id=&#34;the-excerpt&#34;&gt;The excerpt&lt;/h1&gt;

&lt;blockquote&gt;
&lt;p&gt;同样写饮酒，东方是借酒而忘忧、消愁，西方的酒神却是创造极乐、狂欢。&lt;br /&gt;
所以，东方没有狂欢节。魏晋和唐代那么多诗人、文士颂赞酒，没有一个人正面提出酒神精神。东方人写饮酒，说来说去还是在生活层次中盘旋。当然，现在看，悲剧精神并不能救西方人。东方呢，悲观主义早就没有。现代中国人不懂得悲观。&lt;br /&gt;
说到底，悲观是一种远见。鼠目寸光的人，不可能悲观。&lt;br /&gt;
所谓怀疑，悲观是个开场。然后是什么呢？西方没有完成。尼采刚刚开始叫起来：“一切重新估价。”但也才刚刚叫起来。&lt;br /&gt;
悲剧，简单地讲，是人与命运的抗争。&lt;br /&gt;
鲁迅说：“悲剧，是把有价值的东西毁灭给你看！”说对一部分。&lt;br /&gt;
...&lt;br /&gt;
马克思说人类有阶级和阶级斗争。我认为人类只有知与无知的斗争。一切智慧都是从悲从疑而来。我不知道此外还有何种来源可以产生智慧。&lt;br /&gt;
Excerpt From: 木心. “文学回忆录.”&lt;/p&gt;
&lt;/blockquote&gt;</description>
    </item>
    
    <item>
      <title>[Weekly-15] 2019.08.11</title>
      <link>http://nianze.tk/2019/08/2019-08-11-visual-project/</link>
      <pubDate>Sun, 11 Aug 2019 11:00:07 -0400</pubDate>
      
      <guid>http://nianze.tk/2019/08/2019-08-11-visual-project/</guid>
      <description>&lt;p&gt;Weekly visual project - 2019/08/11

&lt;!-- toc --&gt;&lt;/p&gt;

&lt;h1 id=&#34;the-street&#34;&gt;The street&lt;/h1&gt;

&lt;p&gt;

 
  
  
  
  
    
  
    
      
    
  

&lt;div class=&#34;figure fig-100&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2019/08/11/cat.JPG&#34; title=&#34;↑Cat&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2019/08/11/thumbnail/cat.JPG&#34;  alt=&#34;↑Cat&#34;&gt;
  
    &lt;/a&gt;
  
   
    &lt;span class=&#34;caption&#34;&gt;↑Cat&lt;/span&gt;
  
&lt;/div&gt;



 
  
  
  
  
    
  
    
      
    
  

&lt;div class=&#34;figure fig-50&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2019/08/11/google_map.JPG&#34; title=&#34;↑Google Map&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2019/08/11/thumbnail/google_map.JPG&#34;  alt=&#34;↑Google Map&#34;&gt;
  
    &lt;/a&gt;
  
   
    &lt;span class=&#34;caption&#34;&gt;↑Google Map&lt;/span&gt;
  
&lt;/div&gt;



 
  
  
  
  
    
  
    
      
    
  

&lt;div class=&#34;figure fig-50&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2019/08/11/dream.JPG&#34; title=&#34;↑Dream&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2019/08/11/thumbnail/dream.JPG&#34;  alt=&#34;↑Dream&#34;&gt;
  
    &lt;/a&gt;
  
   
    &lt;span class=&#34;caption&#34;&gt;↑Dream&lt;/span&gt;
  
&lt;/div&gt;



 
  
  
  
  
    
  
    
      
    
  

&lt;div class=&#34;figure fig-50&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2019/08/11/biker.JPG&#34; title=&#34;↑Biker&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2019/08/11/thumbnail/biker.JPG&#34;  alt=&#34;↑Biker&#34;&gt;
  
    &lt;/a&gt;
  
   
    &lt;span class=&#34;caption&#34;&gt;↑Biker&lt;/span&gt;
  
&lt;/div&gt;



 
  
  
  
  
    
  
    
      
    
  

&lt;div class=&#34;figure fig-50&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2019/08/11/float.JPG&#34; title=&#34;↑Float&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2019/08/11/thumbnail/float.JPG&#34;  alt=&#34;↑Float&#34;&gt;
  
    &lt;/a&gt;
  
   
    &lt;span class=&#34;caption&#34;&gt;↑Float&lt;/span&gt;
  
&lt;/div&gt;


 
  
  
  
  
    
  
    
      
    
  


&lt;div class=&#34;figure fig-50&#34; &gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;&#34; &gt;
  
  
&lt;/div&gt;

  &lt;div style=&#34;clear:both;&#34;&gt;&lt;/div&gt;



 
  
  
  
  
    
  
    
      
    
  

&lt;div class=&#34;figure fig-100&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2019/08/11/tasty.JPG&#34; title=&#34;↑Tasty&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2019/08/11/thumbnail/tasty.JPG&#34;  alt=&#34;↑Tasty&#34;&gt;
  
    &lt;/a&gt;
  
   
    &lt;span class=&#34;caption&#34;&gt;↑Tasty&lt;/span&gt;
  
&lt;/div&gt;
&lt;/p&gt;

&lt;h1 id=&#34;the-balcony&#34;&gt;The balcony&lt;/h1&gt;

&lt;p&gt;

 
  
  
  
  
    
  
    
      
    
  

&lt;div class=&#34;figure fig-100&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2019/08/11/light.JPG&#34; title=&#34;↑Light&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2019/08/11/thumbnail/light.JPG&#34;  alt=&#34;↑Light&#34;&gt;
  
    &lt;/a&gt;
  
   
    &lt;span class=&#34;caption&#34;&gt;↑Light&lt;/span&gt;
  
&lt;/div&gt;



 
  
  
  
  
    
  
    
      
    
  

&lt;div class=&#34;figure fig-100&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2019/08/11/sunshine.JPG&#34; title=&#34;↑Sunshine&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2019/08/11/thumbnail/sunshine.JPG&#34;  alt=&#34;↑Sunshine&#34;&gt;
  
    &lt;/a&gt;
  
   
    &lt;span class=&#34;caption&#34;&gt;↑Sunshine&lt;/span&gt;
  
&lt;/div&gt;
&lt;/p&gt;

&lt;h1 id=&#34;the-black-and-white&#34;&gt;The black and white&lt;/h1&gt;

&lt;p&gt;

 
  
  
  
  
    
  
    
      
    
  

&lt;div class=&#34;figure fig-100&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2019/08/11/fishing.JPG&#34; title=&#34;↑Fishing&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2019/08/11/thumbnail/fishing.JPG&#34;  alt=&#34;↑Fishing&#34;&gt;
  
    &lt;/a&gt;
  
   
    &lt;span class=&#34;caption&#34;&gt;↑Fishing&lt;/span&gt;
  
&lt;/div&gt;



 
  
  
  
  
    
  
    
      
    
  

&lt;div class=&#34;figure fig-50&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2019/08/11/pull.JPG&#34; title=&#34;↑Pull&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2019/08/11/thumbnail/pull.JPG&#34;  alt=&#34;↑Pull&#34;&gt;
  
    &lt;/a&gt;
  
   
    &lt;span class=&#34;caption&#34;&gt;↑Pull&lt;/span&gt;
  
&lt;/div&gt;



 
  
  
  
  
    
  
    
      
    
  

&lt;div class=&#34;figure fig-50&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2019/08/11/confused.JPG&#34; title=&#34;↑Confused&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2019/08/11/thumbnail/confused.JPG&#34;  alt=&#34;↑Confused&#34;&gt;
  
    &lt;/a&gt;
  
   
    &lt;span class=&#34;caption&#34;&gt;↑Confused&lt;/span&gt;
  
&lt;/div&gt;



 
  
  
  
  
    
  
    
      
    
  

&lt;div class=&#34;figure fig-100&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2019/08/11/headup.JPG&#34; title=&#34;↑Head up&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2019/08/11/thumbnail/headup.JPG&#34;  alt=&#34;↑Head up&#34;&gt;
  
    &lt;/a&gt;
  
   
    &lt;span class=&#34;caption&#34;&gt;↑Head up&lt;/span&gt;
  
&lt;/div&gt;
&lt;/p&gt;

&lt;h1 id=&#34;the-excerpt&#34;&gt;The excerpt&lt;/h1&gt;

&lt;blockquote&gt;
&lt;p&gt;人类的伟大高贵，完全在于精神生活，在于少数的精神贵族，亦即天才和天才的朋友（欣赏者）。&lt;br /&gt;
Excerpt From: 木心. “文学回忆录.”&lt;/p&gt;
&lt;/blockquote&gt;</description>
    </item>
    
    <item>
      <title>[Weekly-14] 2019.08.04</title>
      <link>http://nianze.tk/2019/08/2019-08-04-visual-project/</link>
      <pubDate>Sun, 04 Aug 2019 15:16:45 -0400</pubDate>
      
      <guid>http://nianze.tk/2019/08/2019-08-04-visual-project/</guid>
      <description>&lt;p&gt;Weekly visual project - 2019/08/04

&lt;!-- toc --&gt;&lt;/p&gt;

&lt;h1 id=&#34;the-subway&#34;&gt;The subway&lt;/h1&gt;

&lt;p&gt;

 
  
  
  
  
    
  
    
      
    
  

&lt;div class=&#34;figure fig-100&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2019/08/04/subway_station.JPG&#34; title=&#34;↑Subway Station&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2019/08/04/thumbnail/subway_station.JPG&#34;  alt=&#34;↑Subway Station&#34;&gt;
  
    &lt;/a&gt;
  
   
    &lt;span class=&#34;caption&#34;&gt;↑Subway Station&lt;/span&gt;
  
&lt;/div&gt;



 
  
  
  
  
    
  
    
      
    
  

&lt;div class=&#34;figure fig-100&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2019/08/04/thumbnail/stare.JPG&#34; title=&#34;↑Stare&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2019/08/04/thumbnail/stare.JPG&#34;  alt=&#34;↑Stare&#34;&gt;
  
    &lt;/a&gt;
  
   
    &lt;span class=&#34;caption&#34;&gt;↑Stare&lt;/span&gt;
  
&lt;/div&gt;
&lt;/p&gt;

&lt;h1 id=&#34;the-street&#34;&gt;The street&lt;/h1&gt;

&lt;p&gt;

 
  
  
  
  
    
  
    
      
    
  

&lt;div class=&#34;figure fig-50&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2019/08/04/hold_hands.JPG&#34; title=&#34;↑Hold hands&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2019/08/04/thumbnail/hold_hands.JPG&#34;  alt=&#34;↑Hold hands&#34;&gt;
  
    &lt;/a&gt;
  
   
    &lt;span class=&#34;caption&#34;&gt;↑Hold hands&lt;/span&gt;
  
&lt;/div&gt;



 
  
  
  
  
    
  
    
      
    
  

&lt;div class=&#34;figure fig-50&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2019/08/04/shakes.sundaes.JPG&#34; title=&#34;↑Shakes Sundaes&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2019/08/04/thumbnail/shakes.sundaes.JPG&#34;  alt=&#34;↑Shakes Sundaes&#34;&gt;
  
    &lt;/a&gt;
  
   
    &lt;span class=&#34;caption&#34;&gt;↑Shakes Sundaes&lt;/span&gt;
  
&lt;/div&gt;



 
  
  
  
  
    
  
    
      
    
  

&lt;div class=&#34;figure fig-50&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2019/08/04/runner.JPG&#34; title=&#34;↑Runner&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2019/08/04/thumbnail/runner.JPG&#34;  alt=&#34;↑Runner&#34;&gt;
  
    &lt;/a&gt;
  
   
    &lt;span class=&#34;caption&#34;&gt;↑Runner&lt;/span&gt;
  
&lt;/div&gt;



 
  
  
  
  
    
  
    
      
    
  

&lt;div class=&#34;figure fig-50&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2019/08/04/citi_bike.JPG&#34; title=&#34;↑Citi bikes&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2019/08/04/thumbnail/citi_bike.JPG&#34;  alt=&#34;↑Citi bikes&#34;&gt;
  
    &lt;/a&gt;
  
   
    &lt;span class=&#34;caption&#34;&gt;↑Citi bikes&lt;/span&gt;
  
&lt;/div&gt;



 
  
  
  
  
    
  
    
      
    
  

&lt;div class=&#34;figure fig-100&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2019/08/04/shadows.JPG&#34; title=&#34;↑Shadows&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2019/08/04/thumbnail/shadows.JPG&#34;  alt=&#34;↑Shadows&#34;&gt;
  
    &lt;/a&gt;
  
   
    &lt;span class=&#34;caption&#34;&gt;↑Shadows&lt;/span&gt;
  
&lt;/div&gt;
&lt;/p&gt;

&lt;h1 id=&#34;the-reflection&#34;&gt;The reflection&lt;/h1&gt;

&lt;p&gt;

 
  
  
  
  
    
  
    
      
    
  

&lt;div class=&#34;figure fig-100&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2019/08/04/reflection2.JPG&#34; title=&#34;↑Reflection&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2019/08/04/thumbnail/reflection2.JPG&#34;  alt=&#34;↑Reflection&#34;&gt;
  
    &lt;/a&gt;
  
   
    &lt;span class=&#34;caption&#34;&gt;↑Reflection&lt;/span&gt;
  
&lt;/div&gt;



 
  
  
  
  
    
  
    
      
    
  

&lt;div class=&#34;figure fig-100&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2019/08/04/reflection.JPG&#34; title=&#34;↑Reflection&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2019/08/04/thumbnail/reflection.JPG&#34;  alt=&#34;↑Reflection&#34;&gt;
  
    &lt;/a&gt;
  
   
    &lt;span class=&#34;caption&#34;&gt;↑Reflection&lt;/span&gt;
  
&lt;/div&gt;
&lt;/p&gt;

&lt;h1 id=&#34;the-excerpt&#34;&gt;The excerpt&lt;/h1&gt;

&lt;blockquote&gt;
&lt;p&gt;但古代虽然专制，诗人还可以悲哀。我遇到的时代，谁悲哀，谁就是反革命。所以热爱生活啊、健康积极向上啊，饱含恶念，是阴谋，是骗局，是透明的监狱，是愚民的毒药。我一步步看出这种虚伪，用心之刻毒，远远超出古代。对照起来，要在汉末、魏晋、南北朝，做个艺术家、做个诗人，并不很难，在我青壮年时代，你要活得像个人，太不容易了。所以我同情阮籍，阮籍更应该同情我哩。&lt;br /&gt;
Excerpt From: 木心. “文学回忆录.”&lt;/p&gt;
&lt;/blockquote&gt;</description>
    </item>
    
    <item>
      <title>[Weekly-13] 2019.07.28</title>
      <link>http://nianze.tk/2019/07/2019-07-28-visual-project/</link>
      <pubDate>Sun, 28 Jul 2019 18:22:05 -0400</pubDate>
      
      <guid>http://nianze.tk/2019/07/2019-07-28-visual-project/</guid>
      <description>&lt;p&gt;Weekly visual project - 2019/07/28

&lt;!-- toc --&gt;&lt;/p&gt;

&lt;h1 id=&#34;the-children&#34;&gt;The children&lt;/h1&gt;

&lt;p&gt;

 
  
  
  
  
    
  
    
      
    
  

&lt;div class=&#34;figure fig-100&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2019/07/28/atm_sit.JPG&#34; title=&#34;↑Boys&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2019/07/28/thumbnail/atm_sit.JPG&#34;  alt=&#34;↑Boys&#34;&gt;
  
    &lt;/a&gt;
  
   
    &lt;span class=&#34;caption&#34;&gt;↑Boys&lt;/span&gt;
  
&lt;/div&gt;



 
  
  
  
  
    
  
    
      
    
  

&lt;div class=&#34;figure fig-100&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2019/07/28/atm.JPG&#34; title=&#34;↑Atm&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2019/07/28/thumbnail/atm.JPG&#34;  alt=&#34;↑Atm&#34;&gt;
  
    &lt;/a&gt;
  
   
    &lt;span class=&#34;caption&#34;&gt;↑Atm&lt;/span&gt;
  
&lt;/div&gt;
&lt;/p&gt;

&lt;p&gt;

 
  
  
  
  
    
  
    
      
    
  

&lt;div class=&#34;figure fig-33&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2019/07/28/girl&amp;amp;boy1.JPG&#34; title=&#34;↑Girl &amp;amp; Boy 1&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2019/07/28/thumbnail/girl&amp;amp;boy1.JPG&#34;  alt=&#34;↑Girl &amp;amp; Boy 1&#34;&gt;
  
    &lt;/a&gt;
  
   
    &lt;span class=&#34;caption&#34;&gt;↑Girl &amp;amp; Boy 1&lt;/span&gt;
  
&lt;/div&gt;



 
  
  
  
  
    
  
    
      
    
  

&lt;div class=&#34;figure fig-33&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2019/07/28/girl&amp;amp;boy1.JPG&#34; title=&#34;↑Girl &amp;amp; Boy 2&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2019/07/28/thumbnail/girl&amp;amp;boy1.JPG&#34;  alt=&#34;↑Girl &amp;amp; Boy 2&#34;&gt;
  
    &lt;/a&gt;
  
   
    &lt;span class=&#34;caption&#34;&gt;↑Girl &amp;amp; Boy 2&lt;/span&gt;
  
&lt;/div&gt;



 
  
  
  
  
    
  
    
      
    
  

&lt;div class=&#34;figure fig-33&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2019/07/28/girl&amp;amp;boy3.JPG&#34; title=&#34;↑Girl &amp;amp; Boy 3&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2019/07/28/thumbnail/girl&amp;amp;boy3.JPG&#34;  alt=&#34;↑Girl &amp;amp; Boy 3&#34;&gt;
  
    &lt;/a&gt;
  
   
    &lt;span class=&#34;caption&#34;&gt;↑Girl &amp;amp; Boy 3&lt;/span&gt;
  
&lt;/div&gt;



 
  
  
  
  
    
  
    
      
    
  

&lt;div class=&#34;figure fig-33&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2019/07/28/girl&amp;amp;boy4.JPG&#34; title=&#34;↑Girl &amp;amp; Boy 4&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2019/07/28/thumbnail/girl&amp;amp;boy4.JPG&#34;  alt=&#34;↑Girl &amp;amp; Boy 4&#34;&gt;
  
    &lt;/a&gt;
  
   
    &lt;span class=&#34;caption&#34;&gt;↑Girl &amp;amp; Boy 4&lt;/span&gt;
  
&lt;/div&gt;



 
  
  
  
  
    
  
    
      
    
  

&lt;div class=&#34;figure fig-33&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2019/07/28/girl&amp;amp;boy5.JPG&#34; title=&#34;↑Girl &amp;amp; Boy 5&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2019/07/28/thumbnail/girl&amp;amp;boy5.JPG&#34;  alt=&#34;↑Girl &amp;amp; Boy 5&#34;&gt;
  
    &lt;/a&gt;
  
   
    &lt;span class=&#34;caption&#34;&gt;↑Girl &amp;amp; Boy 5&lt;/span&gt;
  
&lt;/div&gt;



 
  
  
  
  
    
  
    
      
    
  

&lt;div class=&#34;figure fig-33&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2019/07/28/girl&amp;amp;boy6.JPG&#34; title=&#34;↑Girl &amp;amp; Boy 6&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2019/07/28/thumbnail/girl&amp;amp;boy6.JPG&#34;  alt=&#34;↑Girl &amp;amp; Boy 6&#34;&gt;
  
    &lt;/a&gt;
  
   
    &lt;span class=&#34;caption&#34;&gt;↑Girl &amp;amp; Boy 6&lt;/span&gt;
  
&lt;/div&gt;
&lt;/p&gt;

&lt;h1 id=&#34;the-people&#34;&gt;The people&lt;/h1&gt;

&lt;p&gt;

 
  
  
  
  
    
  
    
      
    
  

&lt;div class=&#34;figure fig-50&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2019/07/28/sit.JPG&#34; title=&#34;↑Sit&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2019/07/28/thumbnail/sit.JPG&#34;  alt=&#34;↑Sit&#34;&gt;
  
    &lt;/a&gt;
  
   
    &lt;span class=&#34;caption&#34;&gt;↑Sit&lt;/span&gt;
  
&lt;/div&gt;



 
  
  
  
  
    
  
    
      
    
  

&lt;div class=&#34;figure fig-50&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2019/07/28/memory.JPG&#34; title=&#34;↑Memory&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2019/07/28/thumbnail/memory.JPG&#34;  alt=&#34;↑Memory&#34;&gt;
  
    &lt;/a&gt;
  
   
    &lt;span class=&#34;caption&#34;&gt;↑Memory&lt;/span&gt;
  
&lt;/div&gt;



 
  
  
  
  
    
  
    
      
    
  

&lt;div class=&#34;figure fig-50&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2019/07/28/sits.JPG&#34; title=&#34;↑Sits&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2019/07/28/thumbnail/sits.JPG&#34;  alt=&#34;↑Sits&#34;&gt;
  
    &lt;/a&gt;
  
   
    &lt;span class=&#34;caption&#34;&gt;↑Sits&lt;/span&gt;
  
&lt;/div&gt;



 
  
  
  
  
    
  
    
      
    
  

&lt;div class=&#34;figure fig-50&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2019/07/28/back2back.JPG&#34; title=&#34;↑Back to back&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2019/07/28/thumbnail/back2back.JPG&#34;  alt=&#34;↑Back to back&#34;&gt;
  
    &lt;/a&gt;
  
   
    &lt;span class=&#34;caption&#34;&gt;↑Back to back&lt;/span&gt;
  
&lt;/div&gt;



 
  
  
  
  
    
  
    
      
    
  

&lt;div class=&#34;figure fig-100&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2019/07/28/family.JPG&#34; title=&#34;↑Family&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2019/07/28/thumbnail/family.JPG&#34;  alt=&#34;↑Family&#34;&gt;
  
    &lt;/a&gt;
  
   
    &lt;span class=&#34;caption&#34;&gt;↑Family&lt;/span&gt;
  
&lt;/div&gt;



 
  
  
  
  
    
  
    
      
    
  

&lt;div class=&#34;figure fig-50&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2019/07/28/rain.JPG&#34; title=&#34;↑Rain&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2019/07/28/thumbnail/rain.JPG&#34;  alt=&#34;↑Rain&#34;&gt;
  
    &lt;/a&gt;
  
   
    &lt;span class=&#34;caption&#34;&gt;↑Rain&lt;/span&gt;
  
&lt;/div&gt;



 
  
  
  
  
    
  
    
      
    
  

&lt;div class=&#34;figure fig-50&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2019/07/28/subway.JPG&#34; title=&#34;↑Subway&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2019/07/28/thumbnail/subway.JPG&#34;  alt=&#34;↑Subway&#34;&gt;
  
    &lt;/a&gt;
  
   
    &lt;span class=&#34;caption&#34;&gt;↑Subway&lt;/span&gt;
  
&lt;/div&gt;
&lt;/p&gt;

&lt;h1 id=&#34;the-post&#34;&gt;The post&lt;/h1&gt;

&lt;p&gt;

 
  
  
  
  
    
  
    
      
    
  

&lt;div class=&#34;figure fig-100&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2019/07/28/moustache.JPG&#34; title=&#34;↑Moustache&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2019/07/28/thumbnail/moustache.JPG&#34;  alt=&#34;↑Moustache&#34;&gt;
  
    &lt;/a&gt;
  
   
    &lt;span class=&#34;caption&#34;&gt;↑Moustache&lt;/span&gt;
  
&lt;/div&gt;



 
  
  
  
  
    
  
    
      
    
  

&lt;div class=&#34;figure fig-100&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2019/07/28/teeth.JPG&#34; title=&#34;↑Teeth&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2019/07/28/thumbnail/teeth.JPG&#34;  alt=&#34;↑Teeth&#34;&gt;
  
    &lt;/a&gt;
  
   
    &lt;span class=&#34;caption&#34;&gt;↑Teeth&lt;/span&gt;
  
&lt;/div&gt;
&lt;/p&gt;

&lt;h1 id=&#34;the-street&#34;&gt;The street&lt;/h1&gt;

&lt;p&gt;

 
  
  
  
  
    
  
    
      
    
  

&lt;div class=&#34;figure fig-100&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2019/07/28/balloons.JPG&#34; title=&#34;↑Balloons&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2019/07/28/thumbnail/balloons.JPG&#34;  alt=&#34;↑Balloons&#34;&gt;
  
    &lt;/a&gt;
  
   
    &lt;span class=&#34;caption&#34;&gt;↑Balloons&lt;/span&gt;
  
&lt;/div&gt;



 
  
  
  
  
    
  
    
      
    
  

&lt;div class=&#34;figure fig-100&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2019/07/28/crosstown.JPG&#34; title=&#34;↑Crosstown&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2019/07/28/thumbnail/crosstown.JPG&#34;  alt=&#34;↑Crosstown&#34;&gt;
  
    &lt;/a&gt;
  
   
    &lt;span class=&#34;caption&#34;&gt;↑Crosstown&lt;/span&gt;
  
&lt;/div&gt;



 
  
  
  
  
    
  
    
      
    
  

&lt;div class=&#34;figure fig-100&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2019/07/28/facedown.JPG&#34; title=&#34;↑Plush toy&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2019/07/28/thumbnail/facedown.JPG&#34;  alt=&#34;↑Plush toy&#34;&gt;
  
    &lt;/a&gt;
  
   
    &lt;span class=&#34;caption&#34;&gt;↑Plush toy&lt;/span&gt;
  
&lt;/div&gt;



 
  
  
  
  
    
  
    
      
    
  

&lt;div class=&#34;figure fig-50&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2019/07/28/front_door.JPG&#34; title=&#34;↑Front door&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2019/07/28/thumbnail/front_door.JPG&#34;  alt=&#34;↑Front door&#34;&gt;
  
    &lt;/a&gt;
  
   
    &lt;span class=&#34;caption&#34;&gt;↑Front door&lt;/span&gt;
  
&lt;/div&gt;



 
  
  
  
  
    
  
    
      
    
  

&lt;div class=&#34;figure fig-50&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2019/07/28/doves.JPG&#34; title=&#34;Doves&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2019/07/28/thumbnail/doves.JPG&#34;  alt=&#34;Doves&#34;&gt;
  
    &lt;/a&gt;
  
   
    &lt;span class=&#34;caption&#34;&gt;Doves&lt;/span&gt;
  
&lt;/div&gt;


 
  
  
  
  
    
  
    
      
    
  


&lt;div class=&#34;figure fig-50&#34; &gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;&#34; &gt;
  
  
&lt;/div&gt;

  &lt;div style=&#34;clear:both;&#34;&gt;&lt;/div&gt;



 
  
  
  
  
    
  
    
      
    
  

&lt;div class=&#34;figure fig-50&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2019/07/28/phonecall.JPG&#34; title=&#34;↑Call&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2019/07/28/thumbnail/phonecall.JPG&#34;  alt=&#34;↑Call&#34;&gt;
  
    &lt;/a&gt;
  
   
    &lt;span class=&#34;caption&#34;&gt;↑Call&lt;/span&gt;
  
&lt;/div&gt;



 
  
  
  
  
    
  
    
      
    
  

&lt;div class=&#34;figure fig-50&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2019/07/28/walk.JPG&#34; title=&#34;↑Walk&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2019/07/28/thumbnail/walk.JPG&#34;  alt=&#34;↑Walk&#34;&gt;
  
    &lt;/a&gt;
  
   
    &lt;span class=&#34;caption&#34;&gt;↑Walk&lt;/span&gt;
  
&lt;/div&gt;



 
  
  
  
  
    
  
    
      
    
  

&lt;div class=&#34;figure fig-100&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2019/07/28/time_square.JPG&#34; title=&#34;↑Time Squre&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2019/07/28/thumbnail/time_square.JPG&#34;  alt=&#34;↑Time Squre&#34;&gt;
  
    &lt;/a&gt;
  
   
    &lt;span class=&#34;caption&#34;&gt;↑Time Squre&lt;/span&gt;
  
&lt;/div&gt;



 
  
  
  
  
    
  
    
      
    
  

&lt;div class=&#34;figure fig-100&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2019/07/28/light.JPG&#34; title=&#34;↑Light&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2019/07/28/thumbnail/light.JPG&#34;  alt=&#34;↑Light&#34;&gt;
  
    &lt;/a&gt;
  
   
    &lt;span class=&#34;caption&#34;&gt;↑Light&lt;/span&gt;
  
&lt;/div&gt;
&lt;/p&gt;

&lt;h1 id=&#34;the-building&#34;&gt;The building&lt;/h1&gt;

&lt;p&gt;

 
  
  
  
  
    
  
    
      
    
  

&lt;div class=&#34;figure fig-50&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2019/07/28/building_sky.JPG&#34; title=&#34;↑Sky&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2019/07/28/thumbnail/building_sky.JPG&#34;  alt=&#34;↑Sky&#34;&gt;
  
    &lt;/a&gt;
  
   
    &lt;span class=&#34;caption&#34;&gt;↑Sky&lt;/span&gt;
  
&lt;/div&gt;



 
  
  
  
  
    
  
    
      
    
  

&lt;div class=&#34;figure fig-50&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2019/07/28/building_skyscraper.JPG&#34; title=&#34;↑Skyscraper&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2019/07/28/thumbnail/building_skyscraper.JPG&#34;  alt=&#34;↑Skyscraper&#34;&gt;
  
    &lt;/a&gt;
  
   
    &lt;span class=&#34;caption&#34;&gt;↑Skyscraper&lt;/span&gt;
  
&lt;/div&gt;



 
  
  
  
  
    
  
    
      
    
  

&lt;div class=&#34;figure fig-50&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2019/07/28/building1.JPG&#34; title=&#34;↑Water tower1&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2019/07/28/thumbnail/building1.JPG&#34;  alt=&#34;↑Water tower1&#34;&gt;
  
    &lt;/a&gt;
  
   
    &lt;span class=&#34;caption&#34;&gt;↑Water tower1&lt;/span&gt;
  
&lt;/div&gt;



 
  
  
  
  
    
  
    
      
    
  

&lt;div class=&#34;figure fig-50&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2019/07/28/building2.JPG&#34; title=&#34;↑Water tower2&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2019/07/28/thumbnail/building2.JPG&#34;  alt=&#34;↑Water tower2&#34;&gt;
  
    &lt;/a&gt;
  
   
    &lt;span class=&#34;caption&#34;&gt;↑Water tower2&lt;/span&gt;
  
&lt;/div&gt;



 
  
  
  
  
    
  
    
      
    
  

&lt;div class=&#34;figure fig-50&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2019/07/28/building3.JPG&#34; title=&#34;↑Church&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2019/07/28/thumbnail/building3.JPG&#34;  alt=&#34;↑Church&#34;&gt;
  
    &lt;/a&gt;
  
   
    &lt;span class=&#34;caption&#34;&gt;↑Church&lt;/span&gt;
  
&lt;/div&gt;



 
  
  
  
  
    
  
    
      
    
  

&lt;div class=&#34;figure fig-50&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2019/07/28/gallery.JPG&#34; title=&#34;↑Gallery&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2019/07/28/thumbnail/gallery.JPG&#34;  alt=&#34;↑Gallery&#34;&gt;
  
    &lt;/a&gt;
  
   
    &lt;span class=&#34;caption&#34;&gt;↑Gallery&lt;/span&gt;
  
&lt;/div&gt;
&lt;/p&gt;

&lt;h2 id=&#34;碎言&#34;&gt;碎言&lt;/h2&gt;

&lt;p&gt;曼哈顿寸土寸金，我扫街的时候，每隔几个街区却总能发现一座教堂。高耸的哥特式尖塔，有如在钢筋混凝土的森林里点缀上香薰蜡烛,指引迷途的旅魂。摘一段木心先生的话：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;我要相信，或者，我要推翻的那个神，都不是曾经说过的那个神。我最心仪的是音乐、建筑、绘画所体现的宗教情操，那是一种圆融的刚执，一种崇高的温柔。以这样的情操治国、建邦、待人接物，太美好了。&lt;br /&gt;
人类既有这样美好的情操，不给自己，却奉给上帝，数千年没有回报，乃是最大的冤案。听听圣歌，看看伟拔教堂，可知人类多么伟大。人类的悲剧，是对自身的误解。&lt;br /&gt;
宗教是要把人类变成天上的神的家畜，人再也回不到原来野生的状态。家畜成为人类的牺牲品，人类成为自己的牺牲品。尼采说，人本来有这样多的情操，不应该交给上帝。&lt;br /&gt;
&amp;hellip;&lt;br /&gt;
佛教造大佛，用于视觉；击鼓敲木鱼，用于听觉；焚香，用于嗅觉；素食，用于味觉——人类这般伟大、聪明，为什么不用于人类自己，而去奉神？&lt;br /&gt;
希望大家重视宗教艺术，要把含在宗教里的艺术，含在艺术里的宗教，细细分开来。先明白基督教、佛教等是怎么回事，了解其人格高超，一等，然后再去接触宗教的建筑、服装、礼仪、绘画、雕刻，原来是这样体现人类最高精神、最高智慧，而这等宗教文化，又是如何经过兴衰存亡的过程。&lt;br /&gt;
这是很有味道的事。你到欧洲，扑面而来的都是艺术和宗教。&lt;br /&gt;
给父母、子弟、情人的，也不及人类把最好的情操送给上帝，送给宗教。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&#34;the-dog&#34;&gt;The dog&lt;/h1&gt;

&lt;p&gt;

 
  
  
  
  
    
  
    
      
    
  

&lt;div class=&#34;figure fig-100&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2019/07/28/ice_cream.JPG&#34; title=&#34;↑Ice cream&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2019/07/28/thumbnail/ice_cream.JPG&#34;  alt=&#34;↑Ice cream&#34;&gt;
  
    &lt;/a&gt;
  
   
    &lt;span class=&#34;caption&#34;&gt;↑Ice cream&lt;/span&gt;
  
&lt;/div&gt;



 
  
  
  
  
    
  
    
      
    
  

&lt;div class=&#34;figure fig-100&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2019/07/28/dog_in_car.JPG&#34; title=&#34;↑Dog in the car&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2019/07/28/thumbnail/dog_in_car.JPG&#34;  alt=&#34;↑Dog in the car&#34;&gt;
  
    &lt;/a&gt;
  
   
    &lt;span class=&#34;caption&#34;&gt;↑Dog in the car&lt;/span&gt;
  
&lt;/div&gt;
&lt;/p&gt;

&lt;h1 id=&#34;the-story&#34;&gt;The story&lt;/h1&gt;

&lt;p&gt;

 
  
  
  
  
    
  
    
      
    
  

&lt;div class=&#34;figure fig-50&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2019/07/28/story_photo.JPG&#34; title=&#34;↑Story photo&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2019/07/28/thumbnail/story_photo.JPG&#34;  alt=&#34;↑Story photo&#34;&gt;
  
    &lt;/a&gt;
  
   
    &lt;span class=&#34;caption&#34;&gt;↑Story photo&lt;/span&gt;
  
&lt;/div&gt;



 
  
  
  
  
    
  
    
      
    
  

&lt;div class=&#34;figure fig-50&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2019/07/28/story_words.JPG&#34; title=&#34;↑Story behind the photo&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2019/07/28/thumbnail/story_words.JPG&#34;  alt=&#34;↑Story behind the photo&#34;&gt;
  
    &lt;/a&gt;
  
   
    &lt;span class=&#34;caption&#34;&gt;↑Story behind the photo&lt;/span&gt;
  
&lt;/div&gt;


 
  
  
  
  
    
  
    
      
    
  


&lt;div class=&#34;figure fig-50&#34; &gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;&#34; &gt;
  
  
&lt;/div&gt;

  &lt;div style=&#34;clear:both;&#34;&gt;&lt;/div&gt;
&lt;/p&gt;

&lt;h1 id=&#34;the-selfie&#34;&gt;The selfie&lt;/h1&gt;

&lt;p&gt;

 
  
  
  
  
    
  
    
      
    
  

&lt;div class=&#34;figure fig-100&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2019/07/28/reflection.JPG&#34; title=&#34;↑reflection&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2019/07/28/reflection.JPG&#34;  alt=&#34;↑reflection&#34;&gt;
  
    &lt;/a&gt;
  
   
    &lt;span class=&#34;caption&#34;&gt;↑reflection&lt;/span&gt;
  
&lt;/div&gt;



 
  
  
  
  
    
  
    
      
    
  

&lt;div class=&#34;figure fig-100&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2019/07/28/me.JPG&#34; title=&#34;↑Selfie&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2019/07/28/me.JPG&#34;  alt=&#34;↑Selfie&#34;&gt;
  
    &lt;/a&gt;
  
   
    &lt;span class=&#34;caption&#34;&gt;↑Selfie&lt;/span&gt;
  
&lt;/div&gt;
&lt;/p&gt;

&lt;h1 id=&#34;the-excerpt&#34;&gt;The excerpt&lt;/h1&gt;

&lt;blockquote&gt;
&lt;p&gt;中外不少诗人死得早，哲学家多长寿。孟子说：“吾善养吾浩然之气。”这话很文学。“浩然”，形容词，可随时代和个人的差别而解释。文天祥用“浩然”，是爱国，曹雪芹又作别解。要我解，比文天祥胆小，比曹雪芹老实。我以为“浩然之气”，指元气，如你果然献身艺术，艺术会给你不尽元气，一份诚意，换一份元气。牺牲功利，牺牲爱情，背叛政治，得到艺术，真的要牺牲。&lt;br /&gt;
小细节上更难。光阴逝，要在一秒一秒消失的光阴中，保持艺术家风度，守身如玉，决不让步。&lt;br /&gt;
“善养”，指懂得养。&lt;br /&gt;
孟子还提出“存夜气”。后半夜是“平旦之气”，此是养身法，是生理的，又是心理的。我乡下有“平旦”是“卯气”的说法。肖邦、瓦莱里，都懂，一早起创作。&lt;br /&gt;
Excerpt From: 木心. “文学回忆录.”&lt;/p&gt;
&lt;/blockquote&gt;</description>
    </item>
    
    <item>
      <title>[Weekly-12] 2019.07.21</title>
      <link>http://nianze.tk/2019/07/2019-07-21-visual-project/</link>
      <pubDate>Sun, 21 Jul 2019 19:10:41 -0400</pubDate>
      
      <guid>http://nianze.tk/2019/07/2019-07-21-visual-project/</guid>
      <description>&lt;p&gt;Weekly visual project - 2019/07/21

&lt;!-- toc --&gt;&lt;/p&gt;

&lt;h1 id=&#34;the-street&#34;&gt;The street&lt;/h1&gt;

&lt;p&gt;

 
  
  
  
  
    
  
    
      
    
  

&lt;div class=&#34;figure fig-50&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2019/07/21/pinch.JPG&#34; title=&#34;↑Pinch&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2019/07/21/pinch.JPG&#34;  alt=&#34;↑Pinch&#34;&gt;
  
    &lt;/a&gt;
  
   
    &lt;span class=&#34;caption&#34;&gt;↑Pinch&lt;/span&gt;
  
&lt;/div&gt;



 
  
  
  
  
    
  
    
      
    
  

&lt;div class=&#34;figure fig-50&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2019/07/21/wings.JPG&#34; title=&#34;↑Wings&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2019/07/21/wings.JPG&#34;  alt=&#34;↑Wings&#34;&gt;
  
    &lt;/a&gt;
  
   
    &lt;span class=&#34;caption&#34;&gt;↑Wings&lt;/span&gt;
  
&lt;/div&gt;



 
  
  
  
  
    
  
    
      
    
  

&lt;div class=&#34;figure fig-50&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2019/07/21/smile.JPG&#34; title=&#34;↑Smile&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2019/07/21/smile.JPG&#34;  alt=&#34;↑Smile&#34;&gt;
  
    &lt;/a&gt;
  
   
    &lt;span class=&#34;caption&#34;&gt;↑Smile&lt;/span&gt;
  
&lt;/div&gt;



 
  
  
  
  
    
  
    
      
    
  

&lt;div class=&#34;figure fig-50&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2019/07/21/church.JPG&#34; title=&#34;↑Church&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2019/07/21/church.JPG&#34;  alt=&#34;↑Church&#34;&gt;
  
    &lt;/a&gt;
  
   
    &lt;span class=&#34;caption&#34;&gt;↑Church&lt;/span&gt;
  
&lt;/div&gt;
&lt;/p&gt;

&lt;h1 id=&#34;the-generative&#34;&gt;The generative&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;http://www.complexification.net/gallery/machines/bubblechamber/&#34;&gt;Bubble Chamber&lt;/a&gt; by Jared Tarbell in 2003. 点击图框开始生成。&lt;/p&gt;

&lt;div&gt;
    &lt;script src=&#34;https://cdnjs.cloudflare.com/ajax/libs/p5.js/0.7.1/p5.min.js&#34;&gt;&lt;/script&gt;
    &lt;script src=&#34;https://cdnjs.cloudflare.com/ajax/libs/p5.js/0.7.1/addons/p5.dom.min.js&#34;&gt;&lt;/script&gt;
    &lt;script src=&#34;http://nianze.tk/js/p5js-projects/bubblechamber.js&#34;&gt;&lt;/script&gt;
&lt;/div&gt;
&lt;div id=&#34;canvasParent&#34;&gt;&lt;/div&gt;

&lt;h1 id=&#34;the-magic-flute&#34;&gt;The Magic Flute&lt;/h1&gt;



 
  
  
  
  
    
  
    
      
    
  

&lt;div class=&#34;figure fig-100&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2019/07/21/TheMagicFlute.JPG&#34; title=&#34;↑The Magic Flute&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2019/07/21/TheMagicFlute.JPG&#34;  alt=&#34;↑The Magic Flute&#34;&gt;
  
    &lt;/a&gt;
  
   
    &lt;span class=&#34;caption&#34;&gt;↑The Magic Flute&lt;/span&gt;
  
&lt;/div&gt;


&lt;p&gt;这周去Lincoln Center听了 &lt;em&gt;The Magic Flute&lt;/em&gt; ，非常新颖的将歌剧和默剧电影相结合，效果比单纯的歌剧更加生动形象。当记者问道,“What is The Magic Flute &lt;em&gt;really&lt;/em&gt; about/魔笛 &lt;em&gt;究竟&lt;/em&gt; 讲了怎样一个故事？” 时，主创之一的Paul Barritt简单概括道：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;It&amp;rsquo;s a love story, told as a fairy tale.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;另一名主创Barrie Kosky叙述的更加详尽：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;A strange, fairytale love story, one that has a lot of archetypal and mythological elements, such as the trials they must undergo to gain wisdom. They have to go through fire and water to mature. These are ancient rites of initiation.&lt;br /&gt;
&amp;hellip;&lt;br /&gt;
Despite all of the comedic elements, there is a deep loneliness in &lt;em&gt;The Magic Flute&lt;/em&gt;. Half of the piece is the fact that people are alone: Despite the joy in Papageno&amp;rsquo;s bird catcher aria, it&amp;rsquo;s ultimately about a man who feels lonely and longs for love. At the beginning of the opera, Tamino is running alone through the forest. The three ladies are alone, so they are immediately attracted to Tamino. The Queen of the Night is alone&amp;ndash;her husband has died, and her daughter has been kidnapped. Even Sarastro, who has a large following, has no partner at his side. Not to mention Monostatos, whose unfulfilled longing for love degenerates into unbridled lust. &lt;em&gt;The Magic Flute&lt;/em&gt; is about the search for love, and about the different forms that this search can take.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;我印象最深的在话剧第二场：为了救出女主角Pamina，Tamino必须接受试炼，而第一场试炼是保持沉默。据说《魔笛》的创作与共济会(Freemason)有相当深的联系，所以深究起来第二场各个试炼的选取（沉默、诱惑、火与水等）同共济会的入会仪式有相当的渊源。我在第一次听魔笛时当然并不知道这些，当时面对“沉默的试炼”，我的震撼来自于这样的反思：一个人要懂爱，Ta先得懂得如何同自己相处，而保持沉默其实便是考验男主角是否有独处的能力，是否能先“爱自己”。&lt;/p&gt;

&lt;p&gt;与Tamino形成鲜明对比的是剧中的“小丑”人物Papageno，他不停的受到外界的干扰，无法静下心来面对自我。所以我印象很深的另一幕便是歌剧最后——当Papageno看似圆满的和他一直追寻的“心上人”在一起，生了一屋子的孩子之后，他被孩子们包围在家里时脸上浮现出的一种想要逃避的神情，我想他在那一瞬间内心是感到了一种疑惑和荒谬感的吧(按照事后我看到的资料&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:1&#34;&gt;&lt;a href=&#34;#fn:1&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;所言，捕鸟人Papageno代表只关心食色的世俗平民).&lt;/p&gt;

&lt;p&gt;还有一幕，当Pamina看到Tamino一直保持沉默不理会她，由爱转为自责，开始有了轻生的念头，其实也可以联系到我最近看到的一个心理学理论，大概是说人的成长过程中，在处理和外界的关系时，自责的能力会早于自我谅解的那部分先形成。同样道理，夜后的执念、Monostatos的堕落也都可以从心理学的角度来考量。类似这样的看似“戏剧性”很强又在现实生活中能找到原型或例证的情节还蛮多的。&lt;/p&gt;

&lt;p&gt;主创采访中我很喜欢最后Barrie对于这部剧里“音乐”的理解：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Finally, it is also an Orphic story&amp;ndash;it is about the power of music, music that can move mountains and nature. After all, the opera is called &lt;em&gt;The Magic Flute&lt;/em&gt;, not &lt;em&gt;Tamino and Pamina&lt;/em&gt;! The magic flute isn&amp;rsquo;t just an instrument, it is the quintessence of music, and music, in this case, is synonymous with love. I think that&amp;rsquo;s the reason why so many people love this opera so much, because they see, hear and feel that it&amp;rsquo;s a universal representation of those looking for love, a journey that we all take time and time again.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;感谢Mozart，不仅是musician，更是magician。&lt;/p&gt;
&lt;div class=&#34;footnotes&#34;&gt;

&lt;hr /&gt;

&lt;ol&gt;
&lt;li id=&#34;fn:1&#34;&gt;资料&lt;a href=&#34;http://art.ncu.edu.tw/artConf/main/public/11/九_蔡毓純_.pdf&#34;&gt;链接&lt;/a&gt;,其他人物：Sarastro暗指共济会奥地利分会的领导人Igna von Born；夜后隐喻当时对共济会采取高压政策的女王Maria Theresa；Monostatos暗指当时和共济会处于敌对关系的耶稣会；Pamina隐喻奥地利的国民
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:1&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;</description>
    </item>
    
    <item>
      <title>[Weekly-11] 2019.07.14</title>
      <link>http://nianze.tk/2019/07/2019-07-14-visual-project/</link>
      <pubDate>Sun, 14 Jul 2019 17:02:03 -0400</pubDate>
      
      <guid>http://nianze.tk/2019/07/2019-07-14-visual-project/</guid>
      <description>&lt;p&gt;Weekly visual project - 2019/07/14

&lt;!-- toc --&gt;&lt;/p&gt;

&lt;h1 id=&#34;the-building&#34;&gt;The building&lt;/h1&gt;

&lt;p&gt;

 
  
  
  
  
    
  
    
      
    
  

&lt;div class=&#34;figure fig-100&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2019/07/14/grace-church.JPG&#34; title=&#34;↑Grace Church&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2019/07/14/grace-church.JPG&#34;  alt=&#34;↑Grace Church&#34;&gt;
  
    &lt;/a&gt;
  
   
    &lt;span class=&#34;caption&#34;&gt;↑Grace Church&lt;/span&gt;
  
&lt;/div&gt;



 
  
  
  
  
    
  
    
      
    
  

&lt;div class=&#34;figure fig-100&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2019/07/14/true-north.JPG&#34; title=&#34;↑True north&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2019/07/14/true-north.JPG&#34;  alt=&#34;↑True north&#34;&gt;
  
    &lt;/a&gt;
  
   
    &lt;span class=&#34;caption&#34;&gt;↑True north&lt;/span&gt;
  
&lt;/div&gt;



 
  
  
  
  
    
  
    
      
    
  

&lt;div class=&#34;figure fig-100&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2019/07/14/reflection.JPG&#34; title=&#34;↑Reflection of Tisch building&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2019/07/14/reflection.JPG&#34;  alt=&#34;↑Reflection of Tisch building&#34;&gt;
  
    &lt;/a&gt;
  
   
    &lt;span class=&#34;caption&#34;&gt;↑Reflection of Tisch building&lt;/span&gt;
  
&lt;/div&gt;
&lt;/p&gt;

&lt;h1 id=&#34;the-generative&#34;&gt;The generative&lt;/h1&gt;

&lt;p&gt;如&lt;a href=&#34;http://nianze.tk/2019/07/engineering-is-magic/&#34;&gt;上篇博客&lt;/a&gt;所说，我决定在今后的weekly visual project中加入generative art的部分，以程序作画笔来绘制些视觉效果。下面的这张图是利用P5.js实现Jared Tarbell在2003年的作品&lt;a href=&#34;http://www.complexification.net/gallery/machines/substrate/&#34;&gt;Substrate&lt;/a&gt;。绘制过程本身是动态的，可以&lt;a href=&#34;http://nianze.tk/2019/07/engineering-is-magic/#substrate&#34;&gt;点击这里&lt;/a&gt;查看。&lt;/p&gt;



 
  
  
  
  
    
  
    
      
    
  

&lt;div class=&#34;figure fig-100&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2019/07/14/substrate.jpg&#34; title=&#34;↑Substrate&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2019/07/14/substrate.jpg&#34;  alt=&#34;↑Substrate&#34;&gt;
  
    &lt;/a&gt;
  
   
    &lt;span class=&#34;caption&#34;&gt;↑Substrate&lt;/span&gt;
  
&lt;/div&gt;


&lt;h1 id=&#34;the-excerpt&#34;&gt;The excerpt&lt;/h1&gt;

&lt;blockquote&gt;
&lt;p&gt;传道散了，耶稣独自在海面走。门徒惊异，耶稣说勿惊。彼得也从水面走去，怕落水，呼救，耶稣拉他的手近拢，说：你这小信的人，为什么不信我？&lt;br /&gt;
...&lt;br /&gt;
以宗教看，奇迹之一，是用寓言对待其象征性。一个人能否成大器，主观因素最重要，被人忽略的是信心，是信念。信心，信念，一半凭空想，一半凭行动（用功、才能等等）。我的大半生，阅人多矣，阅艺术家多矣。确切说，想成为艺术家者多矣，此后生如行于海，磨难如风浪，但太多人行于海，怕沉没，害怕了，有人沉没，有人时浮时沉。&lt;br /&gt;
一路多小信的人。&lt;br /&gt;
我不比人慧，不比人强，数十年间认识的精英分子前后六批，凡五十人，有大才，甚至天才，至今剩我一人。如果他们成了，文艺复兴。&lt;br /&gt;
下了海，要走下去。&lt;br /&gt;
...&lt;br /&gt;
信心到底哪里来？信心就是忠诚。立志，容易。忠诚其志，太难。许多人立志，随立随毁，不如不立。艺术，爱情，政治，商业，都要忠诚。求道，坚定忠诚无疑，虽蹈海，也走下去。&lt;br /&gt;
所谓第二流者，是原来志在一流，天时、地利、人和，均不合，成了二流。如果甘于二流三流，已经居下流了。&lt;br /&gt;
Excerpt From: 木心. “文学回忆录.”&lt;/p&gt;
&lt;/blockquote&gt;</description>
    </item>
    
    <item>
      <title>Engineering Is Magic</title>
      <link>http://nianze.tk/2019/07/engineering-is-magic/</link>
      <pubDate>Tue, 09 Jul 2019 12:56:29 -0400</pubDate>
      
      <guid>http://nianze.tk/2019/07/engineering-is-magic/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;Or at least the closest thing to magic that exists in the real world&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:1&#34;&gt;&lt;a href=&#34;#fn:1&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;.

&lt;!-- toc --&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Code is the spell. Computer is the wand. Use the magic to create fun stuff might be one of the most exciting things in this age. Starting each day with a creative spell might be a good ritual to become a good magician.&lt;/p&gt;

&lt;p&gt;最近稍稍了解了下&lt;a href=&#34;https://www.artnome.com/news/2018/8/8/generative-art-finds-its-prodigy&#34;&gt;generative art&lt;/a&gt;，感觉很适合加入到weekly project中：不妨先用&lt;a href=&#34;https://processing.org/&#34;&gt;processing&lt;/a&gt;或者&lt;a href=&#34;http://p5js.org/&#34;&gt;P5.js&lt;/a&gt;做原型设计，遇到性能/实时性要求高的成品可以用&lt;a href=&#34;https://libcinder.org/&#34;&gt;cinder&lt;/a&gt;或&lt;a href=&#34;https://openframeworks.cc/&#34;&gt;openframeworks&lt;/a&gt;来进一步实现。&lt;/p&gt;

&lt;p&gt;说起来大二的时候就有了解过processing，彼时还在参加电子设计竞赛，玩TI的&lt;a href=&#34;https://www.ti.com/microcontrollers/msp430-ultra-low-power-mcus/overview.html&#34;&gt;MSP430&lt;/a&gt;；后来注意力被&lt;a href=&#34;https://youtu.be/Y7ey0uSVP0o&#34;&gt;Kinect&lt;/a&gt;吸引，伙同MangoSister和Sirius参加了微软的&lt;a href=&#34;http://nianze.tk/images/2019/07/09/demo.jpg&#34;&gt;Imagine Cup&lt;/a&gt;和创客大赛，先后去了济南，上海和北京参赛，最后以混进人民大会堂领了个事后证明无关轻重的&lt;a href=&#34;http://nianze.tk/images/2019/07/09/chuangke.jpg&#34;&gt;奖&lt;/a&gt;收尾。现在想来还真是够折腾，曾差点因为比赛行程耽搁了提交实验室的&lt;a href=&#34;http://pubs.rsc.org/en/content/articlelanding/2015/nr/c4nr06883a#!divAbstract&#34;&gt;论文&lt;/a&gt;，间接影响了之后GRE备考以及出国申请的时间线。&lt;/p&gt;

&lt;p&gt;唯一的遗憾，是因为怕时间冲突没去微软亚研院实习——暑假的南京，傍晚的暖风吹来，我从四牌楼的显示技术研究中心实验室走出来，感到有些闷热。想着今晚是吃沙塘园还是香园的食堂，又或者去马路对面的沙县小吃匆匆果腹晚上继续做实验时，那通毫无预兆的电话打来，而搞不清状况的我以大四开学提交论文备考GRE有可能没时间去北京实习为由，草草拒绝了这offer。&lt;/p&gt;

&lt;p&gt;图样。&lt;/p&gt;

&lt;p&gt;那是2014年的夏天(也不记得，那晚最后去哪家吃的饭)。五年后的今天，地球的另一端，我在纽约东村的一隅，解决了养活自己的问题，即将回归校园，开始寻思目的的时候，回想起当年的往事，突然有点“浪子回头”的意味。就想到木心先生的话：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;什么是目的？太难说——黑格尔、笛卡尔建立方法论，马克思太重方法——为什么目的难说？&lt;br /&gt;
因为宇宙是无目的。&lt;br /&gt;
&amp;hellip;&lt;br /&gt;
宗教是什么？就因为宇宙无目的，方法论无目的，也是架空。宗教是想在无目的的宇宙中，虚构一目的。此即宗教。&lt;br /&gt;
哲学家是怀疑者、追求者。科学家解释，分析，过程中有所怀疑者，则兼具哲学家气质了。或曰，这样的科学家是有宗教信仰的，为宗教服务的。西方大科学家不满于老是追求科学，总想进入哲学、宗教，进进退退，很有趣。&lt;br /&gt;
艺术家可以做哲学家、宗教家、科学家不能做的事。艺术家是浪子。宗教太沉闷，科学太枯燥，艺术家是水淋淋的浪子。他自设目的，自成方法。以宗教设计目的，借哲学架构方法。&lt;br /&gt;
然而这不是浪子回头，而是先有家，住腻了，浪出来，带足哲学、宗教的家产，浪出来。&lt;br /&gt;
不能太早做浪子，要在宗教、哲学里泡一泡。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;不敢说我“住腻了”，毕竟在哲学和宗教的领域，我门都还没进。不过这一出一进，重返校园，心态是不同的。不敢说清楚了自己想要的是什么，只是更明白自己不想要的是什么，从而不那么容易分心。&lt;/p&gt;

&lt;p&gt;科技日新月异，人心亘古难变。相通的那部分，离永恒更近一些。我想以“美”的名义为之命名，算作当下的目的。音乐，摄影，绘画，都是很好的媒介。生成艺术（generative art）可以看作以代码作笔刷的绘画。&lt;/p&gt;

&lt;p&gt;提起美，不得不提生成艺术领域里结合AI作画的新分支。&lt;a href=&#34;https://twitter.com/js_horne/status/1032038186858426374&#34;&gt;Tweeter&lt;/a&gt;上很多人看了这类作品会觉得“creepy”，不太符合传统和谐的“美”感，但确实具有随机的趣味性。我感觉比起&lt;a href=&#34;https://vimeo.com/22955812&#34;&gt;传统&lt;/a&gt;的generative art从无到有按照某些规则生成图像，AI作画倒更像摄影：创作者掌控取景的自由度，可以调整“相机”的参数，最后成像的过程交由“相机”来完成。不同的是，AI作画过程中生成网络这台“相机”具有更多的参数，同时因为学习对象的不同会引入某种程度的“不可控性”，从而产生趣味性；但如果只利用别人训练好的网络去创作，很多时候就沦为“调参侠”，创作者的自由度局限在学习图片/测试图片的选取和模型参数的调整中，根据生成结果再反回去调整参数的选取，在无数次尝试后炼出一套精致的风格迁移滤镜,有些“炼丹师”般的试验性质。但滤镜毕竟只是滤镜，画风再怎么迁移，依然需要有滤镜下的初始图像作为素材，有时甚至会带来作品归属权的问题&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:2&#34;&gt;&lt;a href=&#34;#fn:2&#34;&gt;2&lt;/a&gt;&lt;/sup&gt;。这个角度看，如果摄影是捕捉决定性瞬间的艺术，那么AI作画倒有点像“炼丹的艺术”。目前来看，它可以很好的作为一种试验性质的画面风格变换/融合手段，并引入一些额外的随机性增添趣味，从而增强作品的表现力。新的发展方向，依赖于深刻理解机器学习有能力训练出原创新网络的“相机制造者”的进一步探索。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;As AI technology becomes increasingly available, artistry and technical advancement will only become more important in separating the remarkable AI artists from those repurposing old tools built by others or simply pushing a button to achieve an overused visual paradigm.&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:3&#34;&gt;&lt;a href=&#34;#fn:3&#34;&gt;3&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&#34;substrate&#34;&gt;Substrate&lt;/h1&gt;

&lt;p&gt;Anyway，着手AI之前，我先小试了下p5.js，复现了Jared Tarbell在2003年的作品&lt;a href=&#34;http://www.complexification.net/gallery/machines/substrate/&#34;&gt;Substrate&lt;/a&gt;。将动态生成的过程迁移到浏览器以方便传播，效果还是很不错的。&lt;/p&gt;

&lt;div&gt;
    &lt;script src=&#34;https://cdnjs.cloudflare.com/ajax/libs/p5.js/0.7.1/p5.min.js&#34;&gt;&lt;/script&gt;
    &lt;script src=&#34;https://cdnjs.cloudflare.com/ajax/libs/p5.js/0.7.1/addons/p5.dom.min.js&#34;&gt;&lt;/script&gt;
    &lt;script src=&#34;http://nianze.tk/js/p5js-projects/substrate.js&#34;&gt;&lt;/script&gt;
&lt;/div&gt;
&lt;div id=&#34;canvasParent&#34;&gt;&lt;/div&gt;

&lt;p&gt;期待有一天能做出类似&lt;a href=&#34;https://vimeo.com/155733402&#34;&gt;Greatness&lt;/a&gt;这样的作品来，再配合自己作的曲子就更完美了。&lt;/p&gt;
&lt;div class=&#34;footnotes&#34;&gt;

&lt;hr /&gt;

&lt;ol&gt;
&lt;li id=&#34;fn:1&#34;&gt;&lt;a href=&#34;https://twitter.com/elonmusk/status/1012784447005995008?lang=en&#34;&gt;Twitter by Elon Musk&lt;/a&gt;.
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:1&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:2&#34;&gt;&lt;a href=&#34;https://www.artnome.com/news/2019/4/17/giving-generative-art-its-due&#34;&gt;Sollfrank’s Warhol Flowers&lt;/a&gt;
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:2&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:3&#34;&gt;&lt;a href=&#34;https://www.artnome.com/news/2018/8/8/why-love-generative-art&#34;&gt;why love generative art&lt;/a&gt;.
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:3&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;</description>
    </item>
    
    <item>
      <title>[Weekly-10] 2019.07.07</title>
      <link>http://nianze.tk/2019/07/2019-07-07-street-photography/</link>
      <pubDate>Sun, 07 Jul 2019 11:54:31 -0400</pubDate>
      
      <guid>http://nianze.tk/2019/07/2019-07-07-street-photography/</guid>
      <description>&lt;p&gt;Weekly shots - 2019/07/07

&lt;!-- toc --&gt;&lt;/p&gt;

&lt;h1 id=&#34;the-building&#34;&gt;The building&lt;/h1&gt;

&lt;p&gt;

 
  
  
  
  
    
  
    
      
    
  

&lt;div class=&#34;figure fig-50&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2019/07/07/building1.JPG&#34; title=&#34;↑Building1&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2019/07/07/thumbnail/building1.JPG&#34;  alt=&#34;↑Building1&#34;&gt;
  
    &lt;/a&gt;
  
   
    &lt;span class=&#34;caption&#34;&gt;↑Building1&lt;/span&gt;
  
&lt;/div&gt;



 
  
  
  
  
    
  
    
      
    
  

&lt;div class=&#34;figure fig-50&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2019/07/07/building2.JPG&#34; title=&#34;↑Building2&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2019/07/07/thumbnail/building2.JPG&#34;  alt=&#34;↑Building2&#34;&gt;
  
    &lt;/a&gt;
  
   
    &lt;span class=&#34;caption&#34;&gt;↑Building2&lt;/span&gt;
  
&lt;/div&gt;



 
  
  
  
  
    
  
    
      
    
  

&lt;div class=&#34;figure fig-50&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2019/07/07/building3.JPG&#34; title=&#34;↑Building3&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2019/07/07/thumbnail/building3.JPG&#34;  alt=&#34;↑Building3&#34;&gt;
  
    &lt;/a&gt;
  
   
    &lt;span class=&#34;caption&#34;&gt;↑Building3&lt;/span&gt;
  
&lt;/div&gt;



 
  
  
  
  
    
  
    
      
    
  

&lt;div class=&#34;figure fig-50&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2019/07/07/building4.JPG&#34; title=&#34;↑Building4&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2019/07/07/thumbnail/building4.JPG&#34;  alt=&#34;↑Building4&#34;&gt;
  
    &lt;/a&gt;
  
   
    &lt;span class=&#34;caption&#34;&gt;↑Building4&lt;/span&gt;
  
&lt;/div&gt;



 
  
  
  
  
    
  
    
      
    
  

&lt;div class=&#34;figure fig-100&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2019/07/07/building5.JPG&#34; title=&#34;↑Building5&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2019/07/07/thumbnail/building5.JPG&#34;  alt=&#34;↑Building5&#34;&gt;
  
    &lt;/a&gt;
  
   
    &lt;span class=&#34;caption&#34;&gt;↑Building5&lt;/span&gt;
  
&lt;/div&gt;



 
  
  
  
  
    
  
    
      
    
  

&lt;div class=&#34;figure fig-100&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2019/07/07/no_help.JPG&#34; title=&#34;↑No help&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2019/07/07/thumbnail/no_help.JPG&#34;  alt=&#34;↑No help&#34;&gt;
  
    &lt;/a&gt;
  
   
    &lt;span class=&#34;caption&#34;&gt;↑No help&lt;/span&gt;
  
&lt;/div&gt;



 
  
  
  
  
    
  
    
      
    
  

&lt;div class=&#34;figure fig-100&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2019/07/07/windows.JPG&#34; title=&#34;↑Windows&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2019/07/07/thumbnail/windows.JPG&#34;  alt=&#34;↑Windows&#34;&gt;
  
    &lt;/a&gt;
  
   
    &lt;span class=&#34;caption&#34;&gt;↑Windows&lt;/span&gt;
  
&lt;/div&gt;
&lt;/p&gt;

&lt;h1 id=&#34;the-food&#34;&gt;The food&lt;/h1&gt;

&lt;p&gt;

 
  
  
  
  
    
  
    
      
    
  

&lt;div class=&#34;figure fig-100&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2019/07/07/baozi.JPG&#34; title=&#34;↑上海印象-小笼包&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2019/07/07/thumbnail/baozi.JPG&#34;  alt=&#34;↑上海印象-小笼包&#34;&gt;
  
    &lt;/a&gt;
  
   
    &lt;span class=&#34;caption&#34;&gt;↑上海印象-小笼包&lt;/span&gt;
  
&lt;/div&gt;



 
  
  
  
  
    
  
    
      
    
  

&lt;div class=&#34;figure fig-100&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2019/07/07/shrimp.JPG&#34; title=&#34;↑Shrimp&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2019/07/07/thumbnail/shrimp.JPG&#34;  alt=&#34;↑Shrimp&#34;&gt;
  
    &lt;/a&gt;
  
   
    &lt;span class=&#34;caption&#34;&gt;↑Shrimp&lt;/span&gt;
  
&lt;/div&gt;



 
  
  
  
  
    
  
    
      
    
  

&lt;div class=&#34;figure fig-100&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2019/07/07/yuzu_ramen.JPG&#34; title=&#34;↑一風堂夏季限定-柚味拉麵&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2019/07/07/thumbnail/yuzu_ramen.JPG&#34;  alt=&#34;↑一風堂夏季限定-柚味拉麵&#34;&gt;
  
    &lt;/a&gt;
  
   
    &lt;span class=&#34;caption&#34;&gt;↑一風堂夏季限定-柚味拉麵&lt;/span&gt;
  
&lt;/div&gt;
&lt;/p&gt;

&lt;h1 id=&#34;the-animal&#34;&gt;The animal&lt;/h1&gt;

&lt;p&gt;

 
  
  
  
  
    
  
    
      
    
  

&lt;div class=&#34;figure fig-100&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2019/07/07/dog.JPG&#34; title=&#34;↑Dog as a bull&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2019/07/07/thumbnail/dog.JPG&#34;  alt=&#34;↑Dog as a bull&#34;&gt;
  
    &lt;/a&gt;
  
   
    &lt;span class=&#34;caption&#34;&gt;↑Dog as a bull&lt;/span&gt;
  
&lt;/div&gt;



 
  
  
  
  
    
  
    
      
    
  

&lt;div class=&#34;figure fig-100&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2019/07/07/butterfly.JPG&#34; title=&#34;↑Butterfly as an autumn leaf&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2019/07/07/thumbnail/butterfly.JPG&#34;  alt=&#34;↑Butterfly as an autumn leaf&#34;&gt;
  
    &lt;/a&gt;
  
   
    &lt;span class=&#34;caption&#34;&gt;↑Butterfly as an autumn leaf&lt;/span&gt;
  
&lt;/div&gt;



 
  
  
  
  
    
  
    
      
    
  

&lt;div class=&#34;figure fig-100&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2019/07/07/eyes.JPG&#34; title=&#34;↑Narcissus&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2019/07/07/thumbnail/eyes.JPG&#34;  alt=&#34;↑Narcissus&#34;&gt;
  
    &lt;/a&gt;
  
   
    &lt;span class=&#34;caption&#34;&gt;↑Narcissus&lt;/span&gt;
  
&lt;/div&gt;
&lt;/p&gt;

&lt;h1 id=&#34;the-excerpt&#34;&gt;The excerpt&lt;/h1&gt;

&lt;blockquote&gt;
&lt;p&gt;关于“打右脸给左脸，勿以眼还眼、以牙还牙，爱仇敌……”这几段话，是无抵抗主义的最高纲领。甘地、托尔斯泰都遵守，都信以为真，身体力行。&lt;br /&gt;
&amp;hellip;&lt;br /&gt;
这段话的精义是什么呢，在于开启人的心怀，开阔到了右脸被打，左脸也凑过去。其实是韬略，是战术。两个好人误会了，一方解释不了，或来不及解释，一方情急动手了，被打的不还手、不躲避，打的那个就会自省：他是好人啊，惭愧啊，误会他了，委屈他了。&lt;br /&gt;
这种忍辱功夫，以柔克刚，是为使人愧悔，是感化的战术——优待俘虏、大赦战犯，都出于这个原则。佛家的慈悲、道家的虚纳（如婴、如水）都源于这种无抵抗的抵抗，以含垢忍辱占上风。吓倒你，不彻底的，使你惭愧而悔改，才是真的征服。&lt;br /&gt;
但耶稣的心理战限于好人之间。歹人、不义之徒，打了右脸打左脸，剥了外衣剥内衣。人类历史就这样。代表人类雕像的，就是鼻青脸肿的亚当、夏娃，赤条条一对，被强逼白走了两千年。&lt;br /&gt;
世界是一群左右脸给人打、内外衣给人剥的亚当、夏娃。&lt;br /&gt;
都给人白打，给人白剥！&lt;br /&gt;
&amp;hellip;&lt;br /&gt;
耶稣讲话是话中有话。我不是好人，也不是坏人，所以听来格外有感。&lt;br /&gt;
一个爱我的人，如果爱得讲话结结巴巴，语无伦次，我就知道他爱我。&lt;br /&gt;
凡真的先知，总是时而雄辩，时而结巴。凡是他说不上来的时候，我最爱他。&lt;br /&gt;
假先知都是朗朗上口的。我全不信。我知道他不爱。&lt;br /&gt;
Excerpt From: 木心. “文学回忆录.”&lt;/p&gt;
&lt;/blockquote&gt;</description>
    </item>
    
    <item>
      <title>[Weekly-9] 2019.06.30</title>
      <link>http://nianze.tk/2019/06/2019-06-30-street-photography/</link>
      <pubDate>Sun, 30 Jun 2019 22:25:55 -0400</pubDate>
      
      <guid>http://nianze.tk/2019/06/2019-06-30-street-photography/</guid>
      <description>&lt;p&gt;Weekly shots - 2019/06/30

&lt;!-- toc --&gt;&lt;/p&gt;

&lt;h1 id=&#34;the-street&#34;&gt;The street&lt;/h1&gt;

&lt;p&gt;

 
  
  
  
  
    
  
    
      
    
  

&lt;div class=&#34;figure fig-100&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2019/06/30/street.JPG&#34; title=&#34;↑Street&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2019/06/30/thumbnail/street.JPG&#34;  alt=&#34;↑Street&#34;&gt;
  
    &lt;/a&gt;
  
   
    &lt;span class=&#34;caption&#34;&gt;↑Street&lt;/span&gt;
  
&lt;/div&gt;



 
  
  
  
  
    
  
    
      
    
  

&lt;div class=&#34;figure fig-50&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2019/06/30/doorman.jpg&#34; title=&#34;↑Doorman&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2019/06/30/thumbnail/doorman.jpg&#34;  alt=&#34;↑Doorman&#34;&gt;
  
    &lt;/a&gt;
  
   
    &lt;span class=&#34;caption&#34;&gt;↑Doorman&lt;/span&gt;
  
&lt;/div&gt;



 
  
  
  
  
    
  
    
      
    
  

&lt;div class=&#34;figure fig-50&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2019/06/30/sunset.JPG&#34; title=&#34;↑Sunset&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2019/06/30/thumbnail/sunset.JPG&#34;  alt=&#34;↑Sunset&#34;&gt;
  
    &lt;/a&gt;
  
   
    &lt;span class=&#34;caption&#34;&gt;↑Sunset&lt;/span&gt;
  
&lt;/div&gt;


 
  
  
  
  
    
  
    
      
    
  


&lt;div class=&#34;figure fig-50&#34; &gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;&#34; &gt;
  
  
&lt;/div&gt;

  &lt;div style=&#34;clear:both;&#34;&gt;&lt;/div&gt;
&lt;/p&gt;

&lt;h1 id=&#34;the-people&#34;&gt;The people&lt;/h1&gt;

&lt;p&gt;

 
  
  
  
  
    
  
    
      
    
  

&lt;div class=&#34;figure fig-50&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2019/06/30/pride_parade.JPG&#34; title=&#34;↑Pride Parade&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2019/06/30/thumbnail/pride_parade.JPG&#34;  alt=&#34;↑Pride Parade&#34;&gt;
  
    &lt;/a&gt;
  
   
    &lt;span class=&#34;caption&#34;&gt;↑Pride Parade&lt;/span&gt;
  
&lt;/div&gt;



 
  
  
  
  
    
  
    
      
    
  

&lt;div class=&#34;figure fig-50&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2019/06/30/couple.jpg&#34; title=&#34;↑Holding hands&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2019/06/30/thumbnail/couple.jpg&#34;  alt=&#34;↑Holding hands&#34;&gt;
  
    &lt;/a&gt;
  
   
    &lt;span class=&#34;caption&#34;&gt;↑Holding hands&lt;/span&gt;
  
&lt;/div&gt;


 
  
  
  
  
    
  
    
      
    
  


&lt;div class=&#34;figure fig-50&#34; &gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;&#34; &gt;
  
  
&lt;/div&gt;

  &lt;div style=&#34;clear:both;&#34;&gt;&lt;/div&gt;



 
  
  
  
  
    
  
    
      
    
  

&lt;div class=&#34;figure fig-100&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2019/06/30/stare.JPG&#34; title=&#34;↑Stare&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2019/06/30/thumbnail/stare.JPG&#34;  alt=&#34;↑Stare&#34;&gt;
  
    &lt;/a&gt;
  
   
    &lt;span class=&#34;caption&#34;&gt;↑Stare&lt;/span&gt;
  
&lt;/div&gt;
&lt;/p&gt;

&lt;h1 id=&#34;the-event&#34;&gt;The event&lt;/h1&gt;



 
  
  
  
  
    
  
    
      
    
  

&lt;div class=&#34;figure fig-100&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2019/06/30/han_dan.JPG&#34; title=&#34;↑Han Dan&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2019/06/30/thumbnail/han_dan.JPG&#34;  alt=&#34;↑Han Dan&#34;&gt;
  
    &lt;/a&gt;
  
   
    &lt;span class=&#34;caption&#34;&gt;↑Han Dan&lt;/span&gt;
  
&lt;/div&gt;


&lt;h1 id=&#34;the-mirror&#34;&gt;The mirror&lt;/h1&gt;

&lt;p&gt;

 
  
  
  
  
    
  
    
      
    
  

&lt;div class=&#34;figure fig-50&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2019/06/30/selfie1.jpg&#34; title=&#34;↑Selfie&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2019/06/30/thumbnail/selfie1.jpg&#34;  alt=&#34;↑Selfie&#34;&gt;
  
    &lt;/a&gt;
  
   
    &lt;span class=&#34;caption&#34;&gt;↑Selfie&lt;/span&gt;
  
&lt;/div&gt;



 
  
  
  
  
    
  
    
      
    
  

&lt;div class=&#34;figure fig-50&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2019/06/30/selfie2.JPG&#34; title=&#34;↑Selfie&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2019/06/30/thumbnail/selfie2.JPG&#34;  alt=&#34;↑Selfie&#34;&gt;
  
    &lt;/a&gt;
  
   
    &lt;span class=&#34;caption&#34;&gt;↑Selfie&lt;/span&gt;
  
&lt;/div&gt;


 
  
  
  
  
    
  
    
      
    
  


&lt;div class=&#34;figure fig-50&#34; &gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;&#34; &gt;
  
  
&lt;/div&gt;

  &lt;div style=&#34;clear:both;&#34;&gt;&lt;/div&gt;
&lt;/p&gt;

&lt;h1 id=&#34;the-food&#34;&gt;The food&lt;/h1&gt;

&lt;p&gt;

 
  
  
  
  
    
  
    
      
    
  

&lt;div class=&#34;figure fig-100&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2019/06/30/duck.JPG&#34; title=&#34;↑Duck&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2019/06/30/thumbnail/duck.JPG&#34;  alt=&#34;↑Duck&#34;&gt;
  
    &lt;/a&gt;
  
   
    &lt;span class=&#34;caption&#34;&gt;↑Duck&lt;/span&gt;
  
&lt;/div&gt;



 
  
  
  
  
    
  
    
      
    
  

&lt;div class=&#34;figure fig-100&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2019/06/30/tartar.jpg&#34; title=&#34;↑Tartar&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2019/06/30/thumbnail/tartar.jpg&#34;  alt=&#34;↑Tartar&#34;&gt;
  
    &lt;/a&gt;
  
   
    &lt;span class=&#34;caption&#34;&gt;↑Tartar&lt;/span&gt;
  
&lt;/div&gt;
&lt;/p&gt;

&lt;h1 id=&#34;the-excerpt&#34;&gt;The excerpt&lt;/h1&gt;

&lt;blockquote&gt;
&lt;p&gt;弥诺陶洛斯，象征欲望。建筑师代达罗斯，即制造迷楼者，象征制定伦理、制度、道德、条例者。迷楼，象征社会，监囚人，人不得出，包括婚姻、法律、契约。在社会中，人进入店，见食物，不能拿，因没有钱，拿即犯法。动物见食便吃。建筑师也出不来，作法自毙。&lt;br /&gt;
唯一的办法是飞。飞出迷楼。艺术家，天才，就是要飞。然而飞高，狂而死。青年艺术家不懂，像伊卡洛斯，飞高而死，他的父亲是老艺术家，懂。&lt;br /&gt;
我曾为文，将尼采、托尔斯泰、拜伦，都列入飞出的伊卡洛斯。但伊卡洛斯的性格，宁可飞高，宁可摔死。&lt;br /&gt;
一定要飞出迷楼，靠艺术的翅膀。宁可摔死。&lt;br /&gt;
欲望，是要关起来，现代迷楼，更难飞出，需要更大的翅膀。&lt;br /&gt;
&amp;hellip;&lt;br /&gt;
纪德（André Gide）解释那耳喀索斯，解释得好。大意是，那耳喀索斯是人的自我，在时间的泉水里发现了映影，这映影，便是艺术，是超自我的自我。艺术不能完成真实，不能实际占有，只可保持距离，两相观照；你要沾惹它，它便消失了，你静着不动，它又显现。&lt;br /&gt;
我觉得艺术、哲学、宗教，都是人类的自恋，都在适当保持距离时，才有美的可能、真的可能、善的可能。如果你把宗教当做哲学对待，就有了距离，看清宗教究竟是什么；如果你把哲学当做艺术对待，就有了距离，看清哲学究竟是什么；如果你把艺术当做宗教对待，就有了距离，看清艺术究竟是什么——我的意见是，将宗教作宗教来信，就迷惑了；将哲学作哲学来研究，就学究了；将艺术作艺术来玩弄，就玩世不恭了。原因，就在于太直接，是人的自我强求，正像那耳喀索斯要亲吻水中的影。而那耳喀索斯是智者，一次两次失败后，不再侵犯自我，满足于距离，纯乎求观照，一直到生命的最后。可见“禅”，东方有，西方也有，换个名称就是“悟”，彻悟，悟又从“迷”来，不垢不净，不迷不恒。那耳喀索斯就因为一度伸手触抚，又一度俯唇求吻，才使他过后保持不饮不食，不眠不动，在时间和空间里证见自我，这就是人类的自我。&lt;br /&gt;
整个希腊文化，可以概称为“人的发现”；全部希腊神话，可以概称为“人的倒影”。妙在倒影比本体更大、更强，而且不在水里，却在天上，在奥林匹斯山上。&lt;br /&gt;
&amp;hellip;&lt;br /&gt;
那耳喀索斯的神话，象征艺术与人生的距离。现实主义取消距离，水即乱。这是人生与艺术的宿命。艺术家只要能把握距离到正好，就成功，不分主义。&lt;br /&gt;
&amp;hellip;&lt;br /&gt;
早先初民的智能，以为风吹孩子，风就是父亲，以为火苗就是野兽，以己度人、度世界。早古人类的疑问，是自问自答，因无人回答，故神话以人类自问自答的方式流传，人格化。此即神话之前的文学雏形。再早，是口传，好则留，坏则不留。到现代、近世，传播出版发达，却相反，坏的容易传播，好的不易流传。&lt;br /&gt;
人类文化的悲哀，是流俗的易传、高雅的失传。&lt;br /&gt;
Excerpt From: 木心. “文学回忆录.”&lt;/p&gt;
&lt;/blockquote&gt;</description>
    </item>
    
    <item>
      <title>[Weekly-8] 2019.06.22</title>
      <link>http://nianze.tk/2019/06/2019-06-22-street-photography/</link>
      <pubDate>Sat, 22 Jun 2019 18:37:03 -0400</pubDate>
      
      <guid>http://nianze.tk/2019/06/2019-06-22-street-photography/</guid>
      <description>&lt;p&gt;Weekly shots - 2019/06/22

&lt;!-- toc --&gt;&lt;/p&gt;

&lt;h1 id=&#34;the-people&#34;&gt;The people&lt;/h1&gt;

&lt;p&gt;

 
  
  
  
  
    
  
    
      
    
  

&lt;div class=&#34;figure fig-100&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2019/06/22/boucherie.JPG&#34; title=&#34;↑Boucherie&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2019/06/22/thumbnail/boucherie.JPG&#34;  alt=&#34;↑Boucherie&#34;&gt;
  
    &lt;/a&gt;
  
   
    &lt;span class=&#34;caption&#34;&gt;↑Boucherie&lt;/span&gt;
  
&lt;/div&gt;



 
  
  
  
  
    
  
    
      
    
  

&lt;div class=&#34;figure fig-100&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2019/06/22/family.jpg&#34; title=&#34;↑Family&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2019/06/22/thumbnail/family.jpg&#34;  alt=&#34;↑Family&#34;&gt;
  
    &lt;/a&gt;
  
   
    &lt;span class=&#34;caption&#34;&gt;↑Family&lt;/span&gt;
  
&lt;/div&gt;



 
  
  
  
  
    
  
    
      
    
  

&lt;div class=&#34;figure fig-100&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2019/06/22/sit.JPG&#34; title=&#34;↑Sit&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2019/06/22/thumbnail/sit.JPG&#34;  alt=&#34;↑Sit&#34;&gt;
  
    &lt;/a&gt;
  
   
    &lt;span class=&#34;caption&#34;&gt;↑Sit&lt;/span&gt;
  
&lt;/div&gt;



 
  
  
  
  
    
  
    
      
    
  

&lt;div class=&#34;figure fig-100&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2019/06/22/dancers_in_park.JPG&#34; title=&#34;↑Dancers in the Park&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2019/06/22/thumbnail/dancers_in_park.JPG&#34;  alt=&#34;↑Dancers in the Park&#34;&gt;
  
    &lt;/a&gt;
  
   
    &lt;span class=&#34;caption&#34;&gt;↑Dancers in the Park&lt;/span&gt;
  
&lt;/div&gt;
&lt;/p&gt;

&lt;h1 id=&#34;the-face&#34;&gt;The face&lt;/h1&gt;

&lt;p&gt;

 
  
  
  
  
    
  
    
      
    
  

&lt;div class=&#34;figure fig-50&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2019/06/22/face_6.JPG&#34; title=&#34;↑Face 6&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2019/06/22/thumbnail/face_6.JPG&#34;  alt=&#34;↑Face 6&#34;&gt;
  
    &lt;/a&gt;
  
   
    &lt;span class=&#34;caption&#34;&gt;↑Face 6&lt;/span&gt;
  
&lt;/div&gt;



 
  
  
  
  
    
  
    
      
    
  

&lt;div class=&#34;figure fig-50&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2019/06/22/two-faces.JPG&#34; title=&#34;↑Two Faces&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2019/06/22/thumbnail/two-faces.JPG&#34;  alt=&#34;↑Two Faces&#34;&gt;
  
    &lt;/a&gt;
  
   
    &lt;span class=&#34;caption&#34;&gt;↑Two Faces&lt;/span&gt;
  
&lt;/div&gt;


 
  
  
  
  
    
  
    
      
    
  


&lt;div class=&#34;figure fig-50&#34; &gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;&#34; &gt;
  
  
&lt;/div&gt;

  &lt;div style=&#34;clear:both;&#34;&gt;&lt;/div&gt;



 
  
  
  
  
    
  
    
      
    
  

&lt;div class=&#34;figure fig-100&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2019/06/22/grumpy_face.JPG&#34; title=&#34;↑Grumpy face&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2019/06/22/thumbnail/grumpy_face.JPG&#34;  alt=&#34;↑Grumpy face&#34;&gt;
  
    &lt;/a&gt;
  
   
    &lt;span class=&#34;caption&#34;&gt;↑Grumpy face&lt;/span&gt;
  
&lt;/div&gt;
&lt;/p&gt;

&lt;h1 id=&#34;the-food&#34;&gt;The food&lt;/h1&gt;

&lt;p&gt;

 
  
  
  
  
    
  
    
      
    
  

&lt;div class=&#34;figure fig-50&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2019/06/22/bluestone_lane.JPG&#34; title=&#34;↑Bluestone Lane&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2019/06/22/thumbnail/bluestone_lane.JPG&#34;  alt=&#34;↑Bluestone Lane&#34;&gt;
  
    &lt;/a&gt;
  
   
    &lt;span class=&#34;caption&#34;&gt;↑Bluestone Lane&lt;/span&gt;
  
&lt;/div&gt;



 
  
  
  
  
    
  
    
      
    
  

&lt;div class=&#34;figure fig-50&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2019/06/22/latte.JPG&#34; title=&#34;↑Partners Coffee&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2019/06/22/thumbnail/latte.JPG&#34;  alt=&#34;↑Partners Coffee&#34;&gt;
  
    &lt;/a&gt;
  
   
    &lt;span class=&#34;caption&#34;&gt;↑Partners Coffee&lt;/span&gt;
  
&lt;/div&gt;


 
  
  
  
  
    
  
    
      
    
  


&lt;div class=&#34;figure fig-50&#34; &gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;&#34; &gt;
  
  
&lt;/div&gt;

  &lt;div style=&#34;clear:both;&#34;&gt;&lt;/div&gt;



 
  
  
  
  
    
  
    
      
    
  

&lt;div class=&#34;figure fig-100&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2019/06/22/grumpy.JPG&#34; title=&#34;↑Café Grumpy&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2019/06/22/thumbnail/grumpy.JPG&#34;  alt=&#34;↑Café Grumpy&#34;&gt;
  
    &lt;/a&gt;
  
   
    &lt;span class=&#34;caption&#34;&gt;↑Café Grumpy&lt;/span&gt;
  
&lt;/div&gt;
&lt;/p&gt;

&lt;h1 id=&#34;the-street&#34;&gt;The street&lt;/h1&gt;

&lt;p&gt;

 
  
  
  
  
    
  
    
      
    
  

&lt;div class=&#34;figure fig-100&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2019/06/22/doggy.JPG&#34; title=&#34;↑The dog&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2019/06/22/thumbnail/doggy.JPG&#34;  alt=&#34;↑The dog&#34;&gt;
  
    &lt;/a&gt;
  
   
    &lt;span class=&#34;caption&#34;&gt;↑The dog&lt;/span&gt;
  
&lt;/div&gt;



 
  
  
  
  
    
  
    
      
    
  

&lt;div class=&#34;figure fig-100&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2019/06/22/silhouette.JPG&#34; title=&#34;↑Silhouette&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2019/06/22/thumbnail/silhouette.JPG&#34;  alt=&#34;↑Silhouette&#34;&gt;
  
    &lt;/a&gt;
  
   
    &lt;span class=&#34;caption&#34;&gt;↑Silhouette&lt;/span&gt;
  
&lt;/div&gt;
&lt;/p&gt;

&lt;p&gt;

 
  
  
  
  
    
  
    
      
    
  

&lt;div class=&#34;figure fig-33&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2019/06/22/reflection1.JPG&#34; title=&#34;↑Reflection&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2019/06/22/thumbnail/reflection1.JPG&#34;  alt=&#34;↑Reflection&#34;&gt;
  
    &lt;/a&gt;
  
   
    &lt;span class=&#34;caption&#34;&gt;↑Reflection&lt;/span&gt;
  
&lt;/div&gt;



 
  
  
  
  
    
  
    
      
    
  

&lt;div class=&#34;figure fig-33&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2019/06/22/reflection2.JPG&#34; title=&#34;↑Reflection&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2019/06/22/thumbnail/reflection2.JPG&#34;  alt=&#34;↑Reflection&#34;&gt;
  
    &lt;/a&gt;
  
   
    &lt;span class=&#34;caption&#34;&gt;↑Reflection&lt;/span&gt;
  
&lt;/div&gt;



 
  
  
  
  
    
  
    
      
    
  

&lt;div class=&#34;figure fig-33&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2019/06/22/reflection3.JPG&#34; title=&#34;↑Reflection&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2019/06/22/thumbnail/reflection3.JPG&#34;  alt=&#34;↑Reflection&#34;&gt;
  
    &lt;/a&gt;
  
   
    &lt;span class=&#34;caption&#34;&gt;↑Reflection&lt;/span&gt;
  
&lt;/div&gt;


 
  
  
  
  
    
  
    
      
    
  


&lt;div class=&#34;figure fig-33&#34; &gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;&#34; &gt;
  
  
&lt;/div&gt;

  &lt;div style=&#34;clear:both;&#34;&gt;&lt;/div&gt;
&lt;/p&gt;

&lt;p&gt;

 
  
  
  
  
    
  
    
      
    
  

&lt;div class=&#34;figure fig-50&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2019/06/22/bryant_park.JPG&#34; title=&#34;↑Bryant Park&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2019/06/22/thumbnail/bryant_park.JPG&#34;  alt=&#34;↑Bryant Park&#34;&gt;
  
    &lt;/a&gt;
  
   
    &lt;span class=&#34;caption&#34;&gt;↑Bryant Park&lt;/span&gt;
  
&lt;/div&gt;



 
  
  
  
  
    
  
    
      
    
  

&lt;div class=&#34;figure fig-50&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2019/06/22/traffic_light.JPG&#34; title=&#34;↑Traffic Light&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2019/06/22/thumbnail/traffic_light.JPG&#34;  alt=&#34;↑Traffic Light&#34;&gt;
  
    &lt;/a&gt;
  
   
    &lt;span class=&#34;caption&#34;&gt;↑Traffic Light&lt;/span&gt;
  
&lt;/div&gt;


 
  
  
  
  
    
  
    
      
    
  


&lt;div class=&#34;figure fig-50&#34; &gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;&#34; &gt;
  
  
&lt;/div&gt;

  &lt;div style=&#34;clear:both;&#34;&gt;&lt;/div&gt;
&lt;/p&gt;

&lt;p&gt;

 
  
  
  
  
    
  
    
      
    
  

&lt;div class=&#34;figure fig-100&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2019/06/22/records.JPG&#34; title=&#34;↑Records&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2019/06/22/thumbnail/records.JPG&#34;  alt=&#34;↑Records&#34;&gt;
  
    &lt;/a&gt;
  
   
    &lt;span class=&#34;caption&#34;&gt;↑Records&lt;/span&gt;
  
&lt;/div&gt;



 
  
  
  
  
    
  
    
      
    
  

&lt;div class=&#34;figure fig-100&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2019/06/22/wall.JPG&#34; title=&#34;↑The wall&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2019/06/22/thumbnail/wall.JPG&#34;  alt=&#34;↑The wall&#34;&gt;
  
    &lt;/a&gt;
  
   
    &lt;span class=&#34;caption&#34;&gt;↑The wall&lt;/span&gt;
  
&lt;/div&gt;
&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>世上只有两类人</title>
      <link>http://nianze.tk/2019/06/two-kinds-of-people/</link>
      <pubDate>Wed, 19 Jun 2019 17:47:31 -0400</pubDate>
      
      <guid>http://nianze.tk/2019/06/two-kinds-of-people/</guid>
      <description>&lt;p&gt;要么牛b要么去死。
&lt;/p&gt;

&lt;p&gt;今天收到NYU bursar的账单，发现两个学分的夏季课程(fundamental of music tech, review of tonal theoy I)算上注册费之类的总共要$4000+，再加上我在岛上的lease签早了一个月，两边同时交房租又要白白浪费差不多2900刀。。。一种马上要吃土了的感觉油然而生。以后需要精打细算过日子了。&lt;/p&gt;

&lt;p&gt;NYU每学分1726刀，我一学期可能最多选6学分。为了尽量精简不必要的损耗（尤其是已经在白交一个月房租的情况下），我想能waive的课都尽量waive。所以基础课程里面，tonal theory I,II以及music history三门总计4学分，我要在暑期自学后直接通过开学前的测试来waive掉；信号处理课加上实验整整有4个学分，据说开学第一周也可以报名考试来waive掉。这样省出来8个学分可就是$13,808了！在业已损失2900刀的沉重心情下，这么大一笔钱，能省就省！所以看到这些书的教材仅仅150刀的时候，真心不再觉得贵了。没有对比就没有伤害。&lt;/p&gt;

&lt;p&gt;说到对比，昨天翻Twyla Tharp的&lt;a href=&#34;https://www.goodreads.com/book/show/254799.The_Creative_Habit&#34;&gt;The Creative Habit&lt;/a&gt;，有段话很有启发（总算扯回正题）：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Robert Benchley wrote that there are two kinds of people in the world: &lt;strong&gt;those who divide the world into two kinds of people, and those who don&amp;rsquo;t.&lt;/strong&gt; I guess I&amp;rsquo;ve always been one who does. &lt;br&gt;&lt;br&gt;
I have issues with ambiguity, preferring my distinctions to be black or white. I don&amp;rsquo;t like gray &amp;hellip; I am always making these clear distinctions in my work, my daily routines, my colleagues, and my goals. Dancers are either acceptable (great) or not (everything less than great). Producers are either good or evil. Colleagues are either committed or missing in action. Critics are either my friends or enemies. The polar distinctions can go on forever.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;我对世界的认识一直是建立在某种谱系上的，所以认为每个人总是处在某种概率分布中的某个位置。也就是说，黑白之外还有广阔的灰。所以在读到《了不起的盖茨比》里父亲在书开头说的那句话&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:1&#34;&gt;&lt;a href=&#34;#fn:1&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;时，我表示非常认同。这在面对客观世界的时候可以解释很多事情，分析很多现象，宽容很多人间的不易。不过我在读完Twyla的想法后，突然发现这套站在对立面的非黑即白的评价体系其实同样有道理，她只是换了个维度审视自己和世界的关系——这是以自我为中心架构起来的一套体系，其产生的缘由很简单，看清自己，明白什么对自己重要，什么是自己欠缺的，什么是自己想要的，然后由自己出发来看他人和世界。这是相当主观的体系，但在诸如艺术这样的领域，却是唯一可行&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:2&#34;&gt;&lt;a href=&#34;#fn:2&#34;&gt;2&lt;/a&gt;&lt;/sup&gt;的视角——想要创作出厉害的作品，当然得燃烧自己的一切，把事情做到极致；做不到exceptional，那就在mediocre中默默死去。&lt;/p&gt;
&lt;div class=&#34;footnotes&#34;&gt;

&lt;hr /&gt;

&lt;ol&gt;
&lt;li id=&#34;fn:1&#34;&gt;&amp;ldquo;Whenever you feel like criticizing any one, just remember that all the people in this world haven&amp;rsquo;t had the advantages that you&amp;rsquo;ve had.&amp;rdquo;&amp;ldquo;每逢你想要对别人评头品足的时候，要记住，世上并非所有的人都有你那样的优越条件。&amp;rdquo;
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:1&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:2&#34;&gt;换做以前，我会说这“往往是更行之有效的视角”给其他潜在可能性留条后路。但站在非黑即白的世界观中，我就得相信，这是唯一解。
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:2&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;</description>
    </item>
    
    <item>
      <title>Basic Musicianship Review</title>
      <link>http://nianze.tk/2019/06/basic-musicianship-review/</link>
      <pubDate>Sat, 15 Jun 2019 19:39:39 -0400</pubDate>
      
      <guid>http://nianze.tk/2019/06/basic-musicianship-review/</guid>
      <description>&lt;p&gt;A review of some basic music theory before the NYU Steinhardt music technology placement exam.

&lt;!-- toc --&gt;&lt;/p&gt;

&lt;h1 id=&#34;intervals&#34;&gt;Intervals&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;Perfect Intervals: 1(perfect unison), 4(perfect 4th), 5(perfect 5th), 8(perfect octave)&lt;/li&gt;
&lt;li&gt;Major Intervals: 2(major 2nd), 3(major 3rd), 6(major 6th), 7(major 7th)&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;scales&#34;&gt;Scales&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;major scale (WWHWWWH)&lt;/li&gt;
&lt;li&gt;natural minor scale / aeolian scale (WHWWHWW) = based off the 6th degree that shares the key signature of the major scale&lt;/li&gt;
&lt;li&gt;harmonic minor scale(WHWWH1.5H) = natural minor + sharpened 7th degree&lt;/li&gt;
&lt;li&gt;melodic minor scale(ASC:WHWWWWH, DESC:WWHWWHW) =  the ascending form of the scale has both a raised 6th and 7th degree, and the descending form of the scale reverts back to the natural minor scale form&lt;/li&gt;
&lt;li&gt;chromatic scale(H*12) = constructed entirely of half steps or semitones.&lt;/li&gt;
&lt;li&gt;wholetone scale(W*6) = constructed entirely of whole-steps or tones.&lt;/li&gt;
&lt;li&gt;lydian scale(WWWHWWH) = based off the 4th degree of any major scale (C major scale from its fourth degree (F) -&amp;gt; F lydian scale)&lt;/li&gt;
&lt;li&gt;mixolydian scale(WWHWWHW) = based off the 5th degree of any major scale (C major scale from its fifth degree (G), -&amp;gt; G mixolydian scale)&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;chords&#34;&gt;Chords&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;Tonic: the note considered to be the basis of the chord, e.g.: C, D, …&lt;/li&gt;
&lt;li&gt;Quality

&lt;ul&gt;
&lt;li&gt;major chords = 1,3,5 notes of major scale, major 3rd followed by minor 3rd;&lt;/li&gt;
&lt;li&gt;minor chords = 1,3,5 notes of minor scale, minor 3rd followed by major 3rd, same as a major chord but the third being lowered a semitone&lt;/li&gt;
&lt;li&gt;diminished chords = similar to minor, but the top note (the fifth) is also flattened, minor 3rd followed by minor 3rd.&lt;/li&gt;
&lt;li&gt;augmented chords = similar to major, but the top note (the fifth) is raised by a semitone, major 3rd followed by a major 3rd&lt;/li&gt;
&lt;li&gt;dominat 7th chords = similar to major, with the addition of a flattened seventh above the root note of the chord (C Dominant 7th = C,E,G,bB); within a diatonic context, it’s based from the 5th/dominant of any major key, so in the key of C major, the dominant 7th chord starts on G (GBDF)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Inversion: which note of the chord is placed at the bottom (root, 1st inversion, 2nd inversion)&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;key-signatures&#34;&gt;Key Signatures&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;Relative minor &amp;amp; major keys: the sixth degree of the major key is the relative minor key, both share exactly the same key signature (C major -&amp;gt; A minor); similarly, to find the relative major of a minor key = either count down 6 notes, or count up to the 3rd note.&lt;/li&gt;
&lt;li&gt;To add a flat sign, count up four notes from root; to add a sharp, count up five notes.&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;chord-progressions&#34;&gt;Chord Progressions&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;Labelling:

&lt;ul&gt;
&lt;li&gt;C Major Root Position: C = I&lt;/li&gt;
&lt;li&gt;C Major 1st Inversion: C/E = Ib = I6 = I6/3&lt;/li&gt;
&lt;li&gt;C Major 2nd Inversion: C/G = Ic = I6/4&lt;/li&gt;
&lt;li&gt;G7 1st Inversion: G7/B = Vb = V6/5&lt;/li&gt;
&lt;li&gt;G7 2nd Inversion: G7/D = Vc = V4/3&lt;/li&gt;
&lt;li&gt;G7 3rd Inversion: G7/F = Vd = V4/2&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;meter&#34;&gt;Meter&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;Simple meters: the top number in the time signature is a 3 or divisible by 2 (e.g., &lt;sup&gt;2&lt;/sup&gt;&amp;frasl;&lt;sub&gt;4&lt;/sub&gt;, &lt;sup&gt;3&lt;/sup&gt;&amp;frasl;&lt;sub&gt;4&lt;/sub&gt;, &lt;sup&gt;4&lt;/sup&gt;&amp;frasl;&lt;sub&gt;4&lt;/sub&gt;, &lt;sup&gt;2&lt;/sup&gt;&amp;frasl;&lt;sub&gt;2&lt;/sub&gt;, &lt;sup&gt;3&lt;/sup&gt;&amp;frasl;&lt;sub&gt;2&lt;/sub&gt;, &lt;sup&gt;4&lt;/sup&gt;&amp;frasl;&lt;sub&gt;2&lt;/sub&gt;).

&lt;ul&gt;
&lt;li&gt;&lt;sup&gt;4&lt;/sup&gt;&amp;frasl;&lt;sub&gt;4&lt;/sub&gt;: simple quadruple, can be represented by a ‘C’, known as common time;&lt;/li&gt;
&lt;li&gt;&lt;sup&gt;2&lt;/sup&gt;&amp;frasl;&lt;sub&gt;2&lt;/sub&gt; can be represented by ‘C’ with a vertical line through it, known as cut common time&lt;/li&gt;
&lt;li&gt;&lt;sup&gt;2&lt;/sup&gt;&amp;frasl;&lt;sub&gt;4&lt;/sub&gt;: simple duple meter. A bar consists of 2 crotchet beats&lt;/li&gt;
&lt;li&gt;&lt;sup&gt;2&lt;/sup&gt;&amp;frasl;&lt;sub&gt;3&lt;/sub&gt;: simple triple meter. A bar consists of 3 crotchet beats&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Compound meters: top number in the time signature is divisible by 3, by a number greater than 1 (e.g., &lt;sup&gt;6&lt;/sup&gt;&amp;frasl;&lt;sub&gt;8&lt;/sub&gt;, &lt;sup&gt;9&lt;/sup&gt;&amp;frasl;&lt;sub&gt;8&lt;/sub&gt;, &lt;sup&gt;12&lt;/sup&gt;&amp;frasl;&lt;sub&gt;8&lt;/sub&gt;). The rhythmic value that is defined in the bottom number of the time signature, is grouped in 3s, which gives them distinct feel&lt;/li&gt;
&lt;li&gt;Beams: lines that connect shorter note values and help to clearly display the main beats of a meter.&lt;/li&gt;
&lt;li&gt;Grouping: as a general rule, the main beats of the meter must be clearly visible within the displayed rhythm at all times&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>[Weekly-7] 2019.06.15</title>
      <link>http://nianze.tk/2019/06/2019-06-15-street-photography/</link>
      <pubDate>Sat, 15 Jun 2019 18:06:09 -0400</pubDate>
      
      <guid>http://nianze.tk/2019/06/2019-06-15-street-photography/</guid>
      <description>&lt;p&gt;Weekly shots - 2019/06/15
&lt;/p&gt;

&lt;p&gt;.


 
  
  
  
  
    
  
    
      
    
  

&lt;div class=&#34;figure fig-100&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2019/06/15/birds.jpeg&#34; title=&#34;↑Birds&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2019/06/15/thumbnail/birds.jpeg&#34;  alt=&#34;↑Birds&#34;&gt;
  
    &lt;/a&gt;
  
   
    &lt;span class=&#34;caption&#34;&gt;↑Birds&lt;/span&gt;
  
&lt;/div&gt;
&lt;/p&gt;

&lt;p&gt;

 
  
  
  
  
    
  
    
      
    
  

&lt;div class=&#34;figure fig-33&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2019/06/15/think.jpeg&#34; title=&#34;↑Think&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2019/06/15/thumbnail/think.jpeg&#34;  alt=&#34;↑Think&#34;&gt;
  
    &lt;/a&gt;
  
   
    &lt;span class=&#34;caption&#34;&gt;↑Think&lt;/span&gt;
  
&lt;/div&gt;



 
  
  
  
  
    
  
    
      
    
  

&lt;div class=&#34;figure fig-33&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2019/06/15/stand.jpg&#34; title=&#34;↑Stand&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2019/06/15/thumbnail/stand.jpg&#34;  alt=&#34;↑Stand&#34;&gt;
  
    &lt;/a&gt;
  
   
    &lt;span class=&#34;caption&#34;&gt;↑Stand&lt;/span&gt;
  
&lt;/div&gt;



 
  
  
  
  
    
  
    
      
    
  

&lt;div class=&#34;figure fig-33&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2019/06/15/shoot.jpeg&#34; title=&#34;↑Shoot&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2019/06/15/thumbnail/shoot.jpeg&#34;  alt=&#34;↑Shoot&#34;&gt;
  
    &lt;/a&gt;
  
   
    &lt;span class=&#34;caption&#34;&gt;↑Shoot&lt;/span&gt;
  
&lt;/div&gt;


 
  
  
  
  
    
  
    
      
    
  


&lt;div class=&#34;figure fig-33&#34; &gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;&#34; &gt;
  
  
&lt;/div&gt;

  &lt;div style=&#34;clear:both;&#34;&gt;&lt;/div&gt;
&lt;/p&gt;

&lt;p&gt;

 
  
  
  
  
    
  
    
      
    
  

&lt;div class=&#34;figure fig-33&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2019/06/15/idle.jpeg&#34; title=&#34;↑Think&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2019/06/15/thumbnail/idle.jpeg&#34;  alt=&#34;↑Think&#34;&gt;
  
    &lt;/a&gt;
  
   
    &lt;span class=&#34;caption&#34;&gt;↑Think&lt;/span&gt;
  
&lt;/div&gt;



 
  
  
  
  
    
  
    
      
    
  

&lt;div class=&#34;figure fig-33&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2019/06/15/hold.jpg&#34; title=&#34;↑Hold&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2019/06/15/thumbnail/hold.jpg&#34;  alt=&#34;↑Hold&#34;&gt;
  
    &lt;/a&gt;
  
   
    &lt;span class=&#34;caption&#34;&gt;↑Hold&lt;/span&gt;
  
&lt;/div&gt;



 
  
  
  
  
    
  
    
      
    
  

&lt;div class=&#34;figure fig-33&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2019/06/15/wait.jpeg&#34; title=&#34;↑Wait&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2019/06/15/thumbnail/wait.jpeg&#34;  alt=&#34;↑Wait&#34;&gt;
  
    &lt;/a&gt;
  
   
    &lt;span class=&#34;caption&#34;&gt;↑Wait&lt;/span&gt;
  
&lt;/div&gt;


 
  
  
  
  
    
  
    
      
    
  


&lt;div class=&#34;figure fig-33&#34; &gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;&#34; &gt;
  
  
&lt;/div&gt;

  &lt;div style=&#34;clear:both;&#34;&gt;&lt;/div&gt;
&lt;/p&gt;



 
  
  
  
  
    
  
    
      
    
  

&lt;div class=&#34;figure fig-100&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2019/06/15/chat.jpeg&#34; title=&#34;↑Chat&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2019/06/15/thumbnail/chat.jpeg&#34;  alt=&#34;↑Chat&#34;&gt;
  
    &lt;/a&gt;
  
   
    &lt;span class=&#34;caption&#34;&gt;↑Chat&lt;/span&gt;
  
&lt;/div&gt;</description>
    </item>
    
    <item>
      <title>[Weekly-6] 2019.06.08</title>
      <link>http://nianze.tk/2019/06/2019-06-08-street-photography/</link>
      <pubDate>Sat, 08 Jun 2019 00:00:00 +0000</pubDate>
      
      <guid>http://nianze.tk/2019/06/2019-06-08-street-photography/</guid>
      <description>&lt;p&gt;Weekly shots - 2019/06/08
&lt;/p&gt;

&lt;p&gt;.


 
  
  
  
  
    
  
    
      
    
  

&lt;div class=&#34;figure fig-100&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2019/06/08/moon_plane.jpeg&#34; title=&#34;↑Moon plane&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2019/06/08/thumbnail/moon_plane.jpeg&#34;  alt=&#34;↑Moon plane&#34;&gt;
  
    &lt;/a&gt;
  
   
    &lt;span class=&#34;caption&#34;&gt;↑Moon plane&lt;/span&gt;
  
&lt;/div&gt;
&lt;/p&gt;

&lt;p&gt;

 
  
  
  
  
    
  
    
      
    
  

&lt;div class=&#34;figure fig-33&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2019/06/08/date.jpeg&#34; title=&#34;↑Date&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2019/06/08/thumbnail/date.jpeg&#34;  alt=&#34;↑Date&#34;&gt;
  
    &lt;/a&gt;
  
   
    &lt;span class=&#34;caption&#34;&gt;↑Date&lt;/span&gt;
  
&lt;/div&gt;



 
  
  
  
  
    
  
    
      
    
  

&lt;div class=&#34;figure fig-33&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2019/06/08/epiphone.jpeg&#34; title=&#34;↑Epiphone&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2019/06/08/thumbnail/epiphone.jpeg&#34;  alt=&#34;↑Epiphone&#34;&gt;
  
    &lt;/a&gt;
  
   
    &lt;span class=&#34;caption&#34;&gt;↑Epiphone&lt;/span&gt;
  
&lt;/div&gt;



 
  
  
  
  
    
  
    
      
    
  

&lt;div class=&#34;figure fig-33&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2019/06/08/flower_in_strand.jpeg&#34; title=&#34;↑Flower in Strand&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2019/06/08/thumbnail/flower_in_strand.jpeg&#34;  alt=&#34;↑Flower in Strand&#34;&gt;
  
    &lt;/a&gt;
  
   
    &lt;span class=&#34;caption&#34;&gt;↑Flower in Strand&lt;/span&gt;
  
&lt;/div&gt;


 
  
  
  
  
    
  
    
      
    
  


&lt;div class=&#34;figure fig-33&#34; &gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;&#34; &gt;
  
  
&lt;/div&gt;

  &lt;div style=&#34;clear:both;&#34;&gt;&lt;/div&gt;
&lt;/p&gt;

&lt;p&gt;

 
  
  
  
  
    
  
    
      
    
  

&lt;div class=&#34;figure fig-50&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2019/06/08/search.jpeg&#34; title=&#34;↑Search&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2019/06/08/thumbnail/search.jpeg&#34;  alt=&#34;↑Search&#34;&gt;
  
    &lt;/a&gt;
  
   
    &lt;span class=&#34;caption&#34;&gt;↑Search&lt;/span&gt;
  
&lt;/div&gt;



 
  
  
  
  
    
  
    
      
    
  

&lt;div class=&#34;figure fig-50&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2019/06/08/stand.jpeg&#34; title=&#34;↑Stand up&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2019/06/08/thumbnail/stand.jpeg&#34;  alt=&#34;↑Stand up&#34;&gt;
  
    &lt;/a&gt;
  
   
    &lt;span class=&#34;caption&#34;&gt;↑Stand up&lt;/span&gt;
  
&lt;/div&gt;


 
  
  
  
  
    
  
    
      
    
  


&lt;div class=&#34;figure fig-50&#34; &gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;&#34; &gt;
  
  
&lt;/div&gt;

  &lt;div style=&#34;clear:both;&#34;&gt;&lt;/div&gt;
&lt;/p&gt;



 
  
  
  
  
    
  
    
      
    
  

&lt;div class=&#34;figure fig-100&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2019/06/08/stares.jpeg&#34; title=&#34;↑Stares&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2019/06/08/thumbnail/stares.jpeg&#34;  alt=&#34;↑Stares&#34;&gt;
  
    &lt;/a&gt;
  
   
    &lt;span class=&#34;caption&#34;&gt;↑Stares&lt;/span&gt;
  
&lt;/div&gt;</description>
    </item>
    
    <item>
      <title>[Weekly-5] 2019.06.01</title>
      <link>http://nianze.tk/2019/06/2019-06-01-street-photography/</link>
      <pubDate>Sat, 01 Jun 2019 00:00:00 +0000</pubDate>
      
      <guid>http://nianze.tk/2019/06/2019-06-01-street-photography/</guid>
      <description>&lt;p&gt;Weekly shots - 2019/06/01
&lt;/p&gt;

&lt;p&gt;今年纽约的5月总爱下雨，让人不禁多愁善感起来。&lt;/p&gt;

&lt;p&gt;.


 
  
  
  
  
    
  
    
      
    
  

&lt;div class=&#34;figure fig-100&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2019/06/01/look_down.jpeg&#34; title=&#34;↑Look down&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2019/06/01/thumbnail/look_down.jpeg&#34;  alt=&#34;↑Look down&#34;&gt;
  
    &lt;/a&gt;
  
   
    &lt;span class=&#34;caption&#34;&gt;↑Look down&lt;/span&gt;
  
&lt;/div&gt;
&lt;/p&gt;



 
  
  
  
  
    
  
    
      
    
  

&lt;div class=&#34;figure fig-100&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2019/06/01/broken_pepper.jpeg&#34; title=&#34;↑Broken Pepper&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2019/06/01/thumbnail/broken_pepper.jpeg&#34;  alt=&#34;↑Broken Pepper&#34;&gt;
  
    &lt;/a&gt;
  
   
    &lt;span class=&#34;caption&#34;&gt;↑Broken Pepper&lt;/span&gt;
  
&lt;/div&gt;


&lt;p&gt;

 
  
  
  
  
    
  
    
      
    
  

&lt;div class=&#34;figure fig-33&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2019/06/01/kid_on_scooter.jpeg&#34; title=&#34;↑Kid on Scooter&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2019/06/01/thumbnail/kid_on_scooter.jpeg&#34;  alt=&#34;↑Kid on Scooter&#34;&gt;
  
    &lt;/a&gt;
  
   
    &lt;span class=&#34;caption&#34;&gt;↑Kid on Scooter&lt;/span&gt;
  
&lt;/div&gt;



 
  
  
  
  
    
  
    
      
    
  

&lt;div class=&#34;figure fig-33&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2019/06/01/reading.jpeg&#34; title=&#34;↑Reading&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2019/06/01/thumbnail/reading.jpeg&#34;  alt=&#34;↑Reading&#34;&gt;
  
    &lt;/a&gt;
  
   
    &lt;span class=&#34;caption&#34;&gt;↑Reading&lt;/span&gt;
  
&lt;/div&gt;



 
  
  
  
  
    
  
    
      
    
  

&lt;div class=&#34;figure fig-33&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2019/06/01/sunglasses.jpeg&#34; title=&#34;↑Sunglasses&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2019/06/01/thumbnail/sunglasses.jpeg&#34;  alt=&#34;↑Sunglasses&#34;&gt;
  
    &lt;/a&gt;
  
   
    &lt;span class=&#34;caption&#34;&gt;↑Sunglasses&lt;/span&gt;
  
&lt;/div&gt;
&lt;/p&gt;

&lt;p&gt;

 
  
  
  
  
    
  
    
      
    
  

&lt;div class=&#34;figure fig-33&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2019/06/01/biker_in_rain.jpeg&#34; title=&#34;↑Biker&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2019/06/01/thumbnail/biker_in_rain.jpeg&#34;  alt=&#34;↑Biker&#34;&gt;
  
    &lt;/a&gt;
  
   
    &lt;span class=&#34;caption&#34;&gt;↑Biker&lt;/span&gt;
  
&lt;/div&gt;



 
  
  
  
  
    
  
    
      
    
  

&lt;div class=&#34;figure fig-33&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2019/06/01/pic_in_rain.jpeg&#34; title=&#34;↑Taking pictures&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2019/06/01/thumbnail/pic_in_rain.jpeg&#34;  alt=&#34;↑Taking pictures&#34;&gt;
  
    &lt;/a&gt;
  
   
    &lt;span class=&#34;caption&#34;&gt;↑Taking pictures&lt;/span&gt;
  
&lt;/div&gt;



 
  
  
  
  
    
  
    
      
    
  

&lt;div class=&#34;figure fig-33&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2019/06/01/six_ave.jpeg&#34; title=&#34;↑Six Ave.&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2019/06/01/thumbnail/six_ave.jpeg&#34;  alt=&#34;↑Six Ave.&#34;&gt;
  
    &lt;/a&gt;
  
   
    &lt;span class=&#34;caption&#34;&gt;↑Six Ave.&lt;/span&gt;
  
&lt;/div&gt;


 
  
  
  
  
    
  
    
      
    
  


&lt;div class=&#34;figure fig-33&#34; &gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;&#34; &gt;
  
  
&lt;/div&gt;

  &lt;div style=&#34;clear:both;&#34;&gt;&lt;/div&gt;
&lt;/p&gt;

&lt;p&gt;

 
  
  
  
  
    
  
    
      
    
  

&lt;div class=&#34;figure fig-50&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2019/06/01/time_sq.jpeg&#34; title=&#34;↑Time Square&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2019/06/01/thumbnail/time_sq.jpeg&#34;  alt=&#34;↑Time Square&#34;&gt;
  
    &lt;/a&gt;
  
   
    &lt;span class=&#34;caption&#34;&gt;↑Time Square&lt;/span&gt;
  
&lt;/div&gt;



 
  
  
  
  
    
  
    
      
    
  

&lt;div class=&#34;figure fig-50&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2019/06/01/reflection.jpeg&#34; title=&#34;↑Reflection&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2019/06/01/thumbnail/reflection.jpeg&#34;  alt=&#34;↑Reflection&#34;&gt;
  
    &lt;/a&gt;
  
   
    &lt;span class=&#34;caption&#34;&gt;↑Reflection&lt;/span&gt;
  
&lt;/div&gt;


 
  
  
  
  
    
  
    
      
    
  


&lt;div class=&#34;figure fig-50&#34; &gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;&#34; &gt;
  
  
&lt;/div&gt;

  &lt;div style=&#34;clear:both;&#34;&gt;&lt;/div&gt;
&lt;/p&gt;

&lt;p&gt;

 
  
  
  
  
    
  
    
      
    
  

&lt;div class=&#34;figure fig-100&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2019/06/01/walgreens.jpeg&#34; title=&#34;↑Walgreens&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2019/06/01/thumbnail/walgreens.jpeg&#34;  alt=&#34;↑Walgreens&#34;&gt;
  
    &lt;/a&gt;
  
   
    &lt;span class=&#34;caption&#34;&gt;↑Walgreens&lt;/span&gt;
  
&lt;/div&gt;



 
  
  
  
  
    
  
    
      
    
  

&lt;div class=&#34;figure fig-100&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2019/06/01/zebra.jpeg&#34; title=&#34;↑Zebra crossing&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2019/06/01/thumbnail/zebra.jpeg&#34;  alt=&#34;↑Zebra crossing&#34;&gt;
  
    &lt;/a&gt;
  
   
    &lt;span class=&#34;caption&#34;&gt;↑Zebra crossing&lt;/span&gt;
  
&lt;/div&gt;
&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>[Weekly-4] 2019.05.25</title>
      <link>http://nianze.tk/2019/05/2019-05-25-street-photography/</link>
      <pubDate>Sat, 25 May 2019 00:00:00 +0000</pubDate>
      
      <guid>http://nianze.tk/2019/05/2019-05-25-street-photography/</guid>
      <description>&lt;p&gt;Weekly shots - 2019/05/25
&lt;/p&gt;

&lt;p&gt;.


 
  
  
  
  
    
  
    
      
    
  

&lt;div class=&#34;figure fig-33&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2019/05/25/squirrel.jpeg&#34; title=&#34;↑Squirrel&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2019/05/25/squirrel.jpeg&#34;  alt=&#34;↑Squirrel&#34;&gt;
  
    &lt;/a&gt;
  
   
    &lt;span class=&#34;caption&#34;&gt;↑Squirrel&lt;/span&gt;
  
&lt;/div&gt;



 
  
  
  
  
    
  
    
      
    
  

&lt;div class=&#34;figure fig-33&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2019/05/25/red.jpeg&#34; title=&#34;↑Red&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2019/05/25/red.jpeg&#34;  alt=&#34;↑Red&#34;&gt;
  
    &lt;/a&gt;
  
   
    &lt;span class=&#34;caption&#34;&gt;↑Red&lt;/span&gt;
  
&lt;/div&gt;



 
  
  
  
  
    
  
    
      
    
  

&lt;div class=&#34;figure fig-33&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2019/05/25/geese.jpeg&#34; title=&#34;↑Geese&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2019/05/25/geese.jpeg&#34;  alt=&#34;↑Geese&#34;&gt;
  
    &lt;/a&gt;
  
   
    &lt;span class=&#34;caption&#34;&gt;↑Geese&lt;/span&gt;
  
&lt;/div&gt;


 
  
  
  
  
    
  
    
      
    
  


&lt;div class=&#34;figure fig-33&#34; &gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;&#34; &gt;
  
  
&lt;/div&gt;

  &lt;div style=&#34;clear:both;&#34;&gt;&lt;/div&gt;
&lt;/p&gt;



 
  
  
  
  
    
  
    
      
    
  

&lt;div class=&#34;figure fig-100&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2019/05/25/hide.jpeg&#34; title=&#34;↑Hide&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2019/05/25/hide.jpeg&#34;  alt=&#34;↑Hide&#34;&gt;
  
    &lt;/a&gt;
  
   
    &lt;span class=&#34;caption&#34;&gt;↑Hide&lt;/span&gt;
  
&lt;/div&gt;


&lt;p&gt;

 
  
  
  
  
    
  
    
      
    
  

&lt;div class=&#34;figure fig-50&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2019/05/25/yummy.jpeg&#34; title=&#34;↑Yummy&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2019/05/25/yummy.jpeg&#34;  alt=&#34;↑Yummy&#34;&gt;
  
    &lt;/a&gt;
  
   
    &lt;span class=&#34;caption&#34;&gt;↑Yummy&lt;/span&gt;
  
&lt;/div&gt;



 
  
  
  
  
    
  
    
      
    
  

&lt;div class=&#34;figure fig-50&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2019/05/25/dance.jpeg&#34; title=&#34;↑Dance&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2019/05/25/dance.jpeg&#34;  alt=&#34;↑Dance&#34;&gt;
  
    &lt;/a&gt;
  
   
    &lt;span class=&#34;caption&#34;&gt;↑Dance&lt;/span&gt;
  
&lt;/div&gt;


 
  
  
  
  
    
  
    
      
    
  


&lt;div class=&#34;figure fig-50&#34; &gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;&#34; &gt;
  
  
&lt;/div&gt;

  &lt;div style=&#34;clear:both;&#34;&gt;&lt;/div&gt;
&lt;/p&gt;

&lt;p&gt;

 
  
  
  
  
    
  
    
      
    
  

&lt;div class=&#34;figure fig-100&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2019/05/25/road.jpeg&#34; title=&#34;↑Road&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2019/05/25/road.jpeg&#34;  alt=&#34;↑Road&#34;&gt;
  
    &lt;/a&gt;
  
   
    &lt;span class=&#34;caption&#34;&gt;↑Road&lt;/span&gt;
  
&lt;/div&gt;



 
  
  
  
  
    
  
    
      
    
  

&lt;div class=&#34;figure fig-100&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2019/05/25/riverside.jpeg&#34; title=&#34;↑Reverside&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2019/05/25/riverside.jpeg&#34;  alt=&#34;↑Reverside&#34;&gt;
  
    &lt;/a&gt;
  
   
    &lt;span class=&#34;caption&#34;&gt;↑Reverside&lt;/span&gt;
  
&lt;/div&gt;
&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>[Weekly-3] 2019.05.18</title>
      <link>http://nianze.tk/2019/05/2019-05-18-street-photography/</link>
      <pubDate>Sat, 18 May 2019 00:00:00 +0000</pubDate>
      
      <guid>http://nianze.tk/2019/05/2019-05-18-street-photography/</guid>
      <description>&lt;p&gt;Weekly shots - 2019/05/18
&lt;/p&gt;

&lt;p&gt;

 
  
  
  
  
    
  
    
      
    
  

&lt;div class=&#34;figure fig-100&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2019/05/18/flower.jpeg&#34; title=&#34;↑Flower&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2019/05/18/flower.jpeg&#34;  alt=&#34;↑Flower&#34;&gt;
  
    &lt;/a&gt;
  
   
    &lt;span class=&#34;caption&#34;&gt;↑Flower&lt;/span&gt;
  
&lt;/div&gt;



 
  
  
  
  
    
  
    
      
    
  

&lt;div class=&#34;figure fig-100&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2019/05/18/hats.jpeg&#34; title=&#34;↑Hats&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2019/05/18/hats.jpeg&#34;  alt=&#34;↑Hats&#34;&gt;
  
    &lt;/a&gt;
  
   
    &lt;span class=&#34;caption&#34;&gt;↑Hats&lt;/span&gt;
  
&lt;/div&gt;
&lt;/p&gt;

&lt;p&gt;

 
  
  
  
  
    
  
    
      
    
  

&lt;div class=&#34;figure fig-100&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2019/05/18/mother_son_1.jpeg&#34; title=&#34;↑Mother and son&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2019/05/18/mother_son_1.jpeg&#34;  alt=&#34;↑Mother and son&#34;&gt;
  
    &lt;/a&gt;
  
   
    &lt;span class=&#34;caption&#34;&gt;↑Mother and son&lt;/span&gt;
  
&lt;/div&gt;



 
  
  
  
  
    
  
    
      
    
  

&lt;div class=&#34;figure fig-100&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2019/05/18/mother_son_2.jpeg&#34; title=&#34;↑Mother and son&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2019/05/18/mother_son_2.jpeg&#34;  alt=&#34;↑Mother and son&#34;&gt;
  
    &lt;/a&gt;
  
   
    &lt;span class=&#34;caption&#34;&gt;↑Mother and son&lt;/span&gt;
  
&lt;/div&gt;
&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>[Weekly-2] 2019.05.11</title>
      <link>http://nianze.tk/2019/05/2019-05-11-street-photography/</link>
      <pubDate>Sat, 11 May 2019 00:00:00 +0000</pubDate>
      
      <guid>http://nianze.tk/2019/05/2019-05-11-street-photography/</guid>
      <description>&lt;p&gt;Weekly shots - 2019/05/11
&lt;/p&gt;

&lt;p&gt;

 
  
  
  
  
    
  
    
      
    
  

&lt;div class=&#34;figure fig-100&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2019/05/11/turn_around.jpeg&#34; title=&#34;↑Turn around&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2019/05/11/turn_around.jpeg&#34;  alt=&#34;↑Turn around&#34;&gt;
  
    &lt;/a&gt;
  
   
    &lt;span class=&#34;caption&#34;&gt;↑Turn around&lt;/span&gt;
  
&lt;/div&gt;



 
  
  
  
  
    
  
    
      
    
  

&lt;div class=&#34;figure fig-100&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2019/05/11/tramp.jpeg&#34; title=&#34;↑Tramp&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2019/05/11/tramp.jpeg&#34;  alt=&#34;↑Tramp&#34;&gt;
  
    &lt;/a&gt;
  
   
    &lt;span class=&#34;caption&#34;&gt;↑Tramp&lt;/span&gt;
  
&lt;/div&gt;
&lt;/p&gt;

&lt;p&gt;

 
  
  
  
  
    
  
    
      
    
  

&lt;div class=&#34;figure fig-100&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2019/05/11/kids.jpeg&#34; title=&#34;Kids&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2019/05/11/kids.jpeg&#34;  alt=&#34;Kids&#34;&gt;
  
    &lt;/a&gt;
  
   
    &lt;span class=&#34;caption&#34;&gt;Kids&lt;/span&gt;
  
&lt;/div&gt;



 
  
  
  
  
    
  
    
      
    
  

&lt;div class=&#34;figure fig-100&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2019/05/11/lick.jpeg&#34; title=&#34;↑Lick&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2019/05/11/lick.jpeg&#34;  alt=&#34;↑Lick&#34;&gt;
  
    &lt;/a&gt;
  
   
    &lt;span class=&#34;caption&#34;&gt;↑Lick&lt;/span&gt;
  
&lt;/div&gt;
&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>[Weekly-1] May the 4th..</title>
      <link>http://nianze.tk/2019/05/2019-05-04-street-photography/</link>
      <pubDate>Sat, 04 May 2019 00:00:00 +0000</pubDate>
      
      <guid>http://nianze.tk/2019/05/2019-05-04-street-photography/</guid>
      <description>&lt;p&gt;Weekly shots - .. (be with you)
&lt;/p&gt;

&lt;p&gt;最近读了Twyla Tharp的&lt;a href=&#34;https://www.goodreads.com/book/show/254799.The_Creative_Habit&#34;&gt;The Creative Habit&lt;/a&gt;,很受启发。我决定每天下班回家的时候，在纽约的街头多走走，用随身的手机街拍。每周六就节选出比较好的照片发到这里来，作为岁月的留念。&lt;/p&gt;

&lt;p&gt;.


 
  
  
  
  
    
  
    
      
    
  

&lt;div class=&#34;figure fig-100&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2019/05/04/union_sq.jpeg&#34; title=&#34;↑Union Square&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2019/05/04/union_sq.jpeg&#34;  alt=&#34;↑Union Square&#34;&gt;
  
    &lt;/a&gt;
  
   
    &lt;span class=&#34;caption&#34;&gt;↑Union Square&lt;/span&gt;
  
&lt;/div&gt;
&lt;/p&gt;



 
  
  
  
  
    
  
    
      
    
  

&lt;div class=&#34;figure fig-100&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2019/05/04/canada_goose.jpeg&#34; title=&#34;↑Canada Goose&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2019/05/04/canada_goose.jpeg&#34;  alt=&#34;↑Canada Goose&#34;&gt;
  
    &lt;/a&gt;
  
   
    &lt;span class=&#34;caption&#34;&gt;↑Canada Goose&lt;/span&gt;
  
&lt;/div&gt;</description>
    </item>
    
    <item>
      <title>Trade Beats</title>
      <link>http://nianze.tk/2018/12/use-trading-market-data-to-create-beat-sounds/</link>
      <pubDate>Sun, 16 Dec 2018 00:00:00 +0000</pubDate>
      
      <guid>http://nianze.tk/2018/12/use-trading-market-data-to-create-beat-sounds/</guid>
      <description>&lt;p&gt;What would it sound like if trading market data speaks?
&lt;/p&gt;

&lt;h1 id=&#34;a-little-background&#34;&gt;A little background&lt;/h1&gt;

&lt;p&gt;This little project tries to do one thing for fun: to transform the trading market history data into some sords of sound.&lt;/p&gt;

&lt;p&gt;The techniques involve some basic use of web audio API and D3.js. All the ticker names are collected from &lt;a href=&#34;https://dumbstockapi.com/&#34;&gt;dumb stock api&lt;/a&gt;, while all the trading history data comes from &lt;a href=&#34;https://www.alphavantage.co/&#34;&gt;ALPHA VANTAGE&lt;/a&gt;. Since support for web audio API is different by different browsers, it is highly suggested to try this demo with Chrome.&lt;/p&gt;

&lt;div&gt;
    &lt;link rel=&#34;stylesheet&#34; type=&#34;text/css&#34; href=&#34;http://nianze.tk/css/trading-audio/techan.css&#34; /&gt;
    &lt;link rel=&#34;stylesheet&#34; type=&#34;text/css&#34; href=&#34;http://nianze.tk/css/trading-audio/awesomplete.css&#34; /&gt;
    &lt;link rel=&#34;stylesheet&#34; type=&#34;text/css&#34; href=&#34;http://nianze.tk/css/trading-audio/style.css&#34; /&gt;
    &lt;link rel=&#34;stylesheet&#34; href=&#34;https://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css&#34;&gt;
    &lt;script src=&#34;http://d3js.org/d3.v4.min.js&#34;&gt;&lt;/script&gt;
    &lt;script src=&#34;http://nianze.tk/js/trading-audio/techan.min.js&#34;&gt;&lt;/script&gt;
    &lt;script src=&#34;http://nianze.tk/js/trading-audio/awesomplete.min.js&#34;&gt;&lt;/script&gt;
    &lt;script src=&#34;http://nianze.tk/js/trading-audio/main.js&#34; type=&#34;module&#34;&gt;&lt;/script&gt;
    &lt;div&gt;-&lt;/div&gt;
&lt;/div&gt;

&lt;div&gt;
    &lt;section id=&#34;combobox&#34;&gt;
            &lt;label id=&#34;exchange-combobox&#34;&gt;
                &lt;input id=&#34;exchange-input&#34; placeholder=&#34;Select an exchange&#34; class=&#34;dropdown-input&#34; /&gt;
                &lt;button id=&#34;exchange-btn&#34; class=&#34;dropdown-btn&#34; type=&#34;button&#34;&gt;&lt;span class=&#34;caret&#34;&gt;&lt;/span&gt;&lt;/button&gt;
            &lt;/label&gt;
            &lt;label id=&#34;ticker-combobox&#34;&gt;
                &lt;input id=&#34;ticker-input&#34; placeholder=&#34;Enter a ticker name&#34; class=&#34;dropdown-input&#34; /&gt;
                &lt;button id=&#34;ticker-btn&#34; class=&#34;dropdown-btn&#34; type=&#34;button&#34;&gt;&lt;span class=&#34;caret&#34;&gt;&lt;/span&gt;&lt;/button&gt;
            &lt;/label&gt;
            &lt;button id=&#34;togglePlay&#34; hidden&gt;&lt;i class=&#34;fa fa-play&#34;&gt;&lt;/i&gt;&lt;/button&gt;
    &lt;/section&gt;
&lt;div&gt;

&lt;div&gt;&lt;/div&gt;

&lt;blockquote&gt;
&lt;p&gt;Feel free to choose any company interesting to you by typing/selecting corresponding stock exchange name as well as company security ticker (e.g.: NASDAQ for exchange and FB as ticker to listen to how Facebook sounds like.)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div id=&#34;demo&#34;&gt;
    &lt;div id=&#34;chart&#34; hidden&gt;&lt;/div&gt;
&lt;/div&gt;

&lt;p&gt;Currently the mapping from market data to sound is naive:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Each beat stands for one day of the security price in the past, ordered by the security&amp;rsquo;s trading history.&lt;/li&gt;
&lt;li&gt;Sound frequency: the higher the daily close price, the higher the frequency.&lt;/li&gt;
&lt;li&gt;Waveform: if the daily open price is lower than close price, a beat of triangle wave sound is generated, otherwise the sine wave.&lt;/li&gt;
&lt;li&gt;Duration between each two beats are determined by the earlier day&amp;rsquo;s market volume: larger market volume comes with shorter duration.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Apart from the chart for market data, each beat is also visualized to show their waveform and frequency domain distribution.&lt;/p&gt;

&lt;div id=&#34;demo&#34;&gt;
    &lt;canvas id=&#34;proceduralCanvas&#34; hidden&gt;&lt;/canvas&gt;
&lt;/div&gt;

&lt;p&gt;Of course, listening to only one security ticker at a time isn&amp;rsquo;t that much fun. Some good way to extend this project might be to map multiple securities into different sounds, and play them simultaneously, in the hope of creating some sort of &amp;ldquo;symphony&amp;rdquo;.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>[EMCpp]Item-40 Use std::atomic for Concurrency, volatile for Special Memory</title>
      <link>http://nianze.tk/2018/10/use-stdatomic-for-concurrency-volatile-for-special-memory/</link>
      <pubDate>Tue, 30 Oct 2018 19:05:01 -0400</pubDate>
      
      <guid>http://nianze.tk/2018/10/use-stdatomic-for-concurrency-volatile-for-special-memory/</guid>
      <description>&lt;p&gt;&lt;code&gt;std::atomic&lt;/code&gt; is for data accessed from multiple threads without using mutexes (concurrent usage); &lt;code&gt;volatile&lt;/code&gt; is for memory where reads and writes should not be optimised away (special memory).
&lt;/p&gt;

&lt;h1 id=&#34;std-atomic-template&#34;&gt;&lt;code&gt;std::atomic&lt;/code&gt; template&lt;/h1&gt;

&lt;p&gt;Instantiations of &lt;code&gt;std::atomic&lt;/code&gt; template offer operations that are guaranteed to be seen as atomic by other threads, as if they were inside a mutex-protected critical section, generally with the support of special machine instructions that are more efficient than the case of mutex. For example:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;std::atomic&amp;lt;int&amp;gt; ai(0);  // init. ai to 0
ai = 10;                 // atomically set ai to 10
std::cout &amp;lt;&amp;lt; ai;         // atomically read ai&#39;s value
++ai;                    // atomically increment ai to 11
--ai;                    // atomically decrement ai to 10
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;During execution of these statements, other threads reading &lt;code&gt;ai&lt;/code&gt; may see only values of 0, 10, or 11 (assuming, of course, this is the only thread modifying &lt;code&gt;ai&lt;/code&gt;). Two things worth noting here:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;For &lt;code&gt;std::cout &amp;lt;&amp;lt; ai;&lt;/code&gt;, only the read of &lt;code&gt;ai&lt;/code&gt; is atomic, so it&amp;rsquo;s possible that between the time &lt;code&gt;ai&lt;/code&gt;&amp;rsquo;s value is rad and &lt;code&gt;operator&amp;lt;&amp;lt;&lt;/code&gt; is invoked to write it to standard output, another thread may modify &lt;code&gt;ai&lt;/code&gt;&amp;rsquo;s value.&lt;/li&gt;
&lt;li&gt;The increment and decrement of &lt;code&gt;ai&lt;/code&gt; are &lt;em&gt;read-modify-write (RMW)&lt;/em&gt; operations, and they execute atomatically as well, which is one of the nicest characteristics of the &lt;code&gt;std::atomic&lt;/code&gt; types that they guarantee all member functions on &lt;code&gt;std::atomic&lt;/code&gt; types will be seen by other threads as atomic.&lt;/li&gt;
&lt;li&gt;The use of &lt;code&gt;std::atomic&lt;/code&gt; imposes restrictions that no code precedes a write of a &lt;code&gt;std::atomic&lt;/code&gt; variable may take place afterwards. No reorder tricks for compiler/hardwaes for speed-up optimization purpose.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;In contrast, &lt;code&gt;volatile&lt;/code&gt; offers &lt;em&gt;no guarantee of operation atomicity&lt;/em&gt; and suffer &lt;em&gt;insufficient restrictions on code reordering&lt;/em&gt; - basically not useful in multithreaded context. Say if we have a counter defined as &lt;code&gt;volatile int vc(0)&lt;/code&gt;, and there are two threads increment the &lt;code&gt;volatile&lt;/code&gt; counter simultaneously, then the ending value of &lt;code&gt;vc&lt;/code&gt; need not be &lt;code&gt;2&lt;/code&gt; - the RMW operation in each of two threads may take place in any order, involving in a data race, which leading to undefined behavior according to Standard&amp;rsquo;s decree.&lt;/p&gt;

&lt;p&gt;The place in which &lt;code&gt;volatile&lt;/code&gt; shines is in the context where &lt;em&gt;redundant loads&lt;/em&gt; and &lt;em&gt;dead stores&lt;/em&gt; should not be optimized away, that is, we need special memory to perform such kinds of redundent reads and superfluous writes:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;auto y = x;  // read x
y = x;       // read x again

x = 10;      // write x
x = 20;      // write x again
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The most common kind of special memory is memory used for &lt;em&gt;memory-mapped I/O&lt;/em&gt;, which is used for communication with peripherals, e.g., external sensors or displays, printers, network ports, etc. rather than reading or writing normal memory (i.e., RAM). &lt;code&gt;volatile&lt;/code&gt; is the way to tell compilers that we&amp;rsquo;re dealing with special memory.&lt;/p&gt;

&lt;p&gt;Because &lt;code&gt;std::atomic&lt;/code&gt; and &lt;code&gt;volatile&lt;/code&gt; serve different purposes, they can be used together:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;volatile std::atomic&amp;lt;int&amp;gt; vai;  // operations on vai are atomic and can&#39;t be optimized away
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This could be useful if &lt;code&gt;vai&lt;/code&gt; corresponded to a memory-mapped I/O location that was concurrently accessed by multiple threads.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>[EMCpp]Item-39 Consider Void Futures for One-Shot Event Communication</title>
      <link>http://nianze.tk/2018/10/consider-void-futures-for-one-shot-event-communication/</link>
      <pubDate>Thu, 11 Oct 2018 19:23:06 -0400</pubDate>
      
      <guid>http://nianze.tk/2018/10/consider-void-futures-for-one-shot-event-communication/</guid>
      <description>&lt;p&gt;Using &lt;code&gt;std::promise&lt;/code&gt;s and futures is useful skill to create one-shot communication between a detecting task and reacting task.
&lt;/p&gt;

&lt;p&gt;Sometimes we want a task to detect some event and then inform a second asynchronously running task to proceed when some event has taken place (e.g., a data structure has been initialized, a stage of computation has been completed, a significant sensor value has been detected, etc.). In other words, a &lt;em&gt;detecting task&lt;/em&gt; will detect a special event/condition, and a &lt;em&gt;reacting task&lt;/em&gt; will wait until the detecting task notifies that the event occurs/condition changes.&lt;/p&gt;

&lt;p&gt;If we only want to inform once, we can take use of the power of &lt;code&gt;std::promise&lt;/code&gt;s and futures (i.e., &lt;code&gt;std::future&lt;/code&gt; and &lt;code&gt;std::shared_future&lt;/code&gt;). Since both &lt;code&gt;std::promise&lt;/code&gt; and futures are templates requiring a type parameter that indicates the type of data to be transmitted through the communications channel, we specify this type as &lt;code&gt;void&lt;/code&gt; indicating that no data is to be conveyed:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;The detecting task will set its &lt;code&gt;std::promise&amp;lt;void&amp;gt;&lt;/code&gt; when the event of interest occurs&lt;/li&gt;
&lt;li&gt;The reacting task will &lt;code&gt;wait&lt;/code&gt; on its &lt;code&gt;std::future&amp;lt;void&amp;gt;&lt;/code&gt; or &lt;code&gt;std::shared_future&amp;lt;void&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;The communications channel wil permit the reacting task to know when the detecting task has &lt;code&gt;written&lt;/code&gt; its &lt;code&gt;void&lt;/code&gt; data by calling &lt;code&gt;set_value&lt;/code&gt; on its &lt;code&gt;std::promise&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The essence of the technique looks like,&lt;/p&gt;


  
    
  
  
    
  
  
    
  
  
    
  


&lt;figure class=&#34;highlight cpp language-cpp&#34;&gt;
  &lt;figcaption&gt;
    
      &lt;span&gt;&lt;/span&gt;&lt;a href=&#34;http://underscorejs.org/#compact&#34; target=&#34;_blank&#34; rel=&#34;external&#34;&gt;&lt;/a&gt;
    
  &lt;/figcaption&gt;
  &lt;table&gt;
    &lt;tbody&gt;
      &lt;tr&gt;
        &lt;td class=&#34;gutter&#34;&gt;
          &lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;14&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;
        &lt;/td&gt;
        &lt;td class=&#34;code&#34;&gt;
          &lt;pre class=&#34;code-highlight language-cpp&#34;&gt;&lt;code class=&#34;cpp&#34;&gt;std::promise&amp;lt;void&amp;gt; p;

void react();     // func for reacting task

void detect() {   // func for detecting task
    std::thread t([]{
        p.get_future().wait();  // suspend t until future is set
        react();
    });
    ...  // here t is suspend prior to call to react
    p.set_value();  // event detected, so t is unsuspended (and thus call react)
    ...   // do additional work, program is terminated if this part of code throws
    t.join();   // make t unjoinable
}&lt;/code&gt;&lt;/pre&gt;
        &lt;/td&gt;
      &lt;/tr&gt;
    &lt;/tbody&gt;
  &lt;/table&gt;
&lt;/figure&gt;

&lt;p&gt;Taking use of &lt;code&gt;std::future::share()&lt;/code&gt;&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:1&#34;&gt;&lt;a href=&#34;#fn:1&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;, a general form is easy to implement where originally one reacting task extent to many:&lt;/p&gt;


  
    
  
  
    
  
  
    
  
  
    
  


&lt;figure class=&#34;highlight cpp language-cpp&#34;&gt;
  &lt;figcaption&gt;
    
      &lt;span&gt;&lt;/span&gt;&lt;a href=&#34;http://underscorejs.org/#compact&#34; target=&#34;_blank&#34; rel=&#34;external&#34;&gt;&lt;/a&gt;
    
  &lt;/figcaption&gt;
  &lt;table&gt;
    &lt;tbody&gt;
      &lt;tr&gt;
        &lt;td class=&#34;gutter&#34;&gt;
          &lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;19&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;
        &lt;/td&gt;
        &lt;td class=&#34;code&#34;&gt;
          &lt;pre class=&#34;code-highlight language-cpp&#34;&gt;&lt;code class=&#34;cpp&#34;&gt;std::promise&amp;lt;void&amp;gt; p;  // as before

void detect()  // now for multiple reacting tasks
{
    auto sf = p.get_future().share();  // sf&amp;#39;s type is std::shared_future&amp;lt;void&amp;gt;

    std::vector&amp;lt;std::thread&amp;gt; vt;  // container for reacting threads

    for (int i = 0; i &amp;lt; ThreadsToRun; &amp;#43;&amp;#43;i) {
        vt.emplace_back([sf]{ sf.wait();    // wait on local copy of sf
                              react(); });  // see item 42 for info on emplace_back
    }
    ...   // program is terminated if this part of code throws
    p.set_value();   // unsuspend all threads
    ...
    for (auto&amp;amp; t : vt) {  
        t.join();    // make all threads unjoinable
    }
}&lt;/code&gt;&lt;/pre&gt;
        &lt;/td&gt;
      &lt;/tr&gt;
    &lt;/tbody&gt;
  &lt;/table&gt;
&lt;/figure&gt;
&lt;div class=&#34;footnotes&#34;&gt;

&lt;hr /&gt;

&lt;ol&gt;
&lt;li id=&#34;fn:1&#34;&gt;&lt;code&gt;std::future::share()&lt;/code&gt; transfers ownership of its shared state to the &lt;code&gt;std::shared_future&lt;/code&gt; produced by &lt;code&gt;std::future::share()&lt;/code&gt;
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:1&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;</description>
    </item>
    
    <item>
      <title>[EMCpp]Item-38 Be Aware of Varying Thread Handle Destructor Behavior</title>
      <link>http://nianze.tk/2018/10/be-aware-of-varying-thread-handle-destructor-behavior/</link>
      <pubDate>Tue, 09 Oct 2018 19:42:16 -0400</pubDate>
      
      <guid>http://nianze.tk/2018/10/be-aware-of-varying-thread-handle-destructor-behavior/</guid>
      <description>&lt;p&gt;Future destructors normally just destroy the future&amp;rsquo;s data members, execept for the final future referring to a shared state for a non-deferred task launched via &lt;code&gt;std::async&lt;/code&gt;, which blocks until the task completes.
&lt;/p&gt;

&lt;p&gt;Item 37 notes that the destruction of a joinable &lt;code&gt;std::thread&lt;/code&gt; terminates the program. As a comparicon, the behavior of destructor for a future is quit different.&lt;/p&gt;

&lt;p&gt;To take a closer examination on future&amp;rsquo;s destruction behavior, let&amp;rsquo;s first understand that future is one end of a communications channel through which a callee transmits a result to a caller. The model works like this:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;The callee (usually running asynchronously) writes the result of its computation into the communications channel (typically via a &lt;code&gt;std::promise&lt;/code&gt; object&lt;/li&gt;
&lt;li&gt;A location known as &lt;em&gt;shared state&lt;/em&gt; (typically represented by a heap-based object, which is outside both caller and callee) then stores a copy of the result, which is previously local to the callee and will be destroyed when the callee finished&lt;/li&gt;
&lt;li&gt;As the name suggests, this location is also accessible by futures that are associated with the caller.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;The relationship looks like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;      future           Shared State             std::promise
Caller&amp;lt;---------------Callee&#39;s Result&amp;lt;----------------------Callee
                                                 (typically)

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now comes the behavior of a future&amp;rsquo;s destructor:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;The destructor for the last future referring to a shared state for a non-deferred task launched via std::async blocks until the task completes (which acts like an implicit &lt;code&gt;join&lt;/code&gt; on the underlying thread)&lt;/li&gt;
&lt;li&gt;The destructor for all other futures simply destroys the future object (which acts like an implicit &lt;code&gt;detach&lt;/code&gt; on the underlying thread.)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;In other words, the implicit &lt;code&gt;join&lt;/code&gt; occurs only if all of the following apply to a future:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;it refers to a shared state that was created due to a call to &lt;code&gt;std::async&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;the task&amp;rsquo;s launch policy is &lt;code&gt;std::launch::async&lt;/code&gt;, either because that was chosen by the runtime system or because it was specified in the call to &lt;code&gt;std::async&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;the future is the last one referring to the shared state. For &lt;code&gt;std::future&lt;/code&gt;s, this is always the case. For &lt;code&gt;std::shared_future&lt;/code&gt;s, other earlier future&amp;rsquo;s destructor simply destroys its data members&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>[EMCpp]Item-37 Make std::threads Unjoinable on All Paths</title>
      <link>http://nianze.tk/2018/10/make-stdthreads-unjoinable-on-all-paths/</link>
      <pubDate>Tue, 02 Oct 2018 19:16:09 -0400</pubDate>
      
      <guid>http://nianze.tk/2018/10/make-stdthreads-unjoinable-on-all-paths/</guid>
      <description>&lt;p&gt;&lt;em&gt;Join-on-destruction&lt;/em&gt; can lead to difficult-to-debug performance anomalies; while &lt;em&gt;detach-on-destruction&lt;/em&gt; can lead to difficult-to-debug undefined behavior.
&lt;/p&gt;

&lt;p&gt;Every &lt;code&gt;std::thread&lt;/code&gt; object is in one of two states:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;joinable: corresponding to an underlying asynchronous thread of execution that is or could be running.

&lt;ul&gt;
&lt;li&gt;A &lt;code&gt;std::thread&lt;/code&gt; corresponding to an underlying thread that&amp;rsquo;s waiting to be scheduled, blocked, or have run to comletion are all considered joinable.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;unjoinable:

&lt;ul&gt;
&lt;li&gt;Default-constructed &lt;code&gt;std::thread&lt;/code&gt;s: such &lt;code&gt;std::thread&lt;/code&gt;s have no function to execute, thus corresponding to no underlying thread of execution&lt;/li&gt;
&lt;li&gt;&lt;code&gt;std::thread&lt;/code&gt; that have been joined: after a &lt;code&gt;join&lt;/code&gt;, the &lt;code&gt;std::thread&lt;/code&gt; object no longer corresponding to the underlying thread of execution which has finished running.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;std::thread&lt;/code&gt;s that have been detached: a &lt;code&gt;detach&lt;/code&gt; severs the connection between a &lt;code&gt;std::thread&lt;/code&gt; object and the underlying thread of execution it corresponds to.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Due to the requirement that if the destructor for a joinable thread is invoked, execution of the program (i.e., all threads) is terminated. The destructor of &lt;code&gt;std::thread&lt;/code&gt; behaves in this way because the two other obvious options are arguably worse:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;An implicit &lt;code&gt;join&lt;/code&gt;: thus a &lt;code&gt;std::thread&lt;/code&gt;&amp;rsquo;s destructor would wait for its underlying asynchronous thread of execution to complete, leading to performance anomalies that would be difficult to track down.&lt;/li&gt;
&lt;li&gt;An implicit &lt;code&gt;detach&lt;/code&gt;: then a &lt;code&gt;std::thread&lt;/code&gt;&amp;rsquo;s destructor would sever the connection between the &lt;code&gt;std::thread&lt;/code&gt;  object and its underlying thread of execution, which would continue to run. That is wild.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;The Standardization Committee decided this program termination behavior just to tell us that we need to ensure a &lt;code&gt;std::thread&lt;/code&gt; object is made unjoinable on every path out of the scope in which it&amp;rsquo;s defined. That is, we can use &lt;em&gt;RAII&lt;/em&gt; technique to take care of that.&lt;/p&gt;


  
    
  
  
    
  
  
    
  
  
    
  


&lt;figure class=&#34;highlight cpp language-cpp&#34;&gt;
  &lt;figcaption&gt;
    
      &lt;span&gt;&lt;/span&gt;&lt;a href=&#34;http://underscorejs.org/#compact&#34; target=&#34;_blank&#34; rel=&#34;external&#34;&gt;&lt;/a&gt;
    
  &lt;/figcaption&gt;
  &lt;table&gt;
    &lt;tbody&gt;
      &lt;tr&gt;
        &lt;td class=&#34;gutter&#34;&gt;
          &lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;24&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;
        &lt;/td&gt;
        &lt;td class=&#34;code&#34;&gt;
          &lt;pre class=&#34;code-highlight language-cpp&#34;&gt;&lt;code class=&#34;cpp&#34;&gt;class ThreadRAII {
public:
    enum class DtorAction { join, detach };

    ThreadRAII(std::thread&amp;amp;&amp;amp; t, DtorAction a)
    : action(a), t(std::move(t)) {}

    ~ThreadRAII 
    {
        if (t.joinable()) {
            if (action == DtorAction::join) {
                t.join();
            } else {
                t.detach();
            }
        }
    }
    ThreadRAII(ThreadRAII&amp;amp;&amp;amp;) = default; // explicitly requesting the default move operations
    ThreadRAII&amp;amp; operator=(ThreadRAII&amp;amp;&amp;amp;) = default;  // since customized destructor prevent compiler-generated ones
    std::thread&amp;amp; get() { return t; }
private:
    DtorAction action;
    std::thread t;
};&lt;/code&gt;&lt;/pre&gt;
        &lt;/td&gt;
      &lt;/tr&gt;
    &lt;/tbody&gt;
  &lt;/table&gt;
&lt;/figure&gt;

&lt;p&gt;A few points:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;std::thread&lt;/code&gt; objects aren&amp;rsquo;t copyable, so we accepts only &lt;code&gt;std::thread&lt;/code&gt; rvalues&lt;/li&gt;
&lt;li&gt;The parameter order in the constructor is designed to be intuitive to callers, but the member initialization list is designed to match the order of the data members&amp;rsquo; declarations, in which we put the &lt;code&gt;std::thread&lt;/code&gt; object last in case the &lt;code&gt;std::thread&lt;/code&gt; depends on other data members.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;get&lt;/code&gt; is provided to access the underlying &lt;code&gt;std::thread&lt;/code&gt; object so that we gain the full &lt;code&gt;std::thread&lt;/code&gt; interface for free&lt;/li&gt;
&lt;li&gt;A check to make sure the &lt;code&gt;t&lt;/code&gt; is joinable in destructor is necessary in case that clients used &lt;code&gt;get&lt;/code&gt; to acquire &lt;code&gt;t&lt;/code&gt; and then did a move from &lt;code&gt;t&lt;/code&gt; or called &lt;code&gt;join&lt;/code&gt; or &lt;code&gt;detach&lt;/code&gt; on &lt;code&gt;t&lt;/code&gt;, making &lt;code&gt;t&lt;/code&gt; unjoinable.&lt;/li&gt;
&lt;li&gt;If in the client code there are simultaneous calls trying to invoke two member functions (the destructor and something else) on one object at the same time, there is a race: between execution of &lt;code&gt;t.joinable()&lt;/code&gt; and invocation of &lt;code&gt;join&lt;/code&gt; or &lt;code&gt;detach&lt;/code&gt;, another thread could render &lt;code&gt;t&lt;/code&gt; unjoinable.&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:1&#34;&gt;&lt;a href=&#34;#fn:1&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;footnotes&#34;&gt;

&lt;hr /&gt;

&lt;ol&gt;
&lt;li id=&#34;fn:1&#34;&gt;In general, simultaneous member function calls on a single object are safe only if all are to &lt;code&gt;cont&lt;/code&gt; member functions.
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:1&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;</description>
    </item>
    
    <item>
      <title>[EMCpp]Item-36 Specify std::launch::async if Asynchronicity Is Essential</title>
      <link>http://nianze.tk/2018/10/specify-stdlaunchasync-if-asynchronicity-is-essential/</link>
      <pubDate>Mon, 01 Oct 2018 18:33:54 -0400</pubDate>
      
      <guid>http://nianze.tk/2018/10/specify-stdlaunchasync-if-asynchronicity-is-essential/</guid>
      <description>&lt;p&gt;The flexibility that default policy for &lt;code&gt;std::async&lt;/code&gt; permits both async and sync task execution leads to uncertainty when accessing &lt;code&gt;thread_locals&lt;/code&gt;, implies that the task may never execute, and affects program logic for timeout-based &lt;code&gt;wait&lt;/code&gt; calls.
&lt;/p&gt;

&lt;p&gt;When requesting a function &lt;code&gt;f&lt;/code&gt; to be run in accord with a &lt;code&gt;std::async&lt;/code&gt;, there are two standard &lt;em&gt;launch policies&lt;/em&gt;, each represented by an enumerator in the &lt;code&gt;std::launch&lt;/code&gt; scoped enum:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;The &lt;code&gt;std::launch::async&lt;/code&gt; launch policy&lt;/strong&gt;: &lt;code&gt;f&lt;/code&gt; must be run asynchronously on a different thread.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;The &lt;code&gt;std::launch::deferred&lt;/code&gt; launch policy&lt;/strong&gt;: &lt;code&gt;f&lt;/code&gt; may run only when &lt;code&gt;get&lt;/code&gt; or &lt;code&gt;wait&lt;/code&gt; is called on the future returned by &lt;code&gt;std::async&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;In the 2nd policy, things go like this: &lt;code&gt;f&lt;/code&gt;&amp;rsquo;s execution is &lt;em&gt;deferred&lt;/em&gt; until a caller invokes &lt;code&gt;get&lt;/code&gt; or &lt;code&gt;wait&lt;/code&gt;,  upon which time &lt;code&gt;f&lt;/code&gt; will execute synchronously and block the caller until &lt;code&gt;f&lt;/code&gt; finishes running. If neither &lt;code&gt;get&lt;/code&gt; nor &lt;code&gt;wait&lt;/code&gt; is called, &lt;code&gt;f&lt;/code&gt; will never run.&lt;/p&gt;

&lt;p&gt;The default launch policy, however, uses an OR-ed version of the above two policies:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;auto fut1 = std::async(f); // the same meaning as below

auto fut2 = std::async(std::launch::async | 
                       std::launch::deferred,
                       f);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This default policy permits &lt;code&gt;f&lt;/code&gt; to be run either asynchronously or synchronously, depending on the decision of thread-management components of the Standard Library about the best step to do to avoid oversubscription and load balancing. This flexibility, however, also imtroduces some limitations:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;It&amp;rsquo;s not possible to predict whether &lt;code&gt;f&lt;/code&gt; will run concurrently with &lt;code&gt;t&lt;/code&gt;, since &lt;code&gt;f&lt;/code&gt; might be scheduled to run deferred.&lt;/li&gt;
&lt;li&gt;It&amp;rsquo;s not possible to predict whether &lt;code&gt;f&lt;/code&gt; runs on a thread different from the thread invoking &lt;code&gt;get&lt;/code&gt; or &lt;code&gt;wait&lt;/code&gt; on &lt;code&gt;fut&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;It may not be possible to predict whether &lt;code&gt;f&lt;/code&gt; runs at all, since it may not be possible to guarantee that &lt;code&gt;get&lt;/code&gt; or &lt;code&gt;wait&lt;/code&gt; will be called on &lt;code&gt;fut&lt;/code&gt; along every path through the program&lt;/li&gt;

&lt;li&gt;&lt;p&gt;It affects &lt;code&gt;wait&lt;/code&gt;-based loops using timeouts, since calling &lt;code&gt;wait_for&lt;/code&gt; or &lt;code&gt;wait_until&lt;/code&gt; on a task that&amp;rsquo;s deferred yields the value &lt;code&gt;std::future_status_deferred&lt;/code&gt;, leading to following code run forever in some special cases:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;using namespace std::literals;
void f()
{
    std::this_thread::sleep_for(1s);
}
    
auto fut = std::async(f);  // run f in default launch policy
    
while (fut.wait_for(100ms) !=      // f never yield read 
       std::future_status::ready)  // when deferred
{
    ...
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;solution&#34;&gt;Solution&lt;/h4&gt;

&lt;p&gt;To deal with these limitations, if we use both the default launch policy as well as the timeout-based &lt;code&gt;wait&lt;/code&gt; calls, we need to check for deferred case:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;...
if (fut.wait_for(0s) == 
    std::future_status::deferred)
{
    ... // use wait or get on fut to call f synchronously
} else {
    while (fut.wait_for(100ms) !=      // f never yield read 
           std::future_status::ready)  // when deferred
    { 
        ... // do concurrent work until it&#39;s ready
    }
    ...  // fut is ready
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In summary, using &lt;code&gt;std::async&lt;/code&gt; with the default launch policy for a task is fine as long as following conditions are fulfilled:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;The task need not run concurrently with the thread calling &lt;code&gt;get&lt;/code&gt; or &lt;code&gt;wait&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;It doesn&amp;rsquo;t matter which thread&amp;rsquo;s thread_local variables are read or written&lt;/li&gt;
&lt;li&gt;Either there&amp;rsquo;s a guarantee that &lt;code&gt;get&lt;/code&gt; or &lt;code&gt;wait&lt;/code&gt; will be called on the future returned by &lt;code&gt;std::async&lt;/code&gt; or it&amp;rsquo;s acceptable that the task may never execute&lt;/li&gt;
&lt;li&gt;Code using &lt;code&gt;wait_for&lt;/code&gt; or &lt;code&gt;wait_until&lt;/code&gt; takes the possibility of deferred status into account like above example.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;If any of the conditions above fails to hold, schedule the task for truly asynchronous execution:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;auto fut = std::async(std::launch::async, f);  // launch f asynchronously
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A nice wrapper for this purpose goes like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;// C++11 version
template&amp;lt;typename F, typename... Ts&amp;gt;
inline
std::future&amp;lt;typename std::result_of&amp;lt;F(Ts...)&amp;gt;::type&amp;gt;
reallyAsync(F&amp;amp;&amp;amp; f, Ts&amp;amp;&amp;amp;... params)
{
    return std::async(std::launch::async, 
                      std::forward&amp;lt;F&amp;gt;(f), 
                      std::forward&amp;lt;Ts&amp;gt;(params)...);
}

auto fut = reallyAsync(f); // run f asynchronously; throw if std::async would throw
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;// C++14 version
template&amp;lt;typename F, typename... Ts&amp;gt;
inline
auto
reallyAsync(F&amp;amp;&amp;amp; f, Ts&amp;amp;&amp;amp;... params)
{
    return std::async(std::launch::async,
                      std::forward&amp;lt;F&amp;gt;(f),
                      std::forward&amp;lt;Ts&amp;gt;(params)...);
}
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>[EMCpp]Item-35 Prefer Task-Based Programming to Thread-Based</title>
      <link>http://nianze.tk/2018/08/prefer-task-based-programming-to-thread-based/</link>
      <pubDate>Tue, 28 Aug 2018 10:19:06 -0400</pubDate>
      
      <guid>http://nianze.tk/2018/08/prefer-task-based-programming-to-thread-based/</guid>
      <description>&lt;p&gt;Thread-based programming calls for manual management of thread exhaustion, oversubscription, load balancing, and adaptation to new platforms, while task-based programming via &lt;code&gt;std::async&lt;/code&gt; with the default launch policy handles most of the issues for us.
&lt;/p&gt;

&lt;p&gt;In concurrent C++ software, there are three meansings for &lt;em&gt;threads&lt;/em&gt;:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;em&gt;Hardware threads&lt;/em&gt; are threads that actually perform computation. Contemporary machine architectures offer one or more hardware threads per CPU core.&lt;/li&gt;
&lt;li&gt;&lt;em&gt;Software threads&lt;/em&gt; (a.k.a., OS threads or system threads) are the threads that the operating system manages across all processes and schedules for execution on hardware threads.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;std::threads&lt;/code&gt; are objects in a C++ process that act as handles to underlying software threads.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Since software threads are a limited resource, a &lt;code&gt;std::system_error&lt;/code&gt; exception may be thrown if we try to create more of them than the system can provide, even if the function we want to run can&amp;rsquo;t throw:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;int doAsyncWork() noexcept;
std::thread t(doAsyncWork);  // throws if no more threads are available
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This limitation leads to follow-up problems we need to deal with:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;if no more threads are available and we run &lt;code&gt;doAsyncWork&lt;/code&gt; on the current thread, there are issues of unbalanced loads, or even dead lock.&lt;/li&gt;
&lt;li&gt;even if there&amp;rsquo;re still more threads available, we need to face the trouble of &lt;em&gt;oversubscription&lt;/em&gt;, where there are more unblocked software threads than hardware threads, and context switches increase the overall thread management overhead of the system, especially when the hardware thread on which a software thread is scheduled is switched on a diffferent core in a new time-slice.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Using &lt;code&gt;std::async&lt;/code&gt; free us from all these problems by dumping them on somebody else who is responsible to implement the C++ Standard Library:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;auto fut = std::async(doAsyncWork);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The implementer of C++ Statndard Library solves the &amp;ldquo;out-of-threads&amp;rdquo; problem by providing no guarantee that there will be a new software thread: it permits the OS scheduler to arrange for the specified function (&lt;code&gt;doAsyncWork&lt;/code&gt;) to be run on the thread requesting &lt;code&gt;doAsyncWork&lt;/code&gt;&amp;rsquo;s result (i.e., on the thread calling &lt;code&gt;get&lt;/code&gt; or &lt;code&gt;wait&lt;/code&gt; on &lt;code&gt;fut&lt;/code&gt;), and reasonable schedulers take advantage of that freedom if the system is oversubscribed or is out of threads. Since runtime scheduler manages the threads from all processes, it is likely to comprehend the whole picture better and be more capable to solve the load-balancing issues than we do&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:1&#34;&gt;&lt;a href=&#34;#fn:1&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;.&lt;/p&gt;

&lt;h4 id=&#34;edge-cases&#34;&gt;Edge Cases&lt;/h4&gt;

&lt;p&gt;There are some situations where using threads directly may be appropriate:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;We need access to the API of the underlying threading implementation via the member function &lt;code&gt;native_handle&lt;/code&gt; in &lt;code&gt;std::thread&lt;/code&gt; objects&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:2&#34;&gt;&lt;a href=&#34;#fn:2&#34;&gt;2&lt;/a&gt;&lt;/sup&gt;. There is no counterpart to this functionality for &lt;code&gt;std::future&lt;/code&gt;s that &lt;code&gt;std::async&lt;/code&gt; returns.&lt;/li&gt;
&lt;li&gt;We need to and are able to potimize thread usage for our application. E.g., developing server software with a known execution profile that will be deployed as the only significant process on a machine with fixed hardware characteristics.&lt;/li&gt;
&lt;li&gt;We need to implement threading technology beyond the C++ concurrency API. E.g., thread pools on platforms where our C++ implementations don&amp;rsquo;t offer them.&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;footnotes&#34;&gt;

&lt;hr /&gt;

&lt;ol&gt;
&lt;li id=&#34;fn:1&#34;&gt;State-of-the-art thread schedulers employ system-wide thread pools to avoid oversubscription, while improving load balancing across hardware cores through work-stealing algorithms. It will be reasonable to expect that some vendors will take advantage of this technology in their Standard Library implementations, and anyone taking a task-based approach to concurrent programming will automatically reap the benefits.
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:1&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:2&#34;&gt;The C++ concurrent CPI is implemented using a lower-level platform-specifit API, usually pthreads or Windows&amp;rsquo; Threads, which are richer than what C++ offers. For example, C++ has no notion of thread priorities or affinities.
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:2&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;</description>
    </item>
    
    <item>
      <title>[EMCpp]Item-34 Prefer Lambdas to std::bind</title>
      <link>http://nianze.tk/2018/08/prefer-lambdas-to-stdbind/</link>
      <pubDate>Fri, 24 Aug 2018 20:07:38 -0400</pubDate>
      
      <guid>http://nianze.tk/2018/08/prefer-lambdas-to-stdbind/</guid>
      <description>&lt;p&gt;Lambdas are more readable, more expressive, and may be more efficient than using &lt;code&gt;std::bind&lt;/code&gt;.

&lt;!-- toc --&gt;&lt;/p&gt;

&lt;h1 id=&#34;more-readable&#34;&gt;More readable&lt;/h1&gt;

&lt;p&gt;Suppose we want a function to set up an audible alarm that will go off an hour after it&amp;rsquo;s set and that will stay on for 30 seconds, with the alarm sound remaining undecided.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;using Time = std::chrono::steady_clock::time_point;
enum class Sount {Beep, Siren, Whistle};
using Duration = std::chrono::steady_clock::duration;
void setAlarm(Time t, Sound s, Duration d); // at time t, make sound s for duration d
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In C++14, it is very easy to write a lambda version, which is also straight-forward to read:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;auto setSoundL = [](Sound s)
                 {
                     using namespace std::chrono;
                     using namespace std::literals;
                     setAlarm(steady_clock::now() + 1h,  // alarm to go off
                              s,                         // in an hour for
                              30s);                      // 30 seconds
                 }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If we decide to use &lt;code&gt;std::bind&lt;/code&gt;, it looks like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;auto setSoundB = 
    std::bind(setAlarm,
              std::bind(std::plus&amp;lt;&amp;gt;(),
                        std::bind(steady_clock::now),
                        1h),
              _1,
              30s);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here, we used two extra &lt;code&gt;bind&lt;/code&gt; inside the outer &lt;code&gt;bind&lt;/code&gt; instead of passing &lt;code&gt;now() + 1h&lt;/code&gt; directly as an argument of &lt;code&gt;std::bind&lt;/code&gt;, because we want to defer evaluation of the timestamp expression until when &lt;code&gt;setAlarm&lt;/code&gt; is called, rather than when &lt;code&gt;std::bind&lt;/code&gt; is called. In C++11, however, the template type argument for the standard operator tempaltes can not be omitted, so the C++11 &lt;code&gt;std::bind&lt;/code&gt; equivalent look like this shxt:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;struct genericAdder {  
    template&amp;lt;typename T1, typename T2&amp;gt;  
    auto operator()(T1&amp;amp;&amp;amp; param1, T2&amp;amp;&amp;amp; param2)    
        -&amp;gt; decltype(std::forward&amp;lt;T1&amp;gt;(param1) + std::forward&amp;lt;T2&amp;gt;(param2))  
    {    
        return std::forward&amp;lt;T1&amp;gt;(param1) + std::forward&amp;lt;T2&amp;gt;(param2);  
    }
};
auto setSoundB = 
    std::bind(setAlarm,
              std::bind(genericAdder(),
                        std::bind(steady_clock::now),
                        hours(1)),  // std::literals is in C++14
              _1,
              seconds(30));
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Moreover, if we have another overloaded function for &lt;code&gt;setAlarm&lt;/code&gt;, which takes a new parameter specifying the alarm volume:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;enum class Volum {Normal, Loud, VeryLoud};
void setAlarm(Time t, Sound s, Duration d, Volume v);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The lambda above continues to work, because overload resolution chooses the three-argument version of &lt;code&gt;setAlarm&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;However, the &lt;code&gt;std::bind&lt;/code&gt; version fails to compile now, because compilers have no way to determine which of the two &lt;code&gt;setAlarm&lt;/code&gt; functions they should pass to &lt;code&gt;std::bind&lt;/code&gt; - by the function name alone it is ambiguous.&lt;/p&gt;

&lt;p&gt;To specify the exactly which one we want, we need to cast &lt;code&gt;setAlarm&lt;/code&gt; to the proper function pointer type:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;using SetAlarm3ParamType = void(*)(Time t, Sound s, Duration d);
auto setSoundB = 
    std::bind(static_cast&amp;lt;SetAlarm3ParamType&amp;gt;(setAlarm),
              std::bind(std::plus&amp;lt;&amp;gt;(),
                        std::bind(steady_clock::now()),
                        1h),
              _1,
              30s);
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;more-efficient&#34;&gt;More efficient&lt;/h1&gt;

&lt;p&gt;The cast above introduces another side effect:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;std::bind&lt;/code&gt; passes a function pointer to &lt;code&gt;setAlarm&lt;/code&gt;, which means inside the function call operator for &lt;code&gt;setSoundB&lt;/code&gt; (i.e., the function call operator &lt;code&gt;()&lt;/code&gt; for the bind object), the call to &lt;code&gt;setAlarm&lt;/code&gt; takes place through a function pointer, which generally can&amp;rsquo;t be fully inlined&lt;/li&gt;
&lt;li&gt;inside the function call operator for &lt;code&gt;setSoundL&lt;/code&gt; (i.e., the function call operator of the lambda&amp;rsquo;s closure class), the call to &lt;code&gt;setAlarm&lt;/code&gt; is a normal function invocation, which can be inlined by compilers&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;This means using lambdas might generate faster code than using &lt;code&gt;std::bind&lt;/code&gt;.&lt;/p&gt;

&lt;h1 id=&#34;more-expressive&#34;&gt;More expressive&lt;/h1&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;auto betweenL = 
    [lowVal, highVal]
    (const auto&amp;amp; val)
    { return lowVal &amp;lt;= val &amp;amp;&amp;amp; val &amp;lt;= highVal; };

using namespace std::placeholders;
auto betweenB = 
    std::bind(std::logical_and&amp;lt;&amp;gt;(),
              std::bind(std::less_equal&amp;lt;&amp;gt;(), lowVal, _1),
              std::bind(std::less_equal&amp;lt;&amp;gt;(), _1, highVal));
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Moreover, the placeholders (e.g., &lt;code&gt;_1&lt;/code&gt;, &lt;code&gt;_2&lt;/code&gt;, etc.) are opaque in that it doesn&amp;rsquo;t specify how parameters are passed and stored in the bind object, by value or by reference. We have to memorize that it&amp;rsquo;s stored by value. Lambda, however, specifies capture mode very clearly.&lt;/p&gt;

&lt;h1 id=&#34;edge-cases&#34;&gt;Edge cases&lt;/h1&gt;

&lt;p&gt;In C++14, there&amp;rsquo;s no reasonable use case for &lt;code&gt;std::bind&lt;/code&gt;. In C++11, two constrained situations my be useful:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Move capture, as item 32 explains.&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Polymorphic function objects: this takes use of bind object&amp;rsquo;s perfect forwarding ability&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class PolyWidget {
public:
    template&amp;lt;typename T&amp;gt;
    void operator()(const T&amp;amp; param) const;
    ...
};
PolyWidget pw;
auto boundPW = std::bind(pw, _1);
boundPW(1942);  // pass int to PolyWidget::operator()
boundPW(nullptr);  // pass nullptr to PolyWidget::operator()
boundPW(&amp;quot;RoseGun&amp;quot;);  // pass string literal to PolyWidget::operator()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In C++14, simply do this combining lambda with &lt;code&gt;auto&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;auto boundPW = [pw](const auto&amp;amp; param) { pw(param); };
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;</description>
    </item>
    
    <item>
      <title>[EMCpp]Item-33 Use decltype on auto&amp;&amp; parameters to std::forward them</title>
      <link>http://nianze.tk/2018/08/use-decltype-on-auto-parameters-to-stdforward-them/</link>
      <pubDate>Thu, 23 Aug 2018 21:44:29 -0400</pubDate>
      
      <guid>http://nianze.tk/2018/08/use-decltype-on-auto-parameters-to-stdforward-them/</guid>
      <description>&lt;p&gt;C++14 introduces generic lambdas, which use &lt;code&gt;auto&lt;/code&gt; in their parameter specifications.
&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;auto f = [](auto x){ return normalize(x); };
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If we want to perfect-fowrad a parameter &lt;code&gt;x&lt;/code&gt; to &lt;code&gt;normalize&lt;/code&gt;, we make two changes:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;use universal reference &lt;code&gt;auto&amp;amp;&amp;amp;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;apply &lt;code&gt;decltype&lt;/code&gt; on parameter to specify the correct type for type argument of &lt;code&gt;std::forward&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;auto f = [](auto&amp;amp;&amp;amp; x){ return normalize(std::forward&amp;lt;decltype(x)&amp;gt;(x)); };
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As a fact of &lt;code&gt;decltype(x)&lt;/code&gt;:
* if &lt;code&gt;x&lt;/code&gt; is bound to an lvalue, it will yield an lvalue refernece;
* if &lt;code&gt;x&lt;/code&gt; is bound to an rvalue, it will yield an rvalue reference&lt;/p&gt;

&lt;p&gt;Actually, the result of &lt;code&gt;decltype(x)&lt;/code&gt; doesn&amp;rsquo;t follow the convention of &lt;code&gt;std::forward&lt;/code&gt;, where it dictates that the type argument be an lvalue reference to indicate an lvalue and a non-reference to indicate an rvalue.&lt;/p&gt;

&lt;p&gt;Thanks to reference-collapsing rule, even though rvalue convention is broken here, the collapsing result is still the same. Say the &lt;code&gt;T&lt;/code&gt; in the implementation of &lt;code&gt;std::forward&lt;/code&gt; below is instantiated as &lt;code&gt;Widget&amp;amp;&amp;amp;&lt;/code&gt;, an rvalue reference type:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;template&amp;lt;typename T&amp;gt;                         // in namespace
T&amp;amp;&amp;amp; forward(remove_reference_t&amp;lt;T&amp;gt;&amp;amp; param)    // std
{  return static_cast&amp;lt;T&amp;amp;&amp;amp;&amp;gt;(param);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;and we get this before reference collapsing:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;Widget&amp;amp;&amp;amp; &amp;amp;&amp;amp; forward(Widget&amp;amp; param)         // instantiation of
{                                          // std::forward when 
    static_cast&amp;lt;Widget&amp;amp;&amp;amp; &amp;amp;&amp;amp;&amp;gt;(param);       // T is Widget&amp;amp;&amp;amp; 
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;After reference collapsing:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;Widget&amp;amp;&amp;amp; forward(Widget&amp;amp; param)         // instantiation of
{                                       // std::forward when 
    static_cast&amp;lt;Widget&amp;amp;&amp;amp;&amp;gt;(param);       // T is Widget&amp;amp;&amp;amp; 
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is exactly what we expect.&lt;/p&gt;

&lt;h4 id=&#34;variadic-parameters&#34;&gt;Variadic parameters&lt;/h4&gt;

&lt;p&gt;For more than a single parameter, using following format:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;auto f = [](auto&amp;amp;&amp;amp;... xs)
         { return normalize(std::forward&amp;lt;decltype(xs)&amp;gt;(xs)...); }
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>[EMCpp]Item-32 Use Init Capture to Move Objects Into Closures</title>
      <link>http://nianze.tk/2018/08/use-init-capture-to-move-objects-into-closures/</link>
      <pubDate>Wed, 22 Aug 2018 18:24:02 -0400</pubDate>
      
      <guid>http://nianze.tk/2018/08/use-init-capture-to-move-objects-into-closures/</guid>
      <description>&lt;p&gt;Use init capture to move objects into closures in C++14; emulate init capture via hand-written classes or &lt;code&gt;std::bind&lt;/code&gt; in C++11.
&lt;/p&gt;

&lt;h4 id=&#34;in-c-14&#34;&gt;In C++14&lt;/h4&gt;

&lt;p&gt;One nice improvement in C++14, compared with C++11, is that it supports &lt;em&gt;int capture&lt;/em&gt; (a.k.a, &lt;em&gt;generalized lambda capture&lt;/em&gt;), which makes it possible for us to specify:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;the name of a data memeber in the closure class generated from the lambda&lt;/li&gt;
&lt;li&gt;an expression initializing that data member&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;For example:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class Widget {
public:
    ...
    bool isValidated() const;
    bool isProcessed() const;
    bool isArchived() const;
private:
    ...
};

auto pw = std::make_unique&amp;lt;Widget&amp;gt;();
...
auto func = [pw = std::move(pw)]  // init data mbr in closure with std::move(pw)
            { return pw-&amp;gt;isValidated() &amp;amp;&amp;amp; pw-&amp;gt;isArchived(); }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;One thing to note in init capture: the left side of &amp;ldquo;=&amp;rdquo; is the name of the data member in the closure we&amp;rsquo;re specifying, which is in the closure class scope; the right side is the initializing expresion, which is the same scope as where the lambda is being defined. The code in the body of the lambda is in the scope of the closure class, so uses of &lt;code&gt;pw&lt;/code&gt; refer to the closure class data member.&lt;/p&gt;

&lt;h4 id=&#34;in-c-11&#34;&gt;In C++11&lt;/h4&gt;

&lt;p&gt;In C++11, it&amp;rsquo;s not possible to capture the result of an expression. We can still emulate the behaivor by either manually write a class:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class IsValAndArch {
public:
    using DataType = std::unique_ptr&amp;lt;Widget&amp;gt;;
    explicit IsValAndArch(DataType&amp;amp;&amp;amp; ptr)
    : pw(std::move(ptr)) {}
    bool operator()() const
    { return pw-&amp;gt;isValidated() &amp;amp;&amp;amp; pw-&amp;gt;isArchived(); }
private:
    DataType pw;
}

auto func = IsValAndArch(std::make_unique&amp;lt;Widget&amp;gt;());
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;or use &lt;code&gt;std::bind&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;auto func = std::bind(
                [](const std::unique_ptr&amp;lt;Widget&amp;gt;&amp;amp; pw)
                { return pw-&amp;gt;isValidated() &amp;amp;&amp;amp; pw-&amp;gt;isArchived(); },
                std::make_unique&amp;lt;Widget&amp;gt;()
            );
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Some facts about &lt;code&gt;std::bind&lt;/code&gt; above:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;std::bind&lt;/code&gt; produces function objects (called &lt;em&gt;bind object&lt;/em&gt;), which contains copies of all the arguments passed to &lt;code&gt;std::bind&lt;/code&gt; following this rule: copy constructing the lvalue arguemnt, and move construct rvalue argument.&lt;/li&gt;
&lt;li&gt;by default, the &lt;code&gt;operator()&lt;/code&gt; member function inside the closure class generated from a lambda is &lt;code&gt;const&lt;/code&gt;; as a contrast, the move-constructed copy of &lt;code&gt;Widget&lt;/code&gt; inside bind object is not &lt;code&gt;const&lt;/code&gt;, so we declare reference-to-const as the lambda&amp;rsquo;s parameter to prevent that copy of &lt;code&gt;Widget&lt;/code&gt; from being modified inside the lambda&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:1&#34;&gt;&lt;a href=&#34;#fn:1&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;&lt;/li&gt;
&lt;li&gt;the lifetime of the bind is the same as that of the closure, so it&amp;rsquo;s possible to treat objects in the bind object as if they were in the closure.&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;footnotes&#34;&gt;

&lt;hr /&gt;

&lt;ol&gt;
&lt;li id=&#34;fn:1&#34;&gt;We can declare lambda as &lt;code&gt;mutable&lt;/code&gt; if we want to modify the copy inside the lambda: &lt;code&gt;[](std::unique_ptr&amp;lt;Widget&amp;gt;&amp;amp; pw) mutable {...}&lt;/code&gt;
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:1&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;</description>
    </item>
    
    <item>
      <title>[EMCpp]Item-31 Avoid Default Capture Modes</title>
      <link>http://nianze.tk/2018/08/avoid-default-capture-modes/</link>
      <pubDate>Tue, 21 Aug 2018 19:22:22 -0400</pubDate>
      
      <guid>http://nianze.tk/2018/08/avoid-default-capture-modes/</guid>
      <description>&lt;p&gt;Default by-reference capture can lead to dangling references; default by-value capture is susceptible to dangling pointers, while misleadingly susggests the lambdas are self-contained.

&lt;!-- toc --&gt;&lt;/p&gt;

&lt;h1 id=&#34;default-by-reference-capture&#34;&gt;Default by-reference capture&lt;/h1&gt;

&lt;p&gt;If the lifetime of a closure created from a lambda exceeds the lifetime of the local variable or parameter captured by-reference, the reference in the closure will dangle:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;using FilterContainer = std::vector&amp;lt;std::function&amp;lt;bool(int)&amp;gt;&amp;gt;;
FilterContainer filters;

void addDivisorFilter()
{
    auto calc1 = computeSomeValue1();
    auto calc2 = computeSomeValue2();

    auto diviser = coputeDiviser(calc1, calc2);

    filters.emplace_back(
        [&amp;amp;](int value) { return value % divisor = 0; }  // ref to divisor will dangle
    );
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Long-term, it&amp;rsquo;s better software engineering to explicitly list the local variables and parameters that a lambda depends on.&lt;/p&gt;

&lt;h1 id=&#34;default-by-value-capture&#34;&gt;Default by-value capture&lt;/h1&gt;

&lt;p&gt;Capture by value will solve the dangling problem in above example, but it can&amp;rsquo;t guarantee the safety if we capture a pointer and that pointer is deleted outside the lambda, which causes our copied pointer to dangle. This usually happens where &lt;code&gt;this&lt;/code&gt;, a raw pointer, implicitly shows up, for example:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class Widget {
public:
    ...
    void addFilter() const;
private:
    int divisor;
};

void Widget::addFilter() const
{
    filters.emplace_back(
        [=](int value) { return vlaue % diviser == 0; }
    );
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Captures apply only to non-static local variables (including parameters) visible in the scope where the lambda is created. Since &lt;code&gt;diviser&lt;/code&gt; above is a data member of the &lt;code&gt;Widget&lt;/code&gt; class, instead of a local variable, what compilers see is as if it had been written as follows:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;void Widget::addFilter() const
{
    auto currentObjectPtr = this;
    filters.emplace_back(
        [currentObjectPtr](int value)
        { return value % currentObjectPtr-&amp;gt;divisor == 0; }
    );
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;and now consider this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;void doSomeWork()
{
    auto pw = std::make)unique&amp;lt;Widget&amp;gt;();
    pw-&amp;gt;addFilter();
    ...
}  // destroy Widget; filters now holds dangling pointer
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In this code above, a filter is created containing a copy of a &lt;code&gt;this&lt;/code&gt; pointer to the newly created &lt;code&gt;Widget&lt;/code&gt;, and then we add this filter to &lt;code&gt;filters&lt;/code&gt;. When &lt;code&gt;doSomeWork&lt;/code&gt; finishes, the &lt;code&gt;Widget&lt;/code&gt; object is destroyed by &lt;code&gt;std::unique_ptr&lt;/code&gt;, and &lt;code&gt;filters&lt;/code&gt; contains an entry with a dangling pointer.&lt;/p&gt;

&lt;p&gt;To solve the problem, just make a local copy of the data member we want to capture and then capture the copy:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;void Widget::addFilter() const
{
    auto currentObjectPtr = divisor;  // copy data member
    filters.emplace_back(
        [divisorCopy](int value)
        { return value % divisor == 0; }
    );
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In C++14, a better way to capture a data member is to use generalized lambda capture (Item 32):&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;void Widget::addFilter() const
{    
    filters.emplace_back(  // C++14
        [divisor = divisor](int value)  // copy divisor to closure
        { return value % divisor == 0; } // use the copy
    );
}
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>[EMCpp]Item-30 Failure Cases in Perfect Forwarding</title>
      <link>http://nianze.tk/2018/08/failure-cases-in-perfect-forwarding/</link>
      <pubDate>Sun, 19 Aug 2018 16:10:34 -0400</pubDate>
      
      <guid>http://nianze.tk/2018/08/failure-cases-in-perfect-forwarding/</guid>
      <description>&lt;p&gt;Perfect forwarding fails when template type deduction fails or when it deduces the wrong type.
&lt;/p&gt;

&lt;p&gt;Generally, forwarding means passing parameters that are &lt;em&gt;references&lt;/em&gt; so that we can work with the originally-passed-in objects in another function, while perfect forwarding means we will use &lt;em&gt;universal references&lt;/em&gt; to keep track of salient characteristics such as lvalue-ness/rvalue-ness, const-ness, volatile-ness, etc.&lt;/p&gt;

&lt;p&gt;The definition of failure is: given a target function &lt;code&gt;f&lt;/code&gt;, and a forwarding function &lt;code&gt;fwd&lt;/code&gt;, perfect forwarding &lt;em&gt;fails&lt;/em&gt; if calling &lt;code&gt;f&lt;/code&gt; with a particular argument does one thing, but calling &lt;code&gt;fwd&lt;/code&gt; with the same argument does something difference:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;f( expression );
fwd( expression );

template&amp;lt;typename T&amp;gt;
void fwd(T&amp;amp;&amp;amp; param)  // accept any argument
{
    f(std::forward&amp;lt;T&amp;gt;(param));
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Following kinds of arguments will lead to perfect forwarding failure:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;braced initializers&lt;/strong&gt;: passing a braced initializer to a function template parameter that’s not declared to be a std::initializer_list is decreed to be a “non-deduced context,” as the Standard puts it&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;null pointers expressed as &lt;code&gt;0&lt;/code&gt; or &lt;code&gt;NULL&lt;/code&gt;&lt;/strong&gt;: refer to the explanation in EMCpp item 8&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;declaration-only integral &lt;code&gt;const static&lt;/code&gt; data members&lt;/strong&gt;: since compilers perform &lt;em&gt;const propagation&lt;/em&gt; on such members&amp;rsquo; values, there&amp;rsquo;s no memory allocation procedure for them, no address associated with them, and thus no pointers/references, ending up with a linking error.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;template and overloaded function names&lt;/strong&gt;: &lt;code&gt;f&lt;/code&gt;&amp;rsquo;s declaration lets compilers figure out the required vertion of overload/template instantiation to be passed, but it&amp;rsquo;s impossible for compilers to determine which version should be passed to &lt;code&gt;fwd&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;bitfields&lt;/strong&gt;: &amp;ldquo;A non-const reference shall not be bound to a bit-field,&amp;rdquo; as C++ standard condemns&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>[EMCpp]Item-29 Assume Move Operations Are Not Present Not Cheap, and Not Used</title>
      <link>http://nianze.tk/2018/08/assume-move-operations-are-not-present-not-cheap-not-used/</link>
      <pubDate>Sat, 18 Aug 2018 15:15:12 -0400</pubDate>
      
      <guid>http://nianze.tk/2018/08/assume-move-operations-are-not-present-not-cheap-not-used/</guid>
      <description>&lt;p&gt;There are several scenarios in which C++11&amp;rsquo;s move semantics do us no good:
&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;No move operations&lt;/strong&gt;: the object to be moved from fails to offer move operations. The move request thus becomes a copy request&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Move not faster&lt;/strong&gt;: the object to be moved from has move operations that are no faster than its copy operations&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:1&#34;&gt;&lt;a href=&#34;#fn:1&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Move not usable&lt;/strong&gt;: the context in which the moving would take place requires a move operation that emits no exceptions, but that operation isn&amp;rsquo;t declared &lt;code&gt;noexcept&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Source object is lvalue&lt;/strong&gt;: with very few exceptions (e.g., item 25), only rvlaues may be used as the source of a move operation&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;footnotes&#34;&gt;

&lt;hr /&gt;

&lt;ol&gt;
&lt;li id=&#34;fn:1&#34;&gt;For example, &lt;code&gt;std::vector&lt;/code&gt;, conceptually, holds only a pointer to the heap memory storing the contents of the container, so it is possible to move the contents of an entire container in constant time; however, for &lt;code&gt;std::array&lt;/code&gt;, the data is stored directly in the &lt;code&gt;std::array&lt;/code&gt; object, so the move operation runs in linear time. Similar analysis applies to &lt;code&gt;std::string&lt;/code&gt; when the &lt;em&gt;small string optimization&lt;/em&gt; (SSO) occcurs.
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:1&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;</description>
    </item>
    
    <item>
      <title>[EMCpp]Item-28 Understand Reference Collapsing</title>
      <link>http://nianze.tk/2018/08/understand-reference-collapsing/</link>
      <pubDate>Fri, 17 Aug 2018 19:46:25 -0400</pubDate>
      
      <guid>http://nianze.tk/2018/08/understand-reference-collapsing/</guid>
      <description>&lt;p&gt;Reference collapsing occurs in four contexts: template instantiation, auto type generation, creation and use of typedefs and alias declarations, and decltype.
&lt;/p&gt;

&lt;p&gt;The core concept in this item: A universal reference isn&amp;rsquo;t a new kind of reference, it&amp;rsquo;s actually an rvalue reference in a context where two conditions are satisfied:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Type deduction distinguishes lvalues from rvalues&lt;/strong&gt;. (Lvalues of type T are deduced to have type &lt;code&gt;T&amp;amp;&lt;/code&gt;, while rvalues of type &lt;code&gt;T&lt;/code&gt; yield &lt;code&gt;T&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Reference collapsing occurs&lt;/strong&gt;.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Specifically, if a reference to a reference is generated by compilers arises in one of the four context mentioned above, the references collapse to a single reference according this rule:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;if either of the original references is an lvalue reference, the result is an lvalue reference&lt;/li&gt;
&lt;li&gt;otherwise, it&amp;rsquo;s an rvalue reference&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;template-instantiation&#34;&gt;Template instantiation&lt;/h4&gt;

&lt;p&gt;Reference collapsing is a key part to make &lt;code&gt;std::forward&lt;/code&gt; work. For example, given an possible implementation of &lt;code&gt;std::forward&lt;/code&gt; and a function &lt;code&gt;f&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;template&amp;lt;typename T&amp;gt;
T&amp;amp;&amp;amp; forward(typename remove_reference&amp;lt;T&amp;gt;::type&amp;amp; param)
{
    return static_cast&amp;lt;T&amp;amp;&amp;amp;&amp;gt;(param);
}

template&amp;lt;typename T&amp;gt;
void f(T&amp;amp;&amp;amp; Param)
{
    ...
    someFunc(std::forward&amp;lt;T&amp;gt;(fParam));
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If we pass an lvalue of type &lt;code&gt;Widget&lt;/code&gt; to function &lt;code&gt;f&lt;/code&gt;, &lt;code&gt;T&lt;/code&gt; will then be deduced as &lt;code&gt;Widget&amp;amp;&lt;/code&gt;, and we get:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;Widget&amp;amp; &amp;amp;&amp;amp; forward(typename remove_reference&amp;lt;Widget&amp;amp;&amp;gt;::type&amp;amp; param)
{
    return static_cast&amp;lt;Widget&amp;amp; &amp;amp;&amp;amp;&amp;gt;(param);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;According to reference collapsing rule, we get:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;Widget&amp;amp; forward(Widget&amp;amp; param)
{
    return static_cast&amp;lt;Widget&amp;amp;&amp;gt;(param);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If we pass to &lt;code&gt;f&lt;/code&gt; an rvalue of type &lt;code&gt;Widget&lt;/code&gt;, &lt;code&gt;T&lt;/code&gt; will then be &lt;code&gt;Widget&lt;/code&gt;, and we get:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;Widget &amp;amp;&amp;amp; forward(typename remove_reference&amp;lt;Widget&amp;gt;::type&amp;amp; param)
{
    return static_cast&amp;lt;Widget &amp;amp;&amp;amp;&amp;gt;(param);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;According to reference collapsing rule, we get:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;Widget&amp;amp;&amp;amp; forward(Widget&amp;amp; param)
{
    return static_cast&amp;lt;Widget&amp;amp;&amp;amp;&amp;gt;(param);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Overall, an rvalue arguement &lt;code&gt;Widget&lt;/code&gt; passed to &lt;code&gt;f&lt;/code&gt; will be bound to the lvalue parameter &lt;code&gt;fParam&lt;/code&gt; firstly, be casted into an rvalue, and then be &lt;code&gt;forward&lt;/code&gt;ed to &lt;code&gt;someFunc&lt;/code&gt;.&lt;/p&gt;

&lt;h4 id=&#34;auto-type-generation&#34;&gt;auto type generation&lt;/h4&gt;

&lt;p&gt;Type deduction for &lt;code&gt;auto&lt;/code&gt; variables is essentially the same as deduction for templates.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;Widget widgetFactory();

Widget w; // w is lvalue

auto&amp;amp;&amp;amp; w1 = w; // type deduces as Widget&amp;amp;, so Widget&amp;amp; &amp;amp;&amp;amp; w1 = w -collapsing-&amp;gt; Wiget&amp;amp; w1 = w
auto&amp;amp;&amp;amp; w2 = widgetFactory(); // type deduces as Widget, so Widget&amp;amp;&amp;amp; w2 = widgetFactory();
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;typedefs-and-alias-declarations&#34;&gt;typedefs and alias declarations&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;template&amp;lt;typename T&amp;gt;
class Widget {
public:
    typedefs T&amp;amp;&amp;amp; RvalueRefToT;
    ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Given &lt;code&gt;Widget&amp;lt;int&amp;amp;&amp;gt; w;&lt;/code&gt;, we get &lt;code&gt;typedef int&amp;amp; &amp;amp;&amp;amp; RvalueRefToT;&lt;/code&gt;, which then collapses into &lt;code&gt;typedef int&amp;amp; RvalueRefToT;&lt;/code&gt;. Interestingly, the name turns out to be misleading: the &lt;code&gt;typedef&lt;/code&gt; actually refers to an lvalue reference to &lt;code&gt;int&lt;/code&gt; now if instantiated with an lvalue reference type &lt;code&gt;int&amp;amp;&lt;/code&gt;.&lt;/p&gt;

&lt;h4 id=&#34;decltype&#34;&gt;decltype&lt;/h4&gt;

&lt;p&gt;Same logic as above to analyze.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>[EMCpp]Item-27 Alternatives to Overloading on Universal References</title>
      <link>http://nianze.tk/2018/08/alternatives-to-overloading-on-universal-references/</link>
      <pubDate>Wed, 15 Aug 2018 18:25:27 -0400</pubDate>
      
      <guid>http://nianze.tk/2018/08/alternatives-to-overloading-on-universal-references/</guid>
      <description>&lt;p&gt;Universal reference parameters often have efficiency advantages, but they typically have usability disadvantages.

&lt;!-- toc --&gt;&lt;/p&gt;

&lt;h1 id=&#34;abandon-overloading&#34;&gt;Abandon overloading&lt;/h1&gt;

&lt;p&gt;This solution works for overloaded &lt;code&gt;logAndAdd&lt;/code&gt; example in Item 26, where we break the overloaded function into two: &lt;code&gt;logAndAddName&lt;/code&gt; and &lt;code&gt;logAndAddIdx&lt;/code&gt;. However, this will not work for &lt;code&gt;Person&lt;/code&gt; constructor - the constructor names are fixed by the language.&lt;/p&gt;

&lt;h1 id=&#34;pass-by-const-t&#34;&gt;Pass by &lt;code&gt;const T&amp;amp;&lt;/code&gt;&lt;/h1&gt;

&lt;p&gt;This is the original function &lt;code&gt;void logAndAdd(const std::string&amp;amp; name)&lt;/code&gt; we see in Item 26. Not efficient in some cases, but works as expected.&lt;/p&gt;

&lt;h1 id=&#34;pass-by-value&#34;&gt;Pass by value&lt;/h1&gt;

&lt;p&gt;According to the advice in Item 41, we may consider passing objects by value when we know we&amp;rsquo;ll copy them. Thus, the &lt;code&gt;Person&lt;/code&gt; example may get revised like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class Person {
public:
    explicit Person(std::string n)
    : name(std::move(n)) {}
    explicit Person(int idx)
    : name(nameFromIdx(idx)) {}
    ...
private:
    std::string name;
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;With this design, &lt;code&gt;int&lt;/code&gt;-like arguments get passed to &lt;code&gt;int&lt;/code&gt; overload, and arguments of type &lt;code&gt;std::string&lt;/code&gt; (and anything from which &lt;code&gt;std::string&lt;/code&gt; could be created, e.g., literals) get passed to the &lt;code&gt;std::string&lt;/code&gt; overload.&lt;/p&gt;

&lt;h1 id=&#34;use-tag-dispatch&#34;&gt;Use Tag dispatch&lt;/h1&gt;

&lt;p&gt;Add another &amp;ldquo;tag&amp;rdquo; parameter to help compiler differentiate the overloading cases as we want:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;template&amp;lt;typename T&amp;gt;
void logAndAdd(T&amp;amp;&amp;amp; name)
{
    logAndAddImpl(
        std::forward&amp;lt;T&amp;gt;(name),
        std::is_integral&amp;lt;typename std::remove_reference&amp;lt;T&amp;gt;::type&amp;gt;()
    );
}

template&amp;lt;typename T&amp;gt;
void logAndAddImpl(T&amp;amp;&amp;amp; name, std::false_type)
{
    auto now = std::chrono::system_clock::now();
    log(now, &amp;quot;logAndAdd&amp;quot;);
    names.emplace(std::forward&amp;lt;T&amp;gt;(name));
}

std::string nameFromIdx(int idx);

template&amp;lt;typename T&amp;gt;
void logAndAddImpl(T&amp;amp;&amp;amp; name, std::true_type)
{
    logAndAdd(nameFromIdx(idx));
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Conceptually, &lt;code&gt;true&lt;/code&gt; and &lt;code&gt;false&lt;/code&gt; are &lt;em&gt;runtime&lt;/em&gt; values, and what we need here for the tag parameter should be &lt;em&gt;compil-time&lt;/em&gt; types that corresponds to &lt;code&gt;true&lt;/code&gt; and &lt;code&gt;false&lt;/code&gt;, which in the Standard Library are called &lt;code&gt;std::true_type&lt;/code&gt; and &lt;code&gt;std::false_type&lt;/code&gt;. This compile-time variables serve no purpose at runtime, so some compilers who&amp;rsquo;s smart enough may recognize these tag parameters and optimize them out of the program&amp;rsquo;s execution image.&lt;/p&gt;

&lt;p&gt;Tag dispatch is a standard building block of template metaprogramming to let the tag determine which overload gets called, so that overloading on universal references may work as expect.&lt;/p&gt;

&lt;h1 id=&#34;use-enable-if-to-constrain-templates-that-take-universal-references&#34;&gt;Use &lt;code&gt;enable_if&lt;/code&gt; to constrain templates that take universal references&lt;/h1&gt;

&lt;p&gt;Tag dispatch solves some of the problems related with templates taking universal references, but not all of them. The perfect-forwarding constructor for the &lt;code&gt;Person&lt;/code&gt; class, for example, remains problematic: even if we write only one constructor and apply tag dispactch technique to it, some constructor calls (copy from &lt;code&gt;const&lt;/code&gt; vs non-&lt;code&gt;const&lt;/code&gt; lvalues) may sometimes be handled by compiler-generated functions (e.g., copy and move constructors) that bypass the tag dispatch system.&lt;/p&gt;

&lt;p&gt;Thus, we want to constrain on when the function template is permitted to be employed. By default, all templates are &lt;em&gt;enabled&lt;/em&gt;, but a template using &lt;code&gt;std::enable_if&lt;/code&gt; is enabled only if the condition specified by &lt;code&gt;std::enable_if&lt;/code&gt; is satisfied.&lt;/p&gt;

&lt;p&gt;In the case of &lt;code&gt;Person&lt;/code&gt;&amp;rsquo;s perfect forwarding constructor, we want to enable its instantiation only if the type being passed isn&amp;rsquo;t &lt;code&gt;Person&lt;/code&gt;, so that the class&amp;rsquo;s copy or move constructor my handle the calls where a &lt;code&gt;Person&lt;/code&gt; object gets passed in. Specifically, when checking the type of the argument being passed, we want to ignore its referenceness, constness, and volatileness using &lt;code&gt;std::decay&amp;lt;T&amp;gt;&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class Person {
public:
    template&amp;lt;
        typename T,
        typename = typename std::enable_if&amp;lt;
                        !std::is_same&amp;lt;Person,
                                      typename std::decay&amp;lt;T&amp;gt;::type
                                     &amp;gt;::value
                   &amp;gt;::type
    &amp;gt;
    explicit Person(T&amp;amp;&amp;amp; n);
    ...
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Moreover, if we want to make sure the derived class work properly, the conditions for &lt;code&gt;std::enble_if&lt;/code&gt; get more restricted: we want to enable it for any argument type other than &lt;em&gt;&lt;code&gt;Person&lt;/code&gt; or a type derived from &lt;code&gt;Person&lt;/code&gt;&lt;/em&gt;. To determian whether one type is derived from another, we can use &lt;code&gt;std::is_base_of&amp;lt;T1, T2&amp;gt;&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class Person {
public:
    template&amp;lt;
        typename T,
        typename = typename std::enable_if&amp;lt;
                        !std::is_base_of&amp;lt;Person,
                                         typename std::decay&amp;lt;T&amp;gt;::type
                                        &amp;gt;::value
                   &amp;gt;::type
    &amp;gt;
    explicit Person(T&amp;amp;&amp;amp; n);
    ...
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In C++14, by employing alias templates, we can save some typing for &lt;code&gt;typename&lt;/code&gt; and &lt;code&gt;::type&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class Person {
public;
    template&amp;lt;
        typename T,
        typename = std::enbale_if_t&amp;lt;
            !std::is_base_of&amp;lt;Person, std::decay_t&amp;lt;T&amp;gt;&amp;gt;::value
        &amp;gt;
    &amp;gt;
    explicit Person(T&amp;amp;&amp;amp; n);
    ...
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Finally, to get our perfect forwarding constructor to work with the &lt;code&gt;int&lt;/code&gt; overload, we have to add another constrain in &lt;code&gt;std::enbale_if&lt;/code&gt; to check the integral arguments type:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class Person {
public;
    template&amp;lt;
        typename T,
        typename = std::enbale_if_t&amp;lt;
            !std::is_base_of&amp;lt;Person, std::decay_t&amp;lt;T&amp;gt;&amp;gt;::value
            &amp;amp;&amp;amp;
            !std::is_integral&amp;lt;std::remove_reference_t&amp;lt;T&amp;gt;&amp;gt;::value
        &amp;gt;
    &amp;gt;    
    explicit Person(T&amp;amp;&amp;amp; n)   // ctor for std::strings and args convertible to std::strings
    : name(std::forward&amp;lt;T&amp;gt;(n))
    { ... }

    explicit Person(int idx) // ctor for integral args
    : name(nameFromIdx(idx))
    { ... }

    ...                      // copy and move ctors, etc.
private:
    std::string name;
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To make even more effective code, considering some kinds of arguments can&amp;rsquo;t be perfect-forwarded, as well as the fact that forwarding functions tend to create lengthy error messages, which is debug-unfriendly, we can use &lt;code&gt;static_assert&lt;/code&gt;, accompanied with &lt;code&gt;std::is_constructible&lt;/code&gt;, to perform a compile-time test to determine whether an object of one type can be constructed from an object (or a set of objects) of a different type (or set of types):&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class Person {
public;
    template&amp;lt;
        typename T,
        typename = std::enbale_if_t&amp;lt;
            !std::is_base_of&amp;lt;Person, std::decay_t&amp;lt;T&amp;gt;&amp;gt;::value
            &amp;amp;&amp;amp;
            !std::is_integral&amp;lt;std::remove_reference_t&amp;lt;T&amp;gt;&amp;gt;::value
        &amp;gt;
    &amp;gt;    
    explicit Person(T&amp;amp;&amp;amp; n)   // ctor for std::strings and args convertible to std::strings
    : name(std::forward&amp;lt;T&amp;gt;(n))
    { 
        static_assert(
            std::is_constructible&amp;lt;std::string, T&amp;gt;::value,
            &amp;quot;Parameter n can&#39;t be used to construct a std::string&amp;quot;
        );
        ...  // the usual ctor work goes here
    }
    ...
};
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>[EMCpp]Item-26 Avoid Overloading on Universal References</title>
      <link>http://nianze.tk/2018/08/avoid-overloading-on-universal-references/</link>
      <pubDate>Mon, 13 Aug 2018 18:54:05 -0400</pubDate>
      
      <guid>http://nianze.tk/2018/08/avoid-overloading-on-universal-references/</guid>
      <description>&lt;p&gt;Overloading on universal references almost always leads to the universal reference overload being called more frequently than expected.

&lt;!-- toc --&gt;&lt;/p&gt;

&lt;h1 id=&#34;why-universal-references&#34;&gt;Why universal references?&lt;/h1&gt;

&lt;p&gt;We want to introduce universal references because we can eliminate some inefficiencies via it. For example,&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;std::multiset&amp;lt;std::string&amp;gt; names;
void logAndAdd(const std::string&amp;amp; name)
{
    auto now = std::chrono::system_clock::now();
    log(now, &amp;quot;logAndAdd&amp;quot;);
    names.emplace(name);  // add name to global data structure. See EMCpp Item 42 for info on emplace
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;std::string petName(&amp;quot;Amy&amp;quot;);
logAndAdd(petName);  // passing lvalue
logAndAdd(std::string(&amp;quot;Ben&amp;quot;));  // passing rvalue
logAndAdd(&amp;quot;Candice&amp;quot;);  // passing string literal
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;&lt;code&gt;petName&lt;/code&gt; is lvalue, so &lt;code&gt;name&lt;/code&gt; is bound to it, and then copied into &lt;code&gt;names&lt;/code&gt;. Since an lvalue was passed into &lt;code&gt;logAndAdd&lt;/code&gt;, the final copy operation can not be avoided.&lt;/li&gt;
&lt;li&gt;the parameter for the second call is rvalue, where a temporary of type &lt;code&gt;std::string&lt;/code&gt; is explicitly created and gets bound to &lt;code&gt;name&lt;/code&gt;, and then &lt;code&gt;name&lt;/code&gt; get copied into &lt;code&gt;names&lt;/code&gt;. In this call, we might optimize that final copy operation with a move operation since we are dealing with an rvalue&lt;/li&gt;
&lt;li&gt;similar procedure as the second call but the &lt;code&gt;std::string&lt;/code&gt; is implicitly created from string literal &lt;code&gt;Candice&lt;/code&gt;. We might optimize the final copy operation by creating the &lt;code&gt;std::string&lt;/code&gt; object directly inside the &lt;code&gt;std::multiset&lt;/code&gt; if &lt;code&gt;emplace&lt;/code&gt; could use the string literal directly as argument, so there&amp;rsquo;s not even a move operation.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;To achieve such optimization, we find universal reference, accompany with &lt;code&gt;std::forward&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;template&amp;lt;typename T&amp;gt;
void logAndAdd(T&amp;amp;&amp;amp; name)
{
    auto now = std::chrono::system_clock::now();  
    log(now, &amp;quot;logAndAdd&amp;quot;);  
    names.emplace(std::forward&amp;lt;T&amp;gt;(name));
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;what-trouble-universal-references-introduces&#34;&gt;What trouble universal references introduces?&lt;/h1&gt;

&lt;p&gt;Functions taking universal references are the greediest functions in C++, so the usually overload more argument types than the developer generally expects. Suppose there&amp;rsquo;s another function overloading for the type of &lt;code&gt;int&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;std::string nameFromIdx(int idx); // return name corresponding to idx
void logAndAdd(int idx)
{
    auto now = std::chrono::system_clock::now();  
    log(now, &amp;quot;logAndAdd&amp;quot;);  
    names.emplace(nameFromIdx(idx));
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;logAndAdd(22);  // calls int overload
logAndAdd(&amp;quot;David&amp;quot;);  // calls T&amp;amp;&amp;amp; overload
short nameIdx;
...
logAndAdd(nameIdx);  // error!
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We generally assume the last call will invoke the &lt;code&gt;int&lt;/code&gt; overload, but instead it will invoke the &lt;code&gt;T&amp;amp;&amp;amp;&lt;/code&gt; one, since the universal reference overload version exactly matches the &lt;code&gt;short&lt;/code&gt; argument by deduce &lt;code&gt;T&lt;/code&gt; to be &lt;code&gt;short&amp;amp;&lt;/code&gt;, while &lt;code&gt;int&lt;/code&gt; version has to match &lt;code&gt;short&lt;/code&gt; with a promotion. As a result, the exact match beats a match with a promotion. However, within the &lt;code&gt;T&amp;amp;&amp;amp;&lt;/code&gt; overload, the parameter &lt;code&gt;name&lt;/code&gt; with type &lt;code&gt;short&amp;amp;&lt;/code&gt; first get passed into &lt;code&gt;std::forward&lt;/code&gt;, which will not get casted into a rvalue since &lt;code&gt;name&lt;/code&gt; is initialized with an lvalue (refer to EMCpp item 24), and then get passed into &lt;code&gt;emplace&lt;/code&gt; member function on &lt;code&gt;names&lt;/code&gt;, which finally forwards it to the &lt;code&gt;std::string&lt;/code&gt; constructor, and we get an error here because no constructor for &lt;code&gt;std::string&lt;/code&gt; will take a short.&lt;/p&gt;

&lt;h1 id=&#34;more-problematic-perfect-forwarding-consturctors&#34;&gt;More problematic: Perfect-forwarding consturctors&lt;/h1&gt;

&lt;p&gt;Perfect-forwarding constructors are typically better matches than copy constructors for non-&lt;code&gt;const&lt;/code&gt; lvalues, and they can hijack derived class calls to base class copy and move constructors, which makes them problematic. For example:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class Person {
public:
    template&amp;lt;typename T&amp;gt;
    explicit Person(T&amp;amp;&amp;amp; n)
    : name(std::forward&amp;lt;T&amp;gt;(n)) {}  // perfect forwarding ctor;
    
    explicit Person(int idx)
    : name(nameFromIdx(idx)) {} // int ctor
    ...
private:
    std::string name;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Remember in EMCpp item 17 we mensioned that, under appropriate conditions, the compiler will generate copy and move constructors for us, even if the class contains a templatized constructor that could be instantiated to produce the signature of the copy or move constructor. In that case, we get following two compiler-generated member functions:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;Person(const Person&amp;amp; rhs);  // copy ctor generated by compiler
Person(Person&amp;amp;&amp;amp; rhs); // move ctor generated by compiler
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And now comes the problem: these two member functions will easily get shadowed by the universal reference constructor:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;Person p1(&amp;quot;Edward&amp;quot;);
auto cloneOfP1(p1);  // create new Person from p; 
                     // T&amp;amp;&amp;amp; ctor get invoked: T is deduces as &amp;quot;Person&amp;amp;&amp;quot;, better than copy ctor&#39;s type &amp;quot;const Person&amp;amp;&amp;quot;
const Person p2(&amp;quot;Fernando&amp;quot;);
auto cloneOfP2(p2);  // fine; copy ctor get invoked.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Moreover, the inheritance makes the mess even worse:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class SpecialPerson: public Person {
public:
    SpecialPerson(const SpecialPerson&amp;amp; rhs)
    : Person(rhs)  // calls base class forwarding ctor
    { ... }
    SpecialPerson(SpecialPerson&amp;amp;&amp;amp; rhs)
    : Person(std::move(rhs)) // calls base class forwarding ctor
    { ... }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here, the derived class will call the perfect forwarding constructor for their copy and move constructors, because they are using arguments of type &lt;code&gt;SpecialPerson&lt;/code&gt; to pass to their base class, and base class&amp;rsquo;s forwarding constructor will happily instantiate an exact match for this call. Since there&amp;rsquo;s no &lt;code&gt;std::string&lt;/code&gt; constructor taking a &lt;code&gt;SpecialPerson&lt;/code&gt;, the code won&amp;rsquo;t compile.&lt;/p&gt;

&lt;h1 id=&#34;conclusion&#34;&gt;Conclusion&lt;/h1&gt;

&lt;p&gt;Overloading on universal reference is something we should avoid if possible. However, if we do want a function that forwards most argument types, while still support special treatment for some special types, we can find some alternatives to achieve this goal in EMCpp item 27.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>[EMCpp]Item-25 Use std::move on Rvalue References, std::forward on Universal References</title>
      <link>http://nianze.tk/2018/08/use-stdmove-on-rvalue-references-stdforward-on-universal-references/</link>
      <pubDate>Sat, 11 Aug 2018 15:26:53 -0400</pubDate>
      
      <guid>http://nianze.tk/2018/08/use-stdmove-on-rvalue-references-stdforward-on-universal-references/</guid>
      <description>&lt;p&gt;But don&amp;rsquo;t apply &lt;code&gt;std::move&lt;/code&gt; or &lt;code&gt;std::forward&lt;/code&gt; to local objects if they would otherwise be eligible for the return value optimization.

&lt;!-- toc --&gt;&lt;/p&gt;

&lt;h1 id=&#34;normal-cases&#34;&gt;Normal cases&lt;/h1&gt;

&lt;p&gt;When forwarding them to other functions, rvalue references, which is always bound to rvalues, should be &lt;em&gt;unconditionally&lt;/em&gt; cast to rvalues (via &lt;code&gt;std::move&lt;/code&gt;), while universal references, which is sometimes bound be rvalues, should be &lt;em&gt;conditionally&lt;/em&gt; cast to rvalues (via &lt;code&gt;std::forward&lt;/code&gt;):&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class Widget {
public:
    Widget(Widget&amp;amp;&amp;amp; rhs)          // rhs is rvalue reference
    : name(std::move(rhs.name)),
      p(std::move(rhs.p))
      {...}
    template&amp;lt;typename T&amp;gt;
    void setName(T&amp;amp;&amp;amp; newName)     // newName is rvalue reference
    { name = std::forward&amp;lt;T&amp;gt;(newName); }
    ...
private:
    std::string name;
    std::shared_ptr&amp;lt;SomeDataStructure&amp;gt; p;
};
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;what-if&#34;&gt;What if&lt;/h1&gt;

&lt;p&gt;You may wonder, what will happen if we exchange &lt;code&gt;std::forward&lt;/code&gt; ans &lt;code&gt;std::move&lt;/code&gt;:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;applying &lt;code&gt;std::forward&lt;/code&gt; on rvalue references can exhibit the proper behavior, but the source code is wordy, error-prone&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:1&#34;&gt;&lt;a href=&#34;#fn:1&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;, and unidiomatic:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;Widget::Widget(Widget&amp;amp;&amp;amp; rhs) : 
    name(std::forward&amp;lt;std::string&amp;gt;(rhs.name)), 
    p(std::forward&amp;lt;std::shared_ptr&amp;lt;SomeDataStructure&amp;gt;&amp;gt;(rhs.p))
{...}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;using &lt;code&gt;std::move&lt;/code&gt; on universal refenreces can have the effect of unexpectedly modifying lvalues (e.g., local variables):&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;template&amp;lt;typename T&amp;gt;
void Widget::setName(T&amp;amp;&amp;amp; newName)
{ name = std::move(newName); } // compiles, but is bad!

std::string getWidgetName();   // factory function
Widget w;
auto n = getWidgetName();      // n is local variable
w.setName(n);                  // moves n into w
...                            // n&#39;s value now unkown!
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Another alternative is to replace the template taking a universal reference with a pair of functions overloaded on lvalue references and rvalue references:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class Widget {
public:
    void setName(const std::string&amp;amp; newName)  // set from const lvalue
    { name = newName; }
    void setName(std::string&amp;amp;&amp;amp; newName)      // set from rvalue
    { name = std::move(newName); }
    ...
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The cost we pay for this replacement is:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;More source code to write and maintain (two functions instead of a single template)&lt;/li&gt;
&lt;li&gt;Less efficient in some cases such as this&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:2&#34;&gt;&lt;a href=&#34;#fn:2&#34;&gt;2&lt;/a&gt;&lt;/sup&gt;:&lt;br /&gt;
&lt;code&gt;cpp
w.setName(&amp;quot;John Smith&amp;quot;);
&lt;/code&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Poor scalability of the design if more parameters come (each of which can be an lvalue or rvalue):&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;tempalte&amp;lt;class T, class... Args&amp;gt; 
shared_ptr&amp;lt;T&amp;gt; make_shared(Args&amp;amp;&amp;amp;... args);  // can&#39;t overload on lvalues and rvalues on args. universal reference is used and std::forward is applyied
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&#34;other-usage&#34;&gt;Other usage&lt;/h1&gt;

&lt;p&gt;Moreove, sometimes we want to apply &lt;code&gt;std::move&lt;/code&gt; or &lt;code&gt;std::forward&lt;/code&gt; to only the final use of the reference when an rvalue reference or a universal reference will be used more than once in a single function:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;template&amp;lt;typename T&amp;gt;
void setSignText(T&amp;amp;&amp;amp; text)  // text is a universal reference
{
    sign.setText(text);  // use text, but do not modify it
    auto now = std::chrono::system_clock::now();
    signHistory.add(now, std::forward&amp;lt;T&amp;gt;(text)); // conditionally cast to rvalue
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The same logic applies to &lt;code&gt;std::move&lt;/code&gt;, except that in rare cases, we want to call &lt;code&gt;std::move_if_noexcept&lt;/code&gt; instead of &lt;code&gt;std::move&lt;/code&gt; (refer to EMCpp item 14).&lt;/p&gt;

&lt;p&gt;If a function &lt;em&gt;returns be value&lt;/em&gt;, and the returning object is bound to an rvalue refernece or a universal reference, we also want to apply &lt;code&gt;std::move&lt;/code&gt; or &lt;code&gt;std::forward&lt;/code&gt; to support potential move construction and get more efficient:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;Matric operator+(Matric&amp;amp;&amp;amp; lhs, const Matrix&amp;amp; rhs)
{
    lhs += rhs;
    return std::move(lhs);  // move lhs into return value
}

template&amp;lt;typename T&amp;gt;
Fraction reduceAndCopy(T&amp;amp;&amp;amp; frac)
{
    frac.reduce();
    return std::forward&amp;lt;T&amp;gt;(frac);  // move rvalue into return value; copy lvalue
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;when-not-to&#34;&gt;When not to&lt;/h1&gt;

&lt;p&gt;According to Standardization Committee, there&amp;rsquo;s a kind of optimizatoin called &lt;em&gt;return value optimization (RVO)&lt;/em&gt;:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;the “copying” version of makeWidget can avoid the need to copy the local variable w by constructing it in the memory alloted for the function’s return value&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Due to this optimization, we should not use &lt;code&gt;std::move&lt;/code&gt; on a local object being returnd from a function that&amp;rsquo;s returning by value so that we won&amp;rsquo;t precluding the RVO that compilers will do for the return value.&lt;/p&gt;
&lt;div class=&#34;footnotes&#34;&gt;

&lt;hr /&gt;

&lt;ol&gt;
&lt;li id=&#34;fn:1&#34;&gt;The type we pass to &lt;code&gt;std::forward&lt;/code&gt; should be a non-reference, according to the convention for encoding that the argument being passed is an rvalue (see EMCpp Item 28).
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:1&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:2&#34;&gt;With the universal reference version, there&amp;rsquo;s only one call to &lt;code&gt;std::string&lt;/code&gt; assignment operator for &lt;code&gt;w.name&lt;/code&gt;, since the string literal would be passed to this function as a &lt;code&gt;const char*&lt;/code&gt; pointer; the overloaded versions entail execution of one &lt;code&gt;std::string&lt;/code&gt; constructor (to create a temporary), one &lt;code&gt;std::string&lt;/code&gt; move assignment operator (to move &lt;code&gt;newName&lt;/code&gt; into &lt;code&gt;w.name&lt;/code&gt;), and one &lt;code&gt;std::string&lt;/code&gt; destructor (to destroy the temporary), which is almost certainly more expensive.
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:2&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;</description>
    </item>
    
    <item>
      <title>[EMCpp]Item-24 Distinguish Universal References From Rvalue References</title>
      <link>http://nianze.tk/2018/08/distinguish-universal-references-from-rvalue-references/</link>
      <pubDate>Wed, 08 Aug 2018 18:56:09 -0400</pubDate>
      
      <guid>http://nianze.tk/2018/08/distinguish-universal-references-from-rvalue-references/</guid>
      <description>&lt;p&gt;If a function template parameter has type &lt;code&gt;T&amp;amp;&amp;amp;&lt;/code&gt; for a deduced type &lt;code&gt;T&lt;/code&gt;, or if an object is declared using &lt;code&gt;auto&amp;amp;&amp;amp;&lt;/code&gt;, the parameter or object is a &lt;em&gt;universal reference&lt;/em&gt;.
&lt;/p&gt;

&lt;p&gt;&lt;code&gt;T&amp;amp;&amp;amp;&lt;/code&gt; has two different meanings: one is for rvalue reference, another is for universal reference. Universal references are called &amp;ldquo;universal&amp;rdquo;, because they can bind to virtually &lt;em&gt;anything&lt;/em&gt;:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;bind to rvalues (behave like rvalue references &lt;code&gt;T&amp;amp;&amp;amp;&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;bind to lvalues (behave like lvalue references &lt;code&gt;T&amp;amp;&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;bind to objects that is &lt;code&gt;const&lt;/code&gt; or non-&lt;code&gt;const&lt;/code&gt;, &lt;code&gt;volatile&lt;/code&gt; or non-&lt;code&gt;volatile&lt;/code&gt;, or both &lt;code&gt;const&lt;/code&gt; and &lt;code&gt;volatile&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Universal refenrences must company with a special form (i.e., the form of &amp;ldquo;&lt;code&gt;T&amp;amp;&amp;amp;&lt;/code&gt;&amp;rdquo;) after the occurrence of &lt;em&gt;type deduction&lt;/em&gt;, and typically arise in two contexts: the most common case is function template parameters, while another context is &lt;code&gt;auto&lt;/code&gt; declarations:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;template&amp;lt;typename T&amp;gt;
void f(T&amp;amp;&amp;amp; param);  // param is a universal reference
auto&amp;amp;&amp;amp; var2 = var1;  // var2 is a universal reference

Widget w;
f(w);  // lvalue passed to f; param&#39;s type is Widget&amp;amp;, act as an lvalue ref.
f(std::move(w));  // rvalue passed to f; param&#39;s type is Widget&amp;amp;&amp;amp;, act as an rvalue ref.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If there&amp;rsquo;s no type deduction, or if the type deduction form is incorrect (not in form of &amp;ldquo;T&amp;amp;&amp;amp;&amp;ldquo;), then there&amp;rsquo;s no universal references:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;void f(Widget&amp;amp;&amp;amp; param);  // no type deduction; param is an rvalue reference
Widget&amp;amp;&amp;amp; var1 = Widget(); // no type deduction; param is an rvalue reference

template&amp;lt;typename T&amp;gt;
void f(std::vector&amp;lt;T&amp;gt;&amp;amp;&amp;amp; param);  // not in precise form of T&amp;amp;&amp;amp;, param here is an rvalue ref.

template&amp;lt;typename T&amp;gt;
void f(const T&amp;amp;&amp;amp; param); // not in precise form of T&amp;amp;&amp;amp;, param here is an rvalue ref.

template&amp;lt;typename T, class Allocator = allocator&amp;lt;T&amp;gt;&amp;gt;  // from C++ standards
class vector {
public:
    void push_back(T&amp;amp;&amp;amp; x);  // no type deduction here; x is rvalue reference;
    ...   // a particular vector instantiation must have occurred prior to any call to this function
}

template&amp;lt;typename T, class Allocator = allocator&amp;lt;T&amp;gt;&amp;gt;  // from C++ standards
class vector {
public:
    template&amp;lt;class... Args&amp;gt;
    void emplace_back(Args&amp;amp;&amp;amp;... args);  // universal reference! because:
    ...  // 1. in correct form of &amp;quot;T&amp;amp;&amp;amp;&amp;quot;; 2. type parameter Args must be deduced each time emplace_back is called
}

// this function can time pretty much any function execution. more information is in EMCpp item 30
auto timeFuncInvocation =    // C++14
    [] (auto&amp;amp;&amp;amp; func, auto&amp;amp;&amp;amp;... param)  // func is a universal reference that can be bound to any callable object, lvaue or rvalue
    {   // param is zero or more universal references (i.e., a universal reference parameter pack) that can be bound to any number of objects of arbitrary types
        // start timer;
        std::forward&amp;lt;decltype(func)&amp;gt;(func)(  // invoke func on params
            std::forward&amp;lt;decltype(params)&amp;gt;(params)...
        );
        // stop timer and record elapsed time;
    };
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In fact, the foundation of univeral references is a lie (an &amp;ldquo;abstraction&amp;rdquo;), with underlying truth being known as &lt;em&gt;reference collapsing&lt;/em&gt; discussed in EMCpp Item 28. Distinguishing between rvalue references and universal references will help us read source code more accurately.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>[EMCpp]Item-23 Understand std::Move and std::Forward</title>
      <link>http://nianze.tk/2018/08/understand-stdmove-and-stdforward/</link>
      <pubDate>Tue, 07 Aug 2018 17:57:26 -0400</pubDate>
      
      <guid>http://nianze.tk/2018/08/understand-stdmove-and-stdforward/</guid>
      <description>&lt;p&gt;&lt;code&gt;std::move&lt;/code&gt; performs an unconditional cast to an rvalue, while &lt;code&gt;std::forward&lt;/code&gt; casts its argument to an rvalue only if that argument is bound to an rvalue.

&lt;!-- toc --&gt;&lt;/p&gt;

&lt;p&gt;Some facts:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Neither &lt;code&gt;std::move&lt;/code&gt; nor &lt;code&gt;std::forward&lt;/code&gt; do anything at runtime.&lt;/li&gt;
&lt;li&gt;Move request on &lt;code&gt;const&lt;/code&gt; objects are treated as copy requests.&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;std-move&#34;&gt;std::move&lt;/h1&gt;

&lt;p&gt;To make things concrete, a very basic implementation of &lt;code&gt;std::move&lt;/code&gt; in C++11 looks like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;template&amp;lt;typename T&amp;gt;
typename remove_reference&amp;lt;T&amp;gt;::type&amp;amp;&amp;amp;
move(T&amp;amp;&amp;amp; param)
{
    using ReturnType = typename remove_reference&amp;lt;T&amp;gt;::type&amp;amp;&amp;amp;;
    return static_cast&amp;lt;ReturnType&amp;gt;(param);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Or, a more elegant implementation in C++14:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;template&amp;lt;typename T&amp;gt;
decltype&amp;lt;auto&amp;gt; move(T&amp;amp;&amp;amp; param)
{
    using ReturnType = remove_reference_t&amp;lt;T&amp;gt;&amp;amp;&amp;amp;;
    return static_cast&amp;lt;ReturnType&amp;gt;(param);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Basically, &lt;code&gt;std::move&lt;/code&gt; does nothing but cast its argument to an rvalue, and we might think it as &lt;code&gt;rvalue_cast&lt;/code&gt;. Usually we want &lt;code&gt;move&lt;/code&gt; operation on rvalues, so every time we see a &lt;code&gt;move&lt;/code&gt; over some parameter, we know we want to perform move operation over the resulting rvalue. However, not all rvalues are candidates for moving, especailly those annotated by &lt;code&gt;const&lt;/code&gt; - &lt;em&gt;move requests on &lt;code&gt;const&lt;/code&gt; objects are silentlly transformed into copy operation&lt;/em&gt;.&lt;/p&gt;

&lt;h1 id=&#34;std-forward&#34;&gt;std::forward&lt;/h1&gt;

&lt;p&gt;&lt;code&gt;std::move&lt;/code&gt; unconditionally casts its argument to an rvalue, while &lt;code&gt;std::forward&lt;/code&gt; conditionally do so: it casts to an rvalue only if its argument was initialized with an rvalue.&lt;/p&gt;

&lt;p&gt;The most common scenario is a function template taking a universal reference parameter that is to be passed to another function:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;void process(const Widget&amp;amp; lvalArg);
void process(Widget&amp;amp;&amp;amp; rvalArg);

template&amp;lt;typename T&amp;gt;
void logAndProcess(T&amp;amp;&amp;amp; param)  // universal reference
{
    auto now = std::chrono::system_clock::now();
    makeLogEntry(&amp;quot;Calling &#39;process&#39;&amp;quot;, now);
    process(std::forward&amp;lt;T&amp;gt;(param));
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;Widget w;
logAndProcess(w);             // call with lvalue
logAndProcess(std::move(w));  // call with rvalue
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In the code above, &lt;code&gt;std::forward&lt;/code&gt; is able to tell whether &lt;code&gt;param&lt;/code&gt; is initialized with an lvalue or an rvalue because that information is encoded in &lt;code&gt;logAndProcess&lt;/code&gt;&amp;rsquo;s template parameter &lt;code&gt;T&lt;/code&gt;, which is then passed to &lt;code&gt;std::forward&lt;/code&gt;, which is able to recover the encoded information. For details, refer to EMCpp item 28.&lt;/p&gt;

&lt;h1 id=&#34;comparison&#34;&gt;Comparison&lt;/h1&gt;

&lt;p&gt;Depending on the usecase scenario, we can tell when to use which:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;std:move&lt;/code&gt; typically sets up a move&lt;/li&gt;
&lt;li&gt;&lt;code&gt;std::forward&lt;/code&gt; just passes - &lt;em&gt;forwards&lt;/em&gt;- an object to another function in a way that retains its original lvalueness or rvalueness.&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>[EMCpp]Item-22 When Using Pimple Idiom, Define Special Member Functions in the Implementation File</title>
      <link>http://nianze.tk/2018/08/prefer-make_unique-and-make_shared-to-direct-use-of-new/</link>
      <pubDate>Sun, 05 Aug 2018 23:46:08 -0400</pubDate>
      
      <guid>http://nianze.tk/2018/08/prefer-make_unique-and-make_shared-to-direct-use-of-new/</guid>
      <description>&lt;p&gt;For &lt;code&gt;std::unique_ptr&lt;/code&gt; pImpl pointers, declare special member functions in the class header, but implement them in the implementation file.
&lt;/p&gt;

&lt;p&gt;The Pimpl Idiom decreases build times by reducing compilation dependeencies between class clients and class implementation. For example:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;// header file
class Widget {
public:
    Widget();
    ...
private:
    struct Impl;
    std::unique_ptr&amp;lt;Impl&amp;gt; pImpl;
};
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;// impl. file
#include &amp;quot;Widget.h&amp;quot;
#include &amp;quot;gadget.h&amp;quot;
#include &amp;lt;string&amp;gt;
#include &amp;lt;vector&amp;gt;

struct Widget::Impl {
    std::string name;
    std::vector&amp;lt;double&amp;gt; data;
    Gadget g1, g2, g3;
};

Widget::Widget ()
: pImpl(std::make_unique&amp;lt;Impl&amp;gt;())
{}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;However, even though the code above compiles, client code below won&amp;rsquo;t compile:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;quot;Widget.h&amp;quot;
Widget w; // error!
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The issue arises due to the code that&amp;rsquo;s generated when &lt;code&gt;w&lt;/code&gt; goes out of scope and gets destroyed:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Since there&amp;rsquo;s no user defined destructor, destructor for &lt;code&gt;Widget&lt;/code&gt; is generated by compiler, inside which there is a call to the destructor for &lt;code&gt;pImpl&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;pImpl&lt;/code&gt; is a &lt;code&gt;std::unique_ptr&amp;lt;Widget::Impl&amp;gt;&lt;/code&gt; using default deleter (a function that uses &lt;code&gt;delete&lt;/code&gt; on the raw pointer inside the &lt;code&gt;std::unique_ptr&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;prior to using &lt;code&gt;delete&lt;/code&gt;, autogenerated implementation will have the default deleter employ C++11&amp;rsquo;s &lt;code&gt;static_assert&lt;/code&gt; to ensure the raw pointer doesn&amp;rsquo;t point to an &lt;em&gt;incomplete type&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;here this &lt;code&gt;static_assert&lt;/code&gt; fails, because autogenerated destructors are implicitly &lt;code&gt;inline&lt;/code&gt;, and thus the definition of &lt;code&gt;Widget::Impl&lt;/code&gt; along with its autogenerated destructor inside &lt;code&gt;Widget.cpp&lt;/code&gt; hasn&amp;rsquo;t been seen by compilers&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;To solve the problem, we need to let the compiler see the body of &lt;code&gt;Widget&lt;/code&gt;&amp;rsquo;s destructor only inside the implementation file after &lt;code&gt;Widget::Impl&lt;/code&gt; has been defined:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;// header file
class Widget {
public:
    Widget();
    ~Widget();  // declaration only
    ...
private:
    struct Impl;
    std::unique_ptr&amp;lt;Impl&amp;gt; pImpl;
};
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;// impl. file
#include &amp;quot;Widget.h&amp;quot;
#include &amp;quot;gadget.h&amp;quot;
#include &amp;lt;string&amp;gt;
#include &amp;lt;vector&amp;gt;

struct Widget::Impl {
    std::string name;
    std::vector&amp;lt;double&amp;gt; data;
    Gadget g1, g2, g3;
};

Widget::Widget ()
: pImpl(std::make_unique&amp;lt;Impl&amp;gt;())
{}

Widget::~Widget()
{}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To emphasize the fact that the compiler-generated destructor would do the right thing, we can also write like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;Widget::~Widget() = default; 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The same reasoning goes with move operation:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;the compiler generated move assignment operator requires &lt;code&gt;Impl&lt;/code&gt; to be complete because the object pointed to by &lt;code&gt;pImpl&lt;/code&gt; needs to be destroyed before assignment&lt;/li&gt;
&lt;li&gt;the compiler generated move constructor requires &lt;code&gt;Impl&lt;/code&gt; to be complete because compilers must be able to generate code to destroy &lt;code&gt;pImpl&lt;/code&gt; in the event that an exception arises inside the move constructor (even it the constructor is &lt;code&gt;noexcept&lt;/code&gt;)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Once we added the move-related functions, compilers won&amp;rsquo;t generate copy operations for us. So to support a well-defined deep copy, we need to write our own version.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class Widget {
public:
    Widget();
    ~Widget();
    Widget(Widget&amp;amp;&amp;amp; rhs) noexcept;
    Widget&amp;amp; operator=(Widget&amp;amp;&amp;amp; rhs) noexcept;
    Widget(const Widget&amp;amp; rhs);
    Widgt&amp;amp; operator=(const Widget&amp;amp; rhs); 
private:
    struct Impl;
    std::unique_str&amp;lt;Impl&amp;gt; pImpl;
};
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;...
Widget::~Widget() = default;
Widget::Widget(Widget&amp;amp;&amp;amp; rhs) noexcept = default;
Widget&amp;amp; Widget::operator=(Widget&amp;amp;&amp;amp; rhs) noexcept = default;

Widget::Widget(const Widget&amp;amp; rhs)
: pImpl(nullptr)
{ if (rhs.pImpl) pImpl = std::make_unique&amp;lt;Impl&amp;gt;(*rhs.pImpl); }

Widget&amp;amp; Widget::operator=(const Widget&amp;amp; rhs)
{
    if (!rhs.pImpl) pImpl.reset();
    else if (!pImpl) pImpl = std::make_unique&amp;lt;Impl&amp;gt;(*rhs.pImpl);
    else *pImpl = *rhs.pImpl;
    return *this;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;On the other hand, the above advice does not apply to &lt;code&gt;std::shared_ptr&lt;/code&gt;, because in &lt;code&gt;std::shared_ptr&lt;/code&gt;, the type of the deleter is not part of the type of the smart pointer, and pointed-to types need not be complete when compiler-generated special functions are employed:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class Widget {
public:
    Widget();
    ...  // no declaration for dtor or move operations
private:
    struct Impl;
    std::shared_ptr&amp;lt;Impl&amp;gt; pImpl;
};
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;// client code compiles without problem
Widget w1;
auto w2(std::move(w1));  // move-construct w2
w1 = std::move(w2);  // move-assign w1
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>[EMCpp]Item-21 Prefer std::make_unique and std::make_shared to Direct Use of New</title>
      <link>http://nianze.tk/2018/08/prefer-make_unique-and-make_shared-to-direct-use-of-new/</link>
      <pubDate>Thu, 02 Aug 2018 18:45:53 -0400</pubDate>
      
      <guid>http://nianze.tk/2018/08/prefer-make_unique-and-make_shared-to-direct-use-of-new/</guid>
      <description>&lt;p&gt;Compared to &lt;code&gt;new&lt;/code&gt;, make functions eliminate source code duplication, improve exception safety, and, for &lt;code&gt;std::make_shard&lt;/code&gt; and &lt;code&gt;std::allocate_shared&lt;/code&gt;, generate code that&amp;rsquo;s smaller and faster.
&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Make functions&lt;/em&gt; take an arbitrary set of arguments, perfect forward them to the constructor for a dynamically allocacted object, and return a smart pointer to that objet. There are three &lt;em&gt;make functions&lt;/em&gt;:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;std::make_unique&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;std::make_shared&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;std::allocate_shared&lt;/code&gt;&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:1&#34;&gt;&lt;a href=&#34;#fn:1&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;According to the description above, a basic version of &lt;code&gt;std::make_unique&lt;/code&gt; is simply:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;template&amp;lt;typename T, typename... Ts&amp;gt;
std::unique_ptr&amp;lt;T&amp;gt; make_unique(Ts&amp;amp;&amp;amp;... params){
    return std::unique_ptr&amp;lt;T&amp;gt;(new T(std::forward&amp;lt;Ts&amp;gt;(params)...));
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;good-parts&#34;&gt;Good parts&lt;/h4&gt;

&lt;p&gt;There are thee reasons to prefer make functions to direct use of &lt;code&gt;new&lt;/code&gt;.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Eliminate code duplication&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;auto upw1(std::make_unique&amp;lt;Widget&amp;gt;());
std::unique_ptr&amp;lt;Widget&amp;gt; upw2(new Widget);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As we can see above, using make functions avoids code duplication of the repeating type &lt;code&gt;Widget&lt;/code&gt;.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Improve exception safety&lt;/p&gt;

&lt;p&gt;Given following functions:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;void processWidget(std::shared_ptr&amp;lt;Widget&amp;gt; spw, int priority);
int computePriority();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;then there will be potential resource leak if we directly use &lt;code&gt;new&lt;/code&gt; like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;processWidget(std::shared_ptr&amp;lt;Widget&amp;gt;(new Widget), computePriority());
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The potential edge case comes with compilers&amp;rsquo; translation of source code into object code: compilers may emit code to execute the operations in this order:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Perform &amp;ldquo;new Widget&amp;rdquo;&lt;/li&gt;
&lt;li&gt;Execute &lt;code&gt;computePriority&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Run &lt;code&gt;std::shared_ptr&lt;/code&gt; constructor&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;At runtime, if &lt;code&gt;computePriority&lt;/code&gt; produces an exception, the dynamically allocated Widget from Step 1 will be leaked, since it will never be stored in the &lt;code&gt;std::shared_ptr&lt;/code&gt; that&amp;rsquo;s supposed to start managing it in Step 3.&lt;/p&gt;

&lt;p&gt;If we use &lt;code&gt;std::make_shared&lt;/code&gt; instead of using &lt;code&gt;new&lt;/code&gt; inside &lt;code&gt;std::shared_ptr&lt;/code&gt;, there&amp;rsquo;s no Step 1, so Step 2 will never be executed between a &lt;code&gt;new&lt;/code&gt; operation and the construction of &lt;code&gt;std::shared_ptr&lt;/code&gt;, which is thus exception-safe.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Smaller and faster code for &lt;code&gt;std::shared_ptr&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Compared with direct use of &lt;code&gt;new&lt;/code&gt;, the improved efficiency provided by &lt;code&gt;std::make_shared&lt;/code&gt; and &lt;code&gt;std::allocate_shared&lt;/code&gt; is related with its memory allocation mechanism.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;If we directly use &lt;code&gt;new&lt;/code&gt; like this - &lt;code&gt;std::shared_ptr&amp;lt;Widget&amp;gt; spw(new Widget);&lt;/code&gt; - there are two phaces of allocation involved:

&lt;ul&gt;
&lt;li&gt;one for &lt;code&gt;Widget&lt;/code&gt; object,&lt;/li&gt;
&lt;li&gt;another for the control block associated with that object.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Instead, &lt;code&gt;auto spw = std::make_shared&amp;lt;Widget&amp;gt;();&lt;/code&gt;, one allocation suffices: &lt;code&gt;std::make_shared&lt;/code&gt; allocates a single chunk of memory to hold both the &lt;code&gt;Widget&lt;/code&gt; object and the constrol block.

&lt;ul&gt;
&lt;li&gt;This optimization reduces the static size of the program, since the code contains only one memory allocation call&lt;/li&gt;
&lt;li&gt;This operation also increases the speed of the executable code, since memory is allocated only once&lt;/li&gt;
&lt;li&gt;Further more, total memory footprint is potentially reduced, since some of the bookkeeping information in the control block is obviated.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&#34;weak-parts&#34;&gt;Weak parts&lt;/h4&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Specify custom deleters&lt;/p&gt;

&lt;p&gt;There&amp;rsquo;s no way to specify a custom deleter using a make function, but using &lt;code&gt;new&lt;/code&gt; is straightforward:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;auto widgetDeleter = [](Widget* pw) {...};
std::unique_ptr&amp;lt;Widget, decltype(widgettDeleter)&amp;gt; upw(new Widget, widgetDeleter);
std::shared_ptr&amp;lt;Widget&amp;gt; spw(new Widget, widgetDeleter);
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Pass braced initializers&lt;/p&gt;

&lt;p&gt;In these calls,&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;auto upv = std::make_unique&amp;lt;std::vector&amp;lt;int&amp;gt;&amp;gt;(10, 20);
auto spv = std::make_shared&amp;lt;std::vector&amp;lt;int&amp;gt;&amp;gt;(10, 20);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;the resulting smart pointers point to &lt;code&gt;std::vector&lt;/code&gt;s with 10 elements, each of value 20, which means within the make functions, the perfect forwarding code uses the non-&lt;code&gt;std::initializer_list&lt;/code&gt; constructor. If we do want to perfect-forward a braced initializer, we use following workaround;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;auto initList = { 10, 20 }; // create std::initializer_list
auto spv = std::make_shared&amp;lt;std::vector&amp;lt;int&amp;gt;&amp;gt;(initList); // create std:vector using std::initializer_list cotr
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Custom memory management or memory restriction concerns for &lt;code&gt;std::shared_ptr&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Due to the extra control block in &lt;code&gt;std::shared_ptr&lt;/code&gt;, there are two more edge cases where make functions may be ill-advised:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;classes with custom memory management:

&lt;ul&gt;
&lt;li&gt;if a class defines its own versions of &lt;code&gt;operator new&lt;/code&gt; and &lt;code&gt;operator delete&lt;/code&gt;, it implies the global memory allocation and deallocation routines for objects of this class are inappropriate.&lt;/li&gt;
&lt;li&gt;class-specific routines are often designed only to allocate and deallocate chunks of memory of pricisely the size of objects of this class&lt;/li&gt;
&lt;li&gt;&lt;code&gt;std::allocate_shared&lt;/code&gt; however requests to allocate the size of one object plus the size of a control block, so the class-specific routines are poor fit for &lt;code&gt;std::allocate_shared&lt;/code&gt; and custom deleters.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;systems with memory concerns

&lt;ul&gt;
&lt;li&gt;when using &lt;code&gt;std::make_shared&lt;/code&gt;, the memory allocation for the object and the control block is at the same time, which brings us the smaller and faster code mentioned above; however, this also means that the deallocation for the same chunk of memory has to be at the same time&lt;/li&gt;
&lt;li&gt;when an object&amp;rsquo;s reference count goes to zero, the object is destroyed (via its destructor), but the memory it occupies will wait to be released until the control block also gets destroyed&lt;/li&gt;
&lt;li&gt;control block contains a &lt;em&gt;weak count&lt;/em&gt; (a second reference count for &lt;code&gt;std::weak_ptr&lt;/code&gt;); as long as the weak count is greater than zero, the control block must continue to exist&lt;/li&gt;
&lt;li&gt;if the object type is quite large and the time between destrution of the last &lt;code&gt;std::shared_ptr&lt;/code&gt; and the last &lt;code&gt;std::weak_ptr&lt;/code&gt; is significant, a lag occurres between when an object is destroyed and when the memory this object (and its control block) occupied is freed&lt;/li&gt;
&lt;li&gt;if memory is a concern, this lag will make us frown&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Due to the reasons above, we may have to give up make function and directly use &lt;code&gt;new&lt;/code&gt;, but we also want to keep our program exception-safe. Here is a workaround, take the same &lt;code&gt;processWidget&lt;/code&gt; for example:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;std::shared_ptr&amp;lt;Widget&amp;gt; spw(new Widget, cusDel);
processWidget(std::move(spw), computePriority());  // keep arg as rvalue, so it&#39;s move-enabled
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;std::move&lt;/code&gt; here is to make sure the argument we pass to &lt;code&gt;processWidget&lt;/code&gt; is rvalue, so that expensive copy construction for a &lt;code&gt;std::shared_ptr&lt;/code&gt; object, which involves atomic increment of its reference count, will be replaced by a move construction, which requires no reference count manipulation.&lt;/p&gt;
&lt;div class=&#34;footnotes&#34;&gt;

&lt;hr /&gt;

&lt;ol&gt;
&lt;li id=&#34;fn:1&#34;&gt;&lt;code&gt;std::allocate_shared&lt;/code&gt; acts just like &lt;code&gt;std::make_shared&lt;/code&gt;, except its first argument is an allocator object to be used for the dynamic memory allocation.
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:1&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;</description>
    </item>
    
    <item>
      <title>[EMCpp]Item-20 Use Weak_ptr for Shared_ptr Like Pointers That Can Dangle</title>
      <link>http://nianze.tk/2018/08/use-weak_ptr-for-shared_ptr-like-pointers-that-can-dangle/</link>
      <pubDate>Wed, 01 Aug 2018 18:44:19 -0400</pubDate>
      
      <guid>http://nianze.tk/2018/08/use-weak_ptr-for-shared_ptr-like-pointers-that-can-dangle/</guid>
      <description>&lt;p&gt;Potential use cases for &lt;code&gt;std::weak_ptr&lt;/code&gt; include caching, observer lists, and the prevention of &lt;code&gt;std::shared_ptr&lt;/code&gt; cycles.
&lt;/p&gt;

&lt;p&gt;From an efficiency perspective, the &lt;code&gt;std::weak_ptr&lt;/code&gt; is essentially the same as &lt;code&gt;std::shared_ptr&lt;/code&gt;, except that they don&amp;rsquo;t participate in the &lt;em&gt;shared ownership&lt;/em&gt; of objects and hence don&amp;rsquo;t affect the &lt;em&gt;pointed-to object&amp;rsquo;s reference count&lt;/em&gt;. However, they do manipulate a second reference count in the control block (&lt;em&gt;weak count&lt;/em&gt;), so they actually do all the same operations such as construction, destruction, and assignment involve atomic reference count manipulations.&lt;/p&gt;

&lt;p&gt;As a fact, &lt;code&gt;std::weak_ptr&lt;/code&gt; isn&amp;rsquo;t a standalone smart pointer, but an augmentation of &lt;code&gt;std::shared_ptr&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;auto spw = std::make_shared&amp;lt;Widget&amp;gt;(); // reference count (RC) is 1 after spw is constructed
...
std::weak_ptr&amp;lt;Widget&amp;gt; wpw(spw);   // RC remains 1 
...
spw = nullptr; // RC becomes 0, Widget gets destroyed, wpw dangles
if (wpw.exipred()) ...  // true
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Usually, the purpose of creating a &lt;code&gt;std::weak_ptr&lt;/code&gt; is to check the dangling &lt;code&gt;std::weak_ptr&lt;/code&gt; (when the related control block has zero-value reference count), and if it hasn&amp;rsquo;t expired, we may access the object it points to. Separating the check and the dereference would introduce a race condition, so we need an atomic operation to check and access the object at the same time. There are two ways to do this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;auto spw1 = wpw.lock();  // spw1 type is shared_ptr&amp;lt;Widget&amp;gt;; if wpw&#39;s expired, spw1 is null
std::shared_ptr&amp;lt;Widget&amp;gt; spw2(wpw);  // if wpw&#39;s expired, throw std::bad_weak_ptr
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;There are at least three use cases for &lt;code&gt;std::weak_ptr&lt;/code&gt;.&lt;/p&gt;

&lt;h4 id=&#34;caching&#34;&gt;Caching&lt;/h4&gt;

&lt;p&gt;Given a factory function returning &lt;code&gt;std::unique_ptr&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;std::unique_ptr&amp;lt;const Widget&amp;gt; loadWidget(WidgetID id);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We might consider wrap a cache layer on top of &lt;code&gt;loadWidget&lt;/code&gt; due to considerations such as expensive database I/O cost or frequent queries from clients. A quick-and-dirty implementation using &lt;code&gt;std::weak_ptr&lt;/code&gt; may fit the requirement&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:1&#34;&gt;&lt;a href=&#34;#fn:1&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;std::shared_ptr&amp;lt;const Widget&amp;gt; fastLoadWidget(WidgetID id)
{
    static std::unordered_map&amp;lt;WidgetID, 
                              std::weak_ptr&amp;lt;const Widget&amp;gt;&amp;gt; cache;
    auto objPtr = cache[id].lock();
    if (!objPtr) {
        objPtr = loadWidget(id);
        cache[id] = objPtr;
    }
    return objPtr;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;observer-list&#34;&gt;Observer list&lt;/h4&gt;

&lt;p&gt;In the Observer design pattern, there are two components:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;subjects: whose state may change&lt;/li&gt;
&lt;li&gt;observers: who will be notified when state changes occur&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Each subject may contain a data member holding pointers to its observers to issue state change notifications. Since subjects only cares if an observer gets destroyed (to cancel subsequent notifications) and needn&amp;rsquo;t control the lifetime of their observers, a reasonable design, therefore, is to let each subject hold a container of &lt;code&gt;std::weak_ptr&lt;/code&gt;s to its observers, and check if a pointer dangles before using it.&lt;/p&gt;

&lt;h4 id=&#34;cycling-prevention&#34;&gt;Cycling prevention&lt;/h4&gt;

&lt;p&gt;In strictly hierarchal data structures such as trees, child nodes are typially owned only by their parents. When a parent node is destroyed, child nodes are destroyed, too. Links from parents to children are generally best represented by &lt;code&gt;std::unique_ptr&lt;/code&gt;, while back-links from children to parents can be safely implemented as raw pointers&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:2&#34;&gt;&lt;a href=&#34;#fn:2&#34;&gt;2&lt;/a&gt;&lt;/sup&gt;.&lt;/p&gt;

&lt;p&gt;In other pointer-based non-strict-hierarchical data structure, however, forward-links may be best implemented in terms of &lt;code&gt;std::shared_ptr&lt;/code&gt;, and to prevent cycles, which will lead to resource leak&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:3&#34;&gt;&lt;a href=&#34;#fn:3&#34;&gt;3&lt;/a&gt;&lt;/sup&gt;, back-link should use &lt;code&gt;std::weak_ptr&lt;/code&gt;.&lt;/p&gt;
&lt;div class=&#34;footnotes&#34;&gt;

&lt;hr /&gt;

&lt;ol&gt;
&lt;li id=&#34;fn:1&#34;&gt;A potential refinement is to remove the expired cache, since right now the cache accumulate &lt;code&gt;std::weak_ptr&lt;/code&gt; corresponding to &lt;code&gt;Widget&lt;/code&gt;s that are no longer in use (and have therefore been destroyed).
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:1&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:2&#34;&gt;Children have a shorter lifetime than their parent node, so there&amp;rsquo;s no risk of a child node dereferencing a dangling parent pointer.
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:2&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:3&#34;&gt;Two &lt;code&gt;std::shared_ptr&lt;/code&gt;s point to each other wil prevent both from being destroyed: even if both object are unreachable from other program data structures, each will have a reference count of one.
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:3&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;</description>
    </item>
    
    <item>
      <title>[EMCpp]Item-19 Use std::Shared_ptr for Shared-ownership Resource Management</title>
      <link>http://nianze.tk/2018/07/use-shared_ptr-for-shared-ownership-resource-management/</link>
      <pubDate>Tue, 31 Jul 2018 17:59:25 -0400</pubDate>
      
      <guid>http://nianze.tk/2018/07/use-shared_ptr-for-shared-ownership-resource-management/</guid>
      <description>&lt;p&gt;&lt;code&gt;std::shared_ptrs&lt;/code&gt; offer convenience approaching that of garbage collection for the shared lifetime management of arbitrary resources.

&lt;!-- toc --&gt;&lt;/p&gt;

&lt;h1 id=&#34;some-facts&#34;&gt;Some facts&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;std::shared_ptr&lt;/code&gt;s are twice the size of a raw pointer:

&lt;ul&gt;
&lt;li&gt;a raw pointer to the resource&lt;/li&gt;
&lt;li&gt;a raw pointer to the resource&amp;rsquo;s &lt;em&gt;control block&lt;/em&gt;, which is dynamically allocated and contains

&lt;ul&gt;
&lt;li&gt;reference count&lt;/li&gt;
&lt;li&gt;weak count&lt;/li&gt;
&lt;li&gt;other optional data (e.g., custom deleter, allocator, etc)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;increments and decrements of the reference count are atomic

&lt;ul&gt;
&lt;li&gt;reading and writing reference counts is typically slower than non-atomic operations and comparatively costly&lt;/li&gt;
&lt;li&gt;the related atomic operations typically map to individual machine instructions. Admittedly, they are expensive compared to non-atomic instructons, but they&amp;rsquo;re still just single instructions&lt;/li&gt;
&lt;li&gt;move-constructing a &lt;code&gt;std::shared_ptr&lt;/code&gt; from another &lt;code&gt;std::shared_ptr&lt;/code&gt; requires no refernece count manipulation&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Default resource destruction is via &lt;code&gt;delete&lt;/code&gt;, but custom deleters are supported

&lt;ul&gt;
&lt;li&gt;the type of the deleter has no effect on the type of the &lt;code&gt;std::shared_ptr&lt;/code&gt; (they&amp;rsquo;re in the control block)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;std::shared_ptr&lt;/code&gt; is designed only for pointers to single objects, and can&amp;rsquo;t work with arrays, unlike &lt;code&gt;std::unique_ptr&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Basically, this is how a &lt;code&gt;std::shared_ptr&amp;lt;T&amp;gt;&lt;/code&gt; object looks like in the memory:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; std::shared_ptr&amp;lt;T&amp;gt;
┌──────────────────────┐   ┌──────────┐
│      Ptr to T        ├──&amp;gt;│ T Object │
├──────────────────────┤   └──────────┘
│ Ptr to Control Block ├───┐
└──────────────────────┘   ↓     Control Block
                           ┌───────────────────────┐
                           │    Reference Count    │
                           ├───────────────────────┤
                           │      Weak Count       │
                           ├───────────────────────┤
                           │      Other Data       │
                           │ (e.g., custom deleter,│
                           │   allocator, etc.)    │
                           └───────────────────────┘

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It is worth noting that &lt;code&gt;std::shared_ptr&lt;/code&gt; design is more flexible than &lt;code&gt;std::unique_ptr&lt;/code&gt; in the aspect of specifying custom deleters, because, unlike &lt;code&gt;std::unique_ptr&lt;/code&gt;, the type of the deleter is not part of the type of the &lt;code&gt;std::shared_ptr&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;auto customDeleter1 = [](Widget *pw) {...};
auto customDeleter2 = [](Widget *pw) {...};

std::unique_ptr&amp;lt;Widget, decltype(customDeleter1)&amp;gt; upw1(new Widget, customDeleter1);
std::unique_ptr&amp;lt;Widget, decltype(customDeleter2)&amp;gt; upw2(new Widget, customDeleter1);

std::shared_ptr&amp;lt;Widget&amp;gt; spw1 (new widget, customDeleter1);
std::shared_ptr&amp;lt;Widget&amp;gt; spw2 (new widget, customDeleter2);
std::vector&amp;lt;std::shared_ptr&amp;lt;Widget&amp;gt;&amp;gt; vpw { spw1, spw2 };
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Apart from placing &lt;code&gt;spw1&lt;/code&gt; and &lt;code&gt;spw2&lt;/code&gt; in the same container, we could also assign one to another, or pass them into a function taking a parameter of type &lt;code&gt;std::shared_ptr&amp;lt;Widget&amp;gt;&lt;/code&gt;. None of these things can be done with &lt;code&gt;std::unique_ptr&lt;/code&gt;s, since their types differ due to different custom deleters.&lt;/p&gt;

&lt;h1 id=&#34;avoid-multiple-control-blocks-from-this-pointer&#34;&gt;Avoid multiple control blocks from &lt;code&gt;this&lt;/code&gt; pointer&lt;/h1&gt;

&lt;p&gt;Below is the rules to create the control block:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;a control block is created when &lt;code&gt;std::make_shared&lt;/code&gt; (EMCpp item 20) is called (which manufactures a new object to point to)&lt;/li&gt;
&lt;li&gt;a control block is created when &lt;code&gt;std::shared_ptr&lt;/code&gt; is constructed from a unique-ownership pointer (i.e., a &lt;code&gt;std::unique_ptr&lt;/code&gt; or &lt;code&gt;std::auto_ptr&lt;/code&gt;), and the unique-ownership pointer is set to null later.&lt;/li&gt;
&lt;li&gt;a control block is created when a &lt;code&gt;std::shared_ptr&lt;/code&gt; is called with a raw pointer

&lt;ul&gt;
&lt;li&gt;this may lead to double deletion issue (creating two control blocks with the same raw pointer), so avoid passing raw pointers to a &lt;code&gt;std::shared_ptr&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;if have to, do in this form &lt;code&gt;std::shared_ptr&amp;lt;Widget&amp;gt; spw(new Widget, loggingDel);&lt;/code&gt; to use &lt;code&gt;new&lt;/code&gt; directly&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;the same control block will be shared if a &lt;code&gt;std::shared_ptr&lt;/code&gt; is constructed using another &lt;code&gt;std::shared_ptr&lt;/code&gt; as initialization argument (by calling &lt;code&gt;std::shared_ptr&lt;/code&gt; copy constructor)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Even though we remember the rule to restrict the creation of &lt;code&gt;std::shared_ptr&lt;/code&gt; from raw pointers, we might surprisingly create multiple control blocks through the &lt;code&gt;this&lt;/code&gt; pointer, which is also a raw pointer. For example, &lt;code&gt;Widget&lt;/code&gt; has a member function &lt;code&gt;void processing();&lt;/code&gt;, and we use a vector to keep track of &lt;code&gt;Widget&lt;/code&gt;s that have been processed. A reasonable-looking approach looks like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;std::vector&amp;lt;std::shared_ptr&amp;lt;Widget&amp;gt;&amp;gt; processedWidgets;
class Widget {
public:
    ...
    void process();
    ...
};

void Widget::process(){
    ...
    processedWidgets.emplace_back(this);  // add current Widget to list of processed Widgets
    ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This code will compiler, but it has potential danger: &lt;code&gt;process()&lt;/code&gt; passes raw pointer &lt;code&gt;this&lt;/code&gt; to a container of &lt;code&gt;std::shared_ptr&lt;/code&gt;, resulting to a new control block for pointed-to &lt;code&gt;Widget&lt;/code&gt;(&lt;code&gt;*this&lt;/code&gt;); as long as there are &lt;code&gt;std::shared_ptr&lt;/code&gt;s outside the &lt;code&gt;process()&lt;/code&gt; that already point to that &lt;code&gt;Widget&lt;/code&gt;, undefined behavior shows up.&lt;/p&gt;

&lt;p&gt;Here, we want a class managed by &lt;code&gt;std::shared_ptr&lt;/code&gt;s to be able to safely create a &lt;code&gt;std::shared_ptr&lt;/code&gt; from a &lt;code&gt;this&lt;/code&gt; pointer without creating multiple control blocks. The solution is to inherit from a base class template  &lt;code&gt;std::enable_shared_from_this&lt;/code&gt;, which contains a member function &lt;code&gt;shared_from_this()&lt;/code&gt;, which points to the same object as the &lt;code&gt;this&lt;/code&gt; pointer. We can use this function to create a &lt;code&gt;std::shared_ptr&lt;/code&gt; worring about creating a new control block.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class Widget: public std::enable_shared_from_this&amp;lt;Widget&amp;gt; {
public:
    ...
    void process();
    ...
};

void Widget::process()
{
    ...
    processedWidgets.emplace_back(shared_from_this());
    ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Two points worth noting:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Here, the derived class(&lt;code&gt;Widget&lt;/code&gt;) inherites from a base class templatized on the derived class. This design pattern is called &lt;em&gt;CRTP&lt;/em&gt;: The Curiously Recurring Template Pattern.&lt;/li&gt;
&lt;li&gt;Internally, &lt;code&gt;shared_from_this()&lt;/code&gt; looks up the control block for the current object, and it creates a new &lt;code&gt;std::shared_ptr&lt;/code&gt; referring to that control block. This means there must be an existing &lt;code&gt;std::shared_ptr&lt;/code&gt; that points to the current object. If no such &lt;code&gt;std::shared_ptr&lt;/code&gt; exists, behavior is undefined (typically an exception will be thrown)&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;To prevent invoking &lt;code&gt;shared_from_this()&lt;/code&gt; before a &lt;code&gt;std::shared_ptr&lt;/code&gt; points to the object, classes inheriting from &lt;code&gt;std::enable_shared_from_this&lt;/code&gt; often declare their constructors &lt;code&gt;private&lt;/code&gt; and provide factory functions returning  &lt;code&gt;std::shared_ptr&lt;/code&gt;s to clients:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class Widget: public std::enable_shared_from_this&amp;lt;Widget&amp;gt; {
public;
    template&amp;lt;typename... Ts&amp;gt;
    static std::shared_ptr&amp;lt;Widget&amp;gt; create(Ts&amp;amp;&amp;amp;... params);
    ...
    void process(); // as before
    ...
private:
    ... // ctors
};
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>[EMCpp]Item-18 Use std::unique_ptr for Exclusive-ownership Resource Management</title>
      <link>http://nianze.tk/2018/07/use-unique_ptr-for-exclusive-ownership-resource-management/</link>
      <pubDate>Mon, 30 Jul 2018 15:18:04 -0400</pubDate>
      
      <guid>http://nianze.tk/2018/07/use-unique_ptr-for-exclusive-ownership-resource-management/</guid>
      <description>&lt;p&gt;&lt;code&gt;std::unique_ptr&lt;/code&gt; is a small, fast, move-only smart pointer for managing resources with exclusive-ownership semantics.
&lt;/p&gt;

&lt;p&gt;Some facts:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;std::unique_ptr&lt;/code&gt; embodies &lt;em&gt;exclusive ownership&lt;/em&gt; semantics: a non-null &lt;code&gt;std::unique_ptr&lt;/code&gt; owns what it points to&lt;/li&gt;
&lt;li&gt;Moving a &lt;code&gt;std::unique_ptr&lt;/code&gt; transfers ownershiip from the source pointer to the destination pointer&lt;/li&gt;
&lt;li&gt;Copying a &lt;code&gt;std::unique_ptr&lt;/code&gt; isn&amp;rsquo;t allowed (it&amp;rsquo;s &lt;em&gt;move-only type&lt;/em&gt;)&lt;/li&gt;
&lt;li&gt;Upong destruction, a non-null &lt;code&gt;std::unique_ptr&lt;/code&gt; destroys its resource by calling its deleter (by default the deleter simply applies &lt;code&gt;delete&lt;/code&gt; to the raw pointer inside the &lt;code&gt;std::unique_ptr&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;std::unique_ptr&lt;/code&gt; can easily and efficiently converts to a &lt;code&gt;std::shared_ptr&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Factory functions and Pimpl Idiom are two common use case for &lt;code&gt;std::ptr&lt;/code&gt;s. For example, supporse we have a hierarchy for types of investments (e.g., stocks, bonds, real estate, etc.) with a factory function alllocating an object on the heap and returning a pointer to it:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class Investment {
public:
    ...
    virtual ~Investment();
    ```
};

class Stock: public Investment {...};
class Bond: public Investment {...};
class RealEstate: public Invesetment {...};

template&amp;lt;typename... Ts&amp;gt;
std::unique_ptr&amp;lt;Investment, decltype(delInvmt)&amp;gt;  // return std::unique_ptr to an object 
makeInvestment(Ts&amp;amp;&amp;amp;... params);  // created from the given args with cutomized deleter
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;By the help of &lt;code&gt;std::unique_ptr&lt;/code&gt;, clients will no longer worry about deleting it:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;{
    ...
    auto pInvestment = makeInvestment( arguments );
    ...
}  // destroy *pInvestment
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Callers can also take use of &lt;code&gt;std::unique_ptr&lt;/code&gt;&amp;rsquo;s feature to adapt it to its more flexible sibling &lt;code&gt;std::shared_ptr&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;std::shared_ptr&amp;lt;Investment&amp;gt; sp = makeInvestment( arguments );
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;implementation&#34;&gt;Implementation&lt;/h4&gt;

&lt;p&gt;For C++11, we can implement the factory function this way:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;auto delInvmt = [](Investment* pInvestment)       // custom deleter
                {                                 // (a lambda expression)
                    makeLogEntry(pInvestment);   
                    delete pInvestment;
                };

template&amp;lt;typename... Ts&amp;gt;
std::unique_ptr&amp;lt;Investment, decltype(delInvmt)&amp;gt;
makeInvestment(Ts&amp;amp;&amp;amp;... params)
{
    std::unique_ptr&amp;lt;Investment, decltype(delInvmt)&amp;gt;
        pInv(nullptr, delInvmt);
    if ( /* a Stock should be created */ )
    {
        pInv.reset(new Stock(std::forward&amp;lt;Ts&amp;gt;(params)...));
    }
    else if ( /* a Bond should be created */ )
    {
        pInv.reset(new Bond(std::forward&amp;lt;Ts&amp;gt;(params)...));
    }
    else if ( /* a RealEstate should be created */ )
    {
        pInv.reset(new RealEstate(std::forward&amp;lt;Ts&amp;gt;(params)...));
    }
    return pInv;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In C++14, we could use function return type deduction to make it simpler and more encapsulated:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;template&amp;lt;typename... Ts&amp;gt;
auto makeInvestment(Ts&amp;amp;&amp;amp;... params) // C++14
{
    auto delInvmt = [](Investment* pInvestment)     // now inside makeInvestment
                    {
                        makeLogEntry(pInvestment);
                        delete pInvestment;
                    };
    std::unique_ptr&amp;lt;Investment, decltype(delInvmt)&amp;gt; pInv(nullptr, delInvmt);
    ... // as before
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It is worth thinking about the size impact on a &lt;code&gt;std::unique_ptr&lt;/code&gt; after introducing a custome deleter:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;if the deleter is a function pointer, the size of a &lt;code&gt;std::unique_ptr&lt;/code&gt; generally grow from one (the size of a raw pointer) to two&lt;/li&gt;
&lt;li&gt;if the deleter is a function object, the change in size depends on how much state is stored in the function object

&lt;ul&gt;
&lt;li&gt;Stateless function objects (e.g., from lambda expressions with no captures) typically incur no size penalty when used as deleters (still one word)&lt;/li&gt;
&lt;li&gt;Function object deleters with extensive state can yield &lt;code&gt;std::unique_ptr&lt;/code&gt; objects of significant size.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;two-forms&#34;&gt;Two forms&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;std::unique_ptr&lt;/code&gt; comes in two forms&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;std::unique_ptr&amp;lt;T&amp;gt;&lt;/code&gt; for individule objects, which lacks indexing operator (&lt;code&gt;operator[]&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;std::unique_ptr&amp;lt;T[]&amp;gt;&lt;/code&gt; for arrays, which lacks dereferencing operators (&lt;code&gt;operator*&lt;/code&gt; and &lt;code&gt;operator-&amp;gt;&lt;/code&gt;)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Generally, &lt;code&gt;std::array&lt;/code&gt;, &lt;code&gt;std::vector&lt;/code&gt;, and &lt;code&gt;std::string&lt;/code&gt; are always better data structure choices than raw arrays, so the only situation where &lt;code&gt;std::unique_ptr&amp;lt;T[]&amp;gt;&lt;/code&gt; makes sense would be when we&amp;rsquo;re using a C-like API that returns a raw pointer to a heap array that we assume ownership of.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>[EMCpp]Item-17 Understand Special Member Function Generation</title>
      <link>http://nianze.tk/2018/07/understand-special-member-function-generation/</link>
      <pubDate>Wed, 25 Jul 2018 20:26:53 -0400</pubDate>
      
      <guid>http://nianze.tk/2018/07/understand-special-member-function-generation/</guid>
      <description>&lt;p&gt;The special member functions are those ccompilers may generate on their own: default constructor, destructor, copy operations, and move operations.

&lt;!-- toc --&gt;&lt;/p&gt;

&lt;p&gt;The rules in C++11:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Default constructor: Generated only if the class contains no user-declared constructors. (Same as C++98)&lt;/li&gt;
&lt;li&gt;Destructor: Destructors are &lt;code&gt;noexcept&lt;/code&gt; by default (see EMCpp item 14). Other rules are essentially the same as C++98.&lt;/li&gt;
&lt;li&gt;Copy constructor

&lt;ul&gt;
&lt;li&gt;Runtime behavior: same as C++98: memberwise copy construction of non-static data members&lt;/li&gt;
&lt;li&gt;Generated only if the class lacks a user-declared copy constructor.&lt;/li&gt;
&lt;li&gt;Generation is deprecated if the user declares a copy assignment operator or destructor.&lt;/li&gt;
&lt;li&gt;Deleted if the class declares a move operation.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Copy assignment operator

&lt;ul&gt;
&lt;li&gt;Runtime behavior: same as C++98: memberwise copy assignment of non-static data members.&lt;/li&gt;
&lt;li&gt;Generation is deprecated if the user declares a copy constructor or destructor.&lt;/li&gt;
&lt;li&gt;Deleted if the class declares a move operation.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Move constructor and Move assignment operator:

&lt;ul&gt;
&lt;li&gt;Runtime behavior: memberwise moving of non-static data members&lt;/li&gt;
&lt;li&gt;Generated only if the class lacks user-declared copy operations, move operations, and destrutor.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;use-of-default&#34;&gt;Use of &amp;ldquo;=default&amp;rdquo;&lt;/h1&gt;

&lt;p&gt;The default implementation for special member functions inside a base class is correct. Since we have to explicitly declare the base destructor as &lt;code&gt;virtual&lt;/code&gt; to avoid undefined or misleading results that often occurs in polymorphic inheritance, using  &amp;ldquo;=default&amp;rdquo; will be a good way to express the suppressed default implementation of the move and/or copy operations:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class Base {
public:
    virtual ~Base() = default;   // make dtor virtual

    Base(Base&amp;amp;&amp;amp;) = default;   // support moving
    Base&amp;amp; operator=(Base&amp;amp;&amp;amp;) = default; 

    Base(const Base&amp;amp;) = default;  // support copying
    Base&amp;amp; operator=(const Base&amp;amp;) = default;
};
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;member-function-templates&#34;&gt;Member function templates&lt;/h1&gt;

&lt;p&gt;Note that there&amp;rsquo;s nothing in the rules about the existence of a member function template preventing compilers from generating the special member functions:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class Widget {
    ...
    template&amp;lt;typename T&amp;gt;
    Widget(const T&amp;amp; rhs);   // construct Widget from anything

    template&amp;lt;typename T&amp;gt;
    Widget&amp;amp; operator=(const T&amp;amp; rhs);  // assign Widget from anything
    ...
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Assuming the usual conditions governing special member functions are fulfilled, compilers will still generate copy and move operations for &lt;code&gt;Widget&lt;/code&gt; even though these templates could be instantiated to produce the signatures for the copy constructor and copy assignment operator (when &lt;code&gt;T&lt;/code&gt; is &lt;code&gt;Widget&lt;/code&gt;). Refer to EMCpp item 26 for cases that have important consequences.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>[EMCpp]Item-16 Make Const Member Functions Thread Safe</title>
      <link>http://nianze.tk/2018/07/make-const-member-functions-thread-safe/</link>
      <pubDate>Tue, 24 Jul 2018 10:26:02 -0400</pubDate>
      
      <guid>http://nianze.tk/2018/07/make-const-member-functions-thread-safe/</guid>
      <description>&lt;p&gt;Make &lt;code&gt;const&lt;/code&gt; member functions thread safe unless we&amp;rsquo;re &lt;em&gt;certain&lt;/em&gt; they&amp;rsquo;ll never be used in a concurrent context.

&lt;!-- toc --&gt;&lt;/p&gt;

&lt;p&gt;Due to &lt;code&gt;mutable&lt;/code&gt; member datas, &lt;code&gt;const&lt;/code&gt; member functions may not be thread safe. For a classic use case for &lt;code&gt;mutable&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class Polynomial {
public:
    using RootsType = std::vector&amp;lt;double&amp;gt;;  // holding val. where poly. evals to zero
    RootsType roots() const
    {
        if (!rootsAreValie) {       // if cache not valid
            ...                     // compute roots, store them in rootVals
            rootsAreValid = true; 
        }
        return rootVals;
    }
    ...
private:
    mutable bool rootsAreValid{ false };
    mutable RootsType rootVals{};
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here &lt;code&gt;roots()&lt;/code&gt; retrieves the roots of a polynomial without changing the value of the &lt;code&gt;Polynomial&lt;/code&gt; object on which it operates, so &lt;code&gt;const&lt;/code&gt; declaratoin is correct. However, &lt;code&gt;rootVals&lt;/code&gt; and &lt;code&gt;rootsAreValid&lt;/code&gt; might be modified for the purpose of caching. Seeing the &lt;code&gt;const&lt;/code&gt; interface for &lt;code&gt;roots()&lt;/code&gt;, clients are perfectly reasonable to do something like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;Polynomial p;
...
// thread 1                   // thread 2
auto rootsOfP = p.roots();    auto valsGivingZero = p.roots();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Having multiple threads perform a read operation without synchronization is safe. However, although &lt;code&gt;roots&lt;/code&gt; is declared &lt;code&gt;const&lt;/code&gt;, it&amp;rsquo;s not thread safe: more than one threads might try to modify the data members &lt;code&gt;rootsAreValid&lt;/code&gt; and &lt;code&gt;rootVals&lt;/code&gt; inside &lt;code&gt;roots&lt;/code&gt;, reading and writing the same memory without synchronization - which is data racing, leading to undefined behavior.&lt;/p&gt;

&lt;h1 id=&#34;solution-mutex&#34;&gt;Solution: mutex&lt;/h1&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class Polynomial {
public:
    using RootsType = std::vector&amp;lt;double&amp;gt;;  // holding val. where poly. evals to zero
    RootsType roots() const
    {
        std::lock_guard&amp;lt;std::mutex&amp;gt; g(m);  // lock mutex
        if (!rootsAreValie) {       // if cache not valid
            ...                     // compute roots, store them in rootVals
            rootsAreValid = true; 
        }
        return rootVals;
    }                                      // unlock mutex
    ...
private:
    mutable std::mutex m;
    mutable bool rootsAreValid{ false };
    mutable RootsType rootVals{};
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;roots&lt;/code&gt; is a &lt;code&gt;const&lt;/code&gt; member function, inside which &lt;code&gt;std::mutex m&lt;/code&gt; would be considered a &lt;code&gt;const&lt;/code&gt; object, while &lt;code&gt;locking&lt;/code&gt; and &lt;code&gt;unlocking&lt;/code&gt; are non-&lt;code&gt;const&lt;/code&gt; member functions, so we need to declared &lt;code&gt;m&lt;/code&gt; as &lt;code&gt;mutable&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Another point worth noting is that &lt;code&gt;std::mutex&lt;/code&gt; can be neither copied nor moved, so a side effect of adding &lt;code&gt;m&lt;/code&gt; to &lt;code&gt;Polynomial&lt;/code&gt; is that &lt;code&gt;Polynomial&lt;/code&gt; loses the ability to be copied and moved.&lt;/p&gt;

&lt;h1 id=&#34;for-a-single-variable-requiring-synchronization&#34;&gt;For a single variable requiring synchronization&lt;/h1&gt;

&lt;p&gt;Sometimes when there&amp;rsquo;s only one variable or memory location requiring synchronization, &lt;code&gt;mutex&lt;/code&gt; might be overkill, and we might consider &lt;code&gt;std::atomic&lt;/code&gt; counter (EMCpp item 40), which is often a less expensive way to go&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:1&#34;&gt;&lt;a href=&#34;#fn:1&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class Point {
public:
    ...
    double distanceFromOrigin() const noexcept
    {
        ++callCount;   // atomic increment
        return std::hypot(x, y);
    }
private:
    mutable std::atomic&amp;lt;unsigned&amp;gt; callCount{ 0 };
    double x, y;
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The same side effect goes here: the existance of &lt;code&gt;callCount&lt;/code&gt; in &lt;code&gt;Point&lt;/code&gt; makes &lt;code&gt;Point&lt;/code&gt; neither copyable nor movable.&lt;/p&gt;

&lt;h1 id=&#34;summary&#34;&gt;Summary&lt;/h1&gt;

&lt;p&gt;The point in this item: when we write a &lt;code&gt;const&lt;/code&gt; member function, we might avoid the costs associated with mutexes and &lt;code&gt;std::stomic&lt;/code&gt;s as well as the side effect of uncopyability as well as unmovability, if we can guarantee that there will never be more than one thread executing that member function on an object.&lt;/p&gt;

&lt;p&gt;However, such threading-free scenarios are increasingly uncommon. In order to support concurrent execution, we should unsure that &lt;code&gt;const&lt;/code&gt; member functions are thread safe.&lt;/p&gt;
&lt;div class=&#34;footnotes&#34;&gt;

&lt;hr /&gt;

&lt;ol&gt;
&lt;li id=&#34;fn:1&#34;&gt;Whether it actually is less expensive depends on the hardware we&amp;rsquo;re runnig on and the implementation of mutexes in our Standard Library.
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:1&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;</description>
    </item>
    
    <item>
      <title>[EMCpp]Item-15 Use Constexpr Whenever Possible</title>
      <link>http://nianze.tk/2018/07/use-constexpr-whenever-possible/</link>
      <pubDate>Mon, 23 Jul 2018 19:27:53 -0400</pubDate>
      
      <guid>http://nianze.tk/2018/07/use-constexpr-whenever-possible/</guid>
      <description>&lt;p&gt;&lt;code&gt;constexpr&lt;/code&gt; objects are &lt;code&gt;const&lt;/code&gt; and are initialized with values known during compilation; &lt;code&gt;constexpr&lt;/code&gt; functions can produce copmile-time results when called with arguments whose values are know during compilations.

&lt;!-- toc --&gt;&lt;/p&gt;

&lt;h1 id=&#34;constexpr-objects&#34;&gt;&lt;code&gt;constexpr&lt;/code&gt; objects&lt;/h1&gt;

&lt;p&gt;Values known during compmilation are privileged: they may be placed in read-only memory (important for embedded systems), and part of them with constant integral values can be used in contexts where C++ requires an &lt;em&gt;integral constant expression&lt;/em&gt;&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:1&#34;&gt;&lt;a href=&#34;#fn:1&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;. Thuse, if we want the compilers to ensure that a variable is constant with a value know at compile time, we declare it &lt;code&gt;constexpr&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;int sz;  // non-constexpr variable
...
constexpr auto arraySize1 = sz;  // error: value not known at compilation
std::array&amp;lt;int, sz&amp;gt; data1;       // error: same problem
constexpr auto arraySize2 = 10;  // fine: 10 is compile-time constant
std::array&amp;lt;int, arraySize2&amp;gt; data2; // fine, arraySize2 is constexpr
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;All &lt;code&gt;constexpr&lt;/code&gt; objects are &lt;code&gt;const&lt;/code&gt;, but not all &lt;code&gt;const&lt;/code&gt; objects are &lt;code&gt;constexpr&lt;/code&gt;, because &lt;code&gt;const&lt;/code&gt; objects need not be initialized with values known during compilations:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;int sz;
...
const auto arraySize = sz;  // fine: arraySize is const copy of sz
std::array&amp;lt;int, arraySize&amp;gt;  data; // error: arraySize&#39;s value not known at compilation
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;constexpr-functions&#34;&gt;&lt;code&gt;constexpr&lt;/code&gt; functions&lt;/h1&gt;

&lt;p&gt;&lt;code&gt;constexpr&lt;/code&gt; is part of a functions&amp;rsquo;s interface, which proclaims &amp;ldquo;I can be used in a context where C++ requires a constant expression.&amp;rdquo; In other words:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;if the values of the arguments we pass to a &lt;code&gt;constexpr&lt;/code&gt; function are known during compilation, the result will be computed during compilation&lt;/li&gt;
&lt;li&gt;when a &lt;code&gt;constexpr&lt;/code&gt; function is called with one or more values that are not known during compilation, it acts like a normal function, computing its result at runtime: so that we don&amp;rsquo;t need two functions to perform the same operation.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;For example, we want to initialize a &lt;code&gt;std::array&lt;/code&gt; with the size of 3^n, wher n is a known integer (or can be computed) during compilation. &lt;code&gt;std::pow&lt;/code&gt; doesn&amp;rsquo;t help here, because&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;code&gt;std::pow&lt;/code&gt; works on floating-point types, while we need an integral result&lt;/li&gt;
&lt;li&gt;&lt;code&gt;std::pow&lt;/code&gt; isn&amp;rsquo;t constexpr&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Thus, we write the pow we need:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;constexpr
int pow(int base, unsigned exp) noexcept  // never throws
{
    ...  // impl is below
}

constexpr auto numConds = 5;   // # of conditions
std::array&amp;lt;int, pow(3, numConds)&amp;gt; results; // results has 3^numConds elements
...
auto base = readFromDB(&amp;quot;base&amp;quot;);  // get the value at runtime
auto exp = readFromDB(&amp;quot;exponent&amp;quot;); // ditto
auto baseToExp = pow(base, exp);  // we can also call pow function at runtime, of course
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In C++11, there&amp;rsquo;re some restrictions on &lt;code&gt;constexpr&lt;/code&gt; functions:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;they may only contain a single return statement&lt;/li&gt;
&lt;li&gt;they are limited to taking and returning &lt;em&gt;literal types&lt;/em&gt;&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:2&#34;&gt;&lt;a href=&#34;#fn:2&#34;&gt;2&lt;/a&gt;&lt;/sup&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;so the implementation goes like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;constexpr int pow(int base, unsigned exp) noexcept
{
    return (exp == 0 ? 1 : base * pow(base, exp - 1));
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;For C++14, the restrictions are substantially looser:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;constexpr int pow(int base, unsigned exp) noexcept
{
    auto result = 1;
    for (unsigned i = 0; i &amp;lt; exp; ++i) result *= base;
    return result;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;constexpr&lt;/code&gt; functions can work with user-defined literal types, too:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class Point {
public:
    constexpr Point(double xVal = 0, dobule yVal = 0) noexcept
    : x(xVal), y(yVal)
    {}

    constexpr double xValue() const noexcept { return x; }
    constexpr double yValue() const noexcept { return y; }
    constexpr void setX(double newX) noexcept { x = newX; }  // due to &amp;quot;void&amp;quot; return type, 
    constexpr void setY(double newY) noexcept { y = newY;    // setters&#39;re contexpr only in C++14
private:
    double x, y;
};

constexpr
Point midpoint(const Point&amp;amp; p1, const Point&amp;amp; p2) noexcept
{
    return { (p1.xValue() + p2.xValue()) / 2,
             (p1.yValue() + p2.yValue()) / 2 };  // call constexpr member funcs
}

constexpr Point reflection(const Point&amp;amp; p) noexcept
{
    Point result;           // create non-const Point
    result.setX(-p.xValue); // set its x and y value
    result.setY(-p.yValue);
    return result;          // return copy of it
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;By introducing &lt;code&gt;constexpr&lt;/code&gt;, we can maximize the range of situation our objects and functions may be used - the traditionally fairly strict line between work done during compilation and work done at runtime begins to blur after we use &lt;code&gt;constexpr&lt;/code&gt; constructors, &lt;code&gt;constexpr&lt;/code&gt; getters, &lt;code&gt;constexpr&lt;/code&gt; setters, &lt;code&gt;constepxr&lt;/code&gt; non-member functions, and create objects in read-only memory:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;constexpr Point p1(9.4, 27.7); // &amp;quot;runs&amp;quot; constexpr ctor during compilation
constexpr Point p2(28.8, 5.3); // same
constexpr auto mid = midpoint(p1, p2);  // init constexpr object with result of constexpr func
constexpr auto reflectedMid = reflection(mid);  // reflectedMid&#39;s value is known during compilation
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As a result, the more code taking part in the compilation time, the faster our software will run&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:3&#34;&gt;&lt;a href=&#34;#fn:3&#34;&gt;3&lt;/a&gt;&lt;/sup&gt;.&lt;/p&gt;
&lt;div class=&#34;footnotes&#34;&gt;

&lt;hr /&gt;

&lt;ol&gt;
&lt;li id=&#34;fn:1&#34;&gt;Such contexts include specification of array sizes, integral template arguments, enumerator values, alignment specifiers, etc.
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:1&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:2&#34;&gt;Literal types: types that can have values determined during compilation. In C++11, all built-in types except &lt;code&gt;void&lt;/code&gt; qualify, plus some user-defined types whose constructors and other member functions are &lt;code&gt;constexpr&lt;/code&gt;.
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:2&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:3&#34;&gt;Compilation may take longer, however.
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:3&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;</description>
    </item>
    
    <item>
      <title>[EMCpp]Item-14 Declare Functions Noexcept if They Won&#39;t Emit Exception</title>
      <link>http://nianze.tk/2018/07/declare-functions-noexcept-if-they-wont-emit-exception/</link>
      <pubDate>Fri, 20 Jul 2018 19:50:39 -0400</pubDate>
      
      <guid>http://nianze.tk/2018/07/declare-functions-noexcept-if-they-wont-emit-exception/</guid>
      <description>&lt;p&gt;Most functions are exception-neutral, but for some, such as move operations, swap, memory deallocation functions, and destructors, &lt;code&gt;noexcept&lt;/code&gt; is particularly valuable.

&lt;!-- toc --&gt;&lt;/p&gt;

&lt;h1 id=&#34;more-optimizable&#34;&gt;More optimizable&lt;/h1&gt;

&lt;p&gt;For functions that won&amp;rsquo;t produce exceptions, we have C++98 style as well as C++11 style:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;int f(int x) throw();   // C++98 style
int f(int x) noexcept;  // C++11 style
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The difference:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;C++98: the call stack is unwound to &lt;code&gt;f&lt;/code&gt;&amp;rsquo;s caller before program execution is terminated&lt;/li&gt;
&lt;li&gt;C++11: the call stack is &lt;em&gt;possibly&lt;/em&gt; unwound before program execution is terminated&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;The difference in &lt;em&gt;possibly&lt;/em&gt; unwinding leads to large impact on code generation: optimizers need not keep the runtime stack in an unwindable state, and need not ensure that objects in a &lt;code&gt;noexcept&lt;/code&gt; function are destroyed in the inverse order of construction, both of which optimization flexibility is lacked for &lt;code&gt;throw()&lt;/code&gt;. In fact, &lt;code&gt;throw&lt;/code&gt; has the same level of optimizability as functions with no exception specification.&lt;/p&gt;

&lt;p&gt;For some functions, &lt;code&gt;noexcept&lt;/code&gt; is even more desired. For example, calls to copy operations in C++98 will be replaced with calls to move operations in C++11, only if the move operation is declared &lt;code&gt;noexcept&lt;/code&gt;. Similarly, &lt;code&gt;swap&lt;/code&gt;s in the Standard Library are &lt;code&gt;noexcpet&lt;/code&gt; sometimes dependends on whether uesr-defined swaps are &lt;code&gt;noexcept&lt;/code&gt;. Following is the declarations for the Standard Library&amp;rsquo;s &lt;code&gt;swap&lt;/code&gt;s for arrays and &lt;code&gt;std::pair&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;template&amp;lt;class T, size_t N&amp;gt;
void swap(T (&amp;amp;a)[N], T (&amp;amp;b)[N]) noexcept(noexcept(swap(*a, *b)));

template&amp;lt;class T1, class T2&amp;gt;
struct pair {
    ...
    void swap(pair&amp;amp; p) noexcept(noexcept(swap(first, p.first)) &amp;amp;&amp;amp;
                                noexcept(swap(second, p.second)));
    ...
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;These functions are &lt;em&gt;conditionally&lt;/em&gt; &lt;code&gt;noexcept&lt;/code&gt;: whether they are &lt;code&gt;noexcept&lt;/code&gt; depends on whether the expression inside the &lt;code&gt;noexcept&lt;/code&gt; clauses are &lt;code&gt;noexcept&lt;/code&gt;. The fact that swapping higher-level data structures can generally be &lt;code&gt;noexcept&lt;/code&gt; only if swapping their lower-level constituents is &lt;code&gt;noexcept&lt;/code&gt; should be reasonable enough to offer &lt;code&gt;noexcept&lt;/code&gt; &lt;code&gt;swap&lt;/code&gt; functions whenever we can.&lt;/p&gt;

&lt;h1 id=&#34;exception-neutral-functions&#34;&gt;Exception Neutral Functions&lt;/h1&gt;

&lt;p&gt;&lt;code&gt;noexcept&lt;/code&gt; is part of a function&amp;rsquo;s interface, so we should declare a function &lt;code&gt;noexcept&lt;/code&gt; only if we are willing to commit to a &lt;code&gt;noexcept&lt;/code&gt; implementation over the long term.&lt;/p&gt;

&lt;p&gt;However, most functions are &lt;em&gt;exception-newtral&lt;/em&gt;: they throw no exceptions themselves, but functions they call might emit one. Such functions are never &lt;code&gt;noexcept&lt;/code&gt;, because they may emit such &amp;ldquo;just passing through&amp;rdquo; exceptions, and thus they lack the &lt;code&gt;noexcept&lt;/code&gt; designation on purpose.&lt;/p&gt;

&lt;p&gt;For some other few functions, on the other hand, being &lt;code&gt;noexcept&lt;/code&gt; is so important that, in C++11, they are implicitly &lt;code&gt;noexcept&lt;/code&gt;: by default, all memory deallocation functions and destructors (both user-defined and compiler-generated) are &lt;code&gt;noexcept&lt;/code&gt;.&lt;/p&gt;

&lt;h1 id=&#34;wide-contracts-vs-narrow-contracts&#34;&gt;Wide Contracts vs Narrow Contracts&lt;/h1&gt;

&lt;p&gt;A function with a wide contract has no preconditions: they can be called regardless of the state of the program, with no constraints on the arguments that callers pass it, and never exhibit undefined behavior.&lt;/p&gt;

&lt;p&gt;Functions withou wide contracts have narrow contract: if a precondition is violated, results are undefined.&lt;/p&gt;

&lt;p&gt;Generally, library desingers reserve &lt;code&gt;noexcept&lt;/code&gt; for functions with wide contracts, so that if a precondition in a narrow contract is violated, the program may throw a  &amp;ldquo;precondition was violated&amp;rdquo; exception, instead of letting the program to terminate.&lt;/p&gt;

&lt;p&gt;If we&amp;rsquo;re writing a function with a wide contract and we know it won&amp;rsquo;t emit exceptions, just declare it &lt;code&gt;noexcept&lt;/code&gt;.&lt;/p&gt;

&lt;h1 id=&#34;backward-compatibility&#34;&gt;Backward compatibility&lt;/h1&gt;

&lt;p&gt;So much legacy code is not decalred with &lt;code&gt;noexcpet&lt;/code&gt; even though they actually never emit exceptions. For the reason of backward compatibility, &lt;code&gt;noexcept&lt;/code&gt; functions calling non-&lt;code&gt;noexcept&lt;/code&gt; functions are permitted in C++, and compilers generally don&amp;rsquo;t issue warnings about it:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;void setup();    // legacy code defined elsewhere
void cleanup();  // without declaring noexcept

void doWork() noexcept
{
    setup();
    ...
    clean();
}
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>[EMCpp]Item-13 Prefer Const_iterators to Iterators</title>
      <link>http://nianze.tk/2018/07/prefer-const_iterators-to-iterators/</link>
      <pubDate>Thu, 19 Jul 2018 18:48:52 -0400</pubDate>
      
      <guid>http://nianze.tk/2018/07/prefer-const_iterators-to-iterators/</guid>
      <description>&lt;p&gt;In maximally generic code, prefer non-member versions of &lt;code&gt;begin&lt;/code&gt;, &lt;code&gt;end&lt;/code&gt;, &lt;code&gt;rbegin&lt;/code&gt;, etc., over their member function counterparts.
&lt;/p&gt;

&lt;p&gt;In C++98, using &lt;code&gt;const&lt;/code&gt; whenever it&amp;rsquo;s meaningful wasn&amp;rsquo;t practical: it wasn&amp;rsquo;t that easy to create them, and once we had one, the ways we could use it were limited. For example:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;std::vector&amp;lt;int&amp;gt; values;
...
std::vector&amp;lt;int&amp;gt;::iterator it = 
    std::find(values.begin(), values.end(), 1983);
values.insert(it, 1998);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The code above search for the first occurrence of 1983 (the year &amp;ldquo;C++&amp;rdquo; replaced &amp;ldquo;C with Classes&amp;rdquo;), then insert the value 1998 (first ISO C++ Standard was adopted) at that location. If no 1983 found, insert at the end of the vector. Since the code never modifies what an &lt;code&gt;iterator&lt;/code&gt; points to, so acoording to the convention to use &lt;code&gt;const&lt;/code&gt; whenever possible, we should use the const-iterator.&lt;/p&gt;

&lt;p&gt;However, in C++98, there was no simple way to get a &lt;code&gt;const_iterator&lt;/code&gt; from a non-&lt;code&gt;const&lt;/code&gt; container. To work it out, we might concider using the cast like the following code, which conceptually works but probably won&amp;rsquo;t compile:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;typedef std::vector&amp;lt;int&amp;gt;::iterator IterT;
typedef std::vector&amp;lt;int&amp;gt;::const_iterator ConstIterT;

std::vector&amp;lt;int&amp;gt; values;
...
ConstIterT ci = 
    std::find(static_cast&amp;lt;ConstIterT&amp;gt;(values.begin()),
              static_cast&amp;lt;ConstIterT&amp;gt;(values.end()),
              1983);
values.insert(static_cast&amp;lt;IterT&amp;gt;(ci), 1998); // may not compile
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The problem here is that in C++98, &lt;code&gt;const_iterator&lt;/code&gt;s weren&amp;rsquo;t acceptable for insertions and erasures, so we cast &lt;code&gt;ci&lt;/code&gt; into its non-const version. However, in C++98, there&amp;rsquo;s no portable conversion from a &lt;code&gt;const_iterator&lt;/code&gt; to an &lt;code&gt;iterator&lt;/code&gt;&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:1&#34;&gt;&lt;a href=&#34;#fn:1&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;, so the last statement probably won&amp;rsquo;t compile. The conclusion: &lt;code&gt;const_iterator&lt;/code&gt;s were so much trouble in C++98.&lt;/p&gt;

&lt;p&gt;Now that we in the new world of C++11, &lt;code&gt;const_iterator&lt;/code&gt;s are both easy to get and easy to use. Even for non-const containers, we get &lt;code&gt;cbegin&lt;/code&gt; and &lt;code&gt;cend&lt;/code&gt; to produce &lt;code&gt;const_iterator&lt;/code&gt;s:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;std::vector&amp;lt;int&amp;gt; values;
...
auto it = std::find(values.cbegin(), values.cend(), 1983);
values.insert(it, 1998);
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;maximally-generic-support&#34;&gt;Maximally Generic Support&lt;/h4&gt;

&lt;p&gt;Taking into account that some containers and container-like data structures offer &lt;code&gt;begin&lt;/code&gt; and &lt;code&gt;end&lt;/code&gt; as &lt;em&gt;non-member&lt;/em&gt; functions, C++11 added the non-member functions &lt;code&gt;begin&lt;/code&gt; and &lt;code&gt;end&lt;/code&gt; to make sure some generic library code using non-member functions is possible.&lt;/p&gt;

&lt;p&gt;C++14 rectified the oversight in C++11, adding the support for &lt;code&gt;cbegin&lt;/code&gt;, &lt;code&gt;cend&lt;/code&gt;, &lt;code&gt;rbegin&lt;/code&gt;, &lt;code&gt;rend&lt;/code&gt;, &lt;code&gt;crbegin&lt;/code&gt;, and &lt;code&gt;crend&lt;/code&gt;. Now we could generalize the code above into a &lt;code&gt;findAndInsert&lt;/code&gt; template as follow:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;template&amp;lt;typename C, typename V&amp;gt;
void findAndInsert(C&amp;amp; container,       // find first occurrence of targetVal in container
                   const V&amp;amp; targetVal, // then insert insertVal there
                   const V&amp;amp; insertVal)
{
    using std::cbegin;
    using std::cend;

    auto it = std::find(cbegin(container),  // non-member cbegin
                        cend(container),    // non-member cend
                        targetVal);
    container.insert(it, insertVal);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If we&amp;rsquo;re using C++11 and want to write maximally generic code, we may build our own implementation for non-member &lt;code&gt;cbegin&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;template&amp;lt;class C&amp;gt;
auto cbegin(const C&amp;amp; container) -&amp;gt; decltype(std::begin(container))
{
    return std::begin(container);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Point here is: through its reference-to-&lt;code&gt;const&lt;/code&gt; parameter, &lt;code&gt;container&lt;/code&gt;, we are invoking the non-member &lt;code&gt;begin&lt;/code&gt; function (provided by C++11) on a &lt;code&gt;const&lt;/code&gt; container, and this process yields a &lt;code&gt;const_iterator&lt;/code&gt;. In fact, this template works even if &lt;code&gt;C&lt;/code&gt; is a built-in array type&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:2&#34;&gt;&lt;a href=&#34;#fn:2&#34;&gt;2&lt;/a&gt;&lt;/sup&gt;.&lt;/p&gt;
&lt;div class=&#34;footnotes&#34;&gt;

&lt;hr /&gt;

&lt;ol&gt;
&lt;li id=&#34;fn:1&#34;&gt;It&amp;rsquo;s true in C++11, too.
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:1&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:2&#34;&gt;For insight into how a template can be specialized for built-in arrays, consult EMCpp item 1&amp;rsquo;s discussion of type deduction in templates that take reference parameters to arrays.
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:2&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;</description>
    </item>
    
    <item>
      <title>[EMCpp]Item-12 Declare Overriding Functions Override</title>
      <link>http://nianze.tk/2018/07/declare-overriding-functions-override/</link>
      <pubDate>Wed, 18 Jul 2018 19:19:07 -0400</pubDate>
      
      <guid>http://nianze.tk/2018/07/declare-overriding-functions-override/</guid>
      <description>&lt;p&gt;C++11 gives us a way to make explicit that a derived class function is supposed to override a base class version: &lt;code&gt;override&lt;/code&gt;.
&lt;/p&gt;

&lt;p&gt;There are several requirements for overriding to occur:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;The base class function must be virtual&lt;/li&gt;
&lt;li&gt;The base and derived funciton names must be identical (except in the case of destructors)&lt;/li&gt;
&lt;li&gt;The parameter types of the base and derived functions must be identical&lt;/li&gt;
&lt;li&gt;The &lt;code&gt;const&lt;/code&gt;ness of the base and derived functions must be identical&lt;/li&gt;
&lt;li&gt;The return types and exception specifications of the base and derived functions must be compatible&lt;/li&gt;
&lt;li&gt;The functions&amp;rsquo; &lt;em&gt;reference qualifiers&lt;/em&gt; mmust be identical (new from C++11)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;All these requirements for overriding mean that small mistakes can make a big difference. Code containing unintended overriding errors is typically still valid, so compilers may fail to notify us the errors. For example, following code is completely legal:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class Base {
public:
    virtual void mf1() const;
    virtual void mf2(int);
    virtual void mf3() &amp;amp;;
    void mf4() const;
};

class Derived: public Base {
public:
    void mf1();  // virtual is optional here for derived classes
    void mf2(unsigned int);
    void mf3() &amp;amp;&amp;amp;;
    virtual void mf4() const;
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;However, we almost certainly intend to override base class functions with derived class ones with the same names, yet none of the derived class functions are tied to the base class ones:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;mf1&lt;/code&gt; is declared &lt;code&gt;const&lt;/code&gt; in &lt;code&gt;Base&lt;/code&gt;, but not in &lt;code&gt;Derived&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;mf2&lt;/code&gt; takes an &lt;code&gt;int&lt;/code&gt; in &lt;code&gt;Base&lt;/code&gt;, but an &lt;code&gt;unsigned int&lt;/code&gt; in &lt;code&gt;Derived&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;mf3&lt;/code&gt; is lvalue-qualified in &lt;code&gt;Base&lt;/code&gt;, but &lt;code&gt;rvalue-qualified&lt;/code&gt; in &lt;code&gt;Derived&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;mf4&lt;/code&gt; isn&amp;rsquo;t declared &lt;code&gt;virtual&lt;/code&gt; in &lt;code&gt;Base&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;If we explicitly declare with the &lt;em&gt;contextual keyword&lt;/em&gt; &lt;code&gt;override&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class Derived: public Base {
public:
    virtual void mf1() override;
    virtual void mf2(unsigned int) override;
    virtual void mf3() &amp;amp;&amp;amp; override;
    virtual void mf4() const override;
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then the code won&amp;rsquo;t compile, because compilers will complain the overriding-related problems above, which is exactly what we want.&lt;/p&gt;

&lt;p&gt;Moreover, taking use of compilers&amp;rsquo; ability to diagnostic overriding problems, we can easily use &lt;code&gt;override&lt;/code&gt; keyword to gauge the ramifications if we&amp;rsquo;re contemplating changing the signature of a virtual funciton in a base class: if derived classes use &lt;code&gt;override&lt;/code&gt; everywhere, we can just change the signature, recompile the system, see how much damage we&amp;rsquo;ve caused, and then decide whether the signature change is worth the trouble.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Nodes on Clean Architecture</title>
      <link>http://nianze.tk/2018/07/nodes-on-clean-architecture/</link>
      <pubDate>Tue, 17 Jul 2018 19:45:47 -0400</pubDate>
      
      <guid>http://nianze.tk/2018/07/nodes-on-clean-architecture/</guid>
      <description>&lt;p&gt;A brief notes on Clean Architecture

&lt;!-- toc --&gt;&lt;/p&gt;

&lt;h1 id=&#34;chapter-1-what-is-design-and-architecture&#34;&gt;Chapter 1 What is design and architecture&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;The Goal:&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
&lt;p&gt;The goal of software architecture is to minimize the human resources required to build and maintain the required system.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;Low-level details andd the high-level structure are all part of the same whole, forming a continuous fabric that defines the shape of the system. There is simply a continuum of decisions from the highest to the lowest levels.&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;chapter-2-a-tale-of-two-values&#34;&gt;Chapter 2 A Tale of Two Values&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;Eisenhower matrix:&lt;/li&gt;
&lt;/ul&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;center&#34;&gt;&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;Urgent&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;Not urgent&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;&lt;strong&gt;Important&lt;/strong&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;Important/Urgent&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;Important/Not urgent&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;&lt;strong&gt;Unimportant&lt;/strong&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;Unimportant/Urgent&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;Unimportant/Not urgent&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;In terms of priorities:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Urgent and important&lt;/li&gt;
&lt;li&gt;Not urgenet and important&lt;/li&gt;
&lt;li&gt;Urgent and not important&lt;/li&gt;
&lt;li&gt;Not urgent and not ipmortant&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;The common mistake we make: elevate items in position 3 to position 1 - fail to separate those that are urgent but not important from those that truly are urgent and important (i.e, ignoring the important architecture of the system in favor of the unimportant features of the system).&lt;/p&gt;

&lt;p&gt;It is the responsibility of the software development team to assert the importance of architecture over the urgency of features.&lt;/p&gt;

&lt;h1 id=&#34;chapter-3-paradigm-overview&#34;&gt;Chapter 3 Paradigm Overview&lt;/h1&gt;

&lt;ol&gt;
&lt;li&gt;Structured Programming: remove &lt;code&gt;goto&lt;/code&gt; - imposing discipline on direct transfer of control&lt;/li&gt;
&lt;li&gt;Object-oriented Programming: polymorphism through the disciplines use of function pointer - imposing discipline on indirect transfer of control&lt;/li&gt;
&lt;li&gt;Functional Programming: remove assignment statement (immutability) - imposing discipline upon assignment&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;Conclusion&lt;/strong&gt;: We use polymorphism as the mechanism to cross architectural boundaries; we use functional programming to impose discipline on the location of and access to data; and we use structured programming as the algorithmic foundation of our modules.&lt;/p&gt;

&lt;h1 id=&#34;chapter-4-sturctured-programming&#34;&gt;Chapter 4 Sturctured Programming&lt;/h1&gt;

&lt;blockquote&gt;
&lt;p&gt;It is this ability to create falsifiable units of programming that makes structured programming valuable.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;Mathematics is the discipline of proving provable statements true;&lt;/li&gt;
&lt;li&gt;Science is the discipline of proving provable statements false&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Software is like a science - we show correctness by failing to prove incorrectness, despite our best efforts. Specifically, we prove incorrectness by tests. Note that:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;such proofs of incorrectness can be applied only to &lt;em&gt;provable&lt;/em&gt; programs. A program that is not provable (due to unrestrained use of &lt;code&gt;goto&lt;/code&gt;) cannot be deemed correct no matter how many tests are applied to it.&lt;/li&gt;
&lt;li&gt;structures programming forces us to recursively decompose a program into a set of small provable functions. We can then use tests to try to prove those small provable functions incorrect.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Therefore, all that tests do, after sufficient testing effort, is allow us to deem a program to be correct enough for our purposes.&lt;/p&gt;

&lt;p&gt;From the smallest function to the largest component, sofwware is driven by falsifiability. Under such a perspective, software architects strive to define modules, components, and services that are easily fasifiable (testable).&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>[EMCpp]Item-11 Prefer Deleted Functions to Private Undefined Ones</title>
      <link>http://nianze.tk/2018/07/prefer-deleted-functions-to-private-undefined-ones/</link>
      <pubDate>Mon, 16 Jul 2018 21:22:57 -0400</pubDate>
      
      <guid>http://nianze.tk/2018/07/prefer-deleted-functions-to-private-undefined-ones/</guid>
      <description>&lt;p&gt;Any function may be deleted, including non-member functions and template instantiations.

&lt;!-- toc --&gt;&lt;/p&gt;

&lt;p&gt;To prevent use of certain function from being called, there is a classic approach in C++98: declare that function &lt;code&gt;private&lt;/code&gt; and not define them.&lt;/p&gt;

&lt;p&gt;However, the fact is that this C++98 practice is really an attempt to achieve what C++11&amp;rsquo;s deleted functions actually accomplish. As an emulation, it is not as good as the real thing: it doesn&amp;rsquo;t work outside classes, it doesn&amp;rsquo;t always work inside classes, and when it does work, it may not work until link-time.&lt;/p&gt;

&lt;h1 id=&#34;link-time-vs-compile-time-failure-diagnostic&#34;&gt;Link-time vs compile-time failure diagnostic&lt;/h1&gt;

&lt;p&gt;In C++98 practice, declaring functions &lt;code&gt;private&lt;/code&gt; prevents clients from calling them. Due absence of function definitions, linking will fail if member functions or &lt;code&gt;friend&lt;/code&gt;s of the class try to call them. Take the copy constructor in uncopyable &lt;code&gt;basic_ios&lt;/code&gt; class for example:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;template &amp;lt;class charT, class traits = char_traits&amp;lt;charT&amp;gt; &amp;gt;
class basic_ios : public ios_base {
public:
    ...
private:
    basic_ios(const basic_ios&amp;amp;);            // not defined
    basic_ios&amp;amp; operator=(const basic_ios&amp;amp;); // not defined
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As a comparason, deleted functions may not be used in any way, so even code that&amp;rsquo;s in member and &lt;code&gt;friend&lt;/code&gt; functions will fail to compile if it tries to copy &lt;code&gt;basic_ios&lt;/code&gt; objects:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;template &amp;lt;class charT, class traits = char_traits&amp;lt;charT&amp;gt; &amp;gt;
class basic_ios : public ios_base {
public:
    ...
    basic_ios(const basic_ios&amp;amp;) = delete ;
    basic_ios&amp;amp; operator=(const basic_ios&amp;amp;) = delete;
 
    ...
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note that by convertion, deleted functions are declared &lt;code&gt;public&lt;/code&gt; instead of &lt;code&gt;private&lt;/code&gt;, because C++ checks accessibility before deleted status. When client code tries to use a deleted &lt;code&gt;private&lt;/code&gt; function, some compilers complain only about the function being &lt;code&gt;private&lt;/code&gt;. If declaring those functions in &lt;code&gt;public&lt;/code&gt;, we will get better error messages.&lt;/p&gt;

&lt;h1 id=&#34;disable-non-member-functions&#34;&gt;Disable non-member functions&lt;/h1&gt;

&lt;p&gt;Functions may be deleted outside classes, while &lt;code&gt;private&lt;/code&gt; functions are always member functions inside some class. For example, we may use &lt;code&gt;delete&lt;/code&gt; to prevent implicit numerical conversion into &lt;code&gt;int&lt;/code&gt; for a non-member function &lt;code&gt;isLucky&lt;/code&gt;, which takes in i
nteger and returns whether it&amp;rsquo;s a lucky number:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;bool isLucky(int number);      // original function
bool isLucky(char) = delete;   // reject chars
bool isLucky(bool) = delete;   // reject bools
bool isLucky(double) = delete; // reject doubles and floats
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;disable-special-template-instantiations&#34;&gt;Disable special template instantiations&lt;/h1&gt;

&lt;p&gt;Suppose we want to handle specail cases of &lt;code&gt;void*&lt;/code&gt; and &lt;code&gt;char*&lt;/code&gt; in the &lt;code&gt;processProinter&lt;/code&gt; template, we may simply delete those instantiations:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;t
emplate&amp;lt;typename T&amp;gt;
void processProinter(T* ptr);

template&amp;lt;&amp;gt;
void processProinter&amp;lt;void*&amp;gt;(void*) = delete;
template&amp;lt;&amp;gt;
void processProinter&amp;lt;char*&amp;gt;(char*) = delete;
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;disable-speacial-member-function-template-instanciation&#34;&gt;Disable speacial member function template instanciation&lt;/h1&gt;

&lt;p&gt;Since template specializations must be written at namespace scope, not class scope, we can&amp;rsquo;t adopt the C++98 convertion to disable specialization of a member function template from being called. Delete functions, however, won&amp;rsquo;t be restricted by class scope, so we can simply delete the specialization outside the class:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class Widget {
public:
    ...
    template&amp;lt;typename T&amp;gt;
    void processProinter(T* ptr)
    {...}
    ...
};

template&amp;lt;&amp;gt;
void Widget::processProinter&amp;lt;void&amp;gt;(void*) = delete;
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>[EMCpp]Item-10 Prefer Scoped enums to Unscopded enums</title>
      <link>http://nianze.tk/2018/07/prefer-scoped-enums-to-unscopded-enums/</link>
      <pubDate>Sat, 14 Jul 2018 13:33:33 -0400</pubDate>
      
      <guid>http://nianze.tk/2018/07/prefer-scoped-enums-to-unscopded-enums/</guid>
      <description>&lt;p&gt;Enumerators of scoped &lt;code&gt;enum&lt;/code&gt;s are visible only within the &lt;code&gt;enum&lt;/code&gt;, convert to other types only with a cast, and always support forward-declared because their default underlying type is &lt;code&gt;int&lt;/code&gt;.

&lt;!-- toc --&gt;&lt;/p&gt;

&lt;h1 id=&#34;scope&#34;&gt;Scope&lt;/h1&gt;

&lt;p&gt;Generally speaking, declaring a name inside curly braces limits the visibility of that name to the scope defined by the braces, with one exception: the C++98-style &lt;code&gt;enum&lt;/code&gt;s, which lead to enumerator names leaking into the scope containing their &lt;code&gt;enum&lt;/code&gt; definition, and thus have an official term - &lt;em&gt;unscoped&lt;/em&gt; &lt;code&gt;enum&lt;/code&gt;s.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;enum Color { black, white, red }; // black, white, red are in same scope as Color
auto white = false; // error! white already declared in this scope
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As their new C++11 counterparts, by adding a &lt;code&gt;class&lt;/code&gt; in declaration, &lt;em&gt;scoped&lt;/em&gt; &lt;code&gt;enum&lt;/code&gt;s don&amp;rsquo;t leak names:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;enum class Color { black, white, red };
auto white = false; // fine. no other &amp;quot;whate&amp;quot; in scope
Color c = white; // error
auto c = Color::white; // fine, type of c is Color
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;implicit-conversion&#34;&gt;Implicit conversion&lt;/h1&gt;

&lt;p&gt;The fact that scoped &lt;code&gt;enum&lt;/code&gt;s have strong typed enumerators results in their inability to implicitly convert to integral types (and, from there, to floating-point types), which behavior is otherwise permited in terms of unscoped &lt;code&gt;enum&lt;/code&gt;s:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;Color c = Color::red;
std::vector&amp;lt;std::size_t&amp;gt; primeFactors(std:size_t x); // func. returning prime factors of x
...
if (c &amp;lt; 14.5) {  // error! can&#39;t compare Color and double
    auto factors = primeFactors(c);  // error! can&#39;t pass Color to function expecting std::size_t
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Instead, in order to convert typefrom &lt;code&gt;Color&lt;/code&gt; to a different type, we need a cast:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;if (static_cast&amp;lt;double&amp;gt;(c) &amp;lt; 14.5 ) {  // odd code, but valid
    auto factors = primeFactors(static_cast&amp;lt;std::size_t&amp;gt;(c));
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;forward-declaration&#34;&gt;Forward declaration&lt;/h1&gt;

&lt;p&gt;Technically speaking, both scoped and unscoped &lt;code&gt;enum&lt;/code&gt;s may be forward-declared, except that unscoped ones need a bit of additional work - by specifying the underlying type for unscoped &lt;code&gt;enum&lt;/code&gt;s&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:1&#34;&gt;&lt;a href=&#34;#fn:1&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;enum Status: std::unit8_t;  // fwd decl for unscoped enum;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Since scoped &lt;code&gt;enum&lt;/code&gt;s have a default underlying type of &lt;code&gt;int&lt;/code&gt;, forward declaration is always supported:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;enum class Status; // forward declaration
void continueProcessing(Status s); // use of fwd-declared enum
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;With the help of forward declaration, the header containing the declarations requires no recompilation if &lt;code&gt;Status&lt;/code&gt;&amp;rsquo;s definition is revised. Furthermore, it is also possible that &lt;code&gt;continueProcessing&lt;/code&gt;&amp;rsquo;s implementation need not be recompiled&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:2&#34;&gt;&lt;a href=&#34;#fn:2&#34;&gt;2&lt;/a&gt;&lt;/sup&gt;.&lt;/p&gt;

&lt;h1 id=&#34;twist&#34;&gt;Twist&lt;/h1&gt;

&lt;p&gt;There&amp;rsquo;s still some situation where unscoped &lt;code&gt;enum&lt;/code&gt;s may be useful: when referring to fields within C++11&amp;rsquo;s &lt;code&gt;std::tuple&lt;/code&gt;s. Suppose we have a tuple holding values for the name, email address, and reputation value for a user at a social networking website:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;using UserInfo =            // type alias
    std::tuple&amp;lt;std::string  // name
               std::string  // email
               std::size_t&amp;gt; // reputation
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To get field value, using an unscoped &lt;code&gt;enum&lt;/code&gt; to associate names with field numbers may be helpful:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;enum UserInfoFields { uiName, uiEmail, uiReputation };
UserInfo uInfo;
...
auto val = std::get&amp;lt;uiEmail&amp;gt;(uInfo); // implicit conversion from UserInfoFields to std::size_t
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To mimic the similar behavior, using scoped &lt;code&gt;enum&lt;/code&gt;s is more verbose:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;enum class UserInfoFields { uiName, uiEmail, uiReputation };
...
auto val = std::get&amp;lt;static_cast&amp;lt;std::size_t&amp;gt;(UserInfoFields::uiEmail)&amp;gt;(uInfo);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To save some typing, we might consider define a helper function, or in a more generalized form, a function template &lt;code&gt;toUType&lt;/code&gt; that takes an arbitrary enumerator and return its value as a compile-time constant:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;template&amp;lt;typename E&amp;gt;
constexpr typename std::underlying_type&amp;lt;E&amp;gt;::typename // see item 9 for info on type traits
    toUType(E enumerator) noexcept
{
    return static_cast&amp;lt;typename std::underlying_type&amp;lt;E&amp;gt;::type&amp;gt;(enumerator);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In C++14, we may simplify the &lt;code&gt;toUType&lt;/code&gt; to a sleeker form:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;template&amp;lt;typename E&amp;gt;
constexpr auto toUType(E enumerator) noexcept
{
    return static_cast&amp;lt;std::underlying_type_t&amp;lt;E&amp;gt;&amp;gt;(enumerator);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And then we access a field of the tuple like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;auto val = std::get&amp;lt;toUType(&amp;lt;UserInfoFields::uiEmail)&amp;gt;(uInfo);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Still more to write than use of the unscoped &lt;code&gt;enum&lt;/code&gt;, but it also avoids namespace pollution and inadvertent conversions involving enumerators, so those extra characters might still be a reasonable to pay for.&lt;/p&gt;
&lt;div class=&#34;footnotes&#34;&gt;

&lt;hr /&gt;

&lt;ol&gt;
&lt;li id=&#34;fn:1&#34;&gt;Since there is no default underlying type for unscoped &lt;code&gt;enum&lt;/code&gt;s, to make it possible for compilers to select an underlying type for each &lt;code&gt;enum&lt;/code&gt; prior to the &lt;code&gt;enum&lt;/code&gt; being used, C++98 supports only &lt;code&gt;enum&lt;/code&gt; definitions (when all enumerators are listed), while &lt;code&gt;enum&lt;/code&gt; declarations are not allowed.
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:1&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:2&#34;&gt;This happens if &lt;code&gt;Status&lt;/code&gt; is modified (e.g., add a new enumerator), but &lt;code&gt;continueProcessing&lt;/code&gt;&amp;rsquo;s behavior is unaffected (e.g., the function doesn&amp;rsquo;t use the newly added enumerator).
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:2&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;</description>
    </item>
    
    <item>
      <title>创作欲望本质是什么？</title>
      <link>http://nianze.tk/2018/07/the-source-of-creative-desire/</link>
      <pubDate>Fri, 13 Jul 2018 00:00:00 +0000</pubDate>
      
      <guid>http://nianze.tk/2018/07/the-source-of-creative-desire/</guid>
      <description>&lt;p&gt;创作欲望的产生也许多种多样，但我觉得最强烈的创作欲，或者说根植创作欲望最深处的动力，来自于深陷内心的恐惧。
&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;转自之前的一个&lt;a href=&#34;https://www.zhihu.com/question/38851352/answer/420954152&#34;&gt;知乎回答&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;创作的前提是有一个创作者。而创作者之所以存在，是因为其自我意识的觉醒。&lt;/p&gt;

&lt;p&gt;当&amp;rdquo;我&amp;rdquo;这个概念第一次觉醒，并看到不远的将来无可避免的死亡，瞥见了无法忍受的&amp;rdquo;虚无&amp;rdquo;，明白了稍纵即逝的&amp;rdquo;存在&amp;rdquo;，&amp;rdquo;我&amp;rdquo;就会本能的渴望继续存在下去，恐惧&amp;rdquo;自我&amp;rdquo;这个概念的消亡。&lt;/p&gt;

&lt;p&gt;《月亮与六便士》里，Strickland说&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;我必须画画，就像溺水的人必须挣扎。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;我的理解是，溺水的恐惧源于对自我意识消亡的抗拒，把心中幻象固化在画板上，便是将一部分自我意识凝固，让这一瞬的精神超越时间的侵蚀，无异于在虚无之水中造一叶救命扁舟。&lt;/p&gt;

&lt;p&gt;不同于生物本能靠两性结合繁殖后代来延续基因/物质层面的自我，意识/灵魂层面的&amp;rdquo;我&amp;rdquo;一旦觉察到自我的存在，在&amp;rdquo;活下去&amp;rdquo;的本能推动下，会渴望通过精神层面的自我复制/自我映射，将一部分自我固化为某种虚幻的实体(诗词，音乐，雕塑，写作，数学&amp;hellip;)。这种投影自我意识的行为，某种角度来说其实是如同《西西弗斯的神话》般的徒劳。然而创作者只需要有渺茫的希望就足够自我安慰：自己的作品将比自己有限的生命在时间尺度上活的更久，或在某种自我评价体系上比过去的自己站的更高，只要能让自己在虚无之海上稍事喘息，这就足够了。&lt;/p&gt;

&lt;p&gt;我无端的猜想，达芬奇放下画笔看着蒙娜丽莎朝自己微笑时，米开朗基罗雕完大卫像最后一刀时，牛顿推导完《自然哲学的数学原理》最后一个公式将天地万物用数学关联时，贝多芬将脑海里的第九交响曲最后一个音符记在谱纸上时。。。那一瞬间内心如释重负，又有些许慰藉，也为寻求下一刻的解脱埋下了创作的种子。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>[EMCpp]Item-9 Prefer Alias Declarations to Typedefs</title>
      <link>http://nianze.tk/2018/07/prefer-alias-declarations-to-typedefs/</link>
      <pubDate>Thu, 12 Jul 2018 13:03:01 -0400</pubDate>
      
      <guid>http://nianze.tk/2018/07/prefer-alias-declarations-to-typedefs/</guid>
      <description>&lt;p&gt;Alias declaration support templatization, which avoids the &amp;ldquo;::type&amp;rdquo; suffix and &amp;ldquo;typename&amp;rdquo; prefix often required to refer &lt;code&gt;typedef&lt;/code&gt;s.
&lt;/p&gt;

&lt;p&gt;Compared with &lt;code&gt;typedef&lt;/code&gt;, alias declarations have following advantages:&lt;/p&gt;

&lt;h4 id=&#34;easier-to-understand&#34;&gt;Easier to understand&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;typedef void (*FP)(int, const std::string&amp;amp;);
// same meaning as above using alias declaration
using FP = void (*)(int, const std::string&amp;amp;);
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;support-for-template&#34;&gt;Support for template&lt;/h4&gt;

&lt;p&gt;Alias declarations may be templatized (called &lt;em&gt;alias templates&lt;/em&gt;), while &lt;code&gt;typedef&lt;/code&gt;s cannot. For example, suppose we want to define a synonym for a linked list that uses a custom allocator &lt;code&gt;MyAlloc&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;template&amp;lt;typename T&amp;gt;
using MyAllocList = std::list&amp;lt;T, MyAlloc&amp;lt;T&amp;gt;&amp;gt;; 

// client code
MyAllocList&amp;lt;std::string&amp;gt; ls;
template&amp;lt;typename T&amp;gt;
class Widget {   // Widget contains a MyAllocList&amp;lt;T&amp;gt; as a data member
private:
    typename MyAllocList&amp;lt;T&amp;gt; list; 
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;With a &lt;code&gt;typedef&lt;/code&gt;, to support template, we need the trick to nest &lt;code&gt;typedef&lt;/code&gt; inside templatized structs:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;template&amp;lt;typename T&amp;gt;
struct MyAllocList {
    typedef std::list&amp;lt;T, MyAlloc&amp;lt;T&amp;gt;&amp;gt; type;
};

// client code
MyAllocList&amp;lt;Widget&amp;gt;::type lw;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To make things worse, when using the &lt;code&gt;typedef&lt;/code&gt; inside a template class, we have to precede the &lt;code&gt;typedef&lt;/code&gt; name with &lt;code&gt;typename&lt;/code&gt;, so that compilers get comfirmed that &lt;code&gt;MyAllocList&amp;lt;T&amp;gt;::type&lt;/code&gt; refers to a type, instead of a data member named &lt;code&gt;type&lt;/code&gt; inside &lt;code&gt;MyAllocList&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;template&amp;lt;typename T&amp;gt;
class Widget {
private:
    typename MyAllocList&amp;lt;T&amp;gt;::type list; 
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Type traits supported by alias templates in C++14&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;When we need to take template type parameters and create revised types from them(e.g., turn &lt;code&gt;Widget&lt;/code&gt; into &lt;code&gt;Widget&amp;amp;&lt;/code&gt;), we perform these kinds of transformations through &lt;em&gt;type traits&lt;/em&gt;. Since type traits in C++11 are implemented as nested &lt;code&gt;typedef&lt;/code&gt;s inside templatized structs, C++14 provides corresponding alias templates:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;std::remove_const&amp;lt;T&amp;gt;::type  // C++11: const T -&amp;gt; T
std::remove_const_t&amp;lt;T&amp;gt;  // C++14 equivalent

std::remove_reference&amp;lt;T&amp;gt;::type  // C++11: T&amp;amp;/T&amp;amp;&amp;amp; -&amp;gt; T
std::remove_reference_t&amp;lt;T&amp;gt;  // C++14 equivalent

std::add_lvalue_reference&amp;lt;T&amp;gt;::type  // C++11: T -&amp;gt; T&amp;amp;
std::add_lvalue_refernece_t&amp;lt;T&amp;gt;  // C++14 equivalent
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Basically what C++14 adds is simply some code like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;template &amp;lt;class T&amp;gt;
using remove_const_t = typename remove_const&amp;lt;T&amp;gt;::type;
template &amp;lt;class T&amp;gt;
using remove_reference_t = typename remove_reference&amp;lt;T&amp;gt;::type;
template &amp;lt;class T&amp;gt;
using add_lvalue_reference_t = typename add_lvalue_reference&amp;lt;T&amp;gt;::type;
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>[EMCpp]Item-8 Prefer Nullptr to 0 and NULL</title>
      <link>http://nianze.tk/2018/07/prefer-nullptr-to-0-and-null/</link>
      <pubDate>Wed, 11 Jul 2018 18:03:51 -0400</pubDate>
      
      <guid>http://nianze.tk/2018/07/prefer-nullptr-to-0-and-null/</guid>
      <description>&lt;p&gt;&lt;code&gt;nullptr&lt;/code&gt; doean&amp;rsquo;t suffer from the overloading problem or the template deduction problem that 0 and &lt;code&gt;NULL&lt;/code&gt; are susceptible to. It also improves code clarity.
&lt;/p&gt;

&lt;p&gt;In C++98, a null pointer can be represented by an &lt;code&gt;int&lt;/code&gt; 0 or &lt;code&gt;NULL&lt;/code&gt;&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:1&#34;&gt;&lt;a href=&#34;#fn:1&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;, which introduses some controdiction between the &lt;em&gt;apparent&lt;/em&gt; meaning (mean to refer to a null pointer) and &lt;em&gt;actual&lt;/em&gt; meaning (the representation is some kind of integer). Neither &lt;code&gt;0&lt;/code&gt; nor &lt;code&gt;NULL&lt;/code&gt; has a pointer type - it&amp;rsquo;s just that C++ will (reluctently) interpret them as a null pointer in the context where a pointer a pointer is wanted but can&amp;rsquo;t be found.&lt;/p&gt;

&lt;p&gt;That&amp;rsquo;s why &lt;code&gt;nullptr&lt;/code&gt; is introduced: its type is not integral, but &lt;code&gt;std::nullptr_t&lt;/code&gt;&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:2&#34;&gt;&lt;a href=&#34;#fn:2&#34;&gt;2&lt;/a&gt;&lt;/sup&gt;, which could be treated as a pointer of all types due to its ability to implicitly convert to all raw pointer types.&lt;/p&gt;

&lt;p&gt;Compared with 0 and &lt;code&gt;NULL&lt;/code&gt;, the obvious advantages shown by &lt;code&gt;nullptr&lt;/code&gt; is its better support for overloading and template, as well as its improved code clarity.&lt;/p&gt;

&lt;h4 id=&#34;overloading&#34;&gt;Overloading&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;void f(int);
void f(bool);
void f(void*);

f(0); // calls f(int)
f(NULL); // might not compile, but typically calls f(int), never calls f(void*)
f(nullptr); // calls f(void*)
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;template&#34;&gt;Template&lt;/h4&gt;

&lt;p&gt;Inside a template, if an &lt;code&gt;int&lt;/code&gt; or &lt;code&gt;NULL&lt;/code&gt; (which is &lt;code&gt;int&lt;/code&gt;-like type) is being passed to a function that requires a pointer, type errors occur:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;// call these only then approriate mutix is locked
int f1(std::shared_ptr&amp;lt;Widget&amp;gt; spw);
int f2(std::unique_ptr&amp;lt;Widget&amp;gt; upw);
bool f3(Widget* pw);

template&amp;lt;typename FuncType,
         typename MuxType,
         typename PtrType&amp;gt;
declType(auto) lockAndCall(FuncType func,  // C++14
                           MuxType&amp;amp; mutex
                           PtrType ptr)
{
    using MuxGuard = std::lock_guard&amp;lt;std::mutex&amp;gt;;
    MuxGuard g(mutex);  // lock mutex for func
    return func(ptr);   // pass ptr (pointer type) to func
}                       // unlock mutex

std::mutex f1m, f2m, f3m;
auto result1 = lockAndCall(f1, f1m, 0);        // error
auto result2 = lockAndCall(f2, f2m, NULL);     // error
auto result3 = lockAndCall(f3, f3m, nullptr);  // fine
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In contrast, here, when &lt;code&gt;nullptr&lt;/code&gt; is passed to &lt;code&gt;lockAndCall&lt;/code&gt;, the type for &lt;code&gt;ptr&lt;/code&gt; is deduced to be &lt;code&gt;std::nullptr_t&lt;/code&gt; instead of previous &lt;code&gt;int&lt;/code&gt; (or &lt;code&gt;int&lt;/code&gt;-like one), and when &lt;code&gt;ptr&lt;/code&gt; is passed to &lt;code&gt;f3&lt;/code&gt;, there is an implicit conversion from &lt;code&gt;std::nullptr_t&lt;/code&gt; to &lt;code&gt;Widget*&lt;/code&gt;.&lt;/p&gt;

&lt;h4 id=&#34;code-clarity&#34;&gt;Code clarity&lt;/h4&gt;

&lt;p&gt;Using 0, the return type may not be obvious, is it an integral type or a pointer type?&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;auto result = findRecord(/* args. */);
if (result == 0) {
    ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;There&amp;rsquo;s no ambiguity when using &lt;code&gt;nullptr&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;auto result = findRecord( /* args */ );
if (result == nullptr) {
    ...
}
&lt;/code&gt;&lt;/pre&gt;
&lt;div class=&#34;footnotes&#34;&gt;

&lt;hr /&gt;

&lt;ol&gt;
&lt;li id=&#34;fn:1&#34;&gt;There is some leeway regarding the implementaition of the type of &lt;code&gt;NULL&lt;/code&gt; - possibly, &lt;code&gt;NULL&lt;/code&gt; will be defined to be &lt;code&gt;0L&lt;/code&gt; as a &lt;code&gt;long&lt;/code&gt;.
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:1&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:2&#34;&gt;&lt;code&gt;std::nullptr_t&lt;/code&gt;, techniquely, is not a pointer type. The type is in a circular definition: &lt;code&gt;std::nullptr_t&lt;/code&gt; is defined to be the type of &lt;code&gt;nullptr&lt;/code&gt;.
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:2&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;</description>
    </item>
    
    <item>
      <title>[EMCpp]Item-7 Distinguish Betwenn () and {} When Creating Objects</title>
      <link>http://nianze.tk/2018/07/distinguish-betwenn--and--when-creating-objects/</link>
      <pubDate>Tue, 10 Jul 2018 18:55:06 -0400</pubDate>
      
      <guid>http://nianze.tk/2018/07/distinguish-betwenn--and--when-creating-objects/</guid>
      <description>&lt;p&gt;Braced initialization is the most widely usable initialization syntax, which can also prevent narrowing conversions, as well as being immune to C++&amp;rsquo;s most vexing parse.

&lt;!-- toc --&gt;&lt;/p&gt;

&lt;h1 id=&#34;the-good-part&#34;&gt;The good part&lt;/h1&gt;

&lt;h2 id=&#34;syntacticly-widest-usage&#34;&gt;Syntacticly widest usage&lt;/h2&gt;

&lt;p&gt;Syntax choices for object initialization in C++11 are confusing to support 3 forms: parentheses, equal signs, and braces.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;int x(0);   // initializer with parentheses
int y = 0;  // initializer with &amp;quot;=&amp;quot;
int z{ 0 }; // initializer with braces
int zz = {0}; // initializer with &amp;quot;=&amp;quot; and braces, treated the same as braces-only version.

Widget w1;  // default ctor.
Widget w2 = w1; // copy ctor
w1 = w2;  // assignment, calls copy operator=

// easy to specify the init. content of a container
std::vector&amp;lt;int&amp;gt; v{ 1, 3, 5 };  // v&#39;s init. content is 1, 3, 5

// specify default init. value for non-static data members, where parentheses not allowed
class Widget {
    ...
private:
    int x{ 0 }; // fine
    int y = 0;  // fine
    int z(0);   // error
};

// specify init. value for uncopyable objects (EMCpp item 40), where &amp;quot;=&amp;quot; not allowed
std::atomic&amp;lt;int&amp;gt; ai1{ 0 }; // fine
std::atomic&amp;lt;int&amp;gt; ai2(0);   // fine
std::atomic&amp;lt;int&amp;gt; ai3 = 0;  // error
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;From the example above, it&amp;rsquo;s easy to see why braced initialization is called &amp;ldquo;uniform&amp;rdquo; - a single initialization syntax that aims to be used anywhere and express everything.&lt;/p&gt;

&lt;h2 id=&#34;preventing-narrowing-conversion&#34;&gt;Preventing narrowing conversion&lt;/h2&gt;

&lt;p&gt;Braced initialization prohibits implicit &lt;em&gt;narrowing conversions&lt;/em&gt; among built-in types:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;double x, y, z;
...
int sum1{ x + y + z }; // error
int sum2(x + y + z);  // okay to truncate value of expression to an int
int sum3 = x + y + z; // ditto
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;immune-to-most-vexing-parse&#34;&gt;Immune to most vexing parse&lt;/h2&gt;

&lt;p&gt;&lt;em&gt;Most vexing parse&lt;/em&gt;: anything that can be parsed as a declaration must be interpreted as one. This may be annoying when developers want to default-construct an object, but inadvertently end up declaring a function instead. Using braces, we don&amp;rsquo;t have such an issue:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;Widget w1(10); // call Widget ctor with arg. 10
Widget w2();  // intend to call a Widget const. with zero arg., end up declaring a func. named w2 that returns a Widget
Widget w3{}; // calls Widget ctor with no args.
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;the-not-so-good-part&#34;&gt;The not-so-good part&lt;/h1&gt;

&lt;h2 id=&#34;unintuitive-behavior-with-auto&#34;&gt;Unintuitive behavior with &lt;code&gt;auto&lt;/code&gt;&lt;/h2&gt;

&lt;p&gt;As EMCpp item 2 explains, when an &lt;code&gt;auto&lt;/code&gt;-declared variable has a braced initializer, the type deduced is &lt;code&gt;std::initializer_list&lt;/code&gt;, which may lead to surprising behaviors sometimes.&lt;/p&gt;

&lt;h2 id=&#34;too-high-overloading-priority&#34;&gt;(Too) high overloading priority&lt;/h2&gt;

&lt;p&gt;Calls using braced initialization syntax strongly prefer the overloads taking &lt;code&gt;std::initializer_list&lt;/code&gt;s: if there&amp;rsquo;s any way for compilers to construe a call using a braced initializer to be to a constructor taking a &lt;code&gt;std::initializer_list&lt;/code&gt;, compilers will employ that interpretation:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class Widget {
public:
    Widget(int i, bool b);
    Widget(int i, double d);
    Widget(std::initializer_list&amp;lt;long double&amp;gt; il);
    operator float() const; // convert to float
    ...
};

Widget w1(10, true); // calls first ctor.
Widget w2{10, true}; // calls std::initializer_list ctor, 10 and true convert to long double
Widget w3(10, 5.6); // calls second ctor
Widget w4{10, 5.6}; // calls std::initializer_list ctor, 10 and 5.6 convert to long double
Widget w5(w4); // calls copy ctor
Widget w6{w4}; // calls std::initializer_list ctor, w4 converts to float, and float converts to long double
Widget w7(std::move(w4)); // calls move ctor
Widget w8{std::move(w4)}; // calls std::initializer_list ctor, same conversion as w6
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The priority is so high that it prevails even if the best-match &lt;code&gt;std-initializer_list&lt;/code&gt; constructor can&amp;rsquo;t be called:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class Widget {
public:
    Widget(int i, bool b);
    Widget(int i, double d);
    Widget(std::initializer_list&amp;lt;bool&amp;gt; il); // no implicit conversion funcs
    ...
};

Widget w{10, 5.0}; // error: requires narrowing conversions. The other callable ctors is shadowed
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Only if there&amp;rsquo;s no way to convert the types of the arguments in a braced initializer to the type in a &lt;code&gt;std::initializer_list&lt;/code&gt; do compilers fall back on normal overload resolution:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class Widget {
public:
    Widget(int i, bool b);
    Widget(int i, double d);
    Widget(std::initializer_list&amp;lt;std::string&amp;gt; il); // no implicit conversion funcs
    ...
};

Widget w1(10, true);  // calls first ctor
Widget w2{10, true};  // calls first ctor
Widget w3(10, 5.0);  // calls second ctor
Widget w3{10, 5.0};  // calls second ctor
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Edge case&lt;/strong&gt;: Empty braces mean no arguments, not an empty &lt;code&gt;std::initializer_list&lt;/code&gt;. For example&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class Widget {
public:
    Widget();
    Widget(std::initializer_list&amp;lt;int&amp;gt; il); // no implicit conversion funcs
    ...
};

Widget w1; // calls default ctor
Widget w2(); // calls default ctor
Widget w3{}; // calls default ctor
Widget w4({}); // calls std::initializer_list ctor with empty list
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>[EMCpp]Item-6 Use the Explicitly Typed Initializer Idiom when auto deduces undesired types</title>
      <link>http://nianze.tk/2018/07/use-the-explicitly-typed-initializer-idiom-when-auto-deduces-undesired-types/</link>
      <pubDate>Sun, 08 Jul 2018 13:32:48 -0400</pubDate>
      
      <guid>http://nianze.tk/2018/07/use-the-explicitly-typed-initializer-idiom-when-auto-deduces-undesired-types/</guid>
      <description>&lt;p&gt;“Invisible” proxy types can cause &lt;code&gt;auto&lt;/code&gt; to deduce the undesired type for an initializing expression, so we can adopt explicitly typed initializer idiom to force &lt;code&gt;auto&lt;/code&gt; to deduce what we want.
&lt;/p&gt;

&lt;p&gt;Some proxy classe are designed to be apparent to clients, such as &lt;code&gt;std::shared_ptr&lt;/code&gt;, and &lt;code&gt;std::unique_ptr&lt;/code&gt;. Other proxy classes are designed to at more or less invisibly, such as &lt;code&gt;std::vector&amp;lt;bool&amp;gt;::reference&lt;/code&gt;, and &lt;code&gt;std::bitset::reference&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;For example, suppose we have a function that takes a &lt;code&gt;Widget&lt;/code&gt; and returns a &lt;code&gt;std::vector&amp;lt;bool&amp;gt;&lt;/code&gt;, where each bool indicates whether the &lt;code&gt;Widget&lt;/code&gt; offers a particular feature:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;std::vector&amp;lt;bool&amp;gt; features(const Widget&amp;amp; w);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now we want to check the value of bit 5, which indicates whether the &lt;code&gt;Widget&lt;/code&gt; has high priority:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;Widget w;
...
bool highPriority = features(w)[5];  // is w high priority ?
...
processWidget(w, highPriority);  // process w in accord with its priority
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;However, if we change the explicit type for &lt;code&gt;highPriority&lt;/code&gt; with &lt;code&gt;auto&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;auto highPriority = features(w)[5];
processWidget(w, highPriority);  // undefined behavior! 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The undefined behavior is caused by the fact that &lt;code&gt;highPriority&lt;/code&gt; contains dangling pointer. And here is what happened:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;features&lt;/code&gt; returns a temporary &lt;code&gt;std::vector&amp;lt;bool&amp;gt;&lt;/code&gt; object (let&amp;rsquo;s call it &lt;em&gt;temp&lt;/em&gt;), which is specified to represent its &lt;code&gt;bool&lt;/code&gt;s in packed form, one bit per &lt;code&gt;bool&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;operator[]&lt;/code&gt; is invokes on &lt;em&gt;temp&lt;/em&gt;, and returns a &lt;code&gt;std::vector&amp;lt;bool&amp;gt;::reference&lt;/code&gt; object (an invisible proxy), which contains a pointer to a word in the data structure holding the bits that are managed by &lt;code&gt;temp&lt;/code&gt;, plus the offset into that word corresponding to bit 5&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:1&#34;&gt;&lt;a href=&#34;#fn:1&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;auto&lt;/code&gt; deduces &lt;code&gt;std::vector&amp;lt;bool&amp;gt;::reference&lt;/code&gt; as the tpe of &lt;code&gt;highPriority&lt;/code&gt;, and bind &lt;code&gt;highPriority&lt;/code&gt; to a copy of this &lt;code&gt;std::vector&amp;lt;bool&amp;gt;::reference&lt;/code&gt; object&lt;/li&gt;
&lt;li&gt;at the end of the statement, &lt;code&gt;temp&lt;/code&gt; is destroyed. Therefore, as a copy, &lt;code&gt;highPriority&lt;/code&gt; contains a dangling pointer, leading to undefined behavior in the call to &lt;code&gt;processWidget&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Now is the time we adopt the explicitly typed initializer idiom: we declare a variable with &lt;code&gt;auto&lt;/code&gt;, but casting the initialization expression to the type we want &lt;code&gt;auto&lt;/code&gt; to deduce:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;auto highPriority = static_cast&amp;lt;bool&amp;gt;(features(w)[5]);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;At this time, the &lt;code&gt;std::vector&amp;lt;bool&amp;gt;::reference&lt;/code&gt; object returned from &lt;code&gt;std::vector&amp;lt;bool&amp;gt;::operator[]&lt;/code&gt; executes the conversion to &lt;code&gt;bool&lt;/code&gt; it supports, and as part of that conversion, the still-valid pointer to &lt;em&gt;temp&lt;/em&gt; (the &lt;code&gt;std::vector&amp;lt;bool&amp;gt;&lt;/code&gt; object returned from &lt;code&gt;features&lt;/code&gt;) is dereferenced, and the index 5 is then applied to the bits pointed to by the ponter, and the &lt;code&gt;bool&lt;/code&gt; value that emerges is used to initialize &lt;code&gt;highPriority&lt;/code&gt; - therefore, undefined behavior is avoided.&lt;/p&gt;
&lt;div class=&#34;footnotes&#34;&gt;

&lt;hr /&gt;

&lt;ol&gt;
&lt;li id=&#34;fn:1&#34;&gt;C++ forbids references to bits, so in the case where &lt;code&gt;T&lt;/code&gt; is &lt;code&gt;bool&lt;/code&gt;, &lt;code&gt;operator[]&lt;/code&gt; for &lt;code&gt;std::vector&amp;lt;T&amp;gt;&lt;/code&gt; cannot return &lt;code&gt;bool&amp;amp;&lt;/code&gt; in packed form. That&amp;rsquo;s why the proxy is introduced here to make the return value act like a &lt;code&gt;bool&amp;amp;&lt;/code&gt;.
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:1&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;</description>
    </item>
    
    <item>
      <title>[EMCpp]Item-5 Prefer Auto to Explicit Type Declarations</title>
      <link>http://nianze.tk/2018/07/prefer-auto-to-explicit-type-declarations/</link>
      <pubDate>Sat, 07 Jul 2018 13:33:06 -0400</pubDate>
      
      <guid>http://nianze.tk/2018/07/prefer-auto-to-explicit-type-declarations/</guid>
      <description>&lt;p&gt;Despite some pitfalls described in EMCpp item 2 and 6, &lt;code&gt;auto&lt;/code&gt; variables are preferred for they must be initialized, are generally immune to type mismatches that can lead to portability or efficiency problems, can ease the process of refactoring, and typically require less typing than variables with explicitly specified types.

&lt;!-- toc --&gt;&lt;/p&gt;

&lt;h1 id=&#34;avoidance-of-uninitialized-variables&#34;&gt;Avoidance of Uninitialized variables&lt;/h1&gt;

&lt;p&gt;&lt;code&gt;auto&lt;/code&gt; variavbles have their type deduced from their initializer, so they must be initialized.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;int x1;  // potentially unintialized
auto x2;  // error! initializer required
auto x3 = 0; // fine, x3&#39;s value is well-defined
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;avoidance-of-syntactic-verbosity&#34;&gt;Avoidance of Syntactic Verbosity&lt;/h1&gt;

&lt;p&gt;In order to express the type of the value pointed to by an iterator, without &lt;code&gt;auto&lt;/code&gt;, we may write like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;template&amp;lt;typename It&amp;gt;
void dwim(It b, It e) // &amp;quot;do what I mean&amp;quot;. for all elements in range from b to e
{
    for (; b != e; ++b) {
        typename std::iterator_traits&amp;lt;It&amp;gt;::value_type currValue = *b;
        ...
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Thanks to &lt;code&gt;auto&lt;/code&gt;, now we can declare a local variable whose value is that of a dereferenced iterator with ease:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;template&amp;lt;typename It&amp;gt;
void dwim(It b, It e)
{
    for (; b != e; ++b) {
        auto currValue = *b;
        ...
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;ability-to-hold-closure&#34;&gt;Ability to Hold Closure&lt;/h1&gt;

&lt;p&gt;Because &lt;code&gt;auto&lt;/code&gt; uses type deduction, it can represent types known only to compilers, such as lambda expressions:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;// C++14
auto derefLess =           // comparison func. for values pointed
    [](const auto&amp;amp; p1,     // to by anything pointer-like
       const auto&amp;amp; p2) 
    { return *p1 &amp;lt; *p2; };  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;or in C++11, a little more verbose:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;// C++11 doesn&#39;t support auto for parameters to lambda, so more verbose.
auto derefUPLess =  // comparison func. for Wdigets pointed
    [](const std::unique_ptr&amp;lt;Widget&amp;gt;&amp;amp; p1,  // to by std::unique_ptr
       const std::unique_ptr&amp;lt;Widget&amp;gt;&amp;amp; p2)  
    { return *p1 &amp;lt; *p2; }; 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Without using &lt;code&gt;auto&lt;/code&gt;, since lambda expressions yield closures, which are callable objects, we can store them in &lt;code&gt;std::function&lt;/code&gt; objects:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;std::function&amp;lt;bool(const std::unique_ptr&amp;lt;Widget&amp;gt;&amp;amp;, 
              bool(const std::unique_ptr&amp;lt;Widget&amp;gt;&amp;amp;)&amp;gt;
    derefUPLess = [](const std::unique_ptr&amp;lt;Widget&amp;gt;&amp;amp; p1, // comparison func. for Wdigets pointed
                     const std::unique_ptr&amp;lt;Widget&amp;gt;&amp;amp; p2) // to by std::unique_ptr
                    { return *p1 &amp;lt; *p2; };
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As we can see, syntactic verbosity makes &lt;code&gt;auto&lt;/code&gt; a preferred choice. Besides that, there are two more reasons to choose &lt;code&gt;auto&lt;/code&gt;:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;code&gt;std::function&lt;/code&gt; object typically uses more memory than the &lt;code&gt;auto&lt;/code&gt;-declared object&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:1&#34;&gt;&lt;a href=&#34;#fn:1&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;.&lt;/li&gt;
&lt;li&gt;invoking a closure via a &lt;code&gt;std::function&lt;/code&gt; object is almost certain to be slower than calling it via an &lt;code&gt;auto&lt;/code&gt;-declared object&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:2&#34;&gt;&lt;a href=&#34;#fn:2&#34;&gt;2&lt;/a&gt;&lt;/sup&gt;.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;In summary, &lt;code&gt;auto&lt;/code&gt; wins the competition between &lt;code&gt;auto&lt;/code&gt; and &lt;code&gt;std::function&lt;/code&gt; for holding a closure.&lt;/p&gt;

&lt;h1 id=&#34;avoidance-of-unexpected-implicit-conversions&#34;&gt;Avoidance of Unexpected Implicit Conversions&lt;/h1&gt;

&lt;p&gt;Consider this code:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;std::unordered_map&amp;lt;std::string, int&amp;gt; m;
...
for (const std::pair&amp;lt;std::string, int&amp;gt;&amp;amp; p : m)
{
    ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This looks perfectly reasonable, but there&amp;rsquo;s a problem: the key part of a &lt;code&gt;std::unorderd_map&lt;/code&gt; is &lt;code&gt;const&lt;/code&gt;, so the type of &lt;code&gt;std::pair&lt;/code&gt; in the hash table isn&amp;rsquo;t &lt;code&gt;std::pair&amp;lt;std::string, int&amp;gt;&lt;/code&gt;, but &lt;code&gt;std::pair&amp;lt;const std::string, int&amp;gt;&lt;/code&gt;. Since the constness hasn&amp;rsquo;t been declared for the variable &lt;code&gt;p&lt;/code&gt; in the loop, compilers will create a temporary object of the type that &lt;code&gt;p&lt;/code&gt; wants to bind to by coping each object in &lt;code&gt;m&lt;/code&gt;, then binding the reference &lt;code&gt;p&lt;/code&gt; to that temporary object, and finally destroy the temporary at the end of each loop iteration. This is almost certain to be an unwanted behavior - we probably intend to simply bind the reference &lt;code&gt;p&lt;/code&gt; to each element in &lt;code&gt;m&lt;/code&gt; directly.&lt;/p&gt;

&lt;p&gt;Such unintentional type mismatches can be &lt;code&gt;auto&lt;/code&gt;ed away:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;for (auto&amp;amp; p : m)
{
    ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;avoidance-of-explicit-type-revising-during-refactoring&#34;&gt;Avoidance of Explicit Type Revising during Refactoring&lt;/h1&gt;

&lt;p&gt;&lt;code&gt;auto&lt;/code&gt; types automatically change if the type of their initializing expression changes, and that means that some refactoring (e.g., change the return type of a function from &lt;code&gt;int&lt;/code&gt; to &lt;code&gt;long&lt;/code&gt;) are facilitated by the use of &lt;code&gt;auto&lt;/code&gt;:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;if the results of calling the function are stored in &lt;code&gt;auto&lt;/code&gt; variables, the calling code automatically updates itself the next time we compile&lt;/li&gt;
&lt;li&gt;if the results are stored in varibles explicitly declared to be &lt;code&gt;int&lt;/code&gt;, we have to find all the call sites so that we can revise them.&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;footnotes&#34;&gt;

&lt;hr /&gt;

&lt;ol&gt;
&lt;li id=&#34;fn:1&#34;&gt;An &lt;code&gt;auto&lt;/code&gt;-declared variable holding a closure has the same type as the closure, and uses only as much memory as the closure requires. The type of a &lt;code&gt;std::function&lt;/code&gt;-declared variable holding a closure is an instantiation of the &lt;code&gt;std::function&lt;/code&gt; template, and that has a fixed size for any given signature. When this size is not adequate for the closure, &lt;code&gt;std::function&lt;/code&gt; constructor will allocate heap memory to store the closure - leading to typical result that &lt;code&gt;std::function&lt;/code&gt; object uses more memory than the &lt;code&gt;auto&lt;/code&gt;-declared object.
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:1&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:2&#34;&gt;This slowness comes from the implementation details of &lt;code&gt;std::function&lt;/code&gt;, which restrict inlining and yield indirect function calls.
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:2&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;</description>
    </item>
    
    <item>
      <title>[EMCpp]Item-4 Know How to View Deduced Types</title>
      <link>http://nianze.tk/2018/07/know-how-to-view-deduced-types/</link>
      <pubDate>Fri, 06 Jul 2018 10:08:00 -0400</pubDate>
      
      <guid>http://nianze.tk/2018/07/know-how-to-view-deduced-types/</guid>
      <description>&lt;p&gt;Deduced types can often be seen using IDE editors, compiler error messages, and the Boost TypeIndex library, but the results of some tools may be neither helpful nor accurate.
&lt;/p&gt;

&lt;p&gt;Dependending on the phase of the software development process, we might get type deduction information during coding, compilation, and runtime.&lt;/p&gt;

&lt;h4 id=&#34;ide-editors&#34;&gt;IDE Editors&lt;/h4&gt;

&lt;p&gt;Code editors in IDEs often show the types of program entities when we hover our cursor over the entity. In order for the IDE to offer this kind of information, our code must be in a more or less compilable state. Moreover, when more complicated types are involved, the information displayed by IDEs may not be helpful.&lt;/p&gt;

&lt;h4 id=&#34;compiler-diagnostics&#34;&gt;Compiler Diagnostics&lt;/h4&gt;

&lt;p&gt;We can get a compiler to show what it deduced for a type by causing a compilation problem using that type:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;template&amp;lt;typename T&amp;gt; // Declaration only.
class TD; // TD == &amp;quot;Type Displayer&amp;quot;. 
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;const int theAnser = 42;
auto x = theAnswer;
auto y = &amp;amp;theAnswer;

TD&amp;lt;decltype(x)&amp;gt; xType;
TD&amp;lt;decltype(y)&amp;gt; yType;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;For the code above, since there&amp;rsquo;s no template definition to instantiate, compiler will yield the error messages like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;error: &#39;xType&#39; uses undefined class &#39;TD&amp;lt;int&amp;gt;&#39;
error: &#39;yType&#39; uses undefined class &#39;TD&amp;lt;const int *&amp;gt;&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Through these errors, we get useful type information.&lt;/p&gt;

&lt;h4 id=&#34;runtime-output&#34;&gt;Runtime Output&lt;/h4&gt;

&lt;p&gt;Consider a more complex example involving a user-defined type (&lt;code&gt;Widget&lt;/code&gt;), an STL container(&lt;code&gt;std::vector&lt;/code&gt;), and an &lt;code&gt;auto&lt;/code&gt; variable (&lt;code&gt;vm&lt;/code&gt;), which is more representative of the situation where we want to see deduced type information:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;template&amp;lt;typename T&amp;gt;               // template function to
void f(const T&amp;amp; param);            // be called

std::vector&amp;lt;Widget&amp;gt; createVec();   // factory function
const auto vw = createVec();       // init vm with factory return

if (!vm.empty()) {  
    f(&amp;amp;vm[0]);                     // call f
    ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This time, if we want to see what type is deduced for &lt;code&gt;T&lt;/code&gt; and &lt;code&gt;param&lt;/code&gt;, the type information displayed by IDE editors is not reliably useful. For example, the deduced type for &lt;code&gt;T&lt;/code&gt; is shown as:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;conststd::_Simple_types&amp;lt;std::_Wrap_alloc&amp;lt;std::_Vec_base_types&amp;lt;Widget,std::allocator&amp;lt;Widget&amp;gt; &amp;gt;::_Alloc&amp;gt;::value_type&amp;gt;::value_type *
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;and the &lt;code&gt;param&lt;/code&gt;&amp;rsquo;s type is:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;const std::_Simple_types&amp;lt;...&amp;gt;::value_type *const &amp;amp;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In order to create a textual representation of the type we care about and print it out on screen, we might consider the Boost TypeIndex library&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:1&#34;&gt;&lt;a href=&#34;#fn:1&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;. For example:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;boost/type_index.hpp&amp;gt;
template&amp;lt;typename T&amp;gt;
void f(const T&amp;amp; param)
{  
    using std::cout;  
    using boost::typeindex::type_id_with_cvr;  

    // show T  
    cout &amp;lt;&amp;lt; &amp;quot;T =     &amp;quot;       
         &amp;lt;&amp;lt; type_id_with_cvr&amp;lt;T&amp;gt;().pretty_name() 
         &amp;lt;&amp;lt; &#39;\n&#39;;  
    // show param&#39;s type  
    cout &amp;lt;&amp;lt; &amp;quot;param = &amp;quot;
         &amp;lt;&amp;lt; type_id_with_cvr&amp;lt;decltype(param)&amp;gt;().pretty_name()       
         &amp;lt;&amp;lt; &#39;\n&#39;;  
    ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Under compilers from GNU and Clang, Boost.TypeIndex produces this accurate output:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;T =     Widget const*
param = Widget const* const&amp;amp;
&lt;/code&gt;&lt;/pre&gt;
&lt;div class=&#34;footnotes&#34;&gt;

&lt;hr /&gt;

&lt;ol&gt;
&lt;li id=&#34;fn:1&#34;&gt;There is something similar called &lt;code&gt;typeid&lt;/code&gt; and &lt;code&gt;std::type_info::name&lt;/code&gt; in Standard C++ that could also display the type, but the output text may not be straightforward (for example, using &amp;ldquo;PK&amp;rdquo; to stand for &amp;ldquo;pointer to const&amp;rdquo;) and might not be reliable.
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:1&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;</description>
    </item>
    
    <item>
      <title>[EMCpp]Item-3 Understand Decltype</title>
      <link>http://nianze.tk/2018/07/understand-decltype/</link>
      <pubDate>Thu, 05 Jul 2018 18:59:39 -0400</pubDate>
      
      <guid>http://nianze.tk/2018/07/understand-decltype/</guid>
      <description>&lt;p&gt;&lt;code&gt;decltype&lt;/code&gt; almost always yields the type of a variable or expression without any modifications. For lvalue expressions of type T other than names, &lt;code&gt;decltype&lt;/code&gt; always reports a type of T&amp;amp;.
&lt;/p&gt;

&lt;p&gt;The primary use of &lt;code&gt;decltype&lt;/code&gt; is declaring function templates where the function&amp;rsquo;s return type depends on its parameter types. For example, the indexing operator &lt;code&gt;[]&lt;/code&gt; on a containedr of objects of type &lt;code&gt;T&lt;/code&gt; typically return &lt;code&gt;T&amp;amp;&lt;/code&gt;, but in the case of &lt;code&gt;std::vector&amp;lt;bool&amp;gt;&lt;/code&gt;, &lt;code&gt;operator[]&lt;/code&gt; returns a brand new object (refer to EMCpp item 6 for whys and hows). In order to let compiler deduce the return type, we can use &lt;code&gt;decltype&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;// C++14 version
template&amp;lt;typename Container, typename Index&amp;gt;
decltype(auto) authAndAccess(Container&amp;amp;&amp;amp; c, Index i)
{
    authenticateUser();
    return std::forward&amp;lt;Container&amp;gt;(c)[i];
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A few points worth noting here:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;return type is &lt;code&gt;decltype(auto)&lt;/code&gt;&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:1&#34;&gt;&lt;a href=&#34;#fn:1&#34;&gt;1&lt;/a&gt;&lt;/sup&gt; instead of &lt;code&gt;auto&lt;/code&gt;. As EMCpp item 2 points out, compilers employ template type deduction for functions with an &lt;code&gt;auto&lt;/code&gt; return type. If using &lt;code&gt;auto&lt;/code&gt;, the reference-ness will be stripped off, so &lt;code&gt;T&amp;amp;&lt;/code&gt;, which is the type returned by &lt;code&gt;operator[]&lt;/code&gt; in most cases, will be deduced as &lt;code&gt;T&lt;/code&gt;. This is not what we want.&lt;/li&gt;
&lt;li&gt;universal refrences for the first parameter is used here. As EMCpp item 24 explains, this makes the reference paramter &lt;code&gt;c&lt;/code&gt; be able to bind to both lvalues and rvlues&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:2&#34;&gt;&lt;a href=&#34;#fn:2&#34;&gt;2&lt;/a&gt;&lt;/sup&gt;. Following the exmpale of the Standard Library for index values, we stick with pass-by-value for &lt;code&gt;i&lt;/code&gt; though.&lt;/li&gt;
&lt;li&gt;the &lt;code&gt;std::forward&lt;/code&gt; is applied to the universal reference in accord with EMCpp item 25&amp;rsquo;s admonition.&lt;/li&gt;

&lt;li&gt;&lt;p&gt;in C++11, &lt;code&gt;auto&lt;/code&gt; is not permitted as return types for non-lambda functions, so we need the &lt;em&gt;trailing return type&lt;/em&gt; syntax to tell the compiler that the function&amp;rsquo;s return type will be declared following the parameter list (after the &amp;ldquo;-&amp;gt;&amp;rdquo;), which give us the advantage to use the function&amp;rsquo;s parameters (&lt;code&gt;c&lt;/code&gt; and &lt;code&gt;i&lt;/code&gt; here) in the specification of the return type:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;// C++11 version
template&amp;lt;typename Container, typename Index&amp;gt;
auto authAndAccess(Container&amp;amp;&amp;amp; c, Index i)
    -&amp;gt; decltype(std::forward&amp;lt;Container&amp;gt;(c)[i])
{
    authenticateUser();
    return std::forward&amp;lt;Container&amp;gt;(c)[i];
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;exceptions&#34;&gt;Exceptions&lt;/h4&gt;

&lt;p&gt;As mentioned in the begining, &lt;code&gt;decltype&lt;/code&gt; &lt;em&gt;almost&lt;/em&gt; always produces the type we expect - it means that there are exceptions to the rule. We&amp;rsquo;re unlikely to encounter these exceptions unless we&amp;rsquo;re a heavy-duty library implementer.&lt;/p&gt;

&lt;p&gt;For example, &lt;code&gt;decltype&lt;/code&gt; generally ensures that the type induced for lvalue expressions more complicated than names is an lvalue reference. Since the type of most lvalue expressions inherently includes an lvalue reference qualifier (for example, functions returning lvalues always return lvalue references), this property seldom has any impact. However, a seemingly trivial change in the way we write a &lt;code&gt;return&lt;/code&gt; statement can affect the deduced type for a function:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;decltype(auto) f1()
{
    int x = 0;
    ...
    return x;  // decltype(x) is int, so f1 returns int
}

decltype(auto) f2()
{
    int x = 0;
    ...
    return (x);  // decltype((x)) is int&amp;amp;, so f1 returns int&amp;amp;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;C++ defines the expression &lt;code&gt;(x)&lt;/code&gt; to be an lvalue, which is also an expression more complicated than a variable name &lt;code&gt;x&lt;/code&gt;, so &lt;code&gt;decltype((x))&lt;/code&gt; is &lt;code&gt;int&amp;amp;&lt;/code&gt;, leading to different return types in &lt;code&gt;f1&lt;/code&gt; and &lt;code&gt;f2&lt;/code&gt;. Moreover, &lt;code&gt;f2&lt;/code&gt; returns a reference to a local variable, which means undefined behavior that we don&amp;rsquo;t want.&lt;/p&gt;

&lt;h4 id=&#34;summary&#34;&gt;Summary&lt;/h4&gt;

&lt;p&gt;The lesson we learn from the above example is to pay close attention when using &lt;code&gt;decltype(auto)&lt;/code&gt;. The techniques described in EMCpp item 4 may help ensure that the deduced type is what we expect.&lt;/p&gt;

&lt;p&gt;Meanwhile, don&amp;rsquo;t lose sight of the bigger picture: in most normal cases where &lt;code&gt;decltype&lt;/code&gt; is applied to names, &lt;code&gt;decltype&lt;/code&gt; does just what it sounds like: it reports that name&amp;rsquo;s declared type.&lt;/p&gt;
&lt;div class=&#34;footnotes&#34;&gt;

&lt;hr /&gt;

&lt;ol&gt;
&lt;li id=&#34;fn:1&#34;&gt;The use of &lt;code&gt;decltype(auto)&lt;/code&gt; is not limited to function return types. We can use is for declaring variables. For example, given &lt;code&gt;const Widget&amp;amp;&lt;/code&gt; type variable &lt;code&gt;cw&lt;/code&gt;, &lt;code&gt;auto myWidget1 = cw;&lt;/code&gt; will employ auto type deduction and deduce &lt;code&gt;myWidget1&lt;/code&gt; as type of &lt;code&gt;Widget&lt;/code&gt;, while &lt;code&gt;decltype(auto) myWidget2 = cw;&lt;/code&gt; uses decltype type deduction, leading to &lt;code&gt;myWidget2&lt;/code&gt;&amp;rsquo;s type as &lt;code&gt;const Widget&amp;amp;&lt;/code&gt;.
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:1&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:2&#34;&gt;Supporting the use of rvalue is basically supporting such a function that a client might simply make a copy of an element in the temporary container. Otherwise, an rvalue container (a.k.a. a temporary object) would typically be destroyed at the end of the statement containing the call to &lt;code&gt;authAndAccess&lt;/code&gt;, which means that a reference to an element in that container (typically what &lt;code&gt;authAndAccess&lt;/code&gt; would return in the most cases) would dangle at the end of the statement.
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:2&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;</description>
    </item>
    
    <item>
      <title>[EMCpp]Item-2 Understand Auto Type Deduction</title>
      <link>http://nianze.tk/2018/07/understand-auto-type-deduction/</link>
      <pubDate>Tue, 03 Jul 2018 10:07:13 -0400</pubDate>
      
      <guid>http://nianze.tk/2018/07/understand-auto-type-deduction/</guid>
      <description>&lt;p&gt;&lt;code&gt;auto&lt;/code&gt; type deduction is usually the same as template type deduction, with an exception in the case of braced initializer. Also, in C++14, as a function return type or a lambda parameter, &lt;code&gt;auto&lt;/code&gt; implies template type deduction instead of &lt;code&gt;auto&lt;/code&gt; type deduction.
&lt;/p&gt;

&lt;p&gt;With only one curious exception, &lt;code&gt;auto&lt;/code&gt; type deduction &lt;em&gt;is&lt;/em&gt; template type deduction. In the case of general function template form and its general function call:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;template&amp;lt;typename T&amp;gt;
void f(ParamType param);
f(expr);  // general call
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;compilers use &lt;code&gt;expr&lt;/code&gt; to deduce types for &lt;code&gt;T&lt;/code&gt; and &lt;code&gt;ParamType&lt;/code&gt;. Similarly, in the case where a variable is declared using &lt;code&gt;auto&lt;/code&gt;, &lt;code&gt;auto&lt;/code&gt; plays the role of &lt;code&gt;T&lt;/code&gt;, and the type specifier for the variable acts as &lt;code&gt;ParamType&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Therefore, there are also three cases based on the type specifier:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Case 1: the type specifier is a pointer or reference, but not a universal reference&lt;/li&gt;
&lt;li&gt;Case 2: the type specifier is a universal reference&lt;/li&gt;
&lt;li&gt;Case 3: the type specifier is neither a pointer nor a reference&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;For example:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;auto x = 27;  // case 3. type specifier is simply auto by itself.
const auto cx = x; // case 3. type specifier is const auto.
const auto&amp;amp; rx = x; // case 1. type specifier is const auto&amp;amp;. 
// case 2:
auto&amp;amp;&amp;amp; uref1 = x; // x is int and lvalue, so uref1&#39;s type is int&amp;amp;
auto&amp;amp;&amp;amp; uref2 = cx; // cx is const int and lvalue, so uref2&#39;s type is const int&amp;amp;
auto&amp;amp;&amp;amp; uref3 = 27; // 27 is int and rvlue, so uref3&#39;s type is int&amp;amp;&amp;amp;
// array and function names decay into pointers for non-ref type specifiers:
const char name[] = &amp;quot;R. N. Briggs&amp;quot;; // name&#39;s type is const char [13]
auto arr1 = name;  // arr1&#39;s type is const char*
auto&amp;amp; arr2 = name;  // arr2&#39;s type is const char (&amp;amp;)[13]
void someFunc(int, double); // someFunc is a function, type is void(int, double)
auto func1 = someFunc; // func1&#39;s type is void (*)(int, double)
auto&amp;amp; func2 = someFunc; // func2&#39;s type is void (&amp;amp;)(int, double)
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;exception-uniform-initialization&#34;&gt;Exception: uniform initialization&lt;/h4&gt;

&lt;p&gt;C++98 provides two syntactic choices when we want to declare an int with an initial value:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;int x1 = 27;
int x2(27);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;By introducing uniform initialization, C++11 adds these two forms:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;int x3 = { 27 };
int x4{ 27 };
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As EMCpp 5 explains, there are advantages to declare variables using &lt;code&gt;auto&lt;/code&gt;, so we may prefer:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;auto x1 = 27;  // type is int, value is 27
auto x2(27);   // ditto
auto x3 = { 27 };  // type is std::initializer_list&amp;lt;int&amp;gt;, value is {27}
auto x4{ 27 };  // ditto
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;However, after this modification, while the first two statements do declare a variable of type &lt;code&gt;int&lt;/code&gt; with value 27, the second two actually declare a variable of type &lt;code&gt;std::initializer_list&amp;lt;int&amp;gt;&lt;/code&gt; containing a single element with value 27.&lt;/p&gt;

&lt;p&gt;In fact, when an auto-declared variable is initialized with a braced initializer, &lt;code&gt;auto&lt;/code&gt; will assume that the braced initilizer represents a &lt;code&gt;std::initializer_list&lt;/code&gt;, which itself is a template for some type &lt;code&gt;T&lt;/code&gt;, so there are actually two kinds of type deduction taking place:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;code&gt;auto&lt;/code&gt; type deduction: the type is an instantiation of &lt;code&gt;std::initializer_list&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;template type deduction: the type &lt;code&gt;T&lt;/code&gt; in &lt;code&gt;std::initializer_list&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;The only real difference between &lt;code&gt;auto&lt;/code&gt; and template type deduction is the assumption that a braced initializer represents a &lt;code&gt;std::initializer_list&lt;/code&gt;.&lt;/strong&gt; This lead to some interesting results:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;auto x = { 11, 23, 9 };  // x&#39;s type is std::initializer_list&amp;lt;int&amp;gt;

template&amp;lt;typename T&amp;gt;
void f1(T param);
f1({ 11, 23, 9 });  // error! can&#39;t deduce type for T. Do not recognise the type for braced initializer

template&amp;lt;typename T&amp;gt;
void f2(std::initializer_list&amp;lt;T&amp;gt; initList);
f({ 11, 23, 9 });  // T deduced as T, and initList&#39;s type is std::initializer_list&amp;lt;int&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;more-exceptions-in-c-14&#34;&gt;More exceptions in C++14&lt;/h4&gt;

&lt;p&gt;C++14 permits to use &lt;code&gt;auto&lt;/code&gt; as a function&amp;rsquo;s return type as well as in lambda parameter declarations. However, these uses of &lt;code&gt;auto&lt;/code&gt; employ &lt;em&gt;tamplate type deduction&lt;/em&gt;, not &lt;code&gt;auto&lt;/code&gt; type deduction - so a braced initializer won&amp;rsquo;t imply the type of &lt;code&gt;std::initializer_list&lt;/code&gt; automatically, and following statement won&amp;rsquo;t compile:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;// auto in return type
auto createInitList()
{
    return { 1, 2, 3 };  // error: can&#39;t deduce type for { 1, 2, 3 }
}

// auto in a parameter type specification in a C++14 lambda
std::vector&amp;lt;int&amp;gt; v;
...
auto resetV = [&amp;amp;v](const auto&amp;amp; newValue) { v = newValue; };  // C++14 lambda, second auto is in parameter list
...
resetV({ 1, 2, 3 }); // error: can&#39;t deduce type for { 1, 2, 3 }
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>[EMCpp]Item-1 Understand Template Type Deduction</title>
      <link>http://nianze.tk/2018/07/understand-template-type-deduction/</link>
      <pubDate>Mon, 02 Jul 2018 22:44:34 -0400</pubDate>
      
      <guid>http://nianze.tk/2018/07/understand-template-type-deduction/</guid>
      <description>&lt;p&gt;There are three sets of rules for type deduction in modern C++: one for function templates, one for &lt;code&gt;auto&lt;/code&gt;, and one for &lt;code&gt;decltype&lt;/code&gt;. Without a solid understanding of how deduction operates, effective programming in modern C++ is all but impossible.

&lt;!-- toc --&gt;&lt;/p&gt;

&lt;p&gt;Since type deduction for templates is the basis of that for &lt;code&gt;auto&lt;/code&gt;, it&amp;rsquo;s important to truly understand the aspects of template type deduction that &lt;code&gt;auto&lt;/code&gt; builds on: during template type deduction, there are three cases for parameter types:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;pointer type or non-universal reference type&lt;/li&gt;
&lt;li&gt;universal reference type&lt;/li&gt;
&lt;li&gt;neither a pointer nor a reference (value type)&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Moreover, there&amp;rsquo;s a niche case worth knowing about, that arguments that are array or function names decay to pointers unless they&amp;rsquo;re used to initialize references.&lt;/p&gt;

&lt;p&gt;To tell the difference, let&amp;rsquo;s think of a function template as looking like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;tempalte&amp;lt;typename T&amp;gt;
void f(ParamType param);
f(expr); // deduce T and ParamType from expr
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;case-1-paramtype-is-reference-or-pointer-but-not-a-universal-reference&#34;&gt;Case 1: &lt;code&gt;ParamType&lt;/code&gt; is Reference or Pointer, but not a Universal Reference&lt;/h1&gt;

&lt;p&gt;The rules in this case works like this:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;If &lt;code&gt;expr&lt;/code&gt;&amp;rsquo;s type is a reference, ignore the reference part.&lt;/li&gt;
&lt;li&gt;Then pattern-match &lt;code&gt;expr&lt;/code&gt;&amp;rsquo;s type against &lt;code&gt;ParamType&lt;/code&gt; to determine T.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;For example,&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;template&amp;lt;typename T&amp;gt;
void f(T&amp;amp; param);  // param is a reference

int x = 27;         // x is an int
const int cx = x;   // cx is a const int
const int&amp;amp; rx = x;  // rx is a refrence to x as a const int

f(x);   // T is int, param&#39;s type is int&amp;amp;
f(cx);  // T is const int, param&#39;s type is const int&amp;amp;
f(rx);  // T is const int, param&#39;s type is const int&amp;amp;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note that even though rx&amp;rsquo;s type is a reference, T is deduced to be a non-reference, because rx&amp;rsquo;s reference-ness is ignored during type deduction.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;template&amp;lt;typename T&amp;gt;
void f(const T&amp;amp; param);  // param is now a ref-to-const, 
                         // so there&#39;s no longer a need for const to be deduced as part of T
f(x);  // T is int, param&#39;s type is const int&amp;amp;
f(cx); // T is int, param&#39;s type is const int&amp;amp;
f(rx); // T is int, param&#39;s type is const int&amp;amp;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As before, rx&amp;rsquo;s reference-ness is ignored during type deduction.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;template&amp;lt;typename T&amp;gt;
void f(T* param);     // param is now a pointer

int x = 27;           // x is an int
const int *px = &amp;amp;x;   // px is a ptr to x as a const int

f(&amp;amp;x);   // T is int, param&#39;s type is int*
f(px);   // T is const int, param&#39;s type is const int*
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As shown above, when param were a pointer (or a pointer to const), things work essentially the same way.&lt;/p&gt;

&lt;h1 id=&#34;case-2-paramtype-is-a-universal-reference&#34;&gt;Case 2: &lt;code&gt;ParamType&lt;/code&gt; is a Universal Reference&lt;/h1&gt;

&lt;p&gt;Things are less obvious for templates taking universal reference paramters:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;If &lt;code&gt;expr&lt;/code&gt; is an lvalue, both &lt;code&gt;T&lt;/code&gt; and &lt;code&gt;ParamType&lt;/code&gt; are deduced to be lvalue references.&lt;/li&gt;
&lt;li&gt;If &lt;code&gt;expr&lt;/code&gt; is an rvalue, the &amp;ldquo;normal&amp;rdquo; (i.e., case 1) rules apply.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;For example:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;template&amp;lt;typename T&amp;gt;
void f(T&amp;amp;&amp;amp; param);  // param is now a universal reference

int x = 27;         // as before
const int cx = x;   // as before
const int&amp;amp; rx = x;  // as before

f(x);  // x is lvalue, so T is int&amp;amp;, param&#39;s type is also int&amp;amp;
f(cx); // x is lvalue, so T is const int&amp;amp;, param&#39;s type is also const int&amp;amp;
f(rx); // x is lvalue, so T is const int&amp;amp;, param&#39;s type is also const int&amp;amp;
f(27); // x is rvlaue, so T is int, param&#39;s type is therefore int&amp;amp;&amp;amp;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;EMCpp Item24 explains why these examples play out the way they do.&lt;/p&gt;

&lt;h1 id=&#34;case-3-paramtype-is-neither-a-pointer-nor-a-reference&#34;&gt;Case 3: &lt;code&gt;ParamType&lt;/code&gt; is Neither a Pointer nor a Reference&lt;/h1&gt;

&lt;p&gt;In this case, we&amp;rsquo;re dealing with pass-by-value. That means that &lt;code&gt;param&lt;/code&gt; will be a new object, which motivates the rules below:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;As before, if &lt;code&gt;expr&lt;/code&gt;&amp;rsquo;s type is a reference, ignore the reference part&lt;/li&gt;
&lt;li&gt;If, after ignoring &lt;code&gt;expr&lt;/code&gt;&amp;rsquo;s reference-ness, &lt;code&gt;expr&lt;/code&gt; is const, ignore that, too. If it&amp;rsquo;s &lt;code&gt;volatile&lt;/code&gt;, also ignore that (refer to EMCpp item 40 for &lt;code&gt;volatile&lt;/code&gt;).&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;template&amp;lt;typename T&amp;gt;
void f(T param);  // param is now passed by value

int x = 27;         // as before
const int cx = x;   // as before
const int&amp;amp; rx = x;  // as before
const char* const ptr = &amp;quot;Fun with pointers&amp;quot;; // ptr is const ptr to const obj.

f(x);  // T&#39;s and param&#39;s types are both int
f(cx); // T&#39;s and param&#39;s types are both int
f(rx); // T&#39;s and param&#39;s types are both int
f(ptr); // T&#39;s and param&#39;s types are const char*, the constness of ptr is ignored.
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;array-arguments&#34;&gt;Array Arguments&lt;/h1&gt;

&lt;p&gt;Even though they sometimes seems to be interchangeable, array types are, in fact, different from pointer types. We had such equivalence illusion because, in many contexts, an array &lt;em&gt;decays&lt;/em&gt; into a pointer to its first element:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;const char name[] = &amp;quot;J.P. Briggs&amp;quot;;  // name&#39;s type is const char [13]
const char * ptrToName = name;      // array decays to pointer
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Array parameter declarations are treated as if they were pointer parameters, so &lt;code&gt;void myFunc(int param[]);&lt;/code&gt; is equivalent to &lt;code&gt;void myFunc(int* param);&lt;/code&gt;. Thus, the type of an array that&amp;rsquo;s passed to a template function by value is deduced to be a pointer type:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;template&amp;lt;typename T&amp;gt;
void f(T param);

f(name);  // name is array, but T deduced as const char*
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Although functions can&amp;rsquo;t declare parameters that are truly arrays, they &lt;em&gt;can&lt;/em&gt; declare parameters that are &lt;em&gt;references&lt;/em&gt; to arrays. Thus,&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;template&amp;lt;typename T&amp;gt;
void f(T&amp;amp; param);  // template with by-reference parameter

f(name);  // T is deduced as array type: const char [13], type of param is const char (&amp;amp;)[13]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The actual type of the array includes the array size, so in this example, &lt;code&gt;T&lt;/code&gt; is deduced to be &lt;code&gt;const char[13]&lt;/code&gt;, and the type of &lt;code&gt;f&lt;/code&gt;&amp;rsquo;s parameter (a reference to this array) is &lt;code&gt;const char (&amp;amp;)[13]&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Using this ability to declare references to arrays enables creation of a template that deduces the number of elements that an array contains:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;// return size of an array as a compile-time constant.
// array parameter has no name because we don&#39;t care its name
template&amp;lt;typename T, std::size_t N&amp;gt;
constexpr std::size_t arraySize(T (&amp;amp;)[N]) noexcept
{
    return N;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;There are two points worth noting in this declaration:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;constexpr&lt;/code&gt;, as explained in EMCpp 15, makes the function result available during compilation, which makes it possible to declare an array with the same number of elements as a second array whose size is computed from a braced initializer:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;int keyVals[] = { 1, 3, 7, 9, 11, 22, 35 };  // 7 elements
int mappedVals[arraySize(keyVals)]; // 7 elements
std::array&amp;lt;int, arraySize(keyVals)&amp;gt; values;  // size == 7
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;noexcept&lt;/code&gt;, as explained in EMCpp 14, helps compilers generate better code.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&#34;function-arguments&#34;&gt;Function Arguments&lt;/h1&gt;

&lt;p&gt;Apart from arrays, function types can decay into function pointers, too. As a result:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;void someFunc(int, double); // someFunc is a function, type is void(int, double)

template&amp;lt;typename T&amp;gt;
void f1(T param);  // in f1, param passed by value

template&amp;lt;typename T&amp;gt;
void f2(T&amp;amp; param);  // in f2, param passed by ref

f1(someFunc);  // param deduced as ptr-to-func, type is void (*)(int, double)

f2(someFunc);  // param deduced as ref-to-func, type is void (&amp;amp;)(int, double)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This rarely makes any difference in practice.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>A Brief Review of Dynamo</title>
      <link>http://nianze.tk/2018/07/a-brif-review-of-dynamo/</link>
      <pubDate>Sun, 01 Jul 2018 23:03:34 -0400</pubDate>
      
      <guid>http://nianze.tk/2018/07/a-brif-review-of-dynamo/</guid>
      <description>&lt;p&gt;As a highly available and scalable distributed data store, the design principles of Dynamo features high availability for writes (via reconciliation during reads), incremental scalability (consistent hashing), symmetry, decentralization, and heterogeneity (via virtual nodes).
&lt;/p&gt;

&lt;h4 id=&#34;the-summary-of-techniques-used-in-dynamo-and-their-advantages&#34;&gt;The summary of techniques used in &lt;em&gt;Dynamo&lt;/em&gt; and their advantages&lt;/h4&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;strong&gt;Problem&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;Technique&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;Advantage&lt;/strong&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Partitioning&lt;/td&gt;
&lt;td&gt;Consistent Hashing&lt;/td&gt;
&lt;td&gt;Incremental Scalability&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;High Availability&lt;/td&gt;
&lt;td&gt;Vector clocks with reconciliation during reads&lt;/td&gt;
&lt;td&gt;Version size is decoupled from update rates.&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;Handling temporary failures&lt;/td&gt;
&lt;td&gt;Sloppy Quorum and hinted handoff&lt;/td&gt;
&lt;td&gt;Provides high availability and durability guarantee when some of the replicas are not available.&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;Recovering from permanent failures&lt;/td&gt;
&lt;td&gt;Anti-entropy using Merkle trees&lt;/td&gt;
&lt;td&gt;Synchronizes divergent replicas in the background.&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;Membership and failure detection&lt;/td&gt;
&lt;td&gt;Gossip-based membership protocol and (local notion) failure detection&lt;/td&gt;
&lt;td&gt;Perserves symmetry and avoids having a centralized registry for storing membership and node liveness information.&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;</description>
    </item>
    
    <item>
      <title>徕卡M9初体验</title>
      <link>http://nianze.tk/2018/06/a-sip-of-leica-m9/</link>
      <pubDate>Sat, 02 Jun 2018 21:39:34 -0400</pubDate>
      
      <guid>http://nianze.tk/2018/06/a-sip-of-leica-m9/</guid>
      <description>&lt;p&gt;他们说徕卡调教过的那块柯达CCD自带德味，我不信，心想用卡西欧自拍神器理论上也能后期出那味道来。

&lt;!-- toc --&gt;&lt;/p&gt;

&lt;p&gt;上个月正好要去秘鲁玩，按捺不住好奇，赶在出行前到附近某相机店领来了这台二手八五成新M9，配上福伦达VM35-F1.4的狗头亲试了下。我信了。CCD的画质，配合徕卡的调教，直出的照片就能得到很讨喜的颜色，而且有种类似胶片的氛围，我确实后期不来这种味道。以下便是我在这次旅行中对这台相机的简单体验和感受。&lt;/p&gt;



 
  
  
  
  
    
  
    
      
    
  

&lt;div class=&#34;figure fig-100&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2018/2018-06/02/title-image-1.jpg&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2018/2018-06/02/title-image-1.jpg&#34; &gt;
  
    &lt;/a&gt;
  
  
&lt;/div&gt;


&lt;h1 id=&#34;前言-为什么是徕卡&#34;&gt;前言：为什么是徕卡&lt;/h1&gt;

&lt;p&gt;作为35mm画幅的开创者，历史中有太多精彩的&lt;a href=&#34;https://www.zhihu.com/question/25875082/answer/31671331&#34;&gt;决定性瞬间&lt;/a&gt;出自徕卡相机，也让徕卡这家“手工作坊”在上百年的历史积淀中塑造了属于自己的摄影哲学。&lt;/p&gt;

&lt;p&gt;然而随着时代的发展，在日系相机自动化浪潮的冲击下，说起摄影，现在人们最先想到的都是单反的形象，最先熟悉的品牌则是佳能尼康或者近来大热的索尼。即使是知道徕卡这个品牌的人群，也只有部分会真正认同其价值——毕竟徕卡的品牌定位使其镜头和机身的售价更像是“奢侈品”（尤其是各个限量版），加上机身各类参数的缺失（比如只能手动对焦），更是凸显了日系相机的高性价比——其结果便是，随便去任何一个综合性摄影论坛（不论国内还是国外），但凡是徕卡相关的讨论帖，总有评论对徕卡投以调侃、不屑甚至嘲讽。网上相关的讨论帖我看了不少，终究还是不清楚，这红色可乐标背后究竟有何魅力，又是什么构成了徕卡品牌的“逼格”。&lt;/p&gt;

&lt;p&gt;所以，原本眼馋富士相机的我，想到那句“徕卡是全幅相机器材里绕不过去的坎”的传言，就决定一步到位，将最近留给索尼A7iii的预算转而下单了这台徕卡。&lt;/p&gt;



 
  
  
  
  
    
  
    
      
    
  

&lt;div class=&#34;figure fig-100&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2018/2018-06/02/title-image-2.jpg&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2018/2018-06/02/title-image-2.jpg&#34; &gt;
  
    &lt;/a&gt;
  
  
&lt;/div&gt;


&lt;h1 id=&#34;开箱-伪&#34;&gt;开箱（伪）&lt;/h1&gt;

&lt;p&gt;

 
  
  
  
  
    
  
    
      
    
  

&lt;div class=&#34;figure fig-25&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2018/2018-06/02/open-box-1.jpg&#34; title=&#34;↑附近那家相机店的袋子&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2018/2018-06/02/open-box-1.jpg&#34;  alt=&#34;↑附近那家相机店的袋子&#34;&gt;
  
    &lt;/a&gt;
  
   
    &lt;span class=&#34;caption&#34;&gt;↑附近那家相机店的袋子&lt;/span&gt;
  
&lt;/div&gt;



 
  
  
  
  
    
  
    
      
    
  

&lt;div class=&#34;figure fig-25&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2018/2018-06/02/open-box-2.jpg&#34; title=&#34;↑取出硕大的盒子&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2018/2018-06/02/open-box-2.jpg&#34;  alt=&#34;↑取出硕大的盒子&#34;&gt;
  
    &lt;/a&gt;
  
   
    &lt;span class=&#34;caption&#34;&gt;↑取出硕大的盒子&lt;/span&gt;
  
&lt;/div&gt;



 
  
  
  
  
    
  
    
      
    
  

&lt;div class=&#34;figure fig-25&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2018/2018-06/02/open-box-4.jpg&#34; title=&#34;↑专门装机身的中间层&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2018/2018-06/02/open-box-4.jpg&#34;  alt=&#34;↑专门装机身的中间层&#34;&gt;
  
    &lt;/a&gt;
  
   
    &lt;span class=&#34;caption&#34;&gt;↑专门装机身的中间层&lt;/span&gt;
  
&lt;/div&gt;



 
  
  
  
  
    
  
    
      
    
  

&lt;div class=&#34;figure fig-25&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2018/2018-06/02/open-box-5.jpg&#34; title=&#34;↑机身就这么静静躺着&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2018/2018-06/02/open-box-5.jpg&#34;  alt=&#34;↑机身就这么静静躺着&#34;&gt;
  
    &lt;/a&gt;
  
   
    &lt;span class=&#34;caption&#34;&gt;↑机身就这么静静躺着&lt;/span&gt;
  
&lt;/div&gt;
&lt;/p&gt;

&lt;p&gt;徕卡的盒子很大，分了三层，上层是说明书，小册子里会送Lightroom正版软件注册号。相机在中间那层，底层是充电器，电池，肩带等配件。&lt;/p&gt;

&lt;h1 id=&#34;外观&#34;&gt;外观&lt;/h1&gt;

&lt;p&gt;

 
  
  
  
  
    
  
    
      
    
  

&lt;div class=&#34;figure fig-33&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2018/2018-06/02/open-box-7.jpg&#34; title=&#34;↑取出机身&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2018/2018-06/02/open-box-7.jpg&#34;  alt=&#34;↑取出机身&#34;&gt;
  
    &lt;/a&gt;
  
   
    &lt;span class=&#34;caption&#34;&gt;↑取出机身&lt;/span&gt;
  
&lt;/div&gt;



 
  
  
  
  
    
  
    
      
    
  

&lt;div class=&#34;figure fig-33&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2018/2018-06/02/open-box-8.jpg&#34; title=&#34;↑正面照&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2018/2018-06/02/open-box-8.jpg&#34;  alt=&#34;↑正面照&#34;&gt;
  
    &lt;/a&gt;
  
   
    &lt;span class=&#34;caption&#34;&gt;↑正面照&lt;/span&gt;
  
&lt;/div&gt;



 
  
  
  
  
    
  
    
      
    
  

&lt;div class=&#34;figure fig-33&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2018/2018-06/02/open-box-9.jpg&#34; title=&#34;↑背面照，按键很少&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2018/2018-06/02/open-box-9.jpg&#34;  alt=&#34;↑背面照，按键很少&#34;&gt;
  
    &lt;/a&gt;
  
   
    &lt;span class=&#34;caption&#34;&gt;↑背面照，按键很少&lt;/span&gt;
  
&lt;/div&gt;
&lt;/p&gt;

&lt;p&gt;

 
  
  
  
  
    
  
    
      
    
  

&lt;div class=&#34;figure fig-50&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2018/2018-06/02/open-box-11.jpg&#34; title=&#34;↑快门帘&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2018/2018-06/02/open-box-11.jpg&#34;  alt=&#34;↑快门帘&#34;&gt;
  
    &lt;/a&gt;
  
   
    &lt;span class=&#34;caption&#34;&gt;↑快门帘&lt;/span&gt;
  
&lt;/div&gt;



 
  
  
  
  
    
  
    
      
    
  

&lt;div class=&#34;figure fig-50&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2018/2018-06/02/open-box-12.jpg&#34; title=&#34;↑CCD传感器，既是精髓所在，也是bug之源（corrosion了解下）&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2018/2018-06/02/open-box-12.jpg&#34;  alt=&#34;↑CCD传感器，既是精髓所在，也是bug之源（corrosion了解下）&#34;&gt;
  
    &lt;/a&gt;
  
   
    &lt;span class=&#34;caption&#34;&gt;↑CCD传感器，既是精髓所在，也是bug之源（corrosion了解下）&lt;/span&gt;
  
&lt;/div&gt;
&lt;/p&gt;

&lt;p&gt;相机刚拿到手上的时候还是挺惊喜的，毕竟是第一次上手这么小巧的全画幅数码相机。简约的线条和尽可能少的按键继承了经典的设计风格，金属机身分量很扎实手感很细腻，正面右上角可以看到已经有磨损露出的黄铜色。机身侧面还有一个没人用的usb接口。&lt;/p&gt;



 
  
  
  
  
    
  
    
      
    
  

&lt;div class=&#34;figure fig-100&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2018/2018-06/02/bottom-1.jpg&#34; title=&#34;↑USB接口&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2018/2018-06/02/bottom-1.jpg&#34;  alt=&#34;↑USB接口&#34;&gt;
  
    &lt;/a&gt;
  
   
    &lt;span class=&#34;caption&#34;&gt;↑USB接口&lt;/span&gt;
  
&lt;/div&gt;


&lt;p&gt;机身底部是一整块金属板，需要拧开关才能更换电池和SD卡，很有过去换胶片的感觉。这个设计不知是否出于沿袭历史积淀和致敬传统的考虑。&lt;/p&gt;

&lt;p&gt;

 
  
  
  
  
    
  
    
      
    
  

&lt;div class=&#34;figure fig-33&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2018/2018-06/02/bottom-2.jpg&#34; title=&#34;↑拧动开关&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2018/2018-06/02/bottom-2.jpg&#34;  alt=&#34;↑拧动开关&#34;&gt;
  
    &lt;/a&gt;
  
   
    &lt;span class=&#34;caption&#34;&gt;↑拧动开关&lt;/span&gt;
  
&lt;/div&gt;



 
  
  
  
  
    
  
    
      
    
  

&lt;div class=&#34;figure fig-33&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2018/2018-06/02/bottom-3.jpg&#34; title=&#34;↑打开底部金属板&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2018/2018-06/02/bottom-3.jpg&#34;  alt=&#34;↑打开底部金属板&#34;&gt;
  
    &lt;/a&gt;
  
   
    &lt;span class=&#34;caption&#34;&gt;↑打开底部金属板&lt;/span&gt;
  
&lt;/div&gt;



 
  
  
  
  
    
  
    
      
    
  

&lt;div class=&#34;figure fig-33&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2018/2018-06/02/bottom-4.jpg&#34; title=&#34;↑取出电池&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2018/2018-06/02/bottom-4.jpg&#34;  alt=&#34;↑取出电池&#34;&gt;
  
    &lt;/a&gt;
  
   
    &lt;span class=&#34;caption&#34;&gt;↑取出电池&lt;/span&gt;
  
&lt;/div&gt;
&lt;/p&gt;

&lt;h2 id=&#34;镜头&#34;&gt;镜头&lt;/h2&gt;



 
  
  
  
  
    
  
    
      
    
  

&lt;div class=&#34;figure fig-100&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2018/2018-06/02/open-box-15.jpg&#34; title=&#34;↑入得是多层镀膜版本&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2018/2018-06/02/open-box-15.jpg&#34;  alt=&#34;↑入得是多层镀膜版本&#34;&gt;
  
    &lt;/a&gt;
  
   
    &lt;span class=&#34;caption&#34;&gt;↑入得是多层镀膜版本&lt;/span&gt;
  
&lt;/div&gt;


&lt;p&gt;本来准备一步到位11663，不过感觉体(qian)积(bao)偏(tai)大(xiao)，就开始纠结Summicron。最后决定先搞个实惠的福伦达VM 35 F/1.4练练手再说(翻译下：其实就是穷)。&lt;/p&gt;

&lt;p&gt;

 
  
  
  
  
    
  
    
      
    
  

&lt;div class=&#34;figure fig-33&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2018/2018-06/02/open-box-10.jpg&#34; title=&#34;↑VM 35mm F/1.4&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2018/2018-06/02/open-box-10.jpg&#34;  alt=&#34;↑VM 35mm F/1.4&#34;&gt;
  
    &lt;/a&gt;
  
   
    &lt;span class=&#34;caption&#34;&gt;↑VM 35mm F/1.4&lt;/span&gt;
  
&lt;/div&gt;



 
  
  
  
  
    
  
    
      
    
  

&lt;div class=&#34;figure fig-33&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2018/2018-06/02/open-box-13.jpg&#34; title=&#34;↑没加遮光罩&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2018/2018-06/02/open-box-13.jpg&#34;  alt=&#34;↑没加遮光罩&#34;&gt;
  
    &lt;/a&gt;
  
   
    &lt;span class=&#34;caption&#34;&gt;↑没加遮光罩&lt;/span&gt;
  
&lt;/div&gt;



 
  
  
  
  
    
  
    
      
    
  

&lt;div class=&#34;figure fig-33&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2018/2018-06/02/open-box-14.jpg&#34; title=&#34;↑装上遮光罩&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2018/2018-06/02/open-box-14.jpg&#34;  alt=&#34;↑装上遮光罩&#34;&gt;
  
    &lt;/a&gt;
  
   
    &lt;span class=&#34;caption&#34;&gt;↑装上遮光罩&lt;/span&gt;
  
&lt;/div&gt;
&lt;/p&gt;



 
  
  
  
  
    
  
    
      
    
  

&lt;div class=&#34;figure fig-100&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2018/2018-06/02/aperture-ring-1.jpg&#34; title=&#34;↑10片光圈叶片&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2018/2018-06/02/aperture-ring-1.jpg&#34;  alt=&#34;↑10片光圈叶片&#34;&gt;
  
    &lt;/a&gt;
  
   
    &lt;span class=&#34;caption&#34;&gt;↑10片光圈叶片&lt;/span&gt;
  
&lt;/div&gt;


&lt;h2 id=&#34;机身对比&#34;&gt;机身对比&lt;/h2&gt;

&lt;p&gt;这是目前我手上唯一一台全画幅数码相机。让我们来对比下它跟APS-C画幅相机的大小。&lt;/p&gt;

&lt;h3 id=&#34;对比单反宾得kp&#34;&gt;对比单反宾得KP&lt;/h3&gt;

&lt;p&gt;首先跟小巧的宾得残幅单反KP装上同样小巧的饼干头DA15 F/4做个对比。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;没加遮光罩的时候&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;

 
  
  
  
  
    
  
    
      
    
  

&lt;div class=&#34;figure fig-33&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2018/2018-06/02/m9-kp-da15-compare-1.jpg&#34; title=&#34;↑俯视&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2018/2018-06/02/m9-kp-da15-compare-1.jpg&#34;  alt=&#34;↑俯视&#34;&gt;
  
    &lt;/a&gt;
  
   
    &lt;span class=&#34;caption&#34;&gt;↑俯视&lt;/span&gt;
  
&lt;/div&gt;



 
  
  
  
  
    
  
    
      
    
  

&lt;div class=&#34;figure fig-33&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2018/2018-06/02/m9-kp-da15-compare-2.jpg&#34; title=&#34;↑侧面&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2018/2018-06/02/m9-kp-da15-compare-2.jpg&#34;  alt=&#34;↑侧面&#34;&gt;
  
    &lt;/a&gt;
  
   
    &lt;span class=&#34;caption&#34;&gt;↑侧面&lt;/span&gt;
  
&lt;/div&gt;



 
  
  
  
  
    
  
    
      
    
  

&lt;div class=&#34;figure fig-33&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2018/2018-06/02/m9-kp-da15-compare-3.jpg&#34; title=&#34;↑正面&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2018/2018-06/02/m9-kp-da15-compare-3.jpg&#34;  alt=&#34;↑正面&#34;&gt;
  
    &lt;/a&gt;
  
   
    &lt;span class=&#34;caption&#34;&gt;↑正面&lt;/span&gt;
  
&lt;/div&gt;
&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;加了遮光罩的时候&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;

 
  
  
  
  
    
  
    
      
    
  

&lt;div class=&#34;figure fig-33&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2018/2018-06/02/m9-kp-da15-compare-5.jpg&#34; title=&#34;↑俯视&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2018/2018-06/02/m9-kp-da15-compare-5.jpg&#34;  alt=&#34;↑俯视&#34;&gt;
  
    &lt;/a&gt;
  
   
    &lt;span class=&#34;caption&#34;&gt;↑俯视&lt;/span&gt;
  
&lt;/div&gt;



 
  
  
  
  
    
  
    
      
    
  

&lt;div class=&#34;figure fig-33&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2018/2018-06/02/m9-kp-da15-compare-6.jpg&#34; title=&#34;↑侧面&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2018/2018-06/02/m9-kp-da15-compare-6.jpg&#34;  alt=&#34;↑侧面&#34;&gt;
  
    &lt;/a&gt;
  
   
    &lt;span class=&#34;caption&#34;&gt;↑侧面&lt;/span&gt;
  
&lt;/div&gt;



 
  
  
  
  
    
  
    
      
    
  

&lt;div class=&#34;figure fig-33&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2018/2018-06/02/m9-kp-da15-compare-4.jpg&#34; title=&#34;↑正面&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2018/2018-06/02/m9-kp-da15-compare-4.jpg&#34;  alt=&#34;↑正面&#34;&gt;
  
    &lt;/a&gt;
  
   
    &lt;span class=&#34;caption&#34;&gt;↑正面&lt;/span&gt;
  
&lt;/div&gt;
&lt;/p&gt;

&lt;p&gt;宾得的饼干头已经算是很小的镜头了，搭配上以小巧著称的KP，已经达到众多无反相机的体积水平。但是对比下旁轴的徕卡，就会发现旁轴相机的镜头口径比这款残幅的单反还小：配上VM35这颗小巧的大光圈镜头后，徕卡的厚度甚至比宾得KP卡口伸出来部分还薄一些。&lt;/p&gt;

&lt;p&gt;如果搭配上同样是大光圈的单反镜头，比如宾得在产最大光圈的DA*55 F/1.4，体积区别就更大了：&lt;/p&gt;

&lt;p&gt;

 
  
  
  
  
    
  
    
      
    
  

&lt;div class=&#34;figure fig-33&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2018/2018-06/02/m9-kp-da55-compare-1.jpg&#34; title=&#34;↑俯视&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2018/2018-06/02/m9-kp-da55-compare-1.jpg&#34;  alt=&#34;↑俯视&#34;&gt;
  
    &lt;/a&gt;
  
   
    &lt;span class=&#34;caption&#34;&gt;↑俯视&lt;/span&gt;
  
&lt;/div&gt;



 
  
  
  
  
    
  
    
      
    
  

&lt;div class=&#34;figure fig-33&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2018/2018-06/02/m9-kp-da55-compare-3.jpg&#34; title=&#34;↑侧面&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2018/2018-06/02/m9-kp-da55-compare-3.jpg&#34;  alt=&#34;↑侧面&#34;&gt;
  
    &lt;/a&gt;
  
   
    &lt;span class=&#34;caption&#34;&gt;↑侧面&lt;/span&gt;
  
&lt;/div&gt;



 
  
  
  
  
    
  
    
      
    
  

&lt;div class=&#34;figure fig-33&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2018/2018-06/02/m9-kp-da55-compare-4.jpg&#34; title=&#34;↑正视&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2018/2018-06/02/m9-kp-da55-compare-4.jpg&#34;  alt=&#34;↑正视&#34;&gt;
  
    &lt;/a&gt;
  
   
    &lt;span class=&#34;caption&#34;&gt;↑正视&lt;/span&gt;
  
&lt;/div&gt;
&lt;/p&gt;

&lt;h3 id=&#34;对比卡片机grii&#34;&gt;对比卡片机GRii&lt;/h3&gt;

&lt;p&gt;和大底口袋机，比如GRii对比，还是可以看到徕卡这台全幅机会大一圈，装进口袋应该是比较困难的了。不过想来也不会有太多人想把徕卡随便往兜里揣，一般都是拿在手上或者挂在脖子/肩上的。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;GRii 镜头未伸出时&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;

 
  
  
  
  
    
  
    
      
    
  

&lt;div class=&#34;figure fig-33&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2018/2018-06/02/m9-grii-compare-0.jpg&#34; title=&#34;↑俯视&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2018/2018-06/02/m9-grii-compare-0.jpg&#34;  alt=&#34;↑俯视&#34;&gt;
  
    &lt;/a&gt;
  
   
    &lt;span class=&#34;caption&#34;&gt;↑俯视&lt;/span&gt;
  
&lt;/div&gt;



 
  
  
  
  
    
  
    
      
    
  

&lt;div class=&#34;figure fig-33&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2018/2018-06/02/m9-grii-compare-2.jpg&#34; title=&#34;↑侧面&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2018/2018-06/02/m9-grii-compare-2.jpg&#34;  alt=&#34;↑侧面&#34;&gt;
  
    &lt;/a&gt;
  
   
    &lt;span class=&#34;caption&#34;&gt;↑侧面&lt;/span&gt;
  
&lt;/div&gt;


 
  
  
  
  
    
      
    
  
    
  
    
      
    
  

 
  
  
  
  
    
  
    
      
    
  

&lt;div class=&#34;figure fig-33&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2018/2018-06/02/m9-grii-compare-1.jpg&#34; title=&#34;↑正面&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2018/2018-06/02/m9-grii-compare-1.jpg&#34;  alt=&#34;↑正面&#34;&gt;
  
    &lt;/a&gt;
  
   
    &lt;span class=&#34;caption&#34;&gt;↑正面&lt;/span&gt;
  
&lt;/div&gt;

  &lt;div style=&#34;clear:both;&#34;&gt;&lt;/div&gt;
&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;GRii 镜头伸出时&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;

 
  
  
  
  
    
  
    
      
    
  

&lt;div class=&#34;figure fig-33&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2018/2018-06/02/m9-grii-compare-3.jpg&#34; title=&#34;↑俯视&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2018/2018-06/02/m9-grii-compare-3.jpg&#34;  alt=&#34;↑俯视&#34;&gt;
  
    &lt;/a&gt;
  
   
    &lt;span class=&#34;caption&#34;&gt;↑俯视&lt;/span&gt;
  
&lt;/div&gt;



 
  
  
  
  
    
  
    
      
    
  

&lt;div class=&#34;figure fig-33&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2018/2018-06/02/m9-grii-compare-7.jpg&#34; title=&#34;↑侧面&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2018/2018-06/02/m9-grii-compare-7.jpg&#34;  alt=&#34;↑侧面&#34;&gt;
  
    &lt;/a&gt;
  
   
    &lt;span class=&#34;caption&#34;&gt;↑侧面&lt;/span&gt;
  
&lt;/div&gt;



 
  
  
  
  
    
  
    
      
    
  

&lt;div class=&#34;figure fig-33&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2018/2018-06/02/m9-grii-compare-5.jpg&#34; title=&#34;↑正视&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2018/2018-06/02/m9-grii-compare-5.jpg&#34;  alt=&#34;↑正视&#34;&gt;
  
    &lt;/a&gt;
  
   
    &lt;span class=&#34;caption&#34;&gt;↑正视&lt;/span&gt;
  
&lt;/div&gt;
&lt;/p&gt;

&lt;h1 id=&#34;直出样片&#34;&gt;直出样片&lt;/h1&gt;

&lt;p&gt;由于黄斑手动对焦这是第一次体验，估焦的手感也还没培养出来，所以造成这次旅拍很多抓拍的片子没对焦到主体上。主要看下徕卡调教的直出颜色吧。可以明显看到的是，徕卡对蓝色的渲染有独特的理解，会有明显偏色，但是却很讨好眼睛（原片见&lt;a href=&#34;https://www.flickr.com/photos/129774362@N07/&#34;&gt;Flickr&lt;/a&gt;）。&lt;/p&gt;

&lt;p&gt;

 
  
  
  
  
    
  
    
      
    
  

&lt;div class=&#34;figure fig-100&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2018/2018-06/02/sample-1.jpg&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2018/2018-06/02/sample-1.jpg&#34; &gt;
  
    &lt;/a&gt;
  
  
&lt;/div&gt;



 
  
  
  
  
    
  
    
      
    
  

&lt;div class=&#34;figure fig-100&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2018/2018-06/02/sample-2.jpg&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2018/2018-06/02/sample-2.jpg&#34; &gt;
  
    &lt;/a&gt;
  
  
&lt;/div&gt;



 
  
  
  
  
    
  
    
      
    
  

&lt;div class=&#34;figure fig-100&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2018/2018-06/02/sample-3.jpg&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2018/2018-06/02/sample-3.jpg&#34; &gt;
  
    &lt;/a&gt;
  
  
&lt;/div&gt;



 
  
  
  
  
    
  
    
      
    
  

&lt;div class=&#34;figure fig-100&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2018/2018-06/02/sample-4.jpg&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2018/2018-06/02/sample-4.jpg&#34; &gt;
  
    &lt;/a&gt;
  
  
&lt;/div&gt;



 
  
  
  
  
    
  
    
      
    
  

&lt;div class=&#34;figure fig-100&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2018/2018-06/02/sample-5.jpg&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2018/2018-06/02/sample-5.jpg&#34; &gt;
  
    &lt;/a&gt;
  
  
&lt;/div&gt;



 
  
  
  
  
    
  
    
      
    
  

&lt;div class=&#34;figure fig-100&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2018/2018-06/02/sample-6.jpg&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2018/2018-06/02/sample-6.jpg&#34; &gt;
  
    &lt;/a&gt;
  
  
&lt;/div&gt;



 
  
  
  
  
    
  
    
      
    
  

&lt;div class=&#34;figure fig-100&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2018/2018-06/02/sample-7.jpg&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2018/2018-06/02/sample-7.jpg&#34; &gt;
  
    &lt;/a&gt;
  
  
&lt;/div&gt;



 
  
  
  
  
    
  
    
      
    
  

&lt;div class=&#34;figure fig-100&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2018/2018-06/02/sample-8.jpg&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2018/2018-06/02/sample-8.jpg&#34; &gt;
  
    &lt;/a&gt;
  
  
&lt;/div&gt;



 
  
  
  
  
    
  
    
      
    
  

&lt;div class=&#34;figure fig-100&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2018/2018-06/02/sample-9.jpg&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2018/2018-06/02/sample-9.jpg&#34; &gt;
  
    &lt;/a&gt;
  
  
&lt;/div&gt;



 
  
  
  
  
    
  
    
      
    
  

&lt;div class=&#34;figure fig-100&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2018/2018-06/02/sample-10.jpg&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2018/2018-06/02/sample-10.jpg&#34; &gt;
  
    &lt;/a&gt;
  
  
&lt;/div&gt;



 
  
  
  
  
    
  
    
      
    
  

&lt;div class=&#34;figure fig-100&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2018/2018-06/02/sample-11.jpg&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2018/2018-06/02/sample-11.jpg&#34; &gt;
  
    &lt;/a&gt;
  
  
&lt;/div&gt;



 
  
  
  
  
    
  
    
      
    
  

&lt;div class=&#34;figure fig-100&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2018/2018-06/02/sample-12.jpg&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2018/2018-06/02/sample-12.jpg&#34; &gt;
  
    &lt;/a&gt;
  
  
&lt;/div&gt;



 
  
  
  
  
    
  
    
      
    
  

&lt;div class=&#34;figure fig-100&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2018/2018-06/02/sample-13.jpg&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2018/2018-06/02/sample-13.jpg&#34; &gt;
  
    &lt;/a&gt;
  
  
&lt;/div&gt;



 
  
  
  
  
    
  
    
      
    
  

&lt;div class=&#34;figure fig-100&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2018/2018-06/02/sample-14.jpg&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2018/2018-06/02/sample-14.jpg&#34; &gt;
  
    &lt;/a&gt;
  
  
&lt;/div&gt;
&lt;/p&gt;

&lt;h1 id=&#34;初步使用感受&#34;&gt;初步使用感受&lt;/h1&gt;

&lt;p&gt;旁轴相机特殊的取景方式限制了其在长焦端的表现。由于没有自动对焦，很多需要连拍的场合都不再适用。如果是以摄影为职业，靠相机吃饭的话，那么徕卡确实会引入很多限制。但是在人文摄影这个领域，或者对像我这种偏爱慢拍，每次快门只爱按一次的用户来说，徕卡的优点则相当突出，以至于完全可以忽略其弱势领域。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;优点&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;小巧。不仅是机身，还有配套的旁轴镜头。一机两定焦的组合即使每天随身携带也很轻松，带着走一天也不累。&lt;/li&gt;
&lt;li&gt;画质。这块CCD的传感器在低感的时候画质非常扎实，跟CMOS的区别还是可以看出来的。高感时候的黑白片则有胶片的感觉。&lt;/li&gt;
&lt;li&gt;做工。德国手工打造，手感确实对得起价格。&lt;/li&gt;
&lt;li&gt;造型设计简约经典，不拍照的时候当道具也很合适。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;缺点&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;旧型传感器设计问题导致时间久了会有表面腐蚀&lt;/li&gt;
&lt;li&gt;菜单响应和图片写入读出都很慢，部分SD卡会出现无法读取的现象（落后的电子技术）&lt;/li&gt;
&lt;li&gt;间歇性死机。刚拿到手上的时候没摸清M9的脾气，经常死机，只能不停扣电池重启。现在摸熟了，很少再有死机的情况出现&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;关于CCD传感器表层腐蚀，徕卡曾经推出过免费更换计划。不过这个计划2017年底就结束了。我前几天问了客服，说现在想要更换最新的传感器只能自费，美国这边需要寄到徕卡New Jersey的官方维修点，费用$960。我这台的前任机主在2014年做过一次官方维护，但是没换CCD，装的仍然是旧传感器。小光圈时可以很明显的看到图像右上方会出现三个腐蚀点，如下图所示。&lt;/p&gt;



 
  
  
  
  
    
  
    
      
    
  

&lt;div class=&#34;figure fig-100&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2018/2018-06/02/corrosion.jpg&#34; title=&#34;↑分布在各处的腐蚀点，正常街拍的时候其实并不明显&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2018/2018-06/02/corrosion.jpg&#34;  alt=&#34;↑分布在各处的腐蚀点，正常街拍的时候其实并不明显&#34;&gt;
  
    &lt;/a&gt;
  
   
    &lt;span class=&#34;caption&#34;&gt;↑分布在各处的腐蚀点，正常街拍的时候其实并不明显&lt;/span&gt;
  
&lt;/div&gt;


&lt;p&gt;其实拍摄人文为主的照片这些黑点并不会造成太多影响，再加上后期很容易可以处理坏点，所以我应该暂时不会自费更换新的传感器（lazy evaluation&amp;hellip;算是职业习惯了），优先体验镜头吧(翻译下：其实就是穷)。&lt;/p&gt;

&lt;h1 id=&#34;附言-后续感受&#34;&gt;附言：后续感受&lt;/h1&gt;

&lt;h3 id=&#34;1-ccd-vs-cmos&#34;&gt;1. CCD vs CMOS&lt;/h3&gt;

&lt;p&gt;其实说到底，等到2018年才买M9，还是因为觉得M240/M10价格虚高。与之相比，M9就亲民了很多，成了我尝鲜的首选。当然最有争议的还是那块CCD——成像很有特色值得玩味，却有短寿的风险，是问题的祸源。本着用坏前能拍一张是一张的心态，我只能趁换传感器之前多拍点片子物尽其用了吧，苦笑。&lt;/p&gt;

&lt;p&gt;简单总结的话，如果没有特殊的CCD情节，而又有那个预算，直接上M10其实是更实在而保险的策略。喜欢玩“刺激”点，或者预算没那么高，那M9也不会让人失望，还是挺好玩的。&lt;/p&gt;

&lt;h3 id=&#34;2-leica-or-sony&#34;&gt;2. Leica or Sony&lt;/h3&gt;

&lt;p&gt;徕卡最值得称道的其实是其庞大而各具特色的旁轴镜头群，为了用上这些镜头，将其转接在索尼机身上是个很聪明的玩法——毕竟就机身性能来说，索尼有太多优势。我手上没有索尼的机身，不好作过多评价，不过大法无疑是个很好的选择。选什么相机当然还是看自己的拍摄题材和风格，就我来说主要是街拍和旅游的时候用，基本不拍体育类和有追焦需求的题材，所以对机身和对焦性能要求不高（宾得和GR这俩也是对焦捉鸡的货）。上面样片发的黑白照片都是估焦盲拍的，放在腰线附近凭感觉转动对焦环按下快门，连RF也没用到。这种拍法下，如果让我为最先进的对焦系统溢价买单，我其实反而会有所顾虑。不过A7系列我也一直很有兴趣入，毕竟可以共享镜头，还是考虑过段时间收个来玩玩，再做进一步对比吧。按老话来说，唯有都买，方可解毒。&lt;/p&gt;

&lt;p&gt;对于徕卡，总的来说，我算是个中性用户，对其更多的是好奇，买个最便宜的M9过来实际上手体验下才好说哪点好哪点不好。最近这也只是初步体验了下。对比索尼，如果让我说徕卡机身的最大优势，目前只能想到一点，大概就是简单省心吧：功能精简到只能拍照不能视频，菜单直观易上手，直出讨喜省后期，机身做工极佳造型简约让人忍不住想拿来抚摸。对创作者来说， 这称得上是个趁手的工具。有时候趁手很重要，因为拍摄时候的心情直接影响了成像的风格。之前简单摸过索尼的机身，菜单逻辑很不省心，真用起来还得好好适应下。&lt;/p&gt;

&lt;p&gt;(话又说回来，按理说功能少了，价钱应该更低才对。然而到了徕卡这边，价格不降反升，我觉得一方面是做工好产量低，另一个很重要方面是情怀加成。又或者，大概徕卡很好的掌握了消费者心理，让买了徕卡的人心想，自己都花更多的钱了，相机需要很好才对得起自己花钱的决定，所以也更容易让用户心甘情愿自我麻醉，在一买一卖之间形成了类似SM的关系，也就让徕卡溢价能力大增，定价居然年年见涨。这种环境下，买徕卡，就当是买理财产品了吧，附赠拍照功能。）&lt;/p&gt;

&lt;p&gt;总的来说，M9很有特色很好玩，不过又是传感器缺陷又是电子系统老旧，值不值现在这个价？还是看每个人对于那份独有特色的玩味定价几何。毕竟物以稀为贵，别家确实玩不到。&lt;/p&gt;

&lt;p&gt;顺便，既然说到徕卡镜头了，最近查了些资料，选择了先入Summicron 35 asph(一代 11 879)。如果使用后感觉不错，也争取再写一篇心得体会吧。&lt;/p&gt;



 
  
  
  
  
    
  
    
      
    
  

&lt;div class=&#34;figure fig-100&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2018/2018-06/02/summicron35.jpg&#34; title=&#34;↑11879&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2018/2018-06/02/summicron35.jpg&#34;  alt=&#34;↑11879&#34;&gt;
  
    &lt;/a&gt;
  
   
    &lt;span class=&#34;caption&#34;&gt;↑11879&lt;/span&gt;
  
&lt;/div&gt;</description>
    </item>
    
    <item>
      <title>一个油腻中年大叔在儿童节的胡思乱想</title>
      <link>http://nianze.tk/2018/06/a-simple-calculation/</link>
      <pubDate>Fri, 01 Jun 2018 00:00:00 +0000</pubDate>
      
      <guid>http://nianze.tk/2018/06/a-simple-calculation/</guid>
      <description>&lt;p&gt;张爱玲说，出名要趁早。
&lt;/p&gt;

&lt;p&gt;我总是料想，那些没有荒碌一生的人，大概在自己的16岁乃至更早的青春时代，就已经养成了基本人格，看透了很多人世运行的规律，形成了对待外界的基本处世方针，并萌生了串起自己一生行动的原始信念。所以，在二十之前就确定了事业的中心，在二十出头就崭露头角，三十而立，凭借身体，智力和心态相互平衡，逐渐来到成熟的巅峰，在自己的领域内走到时代的前沿，作出自己的贡献，为时人所知；运气好点，还能做出开创性的工作，为后人所知。&lt;/p&gt;

&lt;p&gt;于是照这么回顾自己长达四分之一个世纪的乏善可陈的庸碌人生，看到了一个资质平凡者，沿着升学、考试、实习、找工作这么一条社会环境中的稳定成长路线，规矩而短视的走着，如果遇到分叉，就以一套符合当时认知的简化了很多变量的模型预测最多两年后的人生轨迹，得到各分支的评估分数，其值大概由70%世俗定义的成功和30%个人定义的乐趣匹配度组成，然后沿着这个naive的路径规划算法，跌跌撞撞的被各种机缘和时代洪流裹挟着，滚到了现在的坐标，靠每周五天每天八小时写码搬砖的脑力劳动，挣一口饭钱不至饿死。所以目前最大的成就，就是费了25年，在父母、老师、朋友、各类机缘巧合的帮助和支持下，挣扎着总算在社会上找到一个脆弱的平衡点，凭自己劳动付出的那点微不足道的苦力，来抵消自己生活的各类消耗，苟活于一时。&lt;/p&gt;

&lt;p&gt;照这么继续看下去，按75岁的预期寿命来算(目前中国男性平均寿命是74岁，这里加一岁凑整倍数)，那么我还剩两个25年的时间资产。考虑到50岁后的身体素质和思维活跃程度都会缩水，最后那25年的资产有效转化率可能还得打个6折。这样算下来，实际可支配的时间资产只剩40年，再扣除吃饭睡觉之类杂七杂八的事情，那份“没几天可活了”的紧迫感又袭上心头。我其实在浑浑噩噩中早已过了“趁早”的时候了。&lt;/p&gt;

&lt;p&gt;但又会瞎琢磨，所谓“出名要趁早”，大概是建立在动态看待心智成长的构想上：15岁看懂微积分，和25岁理解它，这之间的差距不只是线性时间上的十年，还有十年间伴随年龄窗口而来的各种机会对人心智和视野的冲击，导致最后可能呈现出指数级的差别。如果原理果真是这样的，对我这种业已荒废25年人生的平庸者来说，也许倒还有一丝希望：如果能保持10年前的年轻心态，把现在的自己当做是10年前的自己穿越时空而来，以少活十年为代价，凭空获得过去10年积攒下来的人生阅历和经验，便站在了一个提前迈入社会自力更生的15岁短寿少年的视角看待世界。有点英年早逝的意味。&lt;/p&gt;

&lt;p&gt;自然，就想起了《Whiplash》里的经典对话：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;-I&amp;rsquo;d rather die drunk, broke at 34 and have people at a dinner table talk about me than live to be rich and sober at 90 and nobody remembered who I was.&lt;br /&gt;
-Ah, but your friends will remember you, that&amp;rsquo;s the point.&lt;br /&gt;
-None of us were friends with Charlie Parker. That&amp;rsquo;s the point.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;需要指出的是，人生的抉择并不是这么一道：die greatly or live peacefully的简单二选一：残酷的现实告诉我们，无数心怀勇气的理想主义者选择了die with greatness，最后的结局只是die with nothing，一无所有。我相信，历史中有太多的Charlie Parker，纵使才华横溢依然湮灭于时间的洪流，穷愁潦倒的度过短暂却并不耀眼的一生，在生命之火即将熄灭之际，回顾往昔，只安慰自己道，&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;天空没有留下鸟的痕迹，但我已飞过.&lt;/p&gt;
&lt;/blockquote&gt;</description>
    </item>
    
    <item>
      <title>A simple archive for music generation</title>
      <link>http://nianze.tk/2018/05/music-generation-archive/</link>
      <pubDate>Thu, 31 May 2018 16:07:41 -0400</pubDate>
      
      <guid>http://nianze.tk/2018/05/music-generation-archive/</guid>
      <description>&lt;p&gt;A random collection of recent works on music generation.

&lt;!-- toc --&gt;&lt;/p&gt;

&lt;h1 id=&#34;papers&#34;&gt;Papers&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Melody Generation for Pop Music via Word Representation of Musical Properties&lt;/strong&gt; (2017.10) [&lt;a href=&#34;https://arxiv.org/abs/1710.11549&#34;&gt;arXiv&lt;/a&gt;] [&lt;a href=&#34;https://github.com/mil-tokyo/NeuralMelody&#34;&gt;Code&lt;/a&gt;]&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Generating Nontrivial Melodies for Music as a Service&lt;/strong&gt; (2017.10) [&lt;a href=&#34;https://arxiv.org/abs/1710.02280&#34;&gt;arXiv&lt;/a&gt;] [&lt;a href=&#34;https://composing.ai&#34;&gt;Page&lt;/a&gt;]&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;MuseGAN: Symbolic-domain Music Generation and Accompaniment with Multi-track Sequential Generative Adversarial Networks&lt;/strong&gt; (2017.9) [&lt;a href=&#34;https://arxiv.org/abs/1709.06298&#34;&gt;arXiv&lt;/a&gt;] [&lt;a href=&#34;https://salu133445.github.io/musegan/&#34;&gt;Page&lt;/a&gt;]&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Similarity Embedding Network for Unsupervised Sequential Pattern Learning by Playing Music Puzzle Games&lt;/strong&gt; （2017.9）[&lt;a href=&#34;https://arxiv.org/abs/1709.04384&#34;&gt;arXiv&lt;/a&gt;] [&lt;a href=&#34;https://remyhuang.github.io/DJnet&#34;&gt;Page&lt;/a&gt;]&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;A Tutorial on Deep Learning for Music Information Retrieval&lt;/strong&gt; (2017.9) [&lt;a href=&#34;https://arxiv.org/abs/1709.04396&#34;&gt;arXiv&lt;/a&gt;]&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Deep Learning Techniques for Music Generation - A Survey&lt;/strong&gt; (2017.9) &lt;a href=&#34;论文综述&#34;&gt;&lt;a href=&#34;https://arxiv.org/abs/1709.01620&#34;&gt;arXiv&lt;/a&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Neural Translation of Musical Style&lt;/strong&gt; (2017.8) [&lt;a href=&#34;https://arxiv.org/abs/1708.03535&#34;&gt;arXiv&lt;/a&gt;] [&lt;a href=&#34;http://imanmalik.com/cs/2017/06/05/neural-style.html&#34;&gt;Page&lt;/a&gt;]&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;GLSR-VAE: Geodesic Latent Space Regularization for Variational AutoEncoder Architectures&lt;/strong&gt; (2017.7) [&lt;a href=&#34;https://arxiv.org/abs/1707.04588&#34;&gt;arXiv&lt;/a&gt;]&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Learning and Evaluating Musical Features with Deep Autoencoders&lt;/strong&gt; (2017.6) [&lt;a href=&#34;https://arxiv.org/abs/1706.04486&#34;&gt;arXiv&lt;/a&gt;]&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Objective-Reinforced Generative Adversarial Networks (ORGAN) for Sequence Generation Models&lt;/strong&gt; (2017.5) [&lt;a href=&#34;https://arxiv.org/abs/1705.10843&#34;&gt;arXiv&lt;/a&gt;] [&lt;a href=&#34;https://github.com/gablg1/ORGAN&#34;&gt;Code&lt;/a&gt;]&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;MidiNet: A Convolutional Generative Adversarial Network for Symbolic-domain Music Generation using 1D and 2D Conditions&lt;/strong&gt; - &lt;strong&gt;ISMIR 2017&lt;/strong&gt; (2017.3) [&lt;a href=&#34;https://arxiv.org/abs/1703.10847&#34;&gt;arXiv&lt;/a&gt;] [&lt;a href=&#34;https://richardyang40148.github.io/TheBlog/midinet_arxiv_demo.html&#34;&gt;Page&lt;/a&gt;]&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Automatic Conversion of Pop Music into Chiptunes for 8-bit Pixel Art&lt;/strong&gt; - &lt;strong&gt;ICASSP 2017&lt;/strong&gt; (2017.2) [&lt;a href=&#34;http://mac.citi.sinica.edu.tw/~yang/pub/su17icassp_8bit.pdf&#34;&gt;Paper&lt;/a&gt;] [&lt;a href=&#34;https://github.com/LemonATsu/pop-to-8bit&#34;&gt;Code&lt;/a&gt;] [&lt;a href=&#34;https://lemonatsu.github.io&#34;&gt;Page&lt;/a&gt;]&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;DeepBach: a Steerable Model for Bach Chorales Generation&lt;/strong&gt; (2016.12) [&lt;a href=&#34;https://arxiv.org/abs/1612.01010&#34;&gt;arXiv&lt;/a&gt;] [&lt;a href=&#34;https://github.com/Ghadjeres/DeepBach&#34;&gt;Code&lt;/a&gt;]&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;C-RNN-GAN: Continuous Recurrent Neural Networks with Adversarial Training&lt;/strong&gt; (2016.11) [&lt;a href=&#34;https://arxiv.org/abs/1611.09904&#34;&gt;arXiv&lt;/a&gt;] [&lt;a href=&#34;https://github.com/olofmogren/c-rnn-gan&#34;&gt;Code&lt;/a&gt;] 🌟&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Tuning Recurrent Neural Networks with Reinforcement Learning - ICLR 2017&lt;/strong&gt; (2016.11) [&lt;a href=&#34;https://arxiv.org/abs/1611.02796&#34;&gt;arXiv&lt;/a&gt;] [&lt;a href=&#34;https://magenta.tensorflow.org/2016/11/09/tuning-recurrent-networks-with-reinforcement-learning&#34;&gt;Web&lt;/a&gt;] [&lt;a href=&#34;https://github.com/tensorflow/magenta/tree/master/magenta/models/rl_tuner&#34;&gt;Code&lt;/a&gt;] 🌟&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;SeqGAN: Sequence Generative Adversarial Nets with Policy Gradient&lt;/strong&gt; - &lt;strong&gt;AAAI 2017&lt;/strong&gt; (2016.9) [&lt;a href=&#34;http://www.aaai.org/ocs/index.php/AAAI/AAAI17/paper/download/14344/14489&#34;&gt;Paper&lt;/a&gt;] [&lt;a href=&#34;https://github.com/LantaoYu/SeqGAN&#34;&gt;Code&lt;/a&gt;]&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Song From PI: A Musically Plausible Network for Pop Music Generation&lt;/strong&gt; - &lt;strong&gt;ICLR 2017&lt;/strong&gt; [&lt;a href=&#34;https://arxiv.org/abs/1611.03477&#34;&gt;arXiv&lt;/a&gt;] [&lt;a href=&#34;http://www.theregister.co.uk/2016/11/11/ai_pop_music_maker/&#34;&gt;Reports&lt;/a&gt;]🌟&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Text-based LSTM networks for Automatic Music Composition&lt;/strong&gt; (2016.4) [&lt;a href=&#34;https://arxiv.org/abs/1604.05358#&#34;&gt;arXiv&lt;/a&gt;] [&lt;a href=&#34;https://keunwoochoi.wordpress.com/2016/02/23/lstmetallica/&#34;&gt;Web&lt;/a&gt;] [&lt;a href=&#34;https://github.com/keunwoochoi/LSTMetallica&#34;&gt;Code&lt;/a&gt;]&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Music Transcription Modelling and Composition Using Deep Learning&lt;/strong&gt; (2016.4) [&lt;a href=&#34;https://arxiv.org/abs/1604.08723&#34;&gt;arXiv&lt;/a&gt;] [&lt;a href=&#34;https://github.com/IraKorshunova/folk-rnn&#34;&gt;Code&lt;/a&gt;]&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Composing A Melody with Long-short Term Memory (LSTM) Recurrent Neural Networks&lt;/strong&gt; (2016.2) [&lt;a href=&#34;http://konstilackner.github.io/LSTM-RNN-Melody-Composer-Website/&#34;&gt;Web&lt;/a&gt;] [&lt;a href=&#34;https://github.com/konstilackner/LSTM-RNN-Melody-Composer&#34;&gt;Code&lt;/a&gt;] [&lt;a href=&#34;http://konstilackner.github.io/LSTM-RNN-Melody-Composer-Website/Thesis_final01.pdf&#34;&gt;Paper&lt;/a&gt;]&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Neural Adaptive Sequential Monte Carlo - NIPS 2015&lt;/strong&gt; (2015) [&lt;a href=&#34;http://papers.nips.cc/paper/5961-neural-adaptive-sequential-monte-carlo.pdf&#34;&gt;Paper&lt;/a&gt;]&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;A Recurrent Latent Variable Model for Sequential Data - NIPS 2015&lt;/strong&gt; (2015) [&lt;a href=&#34;http://papers.nips.cc/paper/5653-a-recurrent-latent-variable-model-for-sequential-data.pdf&#34;&gt;Paper&lt;/a&gt;] [&lt;a href=&#34;https://github.com/jych/nips2015_vrnn&#34;&gt;Code&lt;/a&gt;]&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;AI Methods in Algorithmic Composition: A Comprehensive Survey&lt;/strong&gt; (2013) [&lt;a href=&#34;http://www.jair.org/media/3908/live-3908-7454-jair.pdf&#34;&gt;Paper&lt;/a&gt;] 🌟&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Modeling Temporal Dependencies in High-dimensional Sequences: Application to Polyphonic Music Generation and Transcription&lt;/strong&gt; (2012) [&lt;a href=&#34;https://arxiv.org/abs/1206.6392&#34;&gt;arXiv&lt;/a&gt;]&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Towards Adaptive Music Generation By Reinforcement Learning of Musical Tension&lt;/strong&gt; (2010) [&lt;a href=&#34;https://ccrma.stanford.edu/~slegroux/affect/pubs/SMC2010.pdf&#34;&gt;Paper&lt;/a&gt;]&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;A First Look at Music Composition using LSTM Recurrent Neural Networks&lt;/strong&gt; (2002) [&lt;a href=&#34;http://www.iro.umontreal.ca/~eckdoug/blues/index.html&#34;&gt;Web&lt;/a&gt;] [&lt;a href=&#34;http://www.iro.umontreal.ca/~eckdoug/blues/IDSIA-07-02.pdf&#34;&gt;Paper&lt;/a&gt;]&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;projects&#34;&gt;Projects&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Google Magenta&lt;/strong&gt; [&lt;a href=&#34;https://magenta.tensorflow.org/welcome-to-magenta&#34;&gt;Web&lt;/a&gt;] [&lt;a href=&#34;https://github.com/tensorflow/magenta&#34;&gt;Code&lt;/a&gt;]&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Deep Jazz&lt;/strong&gt;  [&lt;a href=&#34;https://deepjazz.io/&#34;&gt;Web&lt;/a&gt;] [&lt;a href=&#34;https://deepjazz.io/&#34;&gt;Code&lt;/a&gt;]&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;BachBot&lt;/strong&gt; [&lt;a href=&#34;http://bachbot.com/&#34;&gt;Web&lt;/a&gt;] [&lt;a href=&#34;https://github.com/feynmanliang/bachbot/&#34;&gt;Code&lt;/a&gt;]&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;WaveNet&lt;/strong&gt; [&lt;a href=&#34;https://deepmind.com/blog/wavenet-generative-model-raw-audio/&#34;&gt;Web&lt;/a&gt;]&lt;a href=&#34;not fully&#34;&gt;&lt;a href=&#34;https://github.com/ibab/tensorflow-wavenet&#34;&gt;Code&lt;/a&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;GRUV&lt;/strong&gt; [&lt;a href=&#34;https://github.com/MattVitelli/GRUV&#34;&gt;Code&lt;/a&gt;]&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Kulitta&lt;/strong&gt; [&lt;a href=&#34;https://github.com/donya/Kulitta&#34;&gt;Code&lt;/a&gt;]&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;applications&#34;&gt;Applications&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;AIVA&lt;/strong&gt;[&lt;a href=&#34;http://aiva.ai&#34;&gt;Link&lt;/a&gt;]&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Google A.I. Duet&lt;/strong&gt; [&lt;a href=&#34;https://aiexperiments.withgoogle.com/ai-duet&#34;&gt;Link&lt;/a&gt;]&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;The Infinite Drum Machine&lt;/strong&gt; [&lt;a href=&#34;https://aiexperiments.withgoogle.com/drum-machine&#34;&gt;Link&lt;/a&gt;]&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Amper Music&lt;/strong&gt; [&lt;a href=&#34;https://www.ampermusic.com/app#/&#34;&gt;Link&lt;/a&gt;]&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Intelligent Music System&lt;/strong&gt; [&lt;a href=&#34;http://120.52.72.53/www.intelligentmusicsystems.com/c3pr90ntc0td/vid/tempo_shifting.mp4&#34;&gt;Link&lt;/a&gt;]&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Unwind&lt;/strong&gt; [&lt;a href=&#34;http://unwind.ai&#34;&gt;Link&lt;/a&gt;]&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Tidalcycles&lt;/strong&gt; [&lt;a href=&#34;https://tidalcycles.org&#34;&gt;Link&lt;/a&gt;] [&lt;a href=&#34;https://www.youtube.com/watch?v=xoa3OT8ncX0&#34;&gt;Video&lt;/a&gt;]&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Jukedeck&lt;/strong&gt; [&lt;a href=&#34;https://www.jukedeck.com/&#34;&gt;Link&lt;/a&gt;]&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;conferences-workshops&#34;&gt;Conferences&amp;amp;Workshops&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;ACM MM&lt;/strong&gt; - ACM MultiMedia [&lt;a href=&#34;http://www.acmmm.org/2017&#34;&gt;Web&lt;/a&gt;]&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;ISMIR&lt;/strong&gt; - The International Society of Music Information Retrieval [&lt;a href=&#34;http://www.ismir.net/&#34;&gt;Web&lt;/a&gt;]&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;ICASSP&lt;/strong&gt; - Conference on Acoustics, Speech and Signal Processing [&lt;a href=&#34;http://www.ieee-icassp2017.org/&#34;&gt;Web&lt;/a&gt;]&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;DLM&lt;/strong&gt; - Deep Learning for Music Workshop [&lt;a href=&#34;http://dorienherremans.com/dlm2017/&#34;&gt;Web&lt;/a&gt;]&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;CSMC&lt;/strong&gt; - Conference on Computer Simulation of Musical  Creativity [&lt;a href=&#34;https://csmc2016.wordpress.com/&#34;&gt;Web&lt;/a&gt;]&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;CCRMA&lt;/strong&gt; - Center for Computer Research in Music and Acoustics (Stanford University) [&lt;a href=&#34;https://ccrma.stanford.edu/&#34;&gt;Web&lt;/a&gt;]&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;ICMC&lt;/strong&gt; - Internatonal Computer Music Conference [&lt;a href=&#34;http://www.icmc2017.com/&#34;&gt;Web&lt;/a&gt;] [&lt;a href=&#34;http://www.icmc2017.com/cn/page1.html&#34;&gt;Lists&lt;/a&gt;]&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;blogs&#34;&gt;Blogs&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Neural Nets for Generating Music&lt;/strong&gt; [&lt;a href=&#34;https://medium.com/@kcimc/neural-nets-for-generating-music-f46dffac21c0&#34;&gt;Web&lt;/a&gt;]&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Generative Music with JavaScript &amp;amp; Web Audio&lt;/strong&gt; [&lt;a href=&#34;https://teropa.info/generative-music-slides/&#34;&gt;Web&lt;/a&gt;]&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;The Current State Of AI: Artificial Intelligence In Music, Movies &amp;amp; More&lt;/strong&gt; (2017.7) [&lt;a href=&#34;http://www.hypebot.com/hypebot/2017/07/ai-today-the-current-state-of-artificial-intelligence.html&#34;&gt;Web&lt;/a&gt;]&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Composing Music With Recurrent Neural Networks&lt;/strong&gt; (2015.8) [&lt;a href=&#34;http://www.hexahedria.com/2015/08/03/composing-music-with-recurrent-neural-networks/&#34;&gt;Web&lt;/a&gt;] [&lt;a href=&#34;https://github.com/hexahedria/biaxial-rnn-music-composition&#34;&gt;Code&lt;/a&gt;]&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Analyzing deep learning tools for music generation&lt;/strong&gt; [&lt;a href=&#34;http://www.asimovinstitute.org/analyzing-deep-learning-tools-music/&#34;&gt;Web&lt;/a&gt;]&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;COORD&lt;/strong&gt; [&lt;a href=&#34;http://www.coord.fm/home/&#34;&gt;Web&lt;/a&gt;]&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;How evolved LSTMS improvise on a melogy you specify&lt;/strong&gt;[&lt;a href=&#34;https://www.sentient.ai/sentient-labs/ea/lstm-music/&#34;&gt;Web&lt;/a&gt;]&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;AI makes pop music in the style of any composer&lt;/strong&gt;[&lt;a href=&#34;http://www.flow-machines.com/ai-makes-pop-music/&#34;&gt;Web&lt;/a&gt;]&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Richard Yang&amp;rsquo;s Blog&lt;/strong&gt;[&lt;a href=&#34;https://richardyang40148.github.io/TheBlog/index.html&#34;&gt;Blog&lt;/a&gt;]&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Thousands of bird sounds visualized using machine learning&lt;/strong&gt;[&lt;a href=&#34;https://experiments.withgoogle.com/bird-sounds&#34;&gt;Web&lt;/a&gt;]&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Music AI: Loop-in-the-Human&lt;/strong&gt;[&lt;a href=&#34;https://medium.com/@jayhardesty/music-ai-loop-in-the-human-1a15681e573e&#34;&gt;Web&lt;/a&gt;]&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>[MECpp]Item-34 Understand How to Combine C&#43;&#43; and C in the Same Program</title>
      <link>http://nianze.tk/2018/05/understand-how-to-combine-c---and-c-in-the-same-program/</link>
      <pubDate>Wed, 23 May 2018 18:38:10 -0400</pubDate>
      
      <guid>http://nianze.tk/2018/05/understand-how-to-combine-c---and-c-in-the-same-program/</guid>
      <description>&lt;p&gt;There are five points worth noting if we want to mix C++ and C in the same program.

&lt;!-- toc --&gt;&lt;/p&gt;

&lt;h1 id=&#34;summary&#34;&gt;Summary&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;Make sure the C++ and C compilers produce compatible object files&lt;/li&gt;
&lt;li&gt;Declare functions to be used by both languages &lt;code&gt;extern C&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;If at all possible, write &lt;code&gt;main&lt;/code&gt; in C++&lt;/li&gt;
&lt;li&gt;Always use &lt;code&gt;delete&lt;/code&gt; with memory from &lt;code&gt;new&lt;/code&gt;; always use &lt;code&gt;free&lt;/code&gt; with memory from &lt;code&gt;malloc&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Limit what we pass between the two languages to data structures that compile under C; the C++ version of structs may contain nonvirtual member functions&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;1-compatible-object-files&#34;&gt;1. Compatible object files&lt;/h2&gt;

&lt;p&gt;Before mix together object files produced by some C compiler with those from C++ compiler, we have to make sure they both share the same implementation-dependent features, such as the size of &lt;code&gt;int&lt;/code&gt;s and &lt;code&gt;double&lt;/code&gt;s, the mechanism by which parameters are passed from caller to callee, and whether the caller or the callee orchestrates the passing.&lt;/p&gt;

&lt;h2 id=&#34;2-name-mangling&#34;&gt;2. Name Mangling&lt;/h2&gt;

&lt;p&gt;Name mangling is the process through which the C++ compilers give each function in our program a unique name, which is unnecessary in C because we can&amp;rsquo;t overload function names in C.&lt;/p&gt;

&lt;p&gt;For example, when we write this in C++:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;void drawLine(int x1, int y1, int x2, int y2); // suppose this is mangled into xyzzy
...
drawLine(a, b, c, d);  // call to unmangled function name in source code
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then the statement will be translated by the C++ compiler into the mangled version of that function, so the object file conbtains a function call that corresponds to this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;xyzzy(a, b, c, d);  // call to mangled function name
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;However, if &lt;code&gt;drawLine&lt;/code&gt; is a C function, the object file (or archive or dynamically linked library, etc.) that contains the compiled version of &lt;code&gt;drawLine&lt;/code&gt; contains a function called &lt;code&gt;drawLine&lt;/code&gt; - no name mangling occurs. When trying to link mixed style object files together, we may get an error, because the linker is looking for a function called &lt;code&gt;xyzzy&lt;/code&gt;, and there is no such function.&lt;/p&gt;

&lt;p&gt;To solve this problem, we tell C++ compilers not to mangle certain function names:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;extern &amp;quot;C&amp;quot;
void drawLine(int x1, int y1, int x2, int y2);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note that there is only &lt;code&gt;extern &amp;quot;C&amp;quot;&lt;/code&gt;, no &lt;code&gt;extern &amp;quot;Pascal&amp;quot;&lt;/code&gt; or &lt;code&gt;extern &amp;quot;FORTRAN&amp;quot;&lt;/code&gt; or anything else. &lt;code&gt;extern &amp;quot;C&amp;quot;&lt;/code&gt; means that the function should be called as if it &lt;em&gt;were&lt;/em&gt; written in C (Technically, &lt;code&gt;extern &amp;quot;C&amp;quot;&lt;/code&gt; means the function has C linkage, which guarantees that name mangling is suppressed.)&lt;/p&gt;

&lt;p&gt;For a slew of functions whose names don&amp;rsquo;t need mangling, we enclose them in curly braces. For header files we want to share by both C++ and C, we take advantage of preprocessor symbol &amp;ldquo;__cplusplus&amp;rdquo;, which is defined only for C++ compilations:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#ifdef __cplusplus
extern &amp;quot;C&amp;quot; {
#endif
    void drawLine(int x1, int y1, int x2, int y2);
    void twiddleBits(unsigned char bits);
    void simulate(int iterations);
    ...
#ifdef __cplusplus
}
#endif
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;3-initialization-of-statics&#34;&gt;3. Initialization of Statics&lt;/h2&gt;

&lt;p&gt;In C++, the constructors of static class objects and objects at global, namespace, and file scope are usually called before the body of &lt;code&gt;main&lt;/code&gt; is executed, which is known as &lt;em&gt;static initialization&lt;/em&gt;. Similarly, objects that are created through static initialization must have their destructors called during &lt;em&gt;static destruction&lt;/em&gt;, which typically take place after &lt;code&gt;main&lt;/code&gt; has finished executing.&lt;/p&gt;

&lt;p&gt;The implementation of static initialization as well as static destruction is usually achieved by compilers by inserting a call to a special compiler-written function at the beginning of &lt;code&gt;main&lt;/code&gt;, which takes care of static initialization (similarly with static destruction):&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;int main(int argc, char *argv[])
{
    performStaticInitialization(); // generated by the compiler

    the statements we put in main;

    performStaticDestruction(); // generated by the compiler
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The point is, if a software contains a C++ part, which is compiled with this approach to initialize and destruct static objects (they usually do), we should write &lt;code&gt;main&lt;/code&gt; in C++.&lt;/p&gt;

&lt;p&gt;If most of a program is in C and C++ is only a support library, it would make more sense to write &lt;code&gt;main&lt;/code&gt; in C. Nevertheless, in case of static objects in C++ library (if it doesn&amp;rsquo;t now, it probably will in the future, see MECpp item 32), so it&amp;rsquo;s still a good idea to write &lt;code&gt;main&lt;/code&gt; in C++: simply call the C version &lt;code&gt;realMain&lt;/code&gt; in a wrapper &lt;code&gt;main&lt;/code&gt; in C++:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;extern &amp;quot;C&amp;quot; 
int realMain(int argc, char *argv[]); // implement this function in C

int main(int argc, char *argv[]) // write this in C++
{
    return realMain(argc, argv);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;4-dynamic-memory-allocation&#34;&gt;4. Dynamic Memory Allocation&lt;/h2&gt;

&lt;p&gt;Recall MECpp Item 8: the C++ parts of a program use &lt;code&gt;new&lt;/code&gt; and &lt;code&gt;delete&lt;/code&gt;, and the C parts of a program use &lt;code&gt;malloc&lt;/code&gt; (and its variants) and &lt;code&gt;free&lt;/code&gt;. Mismatched allocation and deallocation operation for dynamic memory yields undefined behavior, so never call &lt;code&gt;free&lt;/code&gt; on a &lt;code&gt;new&lt;/code&gt;ed pointer, nor &lt;code&gt;delete&lt;/code&gt;ing a &lt;code&gt;malloc&lt;/code&gt;ed pointer.&lt;/p&gt;

&lt;p&gt;Sometimes this is easier said than done, because some functions are not in the standard library, or not available in the uniform implementation on different computing platforms, making it hard to judge the correct deallocation operation:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;char * strdup(const char *ps); // return a copy of the string pointed to by ps
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If the &lt;code&gt;strdup&lt;/code&gt; is from a C library, we need to call &lt;code&gt;free&lt;/code&gt;; if it was written for a C++ library, we should call &lt;code&gt;delete&lt;/code&gt;. If we can&amp;rsquo;t make sure, then simply avoid calling such functions.&lt;/p&gt;

&lt;h2 id=&#34;5-data-structure-compatibility&#34;&gt;5. Data Structure Compatibility&lt;/h2&gt;

&lt;p&gt;C functions can not understand C++ features, so if we want to pass data between C++ and C programs, we are limited to those concepts that C can express: naturally, &lt;code&gt;struct&lt;/code&gt;s and variables of built-in types (e.g., &lt;code&gt;int&lt;/code&gt;s, &lt;code&gt;char&lt;/code&gt;s, etc.)&lt;/p&gt;

&lt;p&gt;Because the rules governing the layout of a &lt;code&gt;struct&lt;/code&gt; in C++ are consistent with those of C, if we can add structs with nonvirtual member, objects of such structs (or class) containing only non-virtual functions should be compatible with their C counterparts, whose structure definition lacks only the member function declarations, and we are safe to pass them back and forth between C++ and C.&lt;/p&gt;

&lt;p&gt;Adding &lt;em&gt;virtual&lt;/em&gt; functions ends the game, because the addition of virtual functions to a class cuases objects of that type to use a different memory layout (MECpp item 24). Having a struct inherit from another struct (or class) usually changes its layout, too, so structs with base structs (or classes) are also poor candidates for exchange with C functions.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>[MECpp]Item-33 Make Non-Leaf Classes Abstract</title>
      <link>http://nianze.tk/2018/05/make-non-leaf-classes-abstract/</link>
      <pubDate>Mon, 21 May 2018 18:27:39 -0400</pubDate>
      
      <guid>http://nianze.tk/2018/05/make-non-leaf-classes-abstract/</guid>
      <description>&lt;p&gt;The general rule: non-leaf classes should be abstract. This will yields dividends in the form of increased reliability, robustness, comprehensibility, and extensibility throughout our software.

&lt;!-- toc --&gt;&lt;/p&gt;

&lt;h1 id=&#34;redesign-concrete-base-classes-to-abstract-ones&#34;&gt;Redesign concrete base classes to abstract ones&lt;/h1&gt;

&lt;p&gt;If we have two concrete classes C1 and C2 and we&amp;rsquo;d like C2 to publicly inherit from C1, we should transform that two-class hierarchy into a three-class hierarchy by creating a new class A and having both C1 and C2 publicly inherit from it:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;initial idea  |             the transformed hierarchy
┌─────────┐   |                    ┌─────┐
│   C1    │   |                    │  A  │
└─────────┘   |                    └─────┘
     ↑        | public inheritance ↗     ↖ public inheritance
┌─────────┐   |              ┌────┐      ┌────┐
│   C1    │   |              │ C1 │      │ C2 │
└─────────┘   |              └────┘      └────┘
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;For example, we create a software dealing with animals, with two kinds of animals - lizards and chickens - require special handling:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;                    ┌──────────┐
                    │  Animal  │
                    └──────────┘
   public inheritance ↗     ↖ public inheritance
             ┌────────┐      ┌─────────┐
             │ Lizard │      │ Chicken │
             └────────┘      └─────────┘
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;Animal&lt;/code&gt; class embodies the features shared by all the creatures, and the &lt;code&gt;Lizerd&lt;/code&gt; and &lt;code&gt;Chicken&lt;/code&gt; classes specialize &lt;code&gt;Animal&lt;/code&gt; in their own ways:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class Animal {
public:
    Animal&amp;amp; operator=(const Animal&amp;amp; rhs);
    ...
};

class Lizard: public Animal {
public:
    Lizard&amp;amp; operator=(const Lizard&amp;amp; rhs);
    ...
};

class Chicken: public Animal {
public:
    Chicken&amp;amp; operator=(const Chicken&amp;amp; rhs);
    ...
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now consider what happens for assignment operation:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;Lizard liz1;
Lizard liz2;
Animal *pAni1 = &amp;amp;liz1;
Animal *pAni2 = &amp;amp;liz2;
...
*pAni1 = *pAni2;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The two problems here:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;em&gt;partial assignment&lt;/em&gt;: only &lt;code&gt;Animal&lt;/code&gt; members in &lt;code&gt;liz1&lt;/code&gt; get updated from &lt;code&gt;liz2&lt;/code&gt;, while the &lt;code&gt;liz1&lt;/code&gt;&amp;rsquo;s Lizard members remain unchanged.&lt;/li&gt;
&lt;li&gt;it&amp;rsquo;s not uncommon for programmers to make assignments to objects via pointers.&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;solution-1-virtual-functions&#34;&gt;Solution 1: virtual functions&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class Animal {
public:
    virtual Animal&amp;amp; operator=(const Animal&amp;amp; rhs);
    ...
};

class Lizard: public Animal {
public:
    virtual Lizard&amp;amp; operator=(const Animal&amp;amp; rhs);
    ...
};

class Chicken: public Animal {
public:
    virtual Chicken&amp;amp; operator=(const Animal&amp;amp; rhs);
    ...
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We can customize the return value of the virtual assignment operators here, but the rules of C++ force us to declare identical &lt;em&gt;parameter&lt;/em&gt; types for a virtual function in every class in which it is declared, leading to the problem that the assignment operator for the &lt;code&gt;Lizard&lt;/code&gt; and &lt;code&gt;Chicken&lt;/code&gt; must be prepared to accept &lt;em&gt;any&lt;/em&gt; kind of &lt;code&gt;Animal&lt;/code&gt; object on the right-hand side of an assignment:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;Lizard liz;
Chicken chick;

Animal *pAni1 = &amp;amp;liz;
Animal *pAni2 = &amp;amp;chick;

...

*pAni1 = *pAni2; // assign a chicken to a lizard!
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;By making &lt;code&gt;Animal&lt;/code&gt;&amp;rsquo;s assignment operator virtual, we opened the door to such mixed-type operations. To only allow the same type assignment in virtual assignment operation, we have to make distinctions the types at runtime:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;Lizard&amp;amp; Lizard::operator=(const Animal&amp;amp; rhs)
{
    // make sure rhs is really a lizard
    const Lizard&amp;amp; rhs_liz = dynamic_cast&amp;lt;const Lizard&amp;amp;&amp;gt;(rhs);
    ... // proceed with a normal assignment of rhs_liz to *this
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In this case, we have to worry about &lt;code&gt;std::bad_cast&lt;/code&gt; exceptions thrown by &lt;code&gt;dynamic_cast&lt;/code&gt; when &lt;code&gt;rhs&lt;/code&gt; is not a &lt;code&gt;Lizard&lt;/code&gt;, while paying for extra runtime check cost for valid assignment cases, as well as the harder to maintain code.&lt;/p&gt;

&lt;h2 id=&#34;solution-2-adding-another-function&#34;&gt;Solution 2: adding another function&lt;/h2&gt;

&lt;p&gt;If we don&amp;rsquo;t want to pay for the complexity or cost of a &lt;code&gt;dynamic_cast&lt;/code&gt; in the case of valid assignment, we add to &lt;code&gt;Lizard&lt;/code&gt; the conventional assignment operator:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class Lizard: public Animal {
public:
    virtual Lizard&amp;amp; operator=(const Animal&amp;amp; rhs);
    Lizard&amp;amp; operator=(const Lizard&amp;amp; rhs);  // add this
    ...
};

Lizard&amp;amp; Lizard::operator=(const Animal&amp;amp; rhs)
{
    return operator=(dynamic_cast&amp;lt;const Lizard&amp;amp;&amp;gt;(rhs));
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;Lizard liz1, liz2;
...
liz1 = liz2;   // calls operator= taking a const Lizard&amp;amp;

Animal *pAni1 = &amp;amp;liz1;
Animal *pAni2 = &amp;amp;liz2;
...
*pAni1 = *pAni2;  // calls operator= taking a const Animal&amp;amp;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Still, clients of &lt;code&gt;Lizard&lt;/code&gt; and &lt;code&gt;Chicken&lt;/code&gt; have to be prepared to catch &lt;code&gt;bad_cast&lt;/code&gt; exceptions and do something sensible with them each time they perform an assignment, which most programmers are unwilling to do.&lt;/p&gt;

&lt;h2 id=&#34;solution-3-making-partial-assignment-illegal&#34;&gt;Solution 3: making partial assignment illegal&lt;/h2&gt;

&lt;p&gt;The easiest way to prevent partial assignments is to make &lt;code&gt;Animal::operator=&lt;/code&gt; private so that &lt;code&gt;*pAni1 = *pAni2;&lt;/code&gt; is illegal (which calls private &lt;code&gt;Animal::operator=&lt;/code&gt;), but this naive solution has 2 problems:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;code&gt;Animal&lt;/code&gt; is a concrete class. A private &lt;code&gt;operator=&lt;/code&gt; makes also it illegal to make assignments between &lt;code&gt;Animal&lt;/code&gt; objects: &lt;code&gt;animal1 = animal2;&lt;/code&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Assignment operator in derived classes are responsible for calling assignment operators in their base classes, but a private &lt;code&gt;Animal::operator=&lt;/code&gt; makes it impossible to implement the &lt;code&gt;Lizard::operator=&lt;/code&gt; and &lt;code&gt;Chicken::operator=&lt;/code&gt; correctly to assign the &lt;code&gt;Animal&lt;/code&gt; part of &lt;code&gt;*this&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;Lizard&amp;amp; Lizard::operator=(const Lizard&amp;amp; rhs)
{
    if (this == &amp;amp;rhs) return *this;
    Animal::operator=(rhs); // can&#39;t call private Animal::operator=
    ...
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Declaring &lt;code&gt;Animal::operator=&lt;/code&gt; as &lt;code&gt;protected&lt;/code&gt; will solve the latter problem, but the first one still remains.&lt;/p&gt;

&lt;h2 id=&#34;solution-4-redesign-the-inheritance-hierarchy&#34;&gt;Solution 4: redesign the inheritance hierarchy&lt;/h2&gt;

&lt;p&gt;Because our orignimal design for the system presupposed that &lt;code&gt;Animal&lt;/code&gt; objects were necessary, we can not abstract &lt;code&gt;Animal&lt;/code&gt; class. Instead, we create a new class - &lt;code&gt;AbstractAnimal&lt;/code&gt; that consists of the common features of &lt;code&gt;Animal&lt;/code&gt;, &lt;code&gt;Lizard&lt;/code&gt;, and &lt;code&gt;Chicken&lt;/code&gt;, and we make &lt;em&gt;that&lt;/em&gt; class abstract by making its destructor a pure virtual function&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:1&#34;&gt;&lt;a href=&#34;#fn:1&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class AbstractAnimal {
protected:
    AbstractAnimal&amp;amp; operator=(const AbstractAnimal&amp;amp; rhs);
public:
    virtual ~AbstractAnimal() = 0; // still need to impl. the destructor even it&#39;s a pure virtual function
    ...
};

class Animal: public AbstractAnimal {
public:
    Animal&amp;amp; operator=(const Animal&amp;amp; rhs);
    ...
};

class Lizard: public AbstractAnimal {
public:
    Lizard&amp;amp; operator=(const Lizard&amp;amp; rhs);
    ...
};

class Chicken: public AbstractAnimal {
public:
    Chicken&amp;amp; operator=(const Chicken&amp;amp; rhs);
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This design gives us everything:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;homogeneous assignments ar allowed for lizards, chickens, and animals;&lt;/li&gt;
&lt;li&gt;partial assignments and heterogeneous assignments are prohibited&lt;/li&gt;
&lt;li&gt;derived class assignment operators may call the assignment operator in the base class&lt;/li&gt;
&lt;li&gt;non of the code written in terms of the &lt;code&gt;Animal&lt;/code&gt;, &lt;code&gt;Lizard&lt;/code&gt;, or &lt;code&gt;Chicken&lt;/code&gt; requires modification - they behave as they did before &lt;code&gt;AbstractAnimal&lt;/code&gt; was introduced - though the code does need to be recompiled&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;in-reality-when-facing-constraints&#34;&gt;In reality when facing constraints&lt;/h1&gt;

&lt;p&gt;If we want wot create a concrete class that inherits from a concrete class in a thirt-party libraries to which we have only read access, what are we to do?&lt;/p&gt;

&lt;p&gt;Then there are only unappealing options:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Derive the concrete class from the existing concrete class, and put up with the assignment-related problems, and watch out for the array-related pitfalls (MECpp item 3).&lt;/li&gt;
&lt;li&gt;Try to find an abstract class higher in the library hierarchy that does most of what we need, then inherit from that class.&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Implement the new class in terms of the library class we&amp;rsquo;d like to inherit from: having an object of the library class as a data member, then reimplement the library class&amp;rsquo;s interface in the new class - this requires to update the class each time the library vendor updates our dependent library classes, and we also give up the ability to redefine virtual functions declared in the library class (we can&amp;rsquo;t redefine virtual functions unless we inherit them):&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class Window {
public:
    virtual void resize(int newWidth, int newHeight);
    virtual void repaint() const;

    int width() const;
    int height() const;
};

class SpecialWindow { // class we wanted to have inherit from Window
public:
    ...
    int width() const { return w.width(); } // pass through nonvirtual functions
    int height() const { return w.height(); }

    virtual void resize(int newWidth, int newHeight); // new impl. of &amp;quot;inherited&amp;quot; virtual functions
    virtual void repaint() const;
private:
    Window w;
};
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Use the concrete class that&amp;rsquo;s in the library and modify the software so that the class suffices. Write non-member functions to proved the extra functionality we&amp;rsquo;d like to add to the class, but can&amp;rsquo;t - the result may not be as clear, as efficient, as maintainable, or as extensible as we&amp;rsquo;d like.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;footnotes&#34;&gt;

&lt;hr /&gt;

&lt;ol&gt;
&lt;li id=&#34;fn:1&#34;&gt;Declaring a function pure virtual doesn&amp;rsquo;t mean it has no implementation, it means: 1. the current class is abstract, and 2 any concrete class inheriting from the current class must declare the function as a &amp;ldquo;normal&amp;rdquo; virtual function (i.e., without the &amp;ldquo;=0&amp;rdquo;).
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:1&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;</description>
    </item>
    
    <item>
      <title>[MECpp]Item-32 Program in the Future Tense</title>
      <link>http://nianze.tk/2018/05/program-in-the-future-tense/</link>
      <pubDate>Thu, 17 May 2018 19:26:17 -0400</pubDate>
      
      <guid>http://nianze.tk/2018/05/program-in-the-future-tense/</guid>
      <description>&lt;p&gt;Things change. Future tense thinking increases the reusability of the code we write, enhances its maintainability, makes it more robust, and facilitates gracefully in an environment where change is a certainty.

&lt;!-- toc --&gt;&lt;/p&gt;

&lt;p&gt;To program in the future tense is to accept that things will change and to be prepared for it.&lt;/p&gt;

&lt;h1 id=&#34;changing-world&#34;&gt;Changing world&lt;/h1&gt;

&lt;p&gt;Recognize that
* new functions will be added to libraries, that new overloading will occur, and potentially ambiguous function calls that might result
* new classes will be added to hierarchies, present-day derived clases may be tomorrow&amp;rsquo;s base classes
* new application will be written so functions will be called in new contexts while still being expected to perform correctly&lt;/p&gt;

&lt;h1 id=&#34;changing-people&#34;&gt;Changing people&lt;/h1&gt;

&lt;p&gt;Acknowledge that&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;programmers charged with software maintenance are typically not the code&amp;rsquo;s original developers, hence to design and implement in a fashion that facilitates comprehension, modification, and enhancement by others.&lt;/li&gt;
&lt;li&gt;&amp;ldquo;Anything somebody &lt;em&gt;can&lt;/em&gt; do, they &lt;em&gt;will&lt;/em&gt; do&amp;rdquo;: client developers have different level of experience with C++, so the intention of a class designer may be misunderstood.&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;principle&#34;&gt;Principle&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;Design the class easy to use correctly and hard to use incorrectly

&lt;ul&gt;
&lt;li&gt;do what an &lt;code&gt;int&lt;/code&gt;s will do&lt;/li&gt;
&lt;li&gt;use C++ itself to express design constraints instead of (or in addition to) comments or documentation&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Strive for portable code

&lt;ul&gt;
&lt;li&gt;if there is no great penalty for generalizing the code, generalize it&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Design the code so that when changes are necessary, the impact is localized

&lt;ul&gt;
&lt;li&gt;provide complete classes even if some parts aren&amp;rsquo;t currently used - when new demands are made on our classes, we&amp;rsquo;re less likely to have to go back and modify them&lt;/li&gt;
&lt;li&gt;do:

&lt;ul&gt;
&lt;li&gt;encapsulate as much as we can;&lt;/li&gt;
&lt;li&gt;make implementation details private;&lt;/li&gt;
&lt;li&gt;use unnamed namespaces&amp;hellip;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;avoid:

&lt;ul&gt;
&lt;li&gt;designs leading to virtual base classes (such classes must be initialized by every class derived from them, MECpp item 4)&lt;/li&gt;
&lt;li&gt;RTTI-based designs that make use of cascading &lt;code&gt;if-then-else&lt;/code&gt; (MECpp item 31)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>[MECpp]Item-31 Making Functions Virtual With Respect to More Than One Object</title>
      <link>http://nianze.tk/2018/05/making-functions-virtual-with-respect-to-more-than-one-object/</link>
      <pubDate>Fri, 11 May 2018 00:00:00 +0000</pubDate>
      
      <guid>http://nianze.tk/2018/05/making-functions-virtual-with-respect-to-more-than-one-object/</guid>
      <description>&lt;p&gt;A virtual function call is termed a &amp;ldquo;message dispatch.&amp;rdquo; A call that acts virtual on multiple parameters is called &lt;em&gt;multiple dispatch&lt;/em&gt;, which is not directly supported in C++. Several resolutions exist, but none is without its disadvantages.
&lt;/p&gt;

&lt;p&gt;For example, considering we are writing a video game involving space ships, space stations, and asteroids:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class GameObject {...};
class SpaceShip: public GameObject {...};
class SpaceStation: public GameObject {...};
class Asteroid: public GameObjecct {...};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;When one &lt;code&gt;GameObject&lt;/code&gt; collides with another, we call a function depending on &lt;em&gt;both&lt;/em&gt; their dynamic types:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;void checkForCollision(GameObject&amp;amp; object1, GameObject&amp;amp; object2)
{
    if (theyJustCollided(object1, object2)) {
        processCollision(object1, object2);
    }
    else {
        ...
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now comes the &lt;em&gt;double dispatch&lt;/em&gt;: since collisions betwenn different &lt;code&gt;GameObject&lt;/code&gt; effects the environment differently, we want &lt;code&gt;processCollision&lt;/code&gt; to act virtual on both &lt;code&gt;object1&lt;/code&gt; and &lt;code&gt;object2&lt;/code&gt;, but C++ only offers virtual support for one parameter, like &lt;code&gt;object1.processCollision(object2)&lt;/code&gt;. We must come up with some approaches ourselves instead of relyin on compilers.&lt;/p&gt;

&lt;h1 id=&#34;using-virtual-function-and-rtti&#34;&gt;Using Virtual Function and RTTI&lt;/h1&gt;

&lt;p&gt;We need double dispatch, so we can use virtual functions for first half of what we need, and use chains of &lt;code&gt;if-then-else&lt;/code&gt;s for rest half:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class GameObject {
public:
    virtual void collide(GameObject&amp;amp; otherObject) = 0;
    ...
};

class SpaceShip: public GameObject {
public:
    virtual void collide(GameObject&amp;amp; otherObject);
    ...
};
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;// if colliding with an object of unknown type
// throw an exception of this type:
class CollisionWithUnknownObject {
public:
    CollisionWithUnknownObject(GameObject&amp;amp; whatWeHit);
    ...
};

void SpaceShip::collide(GameObject&amp;amp; otherObject)
{
    const type_info&amp;amp; objectType = typeid(otherObject);
    if (objectType == typeid(SpaceShip)) {
        SpaceShip&amp;amp; ss = static_cast&amp;lt;SpaceShip&amp;amp;&amp;gt;(otherObject);
        process a SpaceShip-SpaceShip collision;
    }
    else if (objectType == typeid(SpaceStation)) {
        SpaceStation&amp;amp; ss = static_cast&amp;lt;SpaceStation&amp;amp;&amp;gt;(otherObject);
        process a SpaceShip-SpaceStation collision;
    }
    else if (objectType == typeid(Asteroid)) {
        Asteroid&amp;amp; a = static_cast&amp;lt;Asteroid&amp;amp;&amp;gt;(otherObject);
        process a SpaceShip-Asteroid collision;
    }
    else {
        throw CollisionWithUnknownObject(otherObject);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The danger in this design: each &lt;code&gt;collide&lt;/code&gt; function must be aware of each of its sibling classes, so if a new type of object is added to the game, we must update each RTTI-based &lt;code&gt;if-then-else&lt;/code&gt; chain in the proram that might encounter the new object, which in essence is unmaintainable in the long run. We added a final &lt;code&gt;else&lt;/code&gt; clause where control winds up if we hit an unnknown object, throwing an exception to callers in the hope that they handle the error better than we can (but since we are running into something we didn&amp;rsquo;t know existed, they almost can&amp;rsquo;t do anything more satisfying.)&lt;/p&gt;

&lt;h1 id=&#34;using-virtual-functions-only&#34;&gt;Using Virtual Functions Only&lt;/h1&gt;

&lt;p&gt;We can also implement double-dispatching as two separate virtual function calls:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;// forward declarations
class SpaceShip;
class SpaceStation;
class Asteroid;
class GameObject {
public:
    virtual void collide(GameObject&amp;amp;   otherObject) = 0;
    virtual void collide(SpaceShip&amp;amp;    otherObject) = 0;
    virtual void collide(SpaceStation&amp;amp; otherObject) = 0;
    virtual void collide(Asteroid&amp;amp;     otherObject) = 0;
    ...
};

class SpaceShip: public GameObject {
public:
    virtual void collide(GameObject&amp;amp;   otherObject);
    virtual void collide(SpaceShip&amp;amp;    otherObject);
    virtual void collide(SpaceStation&amp;amp; otherObject);
    virtual void collide(Asteroid&amp;amp;     otherObject);
    ...
};
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;void SpaceShip::collide(GameObject&amp;amp; otherObject)
{
    otherObject.collide(*this);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note that this implementation is not a resursive call: being inside a member function of the class &lt;code&gt;Spaceship&lt;/code&gt;, the static type of &lt;code&gt;*this&lt;/code&gt; is of type &lt;code&gt;SpaceShip&lt;/code&gt;, so the call is routed to the &lt;code&gt;collide(SpaceShip&amp;amp;)&lt;/code&gt; instead of going back to &lt;code&gt;collide(GameObject&amp;amp;)&lt;/code&gt;. All the &lt;code&gt;collide&lt;/code&gt; functions are virtual, so finally this call will resolve to the implementation of &lt;code&gt;collide&lt;/code&gt; corresponding to the real type of &lt;code&gt;otherObject&lt;/code&gt;, where both types are known. So the implementation is simply:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;void SpaceShip::collide(SpaceShip&amp;amp; otherObject)
{
    process a SpaceShip-SpaceShip collision;
}

void SpaceShip::collide(SpaceStation&amp;amp; otherObject) {
    process a SpaceShip-SpaceStation collision;
}

void Spaceship::collide(SpaceStation&amp;amp; otherObject) {
    process a SpaceShip-Asteroid collision;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;There&amp;rsquo;s no RTTI, no need to throw unexpected object types. Still, there&amp;rsquo;s the same old flaw: each class must know about its siblings. Even worth, the &lt;em&gt;way&lt;/em&gt; in which the code must be updated in the case of adding new classes is difficult to extend: if we add a new class, say &lt;code&gt;class Satellite: public GameObject&lt;/code&gt;, to our game, we&amp;rsquo;d have to add a new &lt;code&gt;collide&lt;/code&gt; function to each of the existing classes in the program, rather than just another &lt;code&gt;else&lt;/code&gt; clause in one function before.&lt;/p&gt;

&lt;p&gt;Now let&amp;rsquo;s do a small sum-up:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Virtual function approach is safer than the RTTI strategy, but it constrains the extensibility of the system to match that of our ability to edit header files&lt;/li&gt;
&lt;li&gt;RTTI makes no recompilation demands, but it generally leads unmaintainable software.&lt;/li&gt;
&lt;li&gt;The best recourse is to modify the design to eliminate the need for double-dispatching.&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&#34;emulating-virtual-function-tables&#34;&gt;Emulating Virtual Function Tables&lt;/h1&gt;

&lt;p&gt;Actually, we can build our own virtual function tables, similar to how compilers implement virtual functions by creating an array of function pointers (the vtbl) and then indexing into that array when a virtual function is called, except that this customized version support double-dispatching. Moreover, the virtual function tables is more efficient than the RTTI-based code (indexing into an array and following a function pointer vs running through a series of &lt;code&gt;if-then-else&lt;/code&gt; tests), and we isolate the use of RTTI to a single location where the array of function pointers is initialized.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class GameObject {
public:
    virtual void collide(GameObject&amp;amp; otherObject) = 0;
    ...
};

class SpaceShip: public GameObject {
public:
    virtual void collide(GameObject&amp;amp; otherObject);
    virtual void hitSpaceShip(GameObject&amp;amp; spaceShip);
    virtual void hitSpaceStation(GameObject&amp;amp; spaceStation);
    virtual void hitAsteroid(GameObject&amp;amp; asteroid);
    ...
private:
    typedef void (SpaceShip::*HitFunctionPtr)(GameObject&amp;amp;);
    static HitFunctionPtr lookup(const GameObject&amp;amp; whatWeHit);
    typedef map&amp;lt;string, HitFunctionPtr&amp;gt; HitMap;
    static HitMap * initializeCollisionMap();
    ...
};
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;SpaceShip::HitMap * SpaceShip::initializeCollisionMap()
{
    HitMap *phm = newHitMap;
    (*phm)[&amp;quot;SpaceShip&amp;quot;] = &amp;amp;hitSpaceShip;
    (*phm)[&amp;quot;SpaceStation&amp;quot;] = &amp;amp;hitSpaceStation;
    (*phm)[&amp;quot;Asteroid&amp;quot;] = &amp;amp;hitAsteroid;
    return phm;
}

SpaceShip::HitFunctionPtr SpaceShip::lookup(const GameObject&amp;amp; whatWeHit)
{
    static auto_ptr&amp;lt;HitMap&amp;gt; collisionMap(initializeCollisionMap());
    HitMap::iterator mapEntry = collisionMap.find(typeid(whatWeHit).name());
    if (mapEntry == collisionMap-&amp;gt;end()) return 0;
    return (*mapEntry).second;
}

void SpaceShip::collide(GameObject&amp;amp; otherObject)
{
    HitFunctionPtr hfp = lookup(otherObject);
    if (hfp) {
        (this-&amp;gt;*htp)(otherObject);
    }
    else {
        throw CollisionWithUnknownObject(otherObject);
    }
}

// Each of the `dynamic_cast` will throw a `bad_cast` exception if the cast fails
// they should never fail, though.
void SpaceShip::hitSpaceShip(GameObject&amp;amp; spaceShip)
{
    SpaceShip&amp;amp; otherShip = dynamic_cast&amp;lt;SpaceShip&amp;amp;&amp;gt;(spaceShip);
    process a SpaceShip-SpaceShip collision;
}

void SpaceShip::hitSpaceStation(GameObject&amp;amp; spaceStation) {
    SpaceStation&amp;amp; Station = dynamic_cast&amp;lt;SpaceStation&amp;amp;&amp;gt;(spaceStation)
    process a SpaceShip-SpaceStation collision;
}

void Spaceship::hitAsteroid(GameObject&amp;amp; asteroid) {
    Asteroid&amp;amp; theAsteroid = dynamic_cast&amp;lt;Asteroid&amp;gt;(asteroid)
    process a SpaceShip-Asteroid collision;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note that there&amp;rsquo;s another design which seems doable but is actually error-prone:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class SpaceShip: public GameObject {
public:
    virtual void collide(GameObject&amp;amp; otherObject);
    virtual void hitSpaceShip(SpaceShip&amp;amp; otherObject);
    virtual void hitSpaceStation(SpaceStation&amp;amp; otherObject);
    virtual void hitAsteroid(Asteroid&amp;amp; otherObject);
    ...
};

SpaceShip::HitMap * SpaceShip::initializeCollisionMap()
{
    HitMap *phm = newHitMap;
    (*phm)[&amp;quot;SpaceShip&amp;quot;] = reinterpret_cast&amp;lt;HitFunctionPtr&amp;gt;(&amp;amp;hitSpaceShip);
    (*phm)[&amp;quot;SpaceStation&amp;quot;] = reinterpret_cast&amp;lt;HitFunctionPtr&amp;gt;(&amp;amp;hitSpaceStation);
    (*phm)[&amp;quot;Asteroid&amp;quot;] = reinterpret_cast&amp;lt;HitFunctionPtr&amp;gt;(&amp;amp;hitAsteroid);
    return phm;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here we tell the compiler that &lt;code&gt;hitSpaceShip&lt;/code&gt;, &lt;code&gt;hitSpaceStation&lt;/code&gt;, and &lt;code&gt;hitAsteroid&lt;/code&gt; are functions expecting a &lt;code&gt;GameObject&lt;/code&gt; argument, which is not true. &lt;code&gt;hitSpaceShip&lt;/code&gt; expects a &lt;code&gt;SpaceShip&lt;/code&gt;, &lt;code&gt;hitSpaceStation&lt;/code&gt; expects a &lt;code&gt;SpaceStation&lt;/code&gt;, and &lt;code&gt;hitAsteroid&lt;/code&gt; expects an &lt;code&gt;Asteroid&lt;/code&gt;. All these functions are declared as pass-by-reference, which in fact is implemented by passing a pointer to an object, so ideally compilers will pass the declared type of the parameter(say &lt;code&gt;hitSpaceShip&lt;/code&gt; for function &lt;code&gt;hitSpaceShip&lt;/code&gt;) in the function being called. However, due to the object layout of classes under an inheritance path, after the cast above, it is possible that the wrong address (say &lt;code&gt;GameObject&lt;/code&gt;) is passed into the function, because inside a &lt;code&gt;SpaceShip&lt;/code&gt; object there are both a derived class part as well as a base class part, each having a different address (for detailed discussion, refer to &lt;em&gt;More Effective C++&lt;/em&gt; Item 31-Initializing Emulated Virtual Function Talbes).&lt;/p&gt;

&lt;h2 id=&#34;using-non-member-collision-processing-functions&#34;&gt;Using Non-Member Collision-Processing Functions&lt;/h2&gt;

&lt;p&gt;Still, similar to pure virtual functions based approach, there is one remaining problem: because the associative array contains pointers to &lt;em&gt;member functions&lt;/em&gt;, once a new type of &lt;code&gt;GameObject&lt;/code&gt; is added to the game, every class definition needs to be updated and recompiled, even if that class does not care about the new type of object.&lt;/p&gt;

&lt;p&gt;To solve this problem, we change the associative array so that it contains pointers to &lt;em&gt;non-member functions&lt;/em&gt;. This update also helps us address a design question before: a collision between objects of types A and B should be handles by neither A nor B (depending on whichever is the left-hand argument to &lt;code&gt;processCollision&lt;/code&gt;) but instead in some neutral location outside both classes.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;quot;SpaceShip.h&amp;quot;
#include &amp;quot;SpaceStation.h&amp;quot;
#include &amp;quot;Asteroid.h&amp;quot;

namespace {  

// primary collision-processing functions
void shipStation(GameObject&amp;amp; spaceShip, GameObject&amp;amp; spaceStation);
void shipAsteroid(GameObject&amp;amp; spaceShip, GameObject&amp;amp; asteroid);
void asteroidStation(GameObject&amp;amp; asteroid, GameObject&amp;amp; spaceStation);
// secondary collision-processing functions that just implement symmetry
void stationShip(GameObject&amp;amp; spaceStation, GameObject&amp;amp; spaceShip)
{ shipStation(spaceShip, spaceStation); }
void asteroidShip(GameObject&amp;amp; asteroid, GameObject&amp;amp; spaceShip)
{ shipAsteroid(spaceShip, asteroid); }
void stationAsteroid(GameObject&amp;amp; spaceStation, GameObject&amp;amp; asteroid)
{ asteroidStation(asteroid, spaceStation); }

...

typedef void (*HitFunctionPtr)(GameObject&amp;amp;, GameObject&amp;amp;);
typedef map&amp;lt; pair&amp;lt;string, string&amp;gt;, HitFunctionPtr &amp;gt; HitMap;

pair&amp;lt;string, string&amp;gt; makeStringPair(const char *s1, const char *s2);
HitMap * initializeCollisionMap(const string&amp;amp; class1, const string&amp;amp; class2);
HitFunctionPtr lookup(const string&amp;amp; class1, const string&amp;amp; class2);

} // end of unnamed namespace

void processCollision(GameObject&amp;amp; object1, GameObject&amp;amp; object2)
{
    HitFunctionPtr phf = lookup(typeid(object1).name(), 
                                typeid(object2).name());
    if (phf) phf(object1, object2);
    else throw UnknownCollision(object1, object2);
}

namespace {

pair&amp;lt;string, string&amp;gt; makeStringPair(const char *s1, const char *s2)
{ return pair&amp;lt;stirng, string&amp;gt;(s1, s2); }

HitMap * initializeCollisionMap()
{
    HitMap *phm = new HitMap;
    (*phm)[makeStringPair(&amp;quot;Spaceship&amp;quot;, &amp;quot;Asteroid&amp;quot;)] = &amp;amp;shipAsteroid;
    (*phm)[makeStringPair(&amp;quot;Spaceship&amp;quot;, &amp;quot;SpaceStation&amp;quot;)] = &amp;amp;shipStation;
    ...
    return phm;
}

HitFunctionPtr lookup(const string&amp;amp; class1, const string&amp;amp; class2)
{
    static auto_ptr&amp;lt;HitMap&amp;gt; collisionMap(initializeCollisionMap());
    HitMap::iterator mapEntry = collisionMap-&amp;gt;find(make_pair(class1, class2));
    if (mapEntry == collisionMap-&amp;gt;end()) return 0;
    return (*mapEntry).second;
}

} // end namespace
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note that &lt;code&gt;makeStringPair&lt;/code&gt;, &lt;code&gt;initializeColllisionMap&lt;/code&gt;, and &lt;code&gt;lookup&lt;/code&gt; were declared inside an unnamed namespace, therefore each must also be implemented within the same namespace.&lt;/p&gt;

&lt;p&gt;Now we&amp;rsquo;ve solved the problem: if there are new classes to the hierarchy, it requires only the addition of more map insertions in &lt;code&gt;initializeCollisionMap&lt;/code&gt; and the declarations of the new collision-processing functions in the unnamed namespace associated with the implementation of &lt;code&gt;processCollision&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;However, as uaual, there&amp;rsquo;s still a disadvantage in this design: these non-member functions will not support inheritance-based parameter conversions such as how double-virtual-function-call mechanism does.&lt;/p&gt;

&lt;p&gt;For example, suppose the concrete classes &lt;code&gt;CommercialShip&lt;/code&gt; and &lt;code&gt;MilitaryShip&lt;/code&gt; inherit from the newly abstract class &lt;code&gt;SpaceShip&lt;/code&gt; (according to the guidance of MECpp item 33). If a &lt;code&gt;MilitaryShip&lt;/code&gt; object and an &lt;code&gt;Asteroid&lt;/code&gt; collided, we&amp;rsquo;d expect &lt;code&gt;void shipAsteroid(GameObject&amp;amp;, GameObject&amp;amp;)&lt;/code&gt;  to be called. However, in fact, an &lt;code&gt;UnknownCollision&lt;/code&gt; would be thrown, because &lt;code&gt;lookup&lt;/code&gt; would be asked to find a function corresponding to the type names &lt;code&gt;MilitaryShip&lt;/code&gt; and &lt;code&gt;Asteroid&lt;/code&gt;, and no such function would be found in &lt;code&gt;collisionMap&lt;/code&gt; - after all, &lt;code&gt;lookup&lt;/code&gt; has no way of knowing that &lt;code&gt;MilitaryShip&lt;/code&gt; can be treated like a &lt;code&gt;SpaceShip&lt;/code&gt;.&lt;/p&gt;

&lt;h2 id=&#34;modifying-emulated-virtual-function-talbes-dynamically&#34;&gt;Modifying Emulated Virtual Function Talbes Dynamically&lt;/h2&gt;

&lt;p&gt;If we&amp;rsquo;d like to add, remove, or change collision-processing functions as the game proceeds, the static &lt;code&gt;collisionMap&lt;/code&gt; will not meet this requirement. In this case, we can turn the concept of a static map into a class that offers member functions allowing us to modify the contents of the map dynamically:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class CollisionMap {
public:
    typedef void (*HitFunctionPtr)(GameObject&amp;amp;, GameObject&amp;amp;);
    void addEntry(const string&amp;amp; type1,
                  const String&amp;amp; type2,
                  HitFunctionPtr collisionFunction,
                  bool symmetric = true);
    void removeEntry(const string&amp;amp; type1, const string&amp;amp; type2);
    HitFunctionPtr lookup(const string&amp;amp; type1, const string&amp;amp; type2)
    // return a reference to the one and only map
    static CollisionMap&amp;amp; theCollisionMap();
private:
    // private to prevent the creation of multiple maps
    CollisionMap();
    CollisionMap(const CollisionMap&amp;amp;);
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Clients wishing to add an entry to the map simply do the following step:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;void shipAsteroid(GameObject&amp;amp; spaceShip, GameObject&amp;amp; asteroid);
CollisionMap::theCollisionMap().addEntry(&amp;quot;SpaceShip&amp;quot;, &amp;quot;Asteroid&amp;quot;, &amp;amp;shipAsteroid);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We must take care to ensure that these map entries are added to the map before any collisions occurs. One way is to have constructors in &lt;code&gt;GameObject&lt;/code&gt; subclasses check to make sure the appropriate mappings had been added each time an object was created, but then we have to pay a small performance penalty at runtime. An alternative would be to create a &lt;code&gt;RegisterCollisionFunction&lt;/code&gt; class:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class RegisterCollisionFunction {
public:
    RegisterCollisionFunction(const string&amp;amp; type1,
                              const string&amp;amp; type2,
                              CollisionMap::HitFunctionPtr collisionFunction,
                              bool symmetric = true)
    {
        CollisionMap::theCollisionMap().addEntry(type1, type2, collisionFunction, symmetric);
    }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Clients then use global objects of this type to automatically register the functions before &lt;code&gt;main&lt;/code&gt; is invoked to insure the map is initialized properly before any collision occurs:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;RegisterCollisionFunction cf1(&amp;quot;SpaceShip&amp;quot;, &amp;quot;Asteroid&amp;quot;, &amp;amp;shipAsteroid);
RegisterCollisionFunction cf2(&amp;quot;SpaceShip&amp;quot;, &#39;SpaceStation&#39;, &amp;amp;shipStation);
...

int main(int argc, char * argv[])
{
    ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If, later, a new derived &lt;code&gt;class Satellite: public GameObject {...};&lt;/code&gt; is added, and one or more new collision-processing functions are written (say, &lt;code&gt;void satelliteShip(GameObject&amp;amp;, GameObject&amp;amp;)&lt;/code&gt;, and &lt;code&gt;void satelliteAsteroid(GameObject&amp;amp;,GameObject&amp;amp;)&lt;/code&gt;, etc), we can simply add them to the map without disturbing existing code:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;RegisterCollisionFunction cf4(&amp;quot;Satellite&amp;quot;, &amp;quot;SpaceShip&amp;quot;, &amp;amp;satelliteShip);
RegisterCollisionFunction cf5(&amp;quot;Satellite&amp;quot;, &amp;quot;Asteroid&amp;quot;, &amp;amp;satelliteAsteroid);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Overall, this makes it easy to provide data for a map-based implementation, but it doesn&amp;rsquo;t change the fact that there&amp;rsquo;s no perfect way to implement multiple dispatch.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>[MECpp]Item-30 Proxy Classes</title>
      <link>http://nianze.tk/2018/05/proxy-classes/</link>
      <pubDate>Wed, 09 May 2018 00:00:00 +0000</pubDate>
      
      <guid>http://nianze.tk/2018/05/proxy-classes/</guid>
      <description>&lt;p&gt;Objects that stand for other objects are often called &lt;em&gt;proxy objects&lt;/em&gt; (or &lt;em&gt;surrogates&lt;/em&gt;), and the classes that give rise to proxy objects are often called &lt;em&gt;proxy classes&lt;/em&gt;, which is useful for implementing multidimensional arrays, differentiating lvalue/rvalue, and suppressing implicit conversions.

&lt;!-- toc --&gt;&lt;/p&gt;

&lt;h1 id=&#34;implementing-two-dimensional-arrays&#34;&gt;Implementing Two-Dimensional Arrays&lt;/h1&gt;

&lt;p&gt;Consider this statement:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;int data[10][20];
...
cout &amp;lt;&amp;lt; data[3][6]; // fine
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We want to create a general 2D array supporting operations such as &lt;code&gt;data[3][6]&lt;/code&gt;. However, there&amp;rsquo;s no such thing as a &lt;code&gt;operator[][]&lt;/code&gt; in C++. The reason it is legal to write code above that appears to use &lt;code&gt;operator[][]&lt;/code&gt; is because the variable &lt;code&gt;data&lt;/code&gt; is not really a two-dimensinal array at all, but a 10-element one-dimensional array, each element of which is itself a 20-element array. So the expression &lt;code&gt;data[3][6]&lt;/code&gt; really means &lt;code&gt;(data[3])[6]&lt;/code&gt; - the seventh element of the array that is the fourth element of &lt;code&gt;data&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Playing the same trick as above, we can define our &lt;code&gt;Array2D&lt;/code&gt; class by overloading &lt;code&gt;operator[]&lt;/code&gt; to return an object of a new class, &lt;code&gt;Array1D&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;template&amp;lt;class T&amp;gt;
class Array2D {
public:
    class Array1D {
    public:
        T&amp;amp; operator[](int index);
        const T&amp;amp; operator[](int index) const;
    };

    Array1D operator[](int index);
    const Array1D operator[](int index) const;
    ...
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then it is legal to write code like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;Array2D&amp;lt;float&amp;gt; data(10, 20);
...
cout &amp;lt;&amp;lt; data[3][6];
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Conceptually intances of &lt;code&gt;Array1D&lt;/code&gt; class (which is a &lt;em&gt;proxy class&lt;/em&gt;) do not exist for clients of &lt;code&gt;Array2D&lt;/code&gt;. Such clients program as if they were using real, live two-dimensional arrays.&lt;/p&gt;

&lt;h1 id=&#34;distinguishing-reads-from-writes-via-operator&#34;&gt;Distinguishing Reads from Writes via operator[]&lt;/h1&gt;

&lt;p&gt;&lt;code&gt;operator[]&lt;/code&gt; can be called in two different contexts:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;em&gt;rvalue&lt;/em&gt; usage for read&lt;/li&gt;
&lt;li&gt;&lt;em&gt;lvalue&lt;/em&gt; usage for write&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;In general, using an object as an lvalue means using it such that it might be modified, and using it as rvalue means using it such that it cannot be modified.&lt;/p&gt;

&lt;p&gt;From MECpp item 29 reference counting, we can see reads can be much less expensive than writes - writes of reference-counted object may involve copying an entire data structure, while reads never require more than the simple returning of a value - so it will save a lot to differentiate lvalue usage from rvalue usage. However, it is impossible to tell whether &lt;code&gt;operator[]&lt;/code&gt; is beeing invoked in an lvalue or an rvalue context from within &lt;code&gt;operator[]&lt;/code&gt; - &lt;code&gt;operator[]&lt;/code&gt; alone does not have the ability to determine the calling context.&lt;/p&gt;

&lt;p&gt;The solution: we &lt;em&gt;delay&lt;/em&gt; our lvalue-vs-rvalue actions until we see how the result of &lt;code&gt;operator[]&lt;/code&gt; is used - by using proxy class to postpone our decision until &lt;em&gt;after&lt;/em&gt; &lt;code&gt;operator[]&lt;/code&gt; has returned (lazy evaluation, see MECpp item 7):&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class String {   // reference-counted strings
public:

    class CharProxy {   // proxy fro string chars
    public:
        CharProxy(String&amp;amp; str, int index);  // creation
        CharProxy&amp;amp; operator=(const CharProxy&amp;amp; rhs); // lvalue uses
        CharProxy&amp;amp; operator=(char c);  // lvalue uses
        operator char() const; // rvalue uses
    private:
        String&amp;amp; theString;  // string this proxy pertains to        
        int charIndex;  // char within that string this proxy stands for
    };

    const CharProxy operator[](int index) const; // for const Strings
    CharProxy operator[](int index);  // for non-const Strings
    ...
    friend class CharProxy; // CharProxy need access to private data member: value
private:
    RCPtr&amp;lt;StringValue&amp;gt; value;
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now let&amp;rsquo;s see how it works. Given reference-counted stirngs using proxies above &lt;code&gt;String s1, s2;&lt;/code&gt;,&lt;/p&gt;

&lt;h2 id=&#34;for-rvalue-usage&#34;&gt;For rvalue usage&lt;/h2&gt;

&lt;p&gt;Consider this statement &lt;code&gt;cout &amp;lt;&amp;lt; s1[5];&lt;/code&gt;: &lt;code&gt;s1[5]&lt;/code&gt; yields a &lt;code&gt;CharProxy&lt;/code&gt; object, and compiler implicitly converts this &lt;code&gt;CharProxy&lt;/code&gt; into &lt;code&gt;char&lt;/code&gt; using the conversion operator declared in the &lt;code&gt;CharProxy&lt;/code&gt; class. This is representitive of the &lt;em&gt;CharProxy-to-char&lt;/em&gt; conversion that takes place for all &lt;code&gt;CharProxy&lt;/code&gt; objects used as rvalues.&lt;/p&gt;

&lt;h2 id=&#34;for-lvalue-usage&#34;&gt;For lvalue usage&lt;/h2&gt;

&lt;p&gt;Lvalue usage is handled differently:&lt;/p&gt;

&lt;p&gt;Say, for statement &lt;code&gt;s2[5] = &#39;x&#39;;&lt;/code&gt;, the expression &lt;code&gt;s2[5]&lt;/code&gt; yields a &lt;code&gt;CharProxy&lt;/code&gt; object, which is the target of an assignment, so the assignment operator in the &lt;code&gt;CharProxy&lt;/code&gt; class will be called - this is the crucial postponed step to differentiate writes from reads. Inside this &lt;code&gt;CharProxy&lt;/code&gt; assignment operator, we know the string character for which the proxy stands is being used as an lvalue.&lt;/p&gt;

&lt;p&gt;Similarly, the statement &lt;code&gt;s1[3] = s2[7];&lt;/code&gt; calls the assignment operator for two &lt;code&gt;CharProxy&lt;/code&gt; objects, and inside the operator, we know the object on the left is being used as an lvalue and the object on the right as an rvalue.&lt;/p&gt;

&lt;p&gt;Now that we know exactly the context in which caller invokes the &lt;code&gt;operator[]&lt;/code&gt;, it is easy to implement them:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;const String::CharProxy String::operator[](int index) const
{
    // return a const proxy
    // Because CharProxy::operator= isn&#39;t a const member function,
    // the returned proxies can&#39;t be used as the target of assignment, and this behavior is exactly what we want for const version of operator[]
    return CharProxy(const_cast&amp;lt;String&amp;amp;&amp;gt;(*this), index);
}

String::CharProxy String::operator[](int index)
{
    return CharProxy(*this, index);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;String::CharProxy::CharProxy(String&amp;amp; str, int index)
: theString(str), charIndex(index) {}

String::CharProxy::operator char() const
{
    return theString.value-&amp;gt;data[charIndex];
}

String::CharProxy&amp;amp; String::CharProxy::operator=(const CharProxy&amp;amp; rhs)
{
    if (theString.value-&amp;gt;isShared())
    {
        theString.value = new StringValue(theString.value-&amp;gt;data);
    }
    theString.value-&amp;gt;data[charIndex] = 
        rhs.theString.value-&amp;gt;data[charIndex];
    return *this;
}

String::CharProxy&amp;amp; String::CharProxy::operator=(char c)
{
    if (theString.value-&amp;gt;isShared())
    {
        theString.value = new StringValue(theString.value-&amp;gt;data);
    }
    theString.value-&amp;gt;data[charIndex] = c;
    return *this;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;preventing-implicit-conversions-in-single-argument-constructor&#34;&gt;Preventing implicit conversions in single-argument constructor&lt;/h1&gt;

&lt;p&gt;Refer to MECpp item 5.&lt;/p&gt;

&lt;h1 id=&#34;limitations&#34;&gt;Limitations&lt;/h1&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Taking the address&lt;/p&gt;

&lt;p&gt;In general, taking the address of a proxy yields a different type of pointer than does taking the address of a real object. Thus, the statement &lt;code&gt;char *p = &amp;amp;s1[1];&lt;/code&gt; will cause error. To eliminate the problem, we&amp;rsquo;ll have to overload the address-of operators for &lt;code&gt;CharProxy&lt;/code&gt; class:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class String {
public:
    ...
    class CharProxy {
        char * operator&amp;amp;();
        const char * operator&amp;amp;() const;
        ...
    };
    ...
};
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;const char * String::CharProxy::operator&amp;amp;()
{
    return &amp;amp;(theString.value-&amp;gt;data[charIndex]);
}
char * String::CharProxy::operator&amp;amp;()
{
    if (theString.value-&amp;gt;isShared())
    {
        theString.value = new StringValue(theString.value-&amp;gt;data);
    }
    theString.value-&amp;gt;markUnshareable(); 
    return &amp;amp;(theString.value-&amp;gt;data[charIndex]);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Integrating with templates&lt;/p&gt;

&lt;p&gt;If we have a template for reference-counted arrays that use proxy classes to distringuish lvalue and rvalue invocations of operator[]:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;template&amp;lt;class T&amp;gt;
class Array {
public:
    class Proxy {
    public:
        Proxy(Array&amp;lt;T&amp;gt;&amp;amp; array, int index);
        Proxy&amp;amp; operator=(const T&amp;amp; rhs);
        operator T() const;
        ...
    };
    const Proxy operator[](int index) const;
    Proxy operator[](int index);
    ...
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then for &lt;code&gt;Array&amp;lt;int&amp;gt; intArray;&lt;/code&gt;, we can&amp;rsquo;t make statement such as &lt;code&gt;intArray[5] += 5;&lt;/code&gt; or &lt;code&gt;++intArray[5];&lt;/code&gt;, since &lt;code&gt;operator+=&lt;/code&gt; and &lt;code&gt;operator++&lt;/code&gt; is not defined for proxy objects. To solve this problem, we have to define each of these functions for the &lt;code&gt;Array&amp;lt;T&amp;gt;::Proxy&lt;/code&gt;, which, unfortunately, is a lot of work.&lt;/p&gt;

&lt;p&gt;Similarly, we can&amp;rsquo;t invoke member functions on real objects through  proxies. For an array taking &lt;code&gt;Rational&lt;/code&gt; as elements (&lt;code&gt;Array&amp;lt;Rational&amp;gt; array;&lt;/code&gt;), there is no way to invoke &lt;code&gt;Rational&lt;/code&gt;&amp;rsquo;s member function like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;cout &amp;lt;&amp;lt; array[4].numerator();  // error!
int denom = array[22].denominator();  // error!
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The solution is similar: we need to overload these functions so that they also apply to proxies.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Passed to functions taking references to non-const objects&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;void swap(char&amp;amp; a, char&amp;amp; b);
String s = &amp;quot;+C+&amp;quot;;
swap(s[0], s[1]);  // won&#39;t compile
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A &lt;code&gt;CharProxy&lt;/code&gt; may be implicitly converted into a &lt;code&gt;char&lt;/code&gt;, but there is no conversion function to a &lt;code&gt;char&amp;amp;&lt;/code&gt;. Further more, the &lt;code&gt;char&lt;/code&gt; to which it may be converted can&amp;rsquo;t be bound to swap&amp;rsquo;s &lt;code&gt;char&amp;amp;&lt;/code&gt; parameters, because that &lt;code&gt;char&lt;/code&gt; is a temporary object (&lt;code&gt;operator char&lt;/code&gt; returns by value,) and, as MECpp item 19 explains, temporary objects are refused to be bound to non-const reference parameters.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Implicit type conversions&lt;/p&gt;

&lt;p&gt;The process where a proxy object implicitly converted into the real object it stands for, a user-defined conversion function is invoked. As MECpp item 5 explains, only one user-defined conversion function is used by compiler when implicitly converting a parameter at a call site into the type needed by the corresponding function parameter.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;</description>
    </item>
    
    <item>
      <title>[MECpp]Item-29 Reference Counting</title>
      <link>http://nianze.tk/2018/05/reference-counting/</link>
      <pubDate>Mon, 07 May 2018 00:00:00 +0000</pubDate>
      
      <guid>http://nianze.tk/2018/05/reference-counting/</guid>
      <description>&lt;p&gt;Reference counting is technique that allows multiple objects with the same value to share a sinple representation of that value.

&lt;!-- toc --&gt;&lt;/p&gt;

&lt;p&gt;Consider a customized naive version of &lt;code&gt;class String;&lt;/code&gt;: its assignment operator is implemented in a naive way:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class String {
public:
    String(const char *value = &amp;quot;&amp;quot;);
    String&amp;amp; operator=(const String&amp;amp; rhs);
    ...
private:
    char *data;
};

String&amp;amp; String::operator=(const String&amp;amp; rhs)
{
    if (this == &amp;amp;rhs) return *this;

    delete[] data;
    data = new char[strlen(rhs.data)+1];
    strcpy(data, rhs.data);
    return *this;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;When we write statement &lt;code&gt;a = b = c = d = e = &amp;quot;Hello&amp;quot;;&lt;/code&gt; where &lt;code&gt;a&lt;/code&gt;, &lt;code&gt;b&lt;/code&gt;, &lt;code&gt;c&lt;/code&gt;, &lt;code&gt;d&lt;/code&gt; and &lt;code&gt;e&lt;/code&gt; are all &lt;code&gt;String&lt;/code&gt; type, we get five objects, each with the same value &amp;ldquo;Hello&amp;rdquo;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;┌───┐     ┌───────┐   ┌───┐     ┌───────┐
│ a │ --&amp;gt; │ Hello │   │ b │ --&amp;gt; │ Hello │ 
└───┘     └───────┘   └───┘     └───────┘
┌───┐     ┌───────┐   ┌───┐     ┌───────┐
│ c │ --&amp;gt; │ Hello │   │ d │ --&amp;gt; │ Hello │ 
└───┘     └───────┘   └───┘     └───────┘
┌───┐     ┌───────┐
│ e │ --&amp;gt; │ Hello │
└───┘     └───────┘
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ideally, we&amp;rsquo;d like to change the picture to look like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;┌───┐    
│ a ├──┐
└───┘  | 
┌───┐  | 
│ c ├──┤
└───┘  | 
┌───┐  |  ┌───────┐
│ e ├──┼─&amp;gt;│ Hello │
└───┘  |  └───────┘
┌───┐  | 
│ e ├──┤
└───┘  │ 
┌───┐  │ 
│ e ├──┘
└───┘    
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In practice, we need to keep track of how many objects are sharing - &lt;em&gt;refering to&lt;/em&gt;- a value to make sure the best time to destroy or modify the value &amp;ldquo;Hello&amp;rdquo;, so we need to add &lt;em&gt;reference count&lt;/em&gt; into the picuture:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;┌───┐    
│ a ├──┐
└───┘  | 
┌───┐  | 
│ c ├──┤
└───┘  | 
┌───┐  |  ┌───┐    ┌───────┐
│ c ├──┼─&amp;gt;│ 5 ├───&amp;gt;│ Hello │
└───┘  |  └───┘    └───────┘
┌───┐  | 
│ d ├──┤
└───┘  │ 
┌───┐  │ 
│ e ├──┘
└───┘    
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;implementing-reference-counting&#34;&gt;Implementing Reference Counting&lt;/h1&gt;

&lt;p&gt;From the picture above, we can see we need one reference count per string &lt;em&gt;value&lt;/em&gt;, instead of one per string &lt;em&gt;object&lt;/em&gt;. This implies a decoupling between values and reference counts, leading to our first design: nesting a &lt;code&gt;StringValue&lt;/code&gt; struct in the private part of &lt;code&gt;String&lt;/code&gt; class, so that all the members of &lt;code&gt;String&lt;/code&gt; class get full access to this inner data structure, while everybody else get denied (except friends of the class).&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class String {
public:
    ...
private:
    struct StringValue { // holds a reference count and a string value
        size_t refCount;
        char *data;
        StringValue(const char *initValue);
        ~StringValue();
    }
    StringValue *value;        // value of this String
};

String::StringValue::StringValue(const char *initValue)
: refCount(1)
{
    data = new char[strlen(initValue)+1];
    strcpy(data, initValue);
}

String::StringValue::~StringValue()
{
    delete [] data;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The primary purpose of &lt;code&gt;StringValue&lt;/code&gt; is to provide a place to associate a particular value with a count of the number of &lt;code&gt;String&lt;/code&gt; objects sharing that value, so there&amp;rsquo;s need to define copy constructor or assignment operator for this inner struct, and we provide the manipulation of the &lt;code&gt;refCount&lt;/code&gt; field in &lt;code&gt;String&lt;/code&gt; class:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class String {
public:
    String(const char *initValue = &amp;quot;&amp;quot;);
    String(const String&amp;amp; rhs);
    ~String();
    String&amp;amp; operator=(const String&amp;amp; rhs);
    ...
};

String::String(const char *initValue)
: value(new StringValue(initValue))
{}

String::String(const String&amp;amp; rhs)
: value(rhs.value)
{
    ++value-&amp;gt;refCount;
}

String::~String()
{
    if (--value-&amp;gt;refCount == 0) delete value;
}

String&amp;amp; String::operator=(const String&amp;amp; rhs)
{
    if (value == rhs.value) {
        return *this;
    }

    if (--value-&amp;gt;refCount == 0) { // destroy *this&#39;s value
        delete value;             // if no one else is using it
    }

    value = rhs.value;
    ++value-&amp;gt;refCount;

    return *this;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;copy-on-write&#34;&gt;Copy-on-write&lt;/h1&gt;

&lt;p&gt;Now comes the troublesome one: an array-bracket operator([]), which allows individual characters within strings to be read and written:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class String {
public:
    const char&amp;amp; operator[](int index) const;  // for const Strings
    char&amp;amp; operator[](int index); // for non-const Strings
    ...
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It&amp;rsquo;s straightforward to implement the const version, because it&amp;rsquo;s a read-only operation:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;const char&amp;amp; String::operator[](int index) const
{
    return value-&amp;gt;data[index]; // here&#39;s no sanity checking on index, just like C++ tradition; easy to add though
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;However, since non-const version of &lt;code&gt;operator[]&lt;/code&gt; might be called to write a character, the implementation must consider more scenario to avoid modifying the value of other &lt;code&gt;String&lt;/code&gt; objects that happen to be sharing the same &lt;code&gt;StringValue&lt;/code&gt; object - since there&amp;rsquo;s no way for C++ compilers to tell us whether a particular use of &lt;code&gt;operator[]&lt;/code&gt; is for a read or a write, we must be pessimistic and assume &lt;em&gt;all&lt;/em&gt; calls to the non-const &lt;code&gt;operator[]&lt;/code&gt; are for writes (Proxy classes casn help us differentiate reads from writes, see MECpp item 30.)&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;char&amp;amp; String::operator[](int index)
{
    // if sharing a value with other String obj.
    // break off a separate copy of the value
    if (value-&amp;gt;refCount &amp;gt; 1) {
        --value-&amp;gt;refCount;
        value = new StringValue(value-&amp;gt;data);
    }
    return value-&amp;gt;data[index];
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This technique - to share a value with other objects until we have to write on our own copy of the value - is the well-knwon &lt;em&gt;copy-on-write&lt;/em&gt;, which is a specific example of &lt;em&gt;lazy evaluation&lt;/em&gt; (MECpp item 17), which is a more general approach to efficiency.&lt;/p&gt;

&lt;h1 id=&#34;pointers-references-and-copy-on-write&#34;&gt;Pointers, References, and Copy-on-write&lt;/h1&gt;

&lt;p&gt;Consider this code:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;String s1 = &amp;quot;Hello&amp;quot;;
char *p = &amp;amp;s1[1];
Stirng s2 = s1;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The data structure looks like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;┌───┐    
│s1 ├──┐  ┌───┐    ┌───────┐
└───┘  ├─&amp;gt;│ 2 ├───&amp;gt;│ Hello │
┌───┐  │  └───┘    └───────┘
│s2 ├──┘              ↑
└───┘                 p
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now there is a dangerous situation, where pointer &lt;code&gt;p&lt;/code&gt; modifies both &lt;code&gt;s1&lt;/code&gt; and &lt;code&gt;s2&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;*p = &#39;x&#39;;  // modifies both s1 and s2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To eliminate the problem, we add a flag to each &lt;code&gt;StringValue&lt;/code&gt; object indicating whether that object is shareable. Initially, the flag is set to &lt;code&gt;true&lt;/code&gt; (indicating shareable), but turn it off whenever the non-const &lt;code&gt;operator[]&lt;/code&gt; is invoked on the value represented by that object (once the flag is set to &lt;code&gt;false&lt;/code&gt;, it stays that way forever).&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class String {
public:
    struct StirngValue {
        size_t refCount;
        bool shareable;  // add this line
        char *data;
        ...
    };
    ...
};

String::StringValue::StringValue(const char *initValue)
: refCount(1),
  shareable(true) // add this line
{
    data = new char[strlen(initValue) + 1];
    strcpy(data, initValue);
}

String::String(const String&amp;amp; rhs)
{
    if (rhs.value-&amp;gt;shareable) {  // add this checking
        value = rhs.value;
        ++value-&amp;gt;refCount;
    }
    else {
        value = new StringValue(rhs.value-&amp;gt;data);
    }
}

char&amp;amp; String::operator[](int index)
{
    if (value-&amp;gt;refCount &amp;gt; 1) {
        --value-&amp;gt;refCount;
        value = new StringValue(value-&amp;gt;data);
    }
    value-&amp;gt;shareable = false;  // add this
    return value-&amp;gt;data[index];
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;a-reference-counting-base-class&#34;&gt;A Reference-Counting Base class&lt;/h1&gt;

&lt;p&gt;Reference counting is useful for more than just strings, so it&amp;rsquo;s good practice to separate reference counting code in a context-independent manner. This leads us to the design of a base class &lt;code&gt;RCObject&lt;/code&gt;. Any class wishing to take advantage of automatic reference counting may inherit from this class. Basically, for general purpose usage, &lt;code&gt;RCObject&lt;/code&gt; class should include&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;the reference count, as well as functions for incrementing and decrementing that count.&lt;/li&gt;
&lt;li&gt;the code for destroying a value when it is no longer in use (count == 0)&lt;/li&gt;
&lt;li&gt;a field that keeps track of whether this value is shareable, as well as functions to query this flag and set it to false&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class RCObject {
public:
    RCObject();
    RCObject(const RCObject&amp;amp; rhs);
    RCObject&amp;amp; operator=(const RCObject&amp;amp; rhs);
    virtual ~RCObject() = 0; // virtual shows this class is designed as a base class; pure virtual so that this class should be used only as a base class
    void addReference();
    void removeReference();
    
    void markUnshareable();
    bool isShareable() const;
    bool isShared() const;

private:
    size_t refCount;
    bool shareable;
};
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;RCObject::RCObject()
: refCount(0), shareable(true) {}

RCObject::RCObject(const RCObject&amp;amp;)
: refCount(0), shareable(true) {}

RCObject&amp;amp; RCObject::operator=(const RCObject&amp;amp;)
{ return *this; }

RCObject::~RCObject() {} // pure virtual dtor still need to be impl. see MECpp item 33

void RCObject::addReference() { ++refCount; }

void RCObject::removeReference() 
{ if(--refCount == 0) delete this; }

void RCObject::markUnshareable()
{ shareable = false; }

bool RCObject::isShareable() const
{ return shareable; }

bool RCObject::isShared() const
{ return refCount &amp;gt; 1; }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In this design, there are a few things worth noting:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;The &lt;code&gt;refCount&lt;/code&gt; is set to 0 in both constructors to simplifies the set up process for the creaters of &lt;code&gt;RCObject&lt;/code&gt;s when they set &lt;code&gt;refCount&lt;/code&gt; to 1 themselves&lt;/li&gt;
&lt;li&gt;Copy constructor sets &lt;code&gt;refCount&lt;/code&gt; to 0, because this function is meant to create a new object representing a value, which is always unshared and referenced only by their creator (who will set up &lt;code&gt;refCount&lt;/code&gt; properly later).&lt;/li&gt;
&lt;li&gt;The assignment operator is unlikely to be called, since &lt;code&gt;RCObject&lt;/code&gt; is a base class for a shared &lt;em&gt;value&lt;/em&gt; object, which means in a reference counting system, it is usually the object pointing to these base-class objects that are assigned to one another, with only &lt;code&gt;refCount&lt;/code&gt; being modified as a result. We don&amp;rsquo;t declare assignment operator &lt;code&gt;private&lt;/code&gt;, because there&amp;rsquo;s a chance that someone does have a reason to allow assignment of reference-counted values(e.g., change the string value stored inside &lt;code&gt;StringValue&lt;/code&gt; in the example above), so we adopt this &amp;ldquo;do nothing&amp;rdquo; implementation, which is exactly the right thing to do, because the assignment of value objects doesn&amp;rsquo;t affect the reference count of objects pointing to either &lt;code&gt;lhs&lt;/code&gt; or &lt;code&gt;rhs&lt;/code&gt; of assignment operation: this base-class level assignment is meant to change &lt;code&gt;lhs&lt;/code&gt;&amp;rsquo;s value, meaning all the objects pointing to &lt;code&gt;lhs&lt;/code&gt; now pointing to a new value.&lt;/li&gt;
&lt;li&gt;Here we use &lt;code&gt;delete this;&lt;/code&gt; for &lt;code&gt;removeReference&lt;/code&gt;, which is safe only if we know that &lt;code&gt;*this&lt;/code&gt; is a heap object. In order to ensure this, we might need technichs discussed in MECpp item 27 to restrict &lt;code&gt;RCObject&lt;/code&gt; to be created only on the heap&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:1&#34;&gt;&lt;a href=&#34;#fn:1&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Now taking advantage of this new reference-counting base class, we modify &lt;code&gt;StringValue&lt;/code&gt; to inherit its reference counting capabilities from &lt;code&gt;RCObject&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class String {
private:
    struct StringValue: public RCObject {
        char *data;
        StringValue(const char *initValue);
        ~StringValue();
    };
...
};

String::StringValue::StringValue(const char *initValue)
{
    data = new char[strlen(initValue) + 1];
    strcpy(data, initValue);
}

String::StringValue::~StringValue()
{
    delete [] data;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;After this change, &lt;code&gt;RCObject&lt;/code&gt; now provide the manipulation ability of the &lt;code&gt;refCount&lt;/code&gt; field, instead of &lt;code&gt;StringValue&lt;/code&gt;.&lt;/p&gt;

&lt;h1 id=&#34;automating-reference-count-manipulations&#34;&gt;Automating Reference Count Manipulations&lt;/h1&gt;

&lt;p&gt;The &lt;code&gt;RCObject&lt;/code&gt; class only gives us a place to store a reference count, as well as the member functions to manipulate the &lt;code&gt;refCount&lt;/code&gt; field. However, the &lt;em&gt;calls&lt;/em&gt; to these functions must still be mannually inserted in other classes: &lt;code&gt;String&lt;/code&gt; copy constructor and assignment operator need to call &lt;code&gt;addReference&lt;/code&gt; and &lt;code&gt;removeReference&lt;/code&gt; on &lt;code&gt;StringValue&lt;/code&gt; objects, which is not good practice for reuse.&lt;/p&gt;

&lt;p&gt;To remove such manual works, we introduce &lt;em&gt;smart pointer&lt;/em&gt; for help:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;// template class for smart pointers-to-T object. T must
// support the RCObject interface, typically by inheriting from RCObject
template&amp;lt;class T&amp;gt;
class RCPtr {
public:
    RCPtr(T* realPtr = 0);
    RCPtr(const RCPtr&amp;amp; rhs);
    ~RCPtr();

    RCPtr&amp;amp; operator=(const RCPtr&amp;amp; rhs);

    T* operator-&amp;gt;() const;
    T&amp;amp; operator*() const;
private:
    T *pointee;  // dumb pointer this object is emulating
    void init(); // common init. code
};
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;template&amp;lt;class T&amp;gt;
RCPtr&amp;lt;T&amp;gt;::RCPtr(T* realPtr): pointee(realPtr)
{
    init();
}

template&amp;lt;class T&amp;gt;
RCPtr&amp;lt;T&amp;gt;::RCPtr(const RCPtr&amp;amp; rhs): pointee(rhs.pointee)
{
    init();
}

template&amp;lt;class T&amp;gt;
void RCPtr&amp;lt;T&amp;gt;::init()
{
    if (pointee == 0) {
        return;
    }
    if (pointee-&amp;gt;isShareable() == false) {
        pointee = new T(*pointee);
    }
    pointee-&amp;gt;addReference(); // always add a new reference to the value
}

template&amp;lt;class T&amp;gt;
RCPtr&amp;lt;T&amp;gt;&amp;amp; RCPtr&amp;lt;T&amp;gt;::operator=(const RCPtr&amp;amp; rhs)
{
    if (pointee != rhs.pointee)
        T *oldPointee = pointee;
        pointee = rhs.pointee;
        init();  // if possible, share it; else make own copy
        if (oldPointee) {
            oldPointee-&amp;gt;removeReference();
        }
    }
    return *this;
}

template&amp;lt;class T&amp;gt;
RCPtr&amp;lt;T&amp;gt;::~RCPtr()
{
    if (pointee) pointee-&amp;gt;removeReference();
}

template&amp;lt;class T&amp;gt;
T* RCPtr::operator-&amp;gt;() const { return pointee; }

template&amp;lt;class T&amp;gt;
T&amp;amp; RCPtr::operator*() const { return *pointee; }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;There are three assumptions in this implementation:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;code&gt;T&lt;/code&gt; has a deep-copying constructor, because &lt;code&gt;pointee = new T(*pointee);&lt;/code&gt; will call &lt;code&gt;T&lt;/code&gt;&amp;rsquo;s copy constructor. In the example above, &lt;code&gt;String::StringValue&lt;/code&gt; lack such a user-defined copy constructor, and compiler generated default copy constructor will not copy &lt;code&gt;char*&lt;/code&gt; string &lt;code&gt;data&lt;/code&gt; points to, so we need to add a customized version of copy constructor:
&lt;code&gt;cpp
String::StringValue::StirngValue(const StringValue&amp;amp; rhs)
{
data = new char(strlen(rhs.data) + 1);
strcpy(data, rhs.data);
}
&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;For the same statement calling &lt;code&gt;T&lt;/code&gt;&amp;rsquo;s copy constructor, we assume the type of &lt;code&gt;*pointee&lt;/code&gt; is &lt;code&gt;T&lt;/code&gt; rather than &lt;code&gt;T&lt;/code&gt;&amp;rsquo;s derived class. If, however, chances are &lt;code&gt;poinee&lt;/code&gt; might point to &lt;code&gt;T&lt;/code&gt;&amp;rsquo;s derived class instances, we need to use a virtual copy constructor.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;T&lt;/code&gt; should prove all the functionality that &lt;code&gt;RCObject&lt;/code&gt; does, either or not by inheriting from &lt;code&gt;RCObject&lt;/code&gt;.&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&#34;puting-everyting-together&#34;&gt;Puting Everyting Together&lt;/h1&gt;

&lt;pre&gt;&lt;code&gt;                     ┌──────────┐  
┌──────────┐         │ RCObject │ 
│  String  │         │  class   │
│  object  │         └──────────┘
│          │              ↑ public inheritance
│ ┌─────┐  │         ┌───────────┐         ┌────────────┐
│ │RCPtr├──┼────────&amp;gt;│StringValue├────────&amp;gt;| Heap Memory|
│ └─────┘  │ pointer │  object   | pointer └────────────┘
└──────────┘         └───────────┘ 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The class declaration looks like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;template&amp;lt;class T&amp;gt;
class RCPtr {
public:
    RCPtr(T* realPtr = 0);
    RCPtr(const RCPtr&amp;amp; rhs);
    RCPtr&amp;amp; operator=(const RCPtr&amp;amp; rhs);
    ~RCPtr();

    T* operator-&amp;gt;() const;
    T&amp;amp; operator*() const;
private:
    T *pointee;
    void init();
};

class RCObject {
public:
    RCObjet();
    RCObject(const RCObject&amp;amp; rhs);
    RCObject&amp;amp; operator=(const RCOBject&amp;amp; rhs);
    virtual ~RCObject() = 0;

    void addReference();
    void removeReference();

    void markUnshareable();
    bool isShareable() const;
    bool isShared() const;
private:
    size_t refCount;
    bool shareable;
};

class String {
public:
    String(const char *value = &amp;quot;&amp;quot;);

    const char&amp;amp; operator[](int index) const;
    char&amp;amp; operator[](int index);
private:
    // class representing string value
    struct StringValue: public RCObject {
        char *data;

        StringValue(const char *initValue);
        StringValue(const StringValue&amp;amp; rhs);
        void init(const char *initValue);
        ~StringValue();
    };
    RCPtr&amp;lt;StringValue&amp;gt; value;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It is worth to note that we don&amp;rsquo;t need the copy constructor or assignment operator for &lt;code&gt;String&lt;/code&gt; anymore: compiler-generated copy constructor for &lt;code&gt;Stirng&lt;/code&gt; will automatically call the copy constructor for &lt;code&gt;Stirng&lt;/code&gt;&amp;rsquo;s &lt;code&gt;RCPtr&lt;/code&gt; member, and the copy constructor for &lt;em&gt;that&lt;/em&gt; class will perform all the necessary manipulations of the &lt;code&gt;StringValue&lt;/code&gt; object, including its reference count, and the same goes for assignment and destruction. That&amp;rsquo;s why it is called &lt;em&gt;smart&lt;/em&gt; pointer.&lt;/p&gt;

&lt;p&gt;Now here is all the implementation:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;RCObject::RCObject()
: refCount(0), shareable(true) {}

RCObject::RCObject(const RCObject&amp;amp;)
: refCount(0), shareable(true) {}

RCObject&amp;amp; RCObject::operator=(const RCObject&amp;amp;)
{ return *this; }

RCObject::~RCObject() {}

void RCObject::addReference() { ++refCount; }

void RCObject::removeReference() 
{ if (--refCount == 0) delete this; }

void RCObject::markUnshareable()
{ shareable = false; }

bool RCObject::isShareable() const
{ return shareable; }

bool RCObject::isShared() const
{ return refCount &amp;gt; 1; }
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;template&amp;lt;class T&amp;gt;
void RCPtr&amp;lt;T&amp;gt;::init()
{
    if (pointee == 0) {
        return;
    }
    if (pointee-&amp;gt;isShareable() == false) {
        pointee = new T(*pointee);
    }
    pointee-&amp;gt;addReference(); 
}
template&amp;lt;class T&amp;gt;
RCPtr&amp;lt;T&amp;gt;::RCPtr(T* realPtr): pointee(realPtr)
{ init(); }

template&amp;lt;class T&amp;gt;
RCPtr&amp;lt;T&amp;gt;::RCPtr(const RCPtr&amp;amp; rhs): pointee(rhs.pointee)
{ init(); }


template&amp;lt;class T&amp;gt;
RCPtr&amp;lt;T&amp;gt;&amp;amp; RCPtr&amp;lt;T&amp;gt;::operator=(const RCPtr&amp;amp; rhs)
{
    if (pointee != rhs.pointee)
        T *oldPointee = pointee;
        pointee = rhs.pointee;
        init();  // if possible, share it; else make own copy
        if (oldPointee) {
            oldPointee-&amp;gt;removeReference();
        }
    }
    return *this;
}

template&amp;lt;class T&amp;gt;
RCPtr&amp;lt;T&amp;gt;::~RCPtr()
{ if (pointee) pointee-&amp;gt;removeReference(); }

template&amp;lt;class T&amp;gt;
T* RCPtr::operator-&amp;gt;() const { return pointee; }

template&amp;lt;class T&amp;gt;
T&amp;amp; RCPtr::operator*() const { return *pointee; }
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;void String::StringValue::init(const char *initValue) // ctor and deep copy ctor share this same init function
{
    data = new char[strlen(initValue) + 1];
    strcpy(data, initValue);
}

String::StringValue::StringValue(const char *initValue)
{ init(initValue); }

String::StringValue::StringValue(const StringValue&amp;amp; rhs)
{ init(rhs.data); }

String::StringValue::~StringValue()
{ delete [] data; }
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;String::String(const char *initValue)
: value(new StringValue(initValue)) {}

const char&amp;amp; String::operator[](int index) const
{ return value-&amp;gt;data[index]; }

char&amp;amp; String::operator[](int index)
{
    if (value-&amp;gt;isShared()) {
        value = new StirngValue(value-&amp;gt;data);
    }
    value-&amp;gt;markUnshareable();
    return value-&amp;gt;data[index];
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;adding-refenrence-counting-to-existing-classes&#34;&gt;Adding Refenrence Counting to Existing Classes&lt;/h1&gt;

&lt;p&gt;Given some class &lt;code&gt;Widget&lt;/code&gt; that&amp;rsquo;s in a library we can&amp;rsquo;t modify, and suppose we want to apply the benefits of reference counting to &lt;code&gt;Widget&lt;/code&gt; without being able to inherit &lt;code&gt;Widget&lt;/code&gt; from &lt;code&gt;RCObject&lt;/code&gt;, we solve the problem with an additional level of indirection by adding a new class &lt;code&gt;CountHolder&lt;/code&gt;, which does three jobs:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Hold the reference&lt;/li&gt;
&lt;li&gt;Inherit from &lt;code&gt;RCObject&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Contain a pointer to a &lt;code&gt;Widget&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;The only thing left to do is just an equivalent smart pointer as &lt;code&gt;RCPtr&lt;/code&gt;, and we call it &lt;code&gt;RCIPtr&lt;/code&gt;, where &amp;ldquo;I&amp;rdquo; stands for &amp;ldquo;indirect&amp;rdquo;. Thus, we get someting like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;                     ┌──────────┐  
┌──────────┐         │ RCObject │ 
│ RCWidget │         │  class   │
│  object  │         └──────────┘
│ ┌──────┐ │              ↑ public inheritance
│ |RCIPtr| │         ┌───────────┐         ┌─────────────┐
│ |Object├─┼────────&amp;gt;│CountHolder├────────&amp;gt;|Widget Object|
│ └──────┘ │ pointer │  object   | pointer └─────────────┘
└──────────┘         └───────────┘ 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Since here &lt;code&gt;CountHolder&lt;/code&gt; is just an implementation detial of &lt;code&gt;RCIPtr&lt;/code&gt;, we can simply nested it inside &lt;code&gt;RCIPtr&lt;/code&gt;, just as how &lt;code&gt;StringValue&lt;/code&gt; relates with &lt;code&gt;String&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;template&amp;lt;class T&amp;gt;
class RCIPtr {
public:
    RCIPtr(T* realPtr = 0);
    RCIPtr(const RCIPtr&amp;amp; rhs);
    ~RCIPtr();

    RCIPtr&amp;amp; operator=(const RCIPtr&amp;amp; rhs);

    T* operator-&amp;gt;() const;
    T&amp;amp; operator*() const;

    RCObject&amp;amp; getRCObject();  // give clients access
    { return *counter; }      // isShared, etc.
private:
    struct CountHolder: public RCObject {
        ~CountHolder() { delete pointee; }
        T *pointee;
    };
    CountHolder *counter;
    void init();
};

template&amp;lt;class T&amp;gt;
void RCIPtr&amp;lt;T&amp;gt;::init()
{
    if (counter-&amp;gt;iShareable() == false) {
        T *oldValue = counter-&amp;gt;pointee;
        counter = new CountHolder;
        counter-&amp;gt;pointee = oldValue ? new T(*oldValue) : 0;
    }
    counter-&amp;gt;addReference();
}

template&amp;lt;class T&amp;gt;
RCIPtr&amp;lt;T&amp;gt;::RCIPtr(T* realPtr)
: counter(new CountHolder)
{
    counter-&amp;gt;ponitee = realPtr;
    init();
}

template&amp;lt;class T&amp;gt;
RCIPtr&amp;lt;T&amp;gt;::RCIPtr(const RCIPtr&amp;amp; rhs)
: counter(rhs.counter)
{ init(); }

template&amp;lt;class T&amp;gt;
RCIPtr&amp;lt;T&amp;gt;::~RCIPtr()
{ counter-&amp;gt;removeReference(); }

template&amp;lt;class T&amp;gt;
RCIPtr&amp;lt;T&amp;gt;&amp;amp; RCIPtr&amp;lt;T&amp;gt;::operator=(const RCIPtr&amp;amp; rhs)
{
    if (counter != rhs.counter) {
        counter-&amp;gt;removeReference();
        counter = rhs.counter;
        init();
    }
    return *this;
}

template&amp;lt;class T&amp;gt;
T* RCIPtr&amp;lt;T&amp;gt;::operator-&amp;gt;() const
{ return counter-&amp;gt;pointee; }

template&amp;lt;class T&amp;gt;
T&amp;amp; RCIPtr&amp;lt;T&amp;gt;::operator*() const
{ return *(counter-&amp;gt;pointee); }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then, for a library class &lt;code&gt;Widget&lt;/code&gt; with following interface:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class Widget {
public:
    Widget(int size);
    Widget(const Widget&amp;amp; rhs);
    ~Widget();

    Widge&amp;amp; operator=(const Widget&amp;amp; rhs);

    void doThis();
    int showThat() const;
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We can implementing wrapper &lt;code&gt;RCWidget&lt;/code&gt; by simply forwarding the call through underlying &lt;code&gt;RCIPtr&lt;/code&gt; to a &lt;code&gt;Widget&lt;/code&gt;object:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class RCWidget {
public:
    RCWidget(int size): value(new Widget(size)) {}

    void doThis()
    {
        if (value.getRCObject().isShared()) {
            value = new Widget(*value);
        }
        value-&amp;gt;doThis();
    }
    int showThat() const { return value-&amp;gt;showThat(); }
private:
    RCIPtr&amp;lt;Widget&amp;gt; value;
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As with &lt;code&gt;Stirng&lt;/code&gt; class, there&amp;rsquo;s no need to write copy constructor, assignment operator, or destructor, because the default versions do the right thing.&lt;/p&gt;
&lt;div class=&#34;footnotes&#34;&gt;

&lt;hr /&gt;

&lt;ol&gt;
&lt;li id=&#34;fn:1&#34;&gt;In this example, we guarantee the value objects should be created only via &lt;code&gt;new&lt;/code&gt; by declaring &lt;code&gt;StringValue&lt;/code&gt; as &lt;code&gt;private&lt;/code&gt; in &lt;code&gt;String&lt;/code&gt;, so only &lt;code&gt;String&lt;/code&gt; can create &lt;code&gt;StringValue&lt;/code&gt; objects and the auther of the &lt;code&gt;String&lt;/code&gt; class is able to ensure all such objects are allocated via &lt;code&gt;new&lt;/code&gt;.
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:1&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;</description>
    </item>
    
    <item>
      <title>[MECpp]Item-28 Smart Pointers</title>
      <link>http://nianze.tk/2018/05/smart-pointers/</link>
      <pubDate>Sat, 05 May 2018 16:38:03 -0400</pubDate>
      
      <guid>http://nianze.tk/2018/05/smart-pointers/</guid>
      <description>&lt;p&gt;&lt;em&gt;Smart pointers&lt;/em&gt; are designed to look, act, and feel like built-in pointers, but to offer greater functionality.

&lt;!-- toc --&gt;&lt;/p&gt;

&lt;h1 id=&#34;advantages-of-smart-pointers&#34;&gt;Advantages of smart pointers&lt;/h1&gt;

&lt;p&gt;With the help of smart pointers, we gain control over the following aspects of pointer behavior:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Construction and destrucrtion (default value, reference counting, etc)&lt;/li&gt;
&lt;li&gt;Copying and assignment (deep copy, not allowed to copy, etc)&lt;/li&gt;
&lt;li&gt;Dereferencing (lazy fetching, etc)&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;using-smart-pointer-in-client-perspective&#34;&gt;Using smart pointer in client perspective&lt;/h2&gt;

&lt;p&gt;Consider a distributed system in which some objects are local and some are remote. We can use smart pointer to manage the local and remote objects handling in order to offer such an illusion that all objects appear to be located in the same place.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;template&amp;lt;class T&amp;gt;            // template for smart ptrs
class DBPtr {                // to obj. in a distributed DB
public:
	DBPtr(T *realPtr = 0);   // create a smart ptr to a DB obj given a local dumb pointer
	DBPtr(DataBaseID id);    // create a smart ptr to a DB obj given its unique DB identifier
	...                      // other smart ptr functions
};

class Tuple { // class for database tuples
public:
	...
	void displayEditDialog();  // present a graphical dialog box allowing a user to edit the typle
	bool isValid() const;  // return whether *this passes validity check
};

// class template for making log entries whenever a T object is modified
template&amp;lt;class T&amp;gt;
class LogEntry {
public:
	LogEntry(const T&amp;amp; objectToBeModified);
	~LogEntry();
};

void editTuple(DBPtr&amp;lt;Tuple&amp;gt;&amp;amp; pt)
{
	LogEnty&amp;lt;Tuple&amp;gt; entry(*pt); // make log entry for this editing operation
	// repeatedly display edit dialog until valid values are provided
	do {
		pt-&amp;gt;displayEditDialog();
	} while (pt-&amp;gt;isValid() == false)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The tuple to ber edited inside &lt;code&gt;editTuple&lt;/code&gt; may be physically located on a remote machine, but the programmer writing &lt;code&gt;editTuple&lt;/code&gt; need not be converned with such matters. Wrapped by objects, all kinds of tuples are accessed through smart pointers, which act just like built-in pointers (except for how they&amp;rsquo;re declared).&lt;/p&gt;

&lt;p&gt;Notice the use of &lt;code&gt;LogEntry&lt;/code&gt; object here is to take the advantage of &lt;code&gt;LogEntry&lt;/code&gt;&amp;rsquo;s constructor and destructor to begin and end the log entry, which is more robust in the face of exceptions than explicitly calling functions (MECpp item 9).&lt;/p&gt;

&lt;p&gt;In a word, clients of smart pointers are &lt;em&gt;supposed&lt;/em&gt; to be able to treat them as dumb pointers.&lt;/p&gt;

&lt;h1 id=&#34;construction-assignment-and-destruction-of-smart-pointers&#34;&gt;Construction, assignment, and destruction of smart pointers&lt;/h1&gt;

&lt;p&gt;Construction of a smart pointer is usually straightforward: locate an object to point to, then make the smart pointer&amp;rsquo;s internal dumb pointer point there. If no object can be located, set the internal pointer to 0 or signal an error (by throwing an exception).&lt;/p&gt;

&lt;p&gt;However, the issue of &lt;em&gt;ownership&lt;/em&gt; makes it complicated to implement a smart pointer&amp;rsquo;s copy constructor, assignment operator(s), and destructor: depending on wheter a smart pointer &lt;em&gt;owns&lt;/em&gt; the object it points to, should it delete the object when the smart pointer itself is destroyed?&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;if we just copied the internal dumb pointer in copy constructor and call &lt;code&gt;delete&lt;/code&gt; in destructor, we end up with two smart pointers pointing to the same object, resulting to multiple deletes, which is undefined behavior.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;if we create a new copy of what was pointed to by calling &lt;code&gt;new&lt;/code&gt; in the copy constructor, we may have to face an unacceptable performance hit for the creation (and later destruction) of the new object. Further more, we wouldn&amp;rsquo;t know what type of object to create, because a smart pointer of type &lt;code&gt;T&lt;/code&gt; might point to an object of a type derived from &lt;code&gt;T&lt;/code&gt;. Virtual constructors can help solve this problem, but it seems inappropriate to require their use in a general-purpose smart pointer class.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The problem would vanish if we prohibit copying and assignment, but a more flexible solution was adopted by the &lt;code&gt;auto_ptr&lt;/code&gt; template from the standard C++ library: object ownership is &lt;em&gt;transferred&lt;/em&gt; when an &lt;code&gt;auto_ptr&lt;/code&gt; is copied or assigned:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;template&amp;lt;class T&amp;gt;
class auto_ptr {
public:
	auto_ptr(T *ptr = 0): pointee(ptr) {}
	auto_ptr(auto_ptr&amp;lt;T&amp;gt;&amp;amp; rhs);  // copy constructor
	auto_ptr&amp;lt;T&amp;gt;&amp;amp; operator=(auto_ptr&amp;lt;T&amp;gt;&amp;amp; rhs); // assignment operator
	~auto_ptr&amp;lt;T&amp;gt;() { delete pointee; }
private:
	T *pointee;
};

template&amp;lt;class T&amp;gt;
auto_ptr&amp;lt;T&amp;gt;::auto_ptr(auto_ptr&amp;lt;T&amp;gt;&amp;amp; rhs)
{
	pointee = rhs.pointee;
	rhs.pointee = 0;
}

template&amp;lt;class T&amp;gt;
auto_ptr&amp;lt;T&amp;gt;&amp;amp; auto_ptr&amp;lt;T&amp;gt;::operator=(auto_ptr&amp;lt;T&amp;gt;&amp;amp; rhs)
{
	if (this == &amp;amp;rhs)
		return *this;
	delete pointee;

	pointee = rhs.pointee;
	rhs.pointee = 0;

	return *this;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;For this design, there are three points woth noting:&lt;/p&gt;

&lt;h2 id=&#34;1-pass-by-reference-to-const&#34;&gt;1. Pass by reference to const&lt;/h2&gt;

&lt;p&gt;Because object ownership is transferred when &lt;code&gt;auto_ptr&lt;/code&gt;&amp;rsquo;s copy constructor is called, passing &lt;code&gt;auto_ptr&lt;/code&gt;s by value is often a very bad idea:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;void printTreeNode(ostream&amp;amp; s, auto_ptr&amp;lt;TreeNode&amp;gt; p)
{ s &amp;lt;&amp;lt; *p; }

int main()
{
	auto_ptr&amp;lt;TreeNode&amp;gt; ptn(new TreeNode);
	...
	printTreeNode(cout, ptn);  // pass auto_ptr by value
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;When &lt;code&gt;printTreeNode&lt;/code&gt;&amp;rsquo;s parameter &lt;code&gt;p&lt;/code&gt; is initialized by calling &lt;code&gt;auto_ptr&lt;/code&gt;&amp;rsquo;s copy constructor, ownership of the object pointed to by &lt;code&gt;ptn&lt;/code&gt; is transferred to &lt;code&gt;p&lt;/code&gt;. After &lt;code&gt;printTreeNode&lt;/code&gt; finishes execution, &lt;code&gt;p&lt;/code&gt; goes out of scope and its destructor deletes what it points to, so &lt;code&gt;ptn&lt;/code&gt; no longer points to anything (its underlying dumb pointer is null). This is rarely what we want to do.&lt;/p&gt;

&lt;p&gt;Instead, pass-by-reference-to-const:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;// this function behaves much more intuitively
void printTreeNode(ostream&amp;amp; s, const auto_ptr&amp;lt;TreeNode&amp;gt;&amp;amp; p)
{ s &amp;lt;&amp;lt; *p; }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Since this is pass by reference, no constructor is called to initialize &lt;code&gt;p&lt;/code&gt;, and &lt;code&gt;ptn&lt;/code&gt; retains ownership of the object it points after function execution.&lt;/p&gt;

&lt;h2 id=&#34;2-unconventional-copy-constructor-and-assignment-operator&#34;&gt;2. Unconventional copy constructor and assignment operator&lt;/h2&gt;

&lt;p&gt;Normally the copy constructor and assignment operator take &lt;code&gt;const&lt;/code&gt; parameters during the copy or the assignment. However, &lt;code&gt;auto_ptr&lt;/code&gt; objects are modified if they are copied or are the source of an assignment, so we don&amp;rsquo;t declare &lt;code&gt;const&lt;/code&gt; here for the copy constructor and assignment operator in &lt;code&gt;auto_ptr&lt;/code&gt;.&lt;/p&gt;

&lt;h2 id=&#34;3-no-ownership-testing-in-desturctor&#34;&gt;3. No ownership testing in desturctor&lt;/h2&gt;

&lt;p&gt;An &lt;code&gt;auto_ptr&lt;/code&gt; always owns what it points to, so there is no need for the ownership test in destructor. However, a smart pointers that employs reference counting (MECpp item 29) must adjust a reference count before detrmining whether it has the right to delete what it points to, so their destructor often looks like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;tempalte&amp;lt;class T&amp;gt;
SmartPtr&amp;lt;T&amp;gt;::~SmartPtr()
{
	if (*this owns *pointee) {
		delete pointee;
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;implementing-the-dereferencing-operators&#34;&gt;Implementing the dereferencing operators&lt;/h1&gt;

&lt;h2 id=&#34;operator&#34;&gt;&lt;code&gt;operator*&lt;/code&gt;&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;template&amp;lt;class T&amp;gt;
T&amp;amp; SmartPtr&amp;lt;T&amp;gt;::operator*() const
{
	perform &amp;quot;smart pointer&amp;quot; processing;
	return *pointee;	
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A few things woth noting:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;The &amp;ldquo;smart pointer&amp;rdquo; processing does whatever is needed to initialize or otherwise make &lt;code&gt;pointee&lt;/code&gt; valid. For example, if lazy fetching is being used (MECpp item 17), the process may conjure up a new object for &lt;code&gt;pointee&lt;/code&gt; to point to.&lt;/li&gt;
&lt;li&gt;The &lt;code&gt;operator*&lt;/code&gt; returns a &lt;em&gt;reference&lt;/em&gt; to the pointed-to object, instead of an &lt;em&gt;object&lt;/em&gt;. This is for concerns of both correctness and efficiency.

&lt;ul&gt;
&lt;li&gt;Correctness: if returning an &lt;em&gt;object&lt;/em&gt;, this is possible for &lt;em&gt;slicing problem&lt;/em&gt; - see MECpp item 13 - where a &lt;code&gt;T&lt;/code&gt; object is returned instead of an actual derived class object that is expected.&lt;/li&gt;
&lt;li&gt;Efficiency: there is no need to construcrt a temporary object (MECpp 19), so returning a reference is more efficient.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;The result of dereferencing a null pointer is undefined, so we are free to do anything we want if &lt;code&gt;operator*&lt;/code&gt; is invoked with a null smart pointer. (i.e., throw an exception, call &lt;code&gt;abort&lt;/code&gt;, etc)&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;operator-1&#34;&gt;&lt;code&gt;operator-&amp;gt;&lt;/code&gt;&lt;/h2&gt;

&lt;p&gt;When we call &lt;code&gt;operator-&amp;gt;&lt;/code&gt; in the statement &lt;code&gt;pt-&amp;gt;displayEditDialog();&lt;/code&gt;, the compilers treat it as:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;(pt.operator-&amp;gt;())-&amp;gt;displayEditDialog();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This means it must be legal to apply the member-selection operator(-&amp;gt;) to whatever &lt;code&gt;operator-&amp;gt;&lt;/code&gt; returns, leading to only two options:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;a dumb pointer to an object&lt;/li&gt;
&lt;li&gt;another smart pointer object&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Most of the time we want to return an ordinary dumb pointer, so the implementation for &lt;code&gt;operator-&amp;gt;&lt;/code&gt; is:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;template&amp;lt;class T&amp;gt;
T* SmartPtr::operator-&amp;gt;() const
{
	perform &amp;quot;smart pointer&amp;quot; processing
	return pointee;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note that since this function returns a pointer, virtual function calls via &lt;code&gt;operator-&amp;gt;&lt;/code&gt; will behave the way they&amp;rsquo;re supposed to.&lt;/p&gt;

&lt;h1 id=&#34;testing-smart-pointers-for-nullness&#34;&gt;Testing smart pointers for nullness&lt;/h1&gt;

&lt;p&gt;So far we can not do the following operation to find out if a smart pointer is null:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;SmartPtr&amp;lt;TreeNode&amp;gt; ptn;
...
if (ptn == 0) ... // error!
if (ptn) ...      // error!
if (!ptn) ...     // error!
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If we want to make smart pointer act like dumb pointers when testing for nullness, an additional &lt;code&gt;isNull&lt;/code&gt; member function will not be ideal solution. We may be attempted to provide an implicit conversion operator: &lt;code&gt;operator void*()&lt;/code&gt;, but this will also introduce the draback of letting function calls succeed that most programmers would expect to fail (see MECpp item 5). In particular, it allows comparisons of smart pointers of completely different types:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;SmartPtr&amp;lt;Apple&amp;gt; pa;
SmartPtr&amp;lt;Orange&amp;gt; po;
...
if (pa == po) ... // this compiles!
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This compiles because both smart pointers can be implicitly converted into &lt;code&gt;void*&lt;/code&gt; pointers, and there is a built-in comparison function for built-in pointers. Similarly, even if we advocate conversion to &lt;code&gt;const void*&lt;/code&gt; or &lt;code&gt;bool&lt;/code&gt;, neither of these variations eliminates the problem of allowing mixed-type comparisons. There is simply too much conversion freedom in this wild solution.&lt;/p&gt;

&lt;p&gt;There is a middle middle ground that allows us to offer a reasonable syntactic form for testing for nullness while minimizing the chances of accidentally comparing smart pointers of of different types. That is to overload &lt;code&gt;operator!&lt;/code&gt; to return true if and only if the smart pointer on which it&amp;rsquo;s invoked is null:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;template&amp;lt;class T&amp;gt;
class SmartPtr {
public:
	...
	bool operator!() const; // returns true if and only if the smart ptr is null
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This will lead to:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;if (!ptn) ...  // fine
if (ptn == 0)  ...  // still an error
if (ptn) ...  // still an error
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And the only risk for mixed-type comparisons is statements such as this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;...
if (!pa == !po) ...  // this still compiles
```	

Fortunately, programmers usually don&#39;t write code like this.

# Converting smart pointers to dumb pointers

When a dump pointer is expected for some lagacy libraries (say `normalize(Tuple *pt);`), we can not simply call the library function with a smart pointer-to-`Tuple`, because there is no way to convert a `DBPtr&amp;lt;Tuple&amp;gt;` to a `Tuple*`. We can make it work by doing this:

```cpp
normalize(&amp;amp;*pt);  // gross, but legal
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;but apparently this is not elegant.&lt;/p&gt;

&lt;p&gt;A dangerous solution will be to add to the smart pointer-to-T template an implicit conversion operator to a dumb pointer-to-T:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;template&amp;lt;class T&amp;gt;
class DBPtr{
public:	
	...
	operator T*() { return pointee; }
	...
};

DBPtr&amp;lt;Tuple&amp;gt; pt;
...
normalize(pt);  // this now works
if (pt == 0) ...  // fine, too
if (pt) ... // fine, too
if (!pt) ...  // fine, too
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;However, as stated in MECpp item 5, there&amp;rsquo;s dark side to such conversion function: it&amp;rsquo;s so easy for clients to get access to dumb pointers that they bypass all the smart behavior (such as reference-counting ability) our pointer-like objects designed to provide, which will almost certainly lead to disaster (such as bookkeeping errors that corrupt the reference-counting data structures):&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;void processTuple(DBPtr&amp;lt;Tuple&amp;gt;&amp;amp; pt)
{
	Tuple *rawTuplePtr = pt;  // convert DBPtr&amp;lt;Tuple&amp;gt; to Tuple*
	use rawTuplePtr to modify the tuple;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Besides, even we provide such implicit conversion operator, our smart pointer will never be truly interchangeable with the dumb pointer: the conversion from a smart pointer to a dumb pointer is a user-defined conversion, and compilers are forbidden from applying more than one user-defined conversion at a time. Following example shows this difference, where conversion from &lt;code&gt;DBPtr&amp;lt;Tuple&amp;gt;&lt;/code&gt; to &lt;code&gt;TupleAccessors&lt;/code&gt; calls for two user-defined conversions (1. &lt;code&gt;DBTpr&amp;lt;Tuple&amp;gt;&lt;/code&gt; -&amp;gt; &lt;code&gt;Tuple*&lt;/code&gt;; 2. &lt;code&gt;Tuple*&lt;/code&gt; -&amp;gt; &lt;code&gt;TupleAccessors&lt;/code&gt;), which are prohibited by the language:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class TupleAccessors {
public:
	TupleAccessors(const Tuple *pt); // this ctor also acts as a type-conversion operator
	...
};
TupleAccessors merge(const TupleAccessors&amp;amp; ta1, const TupleAccessors&amp;amp; ta2);
...
Tuple *pt1, *pt2;
merge(pt1, pt2);  // fine, both pointers are converted to TupleAccessors objects
...
DBPtr&amp;lt;Tuple&amp;gt; smart_pt1, smart_pt2;
merge(smart_pt1, smart_pt2);  // error! no way to convert smart_pt1 and smart_pt2 to TupleAccessors implicitly
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Moreover, implicit conversion functino makes it possible to let evil statement compile, which will almost certainly break our program later&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:1&#34;&gt;&lt;a href=&#34;#fn:1&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;DBPtr&amp;lt;Tuple&amp;gt; pt = new Tuple;
...
delete pt;  // this compiles
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;All in all, keep in mind the bottom line: don&amp;rsquo;t provide implicit conversion operators to dumb pointers unless there is a compelling reason to do so.&lt;/p&gt;

&lt;h1 id=&#34;smart-pointers-and-inheritance-based-type-conversions&#34;&gt;Smart pointers and inheritance-based type conversions&lt;/h1&gt;

&lt;p&gt;Given the following public inheritance hierarchy:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class MusicProduct {
public:
	MusicProduct(const string&amp;amp; title);
	virtual void play() const = 0;
	virtual void displayTitle() const = 0;
};
class Cassette: public MusicProduct {
public:
	Cassette(const string&amp;amp; title);
	virtual void play() const;
	vitual void displayTitle() const;
	...
};
class CD: public MusicProduct {
public:
	CD(const string&amp;amp; title);
	virtual void play() const;
	virtual void displayTitle() const;
	...
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It is expected that the virtual function will work properly with dumb pointers:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;void displayAndPlay(const MusicProduct* pmp, int numTimes)
{
	for (int i = 1; i &amp;lt;= numTimes; ++i)
	{
		pmp-&amp;gt;displayTitle();
		pmp-&amp;gt;play();
	}
}

Cassette *funMusic = new Cassette(&amp;quot;Alapalooza&amp;quot;);
CD *nightmareMusic = new CD(&amp;quot;Disco Hits of the 70s&amp;quot;);

displayAndPlay(funMusic, 10);
displayAndPlay(nightmareMusic, 0);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;However, as far as compilers are converned, &lt;code&gt;SmartPtr&amp;lt;CD&amp;gt;&lt;/code&gt;, &lt;code&gt;SmartPtr&amp;lt;Cassette&amp;gt;&lt;/code&gt;, and &lt;code&gt;SmartPtr&amp;lt;MusicProduct&amp;gt;&lt;/code&gt; are three seperate classes without any relationship to one another, so if we pass an object of type &lt;code&gt;SmartPtr&amp;lt;CD&amp;gt;&lt;/code&gt; into a function with signature &lt;code&gt;void displayAndPlay(const SmartPtr&amp;lt;MusicProduct&amp;gt;, int)&lt;/code&gt;, there will be error.&lt;/p&gt;

&lt;h2 id=&#34;manually-adding-implicit-conversion-operator&#34;&gt;Manually adding implicit conversion operator&lt;/h2&gt;

&lt;p&gt;A naive solution: adding into each smart pointer class an implicit type conversion operator. Take &lt;code&gt;SmartPtr&amp;lt;Cassette&amp;gt;&lt;/code&gt; for example:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class SmartPtr&amp;lt;Cassette&amp;gt; {
public:
	operator SmartPtr&amp;lt;MusicProduct&amp;gt;()
	{ return SmartPtr&amp;lt;MusicProduct&amp;gt;(pointee); }
	...
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Yet there are two drawbacks in this design:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;manually adding the necessary implicit type conversion operators specializes the &lt;code&gt;SmartPtr&lt;/code&gt; class instantiations, which defeats the purpose of templates&lt;/li&gt;
&lt;li&gt;too many conversion operators to add - given a deep inheritance hierarchy, we must provide a conversion operator for &lt;em&gt;each&lt;/em&gt; base class from that object directly or indirectly inherits (again, compilers are prohibited from employing more than one user-defined type conversion function at a time.)&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;generating-conversion-operators-via-member-templates&#34;&gt;Generating conversion operators via member templates&lt;/h2&gt;

&lt;p&gt;The right way to take is to take advantage of &lt;em&gt;member function templates&lt;/em&gt; (or just &lt;em&gt;member templates&lt;/em&gt;):&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;template&amp;lt;class T&amp;gt;
class SmartPtr {
public:
	SmartPtr(T* realPtr = 0);
	T* operator-&amp;gt;() const;
	T* operator*() const;

	template&amp;lt;class newType&amp;gt;      // template function for
	operator SmartPtr&amp;lt;newType&amp;gt;() // implicit conversion ops.
	{
		return SmartPtr&amp;lt;newType&amp;gt;(pointee);
	}
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here&amp;rsquo;s what happens:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Compiler needs to convert a smart pointer-to-&lt;code&gt;T&lt;/code&gt; object into a smart pointer-to-base-class-of-&lt;code&gt;T&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Compiler checks the class definition for &lt;code&gt;SmartPtr&amp;lt;T&amp;gt;&lt;/code&gt; to see if the requisite conversion operator is declared -&amp;gt; it is not&lt;/li&gt;
&lt;li&gt;Compiler then checks to see if there&amp;rsquo;s a member function template it can instantiate that would perform the wanted conversion -&amp;gt; it finds a template&lt;/li&gt;
&lt;li&gt;Compiler instantiates the template with &lt;code&gt;newType&lt;/code&gt; bound to the base class of &lt;code&gt;T&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Given this instantiated member function, compiler finds it legal to pass the dumb pointer &lt;code&gt;pointee&lt;/code&gt; to the constructor for the smart pointer-to-base-of-&lt;code&gt;T&lt;/code&gt;, because &lt;code&gt;T&lt;/code&gt;-type &lt;code&gt;pointee&lt;/code&gt; is legal to be converted into a pointer to its (public or protected) base classes&lt;/li&gt;
&lt;li&gt;The code compiles -&amp;gt; the implicit conversion from smart pointer-to-&lt;code&gt;T&lt;/code&gt; to smart pointer-to-base-of-&lt;code&gt;T&lt;/code&gt; succeeds&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Note that this implicit conversion will succeed for &lt;em&gt;any&lt;/em&gt; legal implicit conversion between pointer types: if (and only if) a dumb pointer type &lt;code&gt;T1*&lt;/code&gt; can be implicitly converted to another pointer type &lt;code&gt;T2*&lt;/code&gt;, we can implicitly convert a smart pointer-to-&lt;code&gt;T1&lt;/code&gt; to a smart pointer-to-&lt;code&gt;T2&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;However, there&amp;rsquo;s still a drawback: suppose following augmented &lt;code&gt;MusicProduct&lt;/code&gt; hierarchy:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;                  ┌──────────────┐
 				  │ MusicProduct │
                  └──────────────┘
   					  ↗     ↖ 
             ┌──────────┐      ┌────┐
             │ Cassette │      │ CD │
             └──────────┘      └────┘
                   ↑
             ┌───────────┐
             │ CasSingle │
             └───────────┘
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;template&amp;lt;class T&amp;gt;      // as above, including member tempate
class SmartPtr {...};

void displayAndPlay(const SmartPtr&amp;lt;MusicProduct&amp;gt;&amp;amp; pmp, int howMany);
void displayAndPaly(const SmartPtr&amp;lt;Cassette&amp;gt;&amp;amp; pc, int howMany);

SamrtPtr&amp;lt;CasSingle&amp;gt; dumbMusic(new CasSingle(&amp;quot;Achy Breaky Heart&amp;quot;));
displayAndPlay(dumbMusic, 1);  // error!
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;When invoking &lt;code&gt;displayAndPlay&lt;/code&gt; with a &lt;code&gt;SmartPtr&amp;lt;CasSingle&amp;gt;&lt;/code&gt;, according to the inheritance hierarchy, we may expect the &lt;code&gt;SmartPtr&amp;lt;Cassette&amp;gt;&lt;/code&gt; function to be chosen, because &lt;code&gt;CasSingle&lt;/code&gt; inherits directly from &lt;code&gt;Casssette&lt;/code&gt; and only indirectly from &lt;code&gt;MusicProduct&lt;/code&gt;. However, it will only work in the case of dumb pointers. For our smart pointers, as far as C++ compilers are concerned, both calls to conversion functions here are equally good (the conversion from &lt;code&gt;SmartPtr&amp;lt;CasSingle&amp;gt;&lt;/code&gt; to &lt;code&gt;SmartPtr&amp;lt;Cassette&amp;gt;&lt;/code&gt; is no better than the conversion to &lt;code&gt;SmartPtr&amp;lt;MusicProduct&amp;gt;&lt;/code&gt;), leading to an error of ambiguous call to &lt;code&gt;displayAndPlay&lt;/code&gt;. The best we can do, then, is to use casts (MECpp item 2) in this ambiguous case.&lt;/p&gt;

&lt;h1 id=&#34;smart-pointers-and-const&#34;&gt;Smart pointers and const&lt;/h1&gt;

&lt;p&gt;To mimic the flexibility of constness in terms of smart pointers, we use follwoing ways to create four combinations of &lt;code&gt;const&lt;/code&gt; and non-&lt;code&gt;const&lt;/code&gt; objects and pointers:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;CD goodCD(&amp;quot;Flood&amp;quot;);
SmartPtr&amp;lt;CD&amp;gt; p;  // non-const object, non-const pointer
SmartPtr&amp;lt;const CD&amp;gt; p;  // const object, non-const pointer
const SmartPtr&amp;lt;CD&amp;gt; p = &amp;amp;goodCD;  // non-const object, const pointer
const SmartPtr&amp;lt;const CD&amp;gt; p = &amp;amp;goodCD;  // const object, const pointer
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Moreover, we can use the member templates technique shown above for automatically generating the implicit type conversion operators from &lt;code&gt;SmartPtr&amp;lt;CD&amp;gt;&lt;/code&gt; to &lt;code&gt;SmartPtr&amp;lt;const CD&amp;gt;&lt;/code&gt; - this technique works anytime the corresponding conversion for dumb pointers would work， and conversions involving &lt;code&gt;const&lt;/code&gt; are no exception.&lt;/p&gt;
&lt;div class=&#34;footnotes&#34;&gt;

&lt;hr /&gt;

&lt;ol&gt;
&lt;li id=&#34;fn:1&#34;&gt;It is possible that, after &lt;code&gt;delete pt;&lt;/code&gt;, &lt;code&gt;pt&lt;/code&gt;&amp;rsquo;s destructor (or some true owner of &lt;code&gt;pt&lt;/code&gt;) will invoke &lt;code&gt;delete pt;&lt;/code&gt; for a second time, and double deletion yields undefined behavior.
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:1&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;</description>
    </item>
    
    <item>
      <title>[MECpp]Item-27 Requiring or Prohibiting Heap Based Objects</title>
      <link>http://nianze.tk/2018/05/requiring-or-prohibiting-heap-based-objects/</link>
      <pubDate>Tue, 01 May 2018 00:00:00 +0000</pubDate>
      
      <guid>http://nianze.tk/2018/05/requiring-or-prohibiting-heap-based-objects/</guid>
      <description>&lt;p&gt;Techniques for requiring or prohibiting heap-based objects

&lt;!-- toc --&gt;&lt;/p&gt;

&lt;h1 id=&#34;requiring-heap-based-objects&#34;&gt;Requiring Heap-Based Objects&lt;/h1&gt;

&lt;h2 id=&#34;1-the-straightforward-way&#34;&gt;1. The straightforward way&lt;/h2&gt;

&lt;p&gt;The brutle way is to declare the constructors and the destructor &lt;code&gt;private&lt;/code&gt;, but this is overkill. Either one of them need to be private to ensure objects only be created on the heap. Since there are usually many constructors but only one destructor per class, a more elegant way is to make the destructor private and the constructors public, prividing privileged pseudo-destructor function (which has access to the real destructor) for clients to call, as suggested in MECpp item 26.&lt;/p&gt;

&lt;p&gt;Example:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class UPNumber { // unlimited precision numbers that should only exist on the heap
public:
    UPNumber();
    UPNumber(int initValue);
    UPNumber(double initValue);
    UPNumber(const UPNumber&amp;amp; rhs);
    // pseudo-destructor (a const member function, because even const obj. may be destroyed)
    void destroy() const { delete this; }
    ...
private:
    ~UPNumber();
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Clients would program like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;UPNumber n; // error! (legal here, but illegal when n&#39;s dtor is implicitly invoked later)
UPNumber *p = new UPNumber; // fine
...
delete p; // error! attempt to call private dtor
p-&amp;gt;destroy(); // fine
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;2-inheritance-and-containment-friendly&#34;&gt;2. Inheritance-and-containment friendly&lt;/h2&gt;

&lt;p&gt;Restricting access to a class&amp;rsquo;s destructor or constructors prevents the creation of not only non-heap objects, but also both inheritance and containment. To work this out:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;To be friendly for inheritance, we declare &lt;code&gt;protected&lt;/code&gt; for &lt;code&gt;UPNumber&lt;/code&gt;&amp;rsquo;s destructor.&lt;/li&gt;
&lt;li&gt;To be friendly for containment, classes that need objects of type &lt;code&gt;UPNumber&lt;/code&gt; can be modified to contain pointers to &lt;code&gt;UPNumber&lt;/code&gt; object instead:&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class UPNumer {...};  // declare dtor protected
class NonNegativeUPNumber: public UPNumber {...}; // okay to access protected members

class Asset {
public:
    Asset(int initValue);
    ~Asset();
    ...
private:
    UPNumber *value;
};

Asset::Asset(int initValue)
: value(new UPNumber(initValue)) // fine
{...}

Asset::~Asset()
{ value-&amp;gt;destroy(); }  // fine
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;3-determining-whether-an-object-is-on-the-heap&#34;&gt;3. Determining Whether an Object is On The Heap&lt;/h2&gt;

&lt;p&gt;It&amp;rsquo;s hard to tell whether an object is on the heap. For example, given the class definition above, it&amp;rsquo;s ligal to define a non-heap &lt;code&gt;NonNegativeUPNumber&lt;/code&gt; object, which will not construct its base &lt;code&gt;UPNumber&lt;/code&gt; part on the heap. There is no way to detect whether a constructor is being invoked as the base class part of a heap-based object, which means for the following contexts, it is not possible for the &lt;code&gt;UPNumber&lt;/code&gt; constructor to detect the difference:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;NonNegativeUPNumber *n1 = new NonNegativeUPNumber; // on heap
NonNegativeUPNumber n2; // not on heap
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Sadly, there&amp;rsquo;s no portable way to determine whether an object is on the heap, and there isn&amp;rsquo;t even a semi-portable way that works most of the time. Detailed dicussion on this topic could be found at &lt;a href=&#34;http://www.aristeia.com/BookErrata/M27Comments.html&#34;&gt;Comments on Item 27 of More Effective C++&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;We&amp;rsquo;ll have to turn to unportable, implementation-dependent system calls if we absolutely have to tell whether an address is on the heap. That being the case, we&amp;rsquo;d better off trying to redesign the software so we don&amp;rsquo;t need to determine whether an object is on the heap in the first place.&lt;/p&gt;

&lt;h2 id=&#34;4-determine-whether-it-s-safe-to-delete-a-pointer&#34;&gt;4. Determine whether it&amp;rsquo;s safe to delete a pointer&lt;/h2&gt;

&lt;p&gt;To answer this easier question, all we need to do is to create a collection of addresses that have been returned by &lt;code&gt;operator new&lt;/code&gt;. One possible solution is to provide an abstract mixin base class that offers derived classes the ability to determine whether a pointer was allocated from &lt;code&gt;operator new&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class HeapTracked { // mixin class; keeps track of ptrs returned from op. new
public:
    class MissingAddress();  // exception class
    virtual ~HeapTracked() = 0;

    static void *operator new(size_t size);
    static void operator delete(void *ptr);

    bool isOnHeap() const;
private:
    typedef const void* RawAddress;
    static list&amp;lt;RawAddress&amp;gt; addresses;
};
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;// mandatory definition of static class member
list&amp;lt;RawAddress&amp;gt; HeapTracked::address;
// tho being pure virtual, dtor still needs to be defined
HEapTracked::~HeapTracked() {}

void * HeapTracked::operator new(size_t size)
{
    void *memPtr = ::operator new(size); // get the memory
    addresses.push_front(memPtr);
    return memPtr;
}

void HeapTracked::operator delete(void *ptr)
{
    // gracefully handle null pointer
    if (ptr == 0) return;
    list&amp;lt;RawAddress&amp;gt;::iterator it = 
        find(addresses.begin(), addresses.end(), ptr);
    if (it != addresses.end()) {
        addresses.erase(it);     // remove the entry
        ::operator delete(ptr);  // deallocate the memory
    } else {
        throw MissingAddress();  // ptr wasn&#39;t allocated by op. new. throw an exception
    }
}

bool HeapTracked::isOnHeap() const
{
    // get a pointer to the beginning of the memory occupied by *this
    const void *rawAddress = dynamic_cast&amp;lt;cosnt void*&amp;gt;(this);
    list&amp;lt;RawAddress&amp;gt;::iterator it = 
        find(addresses.begin(), addresses.end(), rawAddress);
    return it != addresses.end();  // return whether it was found
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note that &lt;code&gt;dynamic_cast&lt;/code&gt; is applicable only to pointers to objects that have at least one virtual function, and &lt;code&gt;dynamic_cast&lt;/code&gt;ing a pointer to &lt;code&gt;void*&lt;/code&gt; (or &lt;code&gt;const void*&lt;/code&gt; or &lt;code&gt;volatile void*&lt;/code&gt; or &lt;code&gt;const volatile void*&lt;/code&gt;) yields a pointer to the beginning of the memory for the object pointed to by the pointer. Here &lt;code&gt;dynamic_cast&lt;/code&gt;ing &lt;code&gt;this&lt;/code&gt; to &lt;code&gt;const void*&lt;/code&gt; gives us a pointer to the beginning of the memory for the current object, which is the pointer previously returned by &lt;code&gt;HeapTracked::operator new&lt;/code&gt; as long as the memory for the current object was allocated by &lt;code&gt;HeapTracked::operator new&lt;/code&gt; in the first place.&lt;/p&gt;

&lt;p&gt;To use this basic class, say we want to be able to determine whether a pointer to an &lt;code&gt;Asset&lt;/code&gt; object points to a heap-based object, simply modify &lt;code&gt;Asset&lt;/code&gt;&amp;rsquo;s class definition to specify &lt;code&gt;HeapTracked&lt;/code&gt; as a base class:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class Asset: public HeapTracked {
private:
    UPNumber value;
    ...
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And we could query &lt;code&gt;Asset*&lt;/code&gt; pointers as follows:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;void inventoryAsset(const Asset *ap)
{
    if (ap-&amp;gt;isOnHeap()) {
        as is a heap-based asset -- inventory it as such
    } 
    else {
        ap is non-heap-based  asset  -- record it that way
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Since built-in types such as &lt;code&gt;int&lt;/code&gt; and &lt;code&gt;char&lt;/code&gt; can&amp;rsquo;t inherit from anything, &lt;code&gt;HeapTracked&lt;/code&gt; can&amp;rsquo;t be used with these built-in types. Still, the most common reason for wanting to use a class like &lt;code&gt;HeapTracked&lt;/code&gt; is to determine whether it&amp;rsquo;s okay to &lt;code&gt;delete this&lt;/code&gt;, and we don&amp;rsquo;t want to do that with a built-in type because such types have no &lt;code&gt;this&lt;/code&gt; pointer.&lt;/p&gt;

&lt;h1 id=&#34;prohibiting-heap-based-objects&#34;&gt;Prohibiting Heap-Based Objects&lt;/h1&gt;

&lt;p&gt;To preventing objects from being allocated on the heap, there are three cases:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;objects that are directly instantiated&lt;/li&gt;
&lt;li&gt;objects instantiated as base class parts of derived class objects&lt;/li&gt;
&lt;li&gt;objects embedded inside other objects&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;1-preventing-directly-instantiation-on-heap&#34;&gt;1. Preventing directly instantiation on heap&lt;/h2&gt;

&lt;p&gt;To prevent clients from directly instantiating objects on the heap: we can declare &lt;code&gt;operator new&lt;/code&gt; (and possibly &lt;code&gt;operator new[]&lt;/code&gt;) as &lt;code&gt;private&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class UPNumber {
private:
    static void *operator new(size_t size);
    static void operator delete(void *ptr);
    ...
};
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;UPNumber n1;  // okay
static UPNumber n2;  // okay
UPNumber *p = new UPNumber; // error! attempt to call private operator new
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Declaring &lt;code&gt;operator new&lt;/code&gt; private often also prevents &lt;code&gt;UPNumber&lt;/code&gt; objects from being instantiated as base class parts of heap-based derived class objects, because &lt;code&gt;operator new&lt;/code&gt; and &lt;code&gt;operator delete&lt;/code&gt; are inherited, so if these functions aren&amp;rsquo;t declared public in a derived class, that class inherits the private versions declared in its base(s):&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class UPNumber {...}; // as above
class NonNegativeUPNumber: public UPNumber { // declares no operator new
    ...
};

NonNegativeUPNumber n1; // okay
static NonNegativeUPNumber n2; // okay
NonNegativeUPNumber *p = new NonNegativeUPNumber; // error! attempt to call private operator new
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;2-preventing-base-class-parts-instantiated-on-heap&#34;&gt;2. Preventing base class parts instantiated on heap&lt;/h2&gt;

&lt;p&gt;However, if the derived class declares an &lt;code&gt;operator new&lt;/code&gt; of its own, which will be called when allocating derived class objects on the heap, it is hard to prevent &lt;code&gt;UPNumber&lt;/code&gt; base class parts from winding up there.&lt;/p&gt;

&lt;h2 id=&#34;3-preventing-base-class-parts-instantiated-on-heap&#34;&gt;3. Preventing base class parts instantiated on heap&lt;/h2&gt;

&lt;p&gt;Similarly, the fact that &lt;code&gt;UPNumber&lt;/code&gt;&amp;rsquo;s &lt;code&gt;operator new&lt;/code&gt; is private has no effect on attempts to allocate objects containing &lt;code&gt;UPNumber&lt;/code&gt; objects as members:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class Asset {
public:
    Asset(int initValue);
    ...
private:
    UPNumber value;
};

Asset *pa = new Asset(100);  // fine, calls Asset::operator new or ::operator new,
                             // not UPNumber::operator new
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Just as there&amp;rsquo;s no portable way to determine if an address is on the heap, however, there is no portable way to determine that it is not on the heap, so we can&amp;rsquo;t throw an exception in the &lt;code&gt;UPNumber&lt;/code&gt; constructors if a to-be-tested &lt;code&gt;UPNumber&lt;/code&gt; object being constructed is on the heap. We&amp;rsquo;re out of luck.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>搬了个家</title>
      <link>http://nianze.tk/2018/04/relocation-to-m2/</link>
      <pubDate>Sun, 29 Apr 2018 00:00:00 +0000</pubDate>
      
      <guid>http://nianze.tk/2018/04/relocation-to-m2/</guid>
      <description>&lt;p&gt;搬一次家，掉一层皮
&lt;/p&gt;



 
  
  
  
  
    
  
    
      
    
  
    
      
    
  

&lt;div class=&#34;figure nocaption fig-100&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2018/2018-04/2018-04-29/outside-small.jpg&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2018/2018-04/2018-04-29/outside-small.jpg&#34; &gt;
  
    &lt;/a&gt;
  
  
&lt;/div&gt;


&lt;p&gt;总算是把新公寓布置好了，累得要死，按照之前的设想，这次把钢琴安排在了临近电脑的右侧，方便之后随时练习。至此工作室也就基本搭建好了。&lt;/p&gt;

&lt;p&gt;过去的这三天感觉非常的漫长，先是开始打包装箱行李，接着是开始搬运大件小件，最后是打扫卫生和布置新的卧室。根本没有精力匀出来给技术和音乐。值得安慰的是，还好新公寓风景不错。&lt;/p&gt;



 
  
  
  
  
    
  
    
      
    
  
    
      
    
  

&lt;div class=&#34;figure nocaption fig-100&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2018/2018-04/2018-04-29/internal.jpg&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2018/2018-04/2018-04-29/internal.jpeg&#34; &gt;
  
    &lt;/a&gt;
  
  
&lt;/div&gt;


&lt;p&gt;租期15个月。之后一年半，大方向上还是按照之前的目标行事吧。不过日常作息方面，可以利用新building的健身房和游泳池，加入更多的锻炼项目。&lt;/p&gt;

&lt;hr /&gt;



 
  
  
  
  
    
  
    
      
    
  
    
      
    
  

&lt;div class=&#34;figure nocaption fig-100&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2018/2018-04/2018-04-29/IMG_6108.JPG&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2018/2018-04/2018-04-29/IMG_6108.JPG&#34; &gt;
  
    &lt;/a&gt;
  
  
&lt;/div&gt;


&lt;p&gt;P.S.:本来当初看中了新公寓的那架雅马哈的三角钢琴，巧的是钢琴在39层，走楼梯上一层楼就可以弹。还以为自己可以经常过去练习下。不过可惜的是今天试了下，发现很多音不是很准。有点可惜。不过以后还是可以经常上楼摸一摸的。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>一个大坑</title>
      <link>http://nianze.tk/2018/04/a-big-step/</link>
      <pubDate>Wed, 25 Apr 2018 21:44:06 -0400</pubDate>
      
      <guid>http://nianze.tk/2018/04/a-big-step/</guid>
      <description>&lt;p&gt;我有一个大胆的想法。
&lt;/p&gt;

&lt;p&gt;之前跟组里印度裔小哥闲聊，聊到过自己想用midi结合AI做些有趣的项目。今天他给我发来一个&lt;a href=&#34;https://richardyang40148.github.io/TheBlog/&#34;&gt;链接&lt;/a&gt;，我看了下博主的&lt;a href=&#34;https://richardyang40148.github.io/&#34;&gt;经历&lt;/a&gt;，突然有了一个大胆的想法。&lt;/p&gt;

&lt;p&gt;其实之前也一直有过类似的想法，那就是如果能找到合适的项目，我是很愿意全心投入到这个项目中去的。最近也就是业余时间练练琴的时候会有这种激情的感觉，所以也一直在考虑怎么样才能把自己的激情全部调动出来。这也是一直以来我想结合音乐和AI来搞点创作的原因。毕竟感觉会很有趣。&lt;/p&gt;

&lt;p&gt;所以，当我看了博主小哥发表的几篇论文后，我突然意识到，其实读个phd，有大把时间全力投入到自己喜欢的事情中去，会是件很令人激动的事情。&lt;/p&gt;

&lt;p&gt;于是马上开始了搜索，发现除了小哥所在的Georgia Tech有相关学院，近在咫尺的NYU恰恰就有一个Music Technology的项目。而且里面的硕士和博士项目都恰恰是自己很感兴趣的内容。&lt;/p&gt;

&lt;p&gt;硕士项目以授课为主，会学习很多我感兴趣的课题，但和继续工作相比不太好权衡利弊，毕竟已经有了一个ECE的硕士学位了，那些课程里面的内容我用课余时间自学其实也是可行的；但如果我能申请到phd的项目，还是很值得考虑的。全力投入自己的研究，结合AI和音乐，是很值得探索一番的事业。&lt;/p&gt;

&lt;p&gt;看了下申请要求。别的基本问题不大，尤其是有工作经验并已经身处技术领域，某种程度可能都over qualified了。问题还是在于学术背景太薄弱。申请的时候需要交3篇writing sample。申请截止日期是在12月份。时间很紧。需要补的很多。&lt;/p&gt;

&lt;p&gt;考虑到本来自己也有做相关小项目的想法，那么不妨就以写出三篇论文为目标，争取赶在申请截止日前做出点小成果。当然最近也可以开始reach out，问问看相关学院有没有旁听的课程或者part-time的项目，先跟NYU相关负责人打好交道吧。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>[MECpp]Item-26 Limiting the Number of Objects of a Class</title>
      <link>http://nianze.tk/2018/04/limiting-the-number-of-objects-of-a-class/</link>
      <pubDate>Tue, 24 Apr 2018 15:03:26 -0400</pubDate>
      
      <guid>http://nianze.tk/2018/04/limiting-the-number-of-objects-of-a-class/</guid>
      <description>&lt;p&gt;Combining object-counting technique with the pseudo-constructors, we can limit the number of objects of a class.

&lt;!-- toc --&gt;&lt;/p&gt;

&lt;h1 id=&#34;allowing-zero-or-one-objects&#34;&gt;Allowing zero or one objects&lt;/h1&gt;

&lt;p&gt;Using the classic singleton design pattern, it&amp;rsquo;s easy to limit the number of object to either zero or one. There are three points worth noting in this design:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Declaring the constructors of the class &lt;code&gt;private&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Using static object&lt;/li&gt;
&lt;li&gt;In order to access the single object, encapsulate the single object inside a accessor function (either a friend function inside some namespace/globally, or a static member function of that class). Note that:

&lt;ul&gt;
&lt;li&gt;Remember to put the static object inside this wrapper function to make it a function static instead of a class static, because

&lt;ul&gt;
&lt;li&gt;A class static is always constructed even if it&amp;rsquo;s never used, while a function static is created the first time through the function&lt;/li&gt;
&lt;li&gt;C++ says noting about the initialization order of static objects in different translation units, so class statics turn out to be a source of headaches, which can be avoided in the case of function statics (ECpp Item 4).&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;If this wrapper function is also declared as &lt;code&gt;inline&lt;/code&gt;, it&amp;rsquo;s possible for some compilers to create more than one copy of the static objects in the program due to &lt;em&gt;internal linkage&lt;/em&gt; (the object code for the program may contain more than one copy of each function with internal linkage, and this duplication includes function statics). So shy away from inline functions with static data.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Example:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;namespace PrintingStuff {
class Printer {
public:
    void submitJob(const PrintJob&amp;amp; job);
    void reset();
    void performSelfTest();
    ...
friend Printer&amp;amp; thePrinter();
private:
    Printer();
    Printer(const Printer&amp;amp; rhs);
    ...
};

Printer&amp;amp; thePrinter() // no inline in case of duplication caused by internal linkage
{
    static Printer p;
    return p;
}
} // namespace PrintingStuff
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Since the accessor returns a reference to a &lt;code&gt;Printer&lt;/code&gt; object, clients may use &lt;code&gt;thePrinter&lt;/code&gt; in any context where a &lt;code&gt;Printer&lt;/code&gt; object itself is expected:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;using PrintingStuff::thePrinter; 

thePrinter().reset();
thePrinter().submitJob(buffer);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;However, there&amp;rsquo;s still an inconvenience in this design: we&amp;rsquo;re limited to a single &lt;code&gt;Printer&lt;/code&gt; object for each run of the program. As a result, it&amp;rsquo;s not possible to write code like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;create Printer object p1;
use p1;
destroy p1;
create Printer object p2;
use p2;
destroy p2;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This design never instantiates more than a single &lt;code&gt;Printer&lt;/code&gt; object at a time, but it does use different &lt;code&gt;Printer&lt;/code&gt; objects in different parts of the program. It does not violate the constraint that only one printer may exist, but is still illegal with a single function static implementation.&lt;/p&gt;

&lt;p&gt;This need for flexibility leads us to the design of object-counting.&lt;/p&gt;

&lt;h1 id=&#34;allowing-multimple-objects-object-counting-with-pseudo-constructor&#34;&gt;Allowing multimple objects: object-counting with pseudo-constructor&lt;/h1&gt;

&lt;h2 id=&#34;object-counting&#34;&gt;Object-counting&lt;/h2&gt;

&lt;p&gt;The good point of object-counting is that, it provides us with more flexibility than the function static, and makes it easier to generalize the limit number to more than one. However, object-counting alone will not work. For example:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class Printer {
public:
    class TooManyObjects{};  // exception class for use when too many obj. are requested; may also returning null for too-many-object cases
    Printer();
    Printer(const Printer&amp;amp; rhs);
    ~Printer();
    ...
private:
    static size_t numObjects;
    static const size_t maxObjects = 10; // may need enum hack here for old compiler
};
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;// Obligatory definitions of class statics
size_t Printer::numObjects = 0;
const size_t Printer::maxObjets;

Printer::Printer()
{
    if (numObjects &amp;gt;= maxObjects) {
        throw TooManyObjects();
    }   
    process with normal construction here;
    ++numObjects;
}

Printer::~Printer()
{
    perform normal destruction here;
    --numObjects;
}

Printer::Printer(const Printer&amp;amp; rhs)
{
    if (numObjects &amp;gt;= maxObjects) {
        throw TooManyObjects();
    }    
    perform normal copy construction here
    ++numObjects;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The problem here is that, in order to set a limit on the number of instantiations,  we should not declare the class constructor &lt;code&gt;public&lt;/code&gt;, because that will allow clients to put the class as base class parts of more derived objects, or embedded inside larger objects, which is totally different usage context, and the presence of these different contexts significantly muddies the waters regarding what it means to keep track of the &amp;ldquo;number of objects in existence.&amp;rdquo; For example:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class ColorPrinter: public Printer {
    ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;Printer p;
ColorPrinter cp;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;From object definition above, there are two &lt;code&gt;Printer&lt;/code&gt; objects, one for &lt;code&gt;p&lt;/code&gt; and one for the &lt;code&gt;Printer&lt;/code&gt; part of &lt;code&gt;cp&lt;/code&gt;. This is usually unwanted behavior.&lt;/p&gt;

&lt;p&gt;Often we are interested only in allowing objects to exist on their own, and limit the number of those kinds of instantiations. To satisfy such restrictions, we should declare the class constructors &lt;code&gt;private&lt;/code&gt;, and (in the absence of &lt;code&gt;friend&lt;/code&gt; declarations) classes with private constructors can&amp;rsquo;t be used as base classes, nor can they be embedded inside other objects.&lt;/p&gt;

&lt;h2 id=&#34;pseudo-constructor&#34;&gt;Pseudo-constructor&lt;/h2&gt;

&lt;p&gt;In fact, private constructors are a general solution for preventing derivation. Instead of returning a reference to a single object (like what &lt;code&gt;thePrinter&lt;/code&gt; does), we can declare a pseudo-constructor returning a pointer to a unique object to allow multiple objects.&lt;/p&gt;

&lt;p&gt;That is, we combine the object-counting with pseudo-consturctors:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class Printer {
public:
    class TooManyObjects{};  // exception class for use when too many obj. are requested; may also returning null for too-many-object cases
    // pseudo-constructor
    static Printer * makePrinter();
    static Printer * makePrinter(const Printer&amp;amp; rhs);
    ~Printer();
    ...
private:
    static size_t numObjects;
    static const size_t maxObjects = 10; // may need enum hack here for old compiler
    Printer();
    Printer(const Printer&amp;amp; rhs); 
};
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;// Obligatory definitions of class statics
size_t Printer::numObjects = 0;
const size_t Printer::maxObjets;

Printer::Printer()
{
    if (numObjects &amp;gt;= maxObjects) {
        throw TooManyObjects();
    }
    process with normal construction here;
    ++numObjects;
}

Printer::Printer(const Printer&amp;amp; rhs)
{
    if (numObjects &amp;gt;= maxObjects) {
        throw TooManyObjects();
    }    
    perform normal copy construction here
    ++numObjects;
}

Printer::~Printer()
{
    perform normal destruction here;
    --numObjects;
}

Printer * Printer::makePrinter()
{ return new Printer; }

Printer * Printer::makePrinter(const Printer&amp;amp; rhs)
{ return new Printer(rhs); }
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;an-object-counting-base-class&#34;&gt;An object-counting base class&lt;/h2&gt;

&lt;p&gt;We can split the instance counting ability apart from the &lt;code&gt;Printer&lt;/code&gt; class to reuse the limited-number-of-instance functionality.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;template&amp;lt;class BeingCounted&amp;gt;
class Counted {
public:
    class TooManyObjects{}; // for throwing exceptions
    static size_t objectCount() { return numObjects; }
protected:
    Counted();
    Counted(const Counted&amp;amp; rhs);
    ~Counted() { --numObjects; }
private:
    static size_t numObjects;
    static const size_t maxObjects;
    void init();  // to avoid ctor code duplication
};

template&amp;lt;class BeingCounted&amp;gt;              // defines numObjects and
size_t Counted&amp;lt;BeingCounted&amp;gt;::numObjects; // automatically init. it to 0

template&amp;lt;class BeingCouted&amp;gt;
Counted&amp;lt;BeingCounted&amp;gt;::Counted()
{ init(); }

template&amp;lt;class BeingCounted&amp;gt;
void Counted&amp;lt;BeingCounted&amp;gt;::Counted(const Counted&amp;lt;BeingCounted&amp;gt;&amp;amp;)
{ init(); }

template&amp;lt;class BeingCounted&amp;gt;
void Counted&amp;lt;BeingCounted&amp;gt;::init()
{
    if (numObjects &amp;gt;= maxObjects) throw TooManyObjects();
    ++numObjects;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now modify the &lt;code&gt;Printer&lt;/code&gt; class to use the &lt;code&gt;Counted&lt;/code&gt; template:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class Printer: private Counted&amp;lt;Printer&amp;gt; {
public:
    // pseudo-constructors
    static Printer * makePrinter();
    static Printer * makePrinter(const Printer&amp;amp; rhs);
    ~Printer();
    void submitJob(const PrintJob&amp;amp; job);
    void reset();
    void performSelfTest();
    ...
    using Counted&amp;lt;Printer&amp;gt;::objectCount; // make this function public for clients of Printer
    using Counted&amp;lt;Printer&amp;gt;::TooManyObjects;
private:
    Printer();
    Printer(const Printer&amp;amp; rhs);
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note that:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;We use &lt;code&gt;private&lt;/code&gt; inheritance here because the implementation detials of keeping track of the number of instantiated objects are nobody&amp;rsquo;s business but the author of &lt;code&gt;Printer&lt;/code&gt;&amp;rsquo;s. If we use the alternative public inheritance design, then we have to give the &lt;code&gt;Counted&lt;/code&gt; class a virtual destructor - that will almost certainly affect size and layout of objects of classes inheriting from &lt;code&gt;Counted&lt;/code&gt;, as MECpp item 24 states.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Clients may still want to know how many &lt;code&gt;Printer&lt;/code&gt; objects exists, but &lt;code&gt;objectCount&lt;/code&gt; becomes &lt;code&gt;private&lt;/code&gt; due to the private inheritance. To restore the public accessibility, we employ a &lt;code&gt;using&lt;/code&gt; declaration.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;After inheritance, &lt;code&gt;Printer&lt;/code&gt; can forget about counting objects, so the &lt;code&gt;Printer&lt;/code&gt; constructor now looks like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;Printer::Printer()
{
    proceed with normal object construction;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The benifits:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;No checking of the number of objects to see if the limit is about to be exceeded&lt;/li&gt;
&lt;li&gt;No incrementing the number of objects in existence once the constructor is done&lt;/li&gt;
&lt;li&gt;Base class will always be invoked first, so if too many objects are created, a &lt;code&gt;Connted&amp;lt;Printer&amp;gt;&lt;/code&gt; constructor throws an exception, and the &lt;code&gt;Printer&lt;/code&gt; constructor won&amp;rsquo;t even be invoked&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Clients of the &lt;code&gt;Printer&lt;/code&gt; class are required to initialize &lt;code&gt;maxObjects&lt;/code&gt;, or there will be an error during linking for undefined &lt;code&gt;maxObjects&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;const size_t Counted&amp;lt;Printer&amp;gt;::maxObjects = 10;
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;</description>
    </item>
    
    <item>
      <title>[MECpp]Item-25 Virtualizing Constructors and Non-Member Functions</title>
      <link>http://nianze.tk/2018/04/virtualizing-constructors-and-non-member-functions/</link>
      <pubDate>Mon, 23 Apr 2018 13:30:56 -0400</pubDate>
      
      <guid>http://nianze.tk/2018/04/virtualizing-constructors-and-non-member-functions/</guid>
      <description>&lt;p&gt;Depending on the different input or dynamic types of function parameters, &amp;ldquo;virtualization&amp;rdquo; is a useful technique to construct new objects of different types accordingly, or to conceive of non-member functions whose behavior changes accordingly.

&lt;!-- toc --&gt;&lt;/p&gt;

&lt;p&gt;Constructors and non-member functions can&amp;rsquo;t really be virtual. We just make them act &amp;ldquo;virtually&amp;rdquo; so that it is easier to use. The term &amp;ldquo;virtual&amp;rdquo; means that a function will achieve type-specific behavior when we have a pointer or reference to an object without knowing its dynamic type in advance.&lt;/p&gt;

&lt;h1 id=&#34;virtual-constructor&#34;&gt;Virtual constructor&lt;/h1&gt;

&lt;p&gt;Suppose we write applications for working with newsletters, where a newsletter consists of components that are either textual or graphical:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class NLComponent {  // abstract base class for newsletter components
public:
    // constain at least one pure virtual function
    virtual NLComponet * clone() const = 0; // virtual copy constructor
    ...
};

class TextBlocks: public NLComponent { // 
public:
    virtual TextBlock * clone() const  // virtual copy constructor
    { return new TextBlock(*this); }  
    ...                                // constain no pure virtual function
};

class Graphic: public NLComponent {
public:
    virtual Graphic * clone() const  // virtual copy constructor
    { return new Graphic(*this); } 
    ...                                // constain no pure virtual function    
};

class NewsLetter {  // a newsletter object consists of a list of NLComponent objects
public:
    NewsLetter(istream&amp;amp; str);
    NewsLetter(const NewsLetter&amp;amp; rhs);  // normal copy constructor
    ...
private:
    list&amp;lt;NLComponet*&amp;gt; components; 
    static NLComponet * readComponet(istream&amp;amp; str); // read the data for the next NLComponet from str, create the component and return a pointer to it
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The classes relate in this way:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;NewsLetter object
┌───────────────┐
│     ...       │
├───────────────┤                    ┌──────────────┐
│[list object]--│-----pointers------&amp;gt;│  NLComponent │
└───────────────┘                    └──────────────┘
                       public inheritance ↗   ↖ public inheritance
                             ┌───────────┐      ┌──────────┐
                             │ TextBlock │      │  Graphic │
                             └───────────┘      └──────────┘
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Suppose &lt;code&gt;NewsLetter&lt;/code&gt; objects are stored on disk, it is convevient that &lt;code&gt;NewsLetter&lt;/code&gt;  takes an &lt;code&gt;istream&lt;/code&gt; to read information from the stream as it creates the necessary in-core data structures. Depending on the data it reads, we need to create either a &lt;code&gt;TextBlock&lt;/code&gt; or a &lt;code&gt;Graphic&lt;/code&gt;, which are different types of objects. Here comes the &lt;code&gt;readComponent&lt;/code&gt;, which acts like constructor for its creating new objects, while it is also able to create different types of objects according to the iput it is given. Thus we call such a constructor as the &lt;em&gt;virtual constructor&lt;/em&gt;, which are useful in many constexts.&lt;/p&gt;

&lt;p&gt;Given &lt;code&gt;readComponent&lt;/code&gt; acting as a virtual constructor, it is easy to implement the constructor for &lt;code&gt;NewsLetter&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;NewsLetter::NewsLetter(istream&amp;amp; str)
{
    while (str) {
        componets.push_back(readComponet(str));
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Among all kinds of virtual functions, there is another widely useful one: the &lt;em&gt;virtual copy constructor&lt;/em&gt;, which returns a pointer to a new copy of the object invoking the function, and is typically named like &lt;code&gt;copySelf&lt;/code&gt;, &lt;code&gt;cloneSelf&lt;/code&gt;, or simply &lt;code&gt;clone&lt;/code&gt;. These virtual copy constructors just calls its real copy constructor, so that the meaning of &amp;ldquo;copy&amp;rdquo; keeps the same for both functions&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:1&#34;&gt;&lt;a href=&#34;#fn:1&#34;&gt;1&lt;/a&gt;&lt;/sup&gt; - consistency.&lt;/p&gt;

&lt;p&gt;Notice that a derived class&amp;rsquo;s redefinition of a base class&amp;rsquo;s virtual function declare different return types here: if the function&amp;rsquo;s return type is a pointer (or a reference) to a base class, the derived class&amp;rsquo;s function may return a pointer (or reference)  to a class derived from that base class. Thus &lt;code&gt;TextBlock&lt;/code&gt;&amp;rsquo;s &lt;code&gt;clone&lt;/code&gt; returns a &lt;code&gt;TextBlock*&lt;/code&gt; and &lt;code&gt;Graphic&lt;/code&gt;&amp;rsquo;s &lt;code&gt;clone&lt;/code&gt; returns a &lt;code&gt;Graphic*&lt;/code&gt; while the return type of &lt;code&gt;NLComponent&lt;/code&gt;&amp;rsquo;s &lt;code&gt;clone&lt;/code&gt; is &lt;code&gt;NLComponent*&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Taking advantage of the virtual copy constructor in &lt;code&gt;NLComponent&lt;/code&gt;, &lt;code&gt;NewsLetter&lt;/code&gt; only need to implement a normal copy constructor:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;NewsLetter::NewsLetter(const NewsLetter&amp;amp; rhs); // normal copy constructor impl. in terms of virtual copy constructor
{
    for (list&amp;lt;NLComponent*&amp;gt;::const_iterator it = rhs.components.begin();
         it != rhs.componets.end();
         ++it) {
             componets.push_back((*it)-&amp;gt;clone());
         }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;virtual-non-member-functions&#34;&gt;Virtual Non-member functions&lt;/h1&gt;

&lt;p&gt;Suppose we&amp;rsquo;d like to implement output operators for the &lt;code&gt;TextBlock&lt;/code&gt; and &lt;code&gt;Graphic&lt;/code&gt; classes. Given that the defaultly output operator &lt;code&gt;operator&amp;lt;&amp;lt;&lt;/code&gt; takes an &lt;code&gt;ostream&amp;amp;&lt;/code&gt; as its left-hand argument, we can not make it a member function of the &lt;code&gt;TextBlock&lt;/code&gt; or &lt;code&gt;Graphic&lt;/code&gt; classes, so it can&amp;rsquo;t be declared as &lt;code&gt;virtual&lt;/code&gt;. On the other hand, if we insist on declaring a virtual function for printing (e.g., &lt;code&gt;print&lt;/code&gt;), and thus define a &lt;code&gt;print&lt;/code&gt; for the &lt;code&gt;TextBlock&lt;/code&gt; and &lt;code&gt;Graphic&lt;/code&gt;, the syntax for printing &lt;code&gt;TextBlock&lt;/code&gt; and &lt;code&gt;Graphic&lt;/code&gt; objects is inconsistent with that for the other types in the language, which makes our clients unhappy.&lt;/p&gt;

&lt;p&gt;What we want it a non-member function called &lt;code&gt;operator&amp;lt;&amp;lt;&lt;/code&gt; that exhibits the behavior of a virtual function like &lt;code&gt;print&lt;/code&gt;. The solution? We define both &lt;code&gt;operator&amp;lt;&amp;lt;&lt;/code&gt; and &lt;code&gt;print&lt;/code&gt; and have the former call the latter, and we get the virtual-acting non-member function:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class NLComponent {
public:
    virtual ostream&amp;amp; print(ostream&amp;amp; s) const = 0;
    ...
};

class TextBlock: public NLComponent {
public:
    virtual ostream&amp;amp; print(ostream&amp;amp; s) const;
    ...
}

class Graphic: public NLComponent {
public:
    virtual ostream&amp;amp; print(ostream&amp;amp; s) const;
    ...
}

iinline ostream&amp;amp; operator&amp;lt;&amp;lt;(ostream&amp;amp; s, const NLComponent&amp;amp; c)
{
    return c.print(s);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Since the non-virtual function does nothing but call the virtual function that does the real work, we inline the non-virtual function to avoid the cost of a function call.&lt;/p&gt;

&lt;p&gt;Note that, although not easy, it is possible to make non-member functions act virtually on more than one of their arguments - details in MECpp item 31.&lt;/p&gt;
&lt;div class=&#34;footnotes&#34;&gt;

&lt;hr /&gt;

&lt;ol&gt;
&lt;li id=&#34;fn:1&#34;&gt;If the real copy constructor performs a deep copy, so does the virtual copy constructor. If the real copy constructor does something fancy like reference counting or copy-on-write (MECpp item 29), so does the virtual copy constructor.
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:1&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;</description>
    </item>
    
    <item>
      <title>[米津玄师]Lemon</title>
      <link>http://nianze.tk/2018/04/lemon/</link>
      <pubDate>Sun, 22 Apr 2018 14:10:15 -0400</pubDate>
      
      <guid>http://nianze.tk/2018/04/lemon/</guid>
      <description>&lt;p&gt;Unnatural里每次片尾曲神插入时都让人心头一颤。。。不愧是除了生孩子什么都会的ハチ
谨以此曲献给米津玄師。嗯，以及石原里美🙂
&lt;/p&gt;

&lt;p&gt;这次算是目前乐器练习方面的一个小小总结吧。之前一直想过把平时练习的钢琴和吉他给利用起来，正巧发现这次这首《Lemon》的伴奏不难，加上每次看到Unnatural的片尾都会被感动，所以就化感动为动力，努力做出了这次的cover。由于吉他和launchpad都是第一次录音，所以在准备的时候踩了不少坑，相信以后再cover别的曲目应该会更从容些。&lt;/p&gt;

&lt;p&gt;即便是很简单的伴奏旋律和钢琴和声，我依然练了好久。电吉他按弦还稍显生疏，有时候还是按不准或者消音不干净；钢琴识谱依然还很慢。以后应该多在这些方面加强练习。另外这次重新捡起了好久没玩过的launchpad，发现用好了ableton可以实现之前一直想尝试的一些偏电子的曲风。所以以后有时间也可以多花些功夫在ableton上面。&lt;/p&gt;

&lt;p&gt;主旋律方面，这次加入了很多颤音vibrato来尽量模仿原曲中人声的感觉。然后就发现，一旦注意力在颤音上，吐音基本就没精力控制了。中间有一个音还试了一下喉音，不过效果一般般吧。另外一点就是，我发现目前的音色还有待提高，低音部分发声有点扁，没有木头的那种厚重感。反而是在剪辑视频的时候感觉吉他的声音更出彩些。哎，所以吉他这么受欢迎果然是有道理的。弦乐在很多时候的表现力确实是强些的。这可能也是为什么，3天前的那个深夜，我处理完主旋律的音频后，一个冲动就在reverb上下单买了个二手soprano sax。现代流行曲目还是多些金属质感的音色会更合适。&lt;/p&gt;

&lt;hr /&gt;

&lt;iframe src=&#34;//player.bilibili.com/player.html?aid=22439655&amp;cid=37181204&amp;page=1&#34; scrolling=&#34;no&#34; height=&#34;415&#34; width=&#34;544&#34; border=&#34;0&#34; frameborder=&#34;no&#34; framespacing=&#34;0&#34; allowfullscreen=&#34;true&#34;&gt; &lt;/iframe&gt;</description>
    </item>
    
    <item>
      <title>[MECpp]Item-24 Understand the Costs of Virtual Functions, Multiple Inheritance, Virtual Base Classes, and RTTI</title>
      <link>http://nianze.tk/2018/04/costs-of-virtual-functions-multiple-inheritance-virtual-base-classes-and-rtti/</link>
      <pubDate>Fri, 20 Apr 2018 15:32:45 -0400</pubDate>
      
      <guid>http://nianze.tk/2018/04/costs-of-virtual-functions-multiple-inheritance-virtual-base-classes-and-rtti/</guid>
      <description>&lt;p&gt;It&amp;rsquo;s important to have a basic understanding of the cost of some C++ features that can have a noticeable impact on the size of objects and the speed at which member functions execute.

&lt;!-- toc --&gt;&lt;/p&gt;

&lt;h1 id=&#34;virtual-functions&#34;&gt;Virtual Functions&lt;/h1&gt;

&lt;p&gt;Virtual function feature in C++ gives us the ability to execute the code corresponding to the dynamic type of the object on which the virtual function is invoked. Most implementations use &lt;em&gt;virtual tables&lt;/em&gt; (&lt;em&gt;vtbls&lt;/em&gt;) and &lt;em&gt;virtual table pointers&lt;/em&gt; (&lt;em&gt;vptrs&lt;/em&gt;).&lt;/p&gt;

&lt;h2 id=&#34;cost-of-vtbl&#34;&gt;Cost of vtbl&lt;/h2&gt;

&lt;p&gt;A vtble is usually an array of pointers to functions. Each class that declares or inherits virtual functions has its own vtbl, which holds pointers to the implementations of the virtual functions for that class.&lt;/p&gt;

&lt;p&gt;For example:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class C1 {
public:
    C1();  // nonvirtual func
    virtual ~C1();  // virtual func
    virtual void f1();  // virtual func
    virtual int f2(char c) const;  // virtual func
    virtual void f3(const string&amp;amp; s);  // virtual func
    void f4() const; // nonvirtual func
    ...
};

class C2: public C1 {
public:
    C2(); // nonvirtual func
    virtual ~C2();  // virtual func
    virtual void f1();  // redefined virtual func
    virtual void f5(char *str);  // new virtual func
    ...
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The vtbls for &lt;code&gt;C1&lt;/code&gt; and &lt;code&gt;C2&lt;/code&gt; looks like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;C1&#39;s vtbl:
┌──┐
│  │--&amp;gt; impl. of C1::~C1
├──┤
│  │--&amp;gt; impl. of C1::f1
├──┤
│  │--&amp;gt; impl. of C1::f2
├──┤
│  │--&amp;gt; impl. of C1::f3
└──┘
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;C2&#39;s vtbl:
┌──┐
│  │--&amp;gt; impl. of C2::~C2
├──┤
│  │--&amp;gt; impl. of C2::f1
├──┤
│  │--&amp;gt; impl. of C1::f2
├──┤
│  │--&amp;gt; impl. of C1::f3
├──┤
│  │--&amp;gt; impl. of C2::f5
└──┘
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;These tables come with cost: for each class containing virtual functions we have to set aside space ofr a virtual table, and the size of the vtbl is proportional to the number of virtual functions declared for that class.&lt;/p&gt;

&lt;p&gt;Ideally, we need only one copy of a class&amp;rsquo;s vtbl. Usually a class&amp;rsquo;s vtbl is generated in the object file containing the definition (i.e., the body) of the first non-inline non-pure virtal function in that class &lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:1&#34;&gt;&lt;a href=&#34;#fn:1&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;. However, if all virtual functions are declared &lt;code&gt;inline&lt;/code&gt;, compilers tend to generate a copy of the class&amp;rsquo;s vtbl in &lt;em&gt;every object file&lt;/em&gt; that uses it, so we should avoid declaring virtual functions &lt;code&gt;inline&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Speaking of &lt;code&gt;inline&lt;/code&gt;, it is worth noting that for all practical purposes, virtual functions aren&amp;rsquo;t inlined:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;inline&lt;/code&gt; means replacing the call site with the body of the called function *&lt;strong&gt;during compilation&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;virtual&lt;/code&gt; means wait until &lt;strong&gt;runtime&lt;/strong&gt; to see which function is called.&lt;/li&gt;
&lt;li&gt;In practical real world situation, virtual function calls are made through &lt;em&gt;pointers&lt;/em&gt; or &lt;em&gt;reference&lt;/em&gt; to objects, which are not inlined; only the virtual functions invoked through &lt;em&gt;objects&lt;/em&gt; can be inlined, which is usually pointless.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;cost-of-vptr&#34;&gt;Cost of vptr&lt;/h2&gt;

&lt;p&gt;Each object whose class declares virtual functions will be added by compilers a hidden member that points to the virtual table for that class, so we&amp;rsquo;ll pay for an extra pointer indise each object that is of a class containing virtual functions:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  C1 object                                              C1 object 
┌──────────────┐                                     ┌──────────────┐
│ Data members │                                     │ Data members │
├──────────────┤     C1&#39;s vtbl                       ├──────────────┤
│     vptr     │-----&amp;gt;┌──┐&amp;lt;--------------------------│     vptr     │
└──────────────┘      │  │--&amp;gt; impl. of C1::~C1       └──────────────┘
                      ├──┤
                      │  │--&amp;gt; impl. of C1::f1
                      ├──┤
                      │  │--&amp;gt; impl. of C1::f2
                      ├──┤
                      │  │--&amp;gt; impl. of C1::f3
                      └──┘
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Thus, for a call to the virtual function &lt;code&gt;f1&lt;/code&gt; below:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;void makeACall(C1 *pC1)
{
    pC1-&amp;gt;f1();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;will be translated by compilers like this (given compilers know the hidden member &lt;code&gt;vptr&lt;/code&gt; and the vtbl index of function &lt;code&gt;f1&lt;/code&gt; is &lt;code&gt;i&lt;/code&gt;):&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;(*pC1-&amp;gt;vptr[i])(pC1);  // call the function pointed to by the i-th entry in the vtbl
                       // pointed to by pC1-&amp;gt;vptr; pC1 is passed to the function as the &amp;quot;this&amp;quot; pointer
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;On most machines this is almost as efficient as a non-virtual function call, with only a few more instructions, so the cost of calling a virtual function is basically the same as that of calling a function through a function pointer.&lt;/p&gt;

&lt;h2 id=&#34;summary&#34;&gt;Summary&lt;/h2&gt;

&lt;p&gt;Both the per-class and the per-object space overhead for virtual functions increases, and the runtime invocation cost grows slightly.&lt;/p&gt;

&lt;h1 id=&#34;multiple-inheritance&#34;&gt;Multiple Inheritance&lt;/h1&gt;

&lt;p&gt;The same effect applies to multiple inheritance, except that things get more complex:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;offset claculations to find vptrs within objects become more complicated&lt;/li&gt;
&lt;li&gt;there are multiple vptrs within a single object (one per base class)&lt;/li&gt;
&lt;li&gt;special vtbls must be generated for base classes in addition to the stand-alone vtbls&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;virtual-base-classes&#34;&gt;Virtual Base Classes&lt;/h1&gt;

&lt;p&gt;Multiple inheritance often leads to the need for virtual base classes to eliminate the duplicated copies of base class in each deriving path.&lt;/p&gt;

&lt;p&gt;However, because implementations of virtual base classes often use pointers to virtual base class parts, one or more of these pointers may be stored inside the derived class objects. Take the following &amp;ldquo;dreaded multiple inheritance diamond&amp;rdquo; for example:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;          A
virtual ↗   ↖ virtual
      B       C
        ↖   ↗
          D
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class A {...};
class B: virtual public A {...};
class C: virtual public A {...};
class D: public B, public C {...};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The layout for an object of type &lt;code&gt;D&lt;/code&gt; is likely to look like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    ┌───────────────────────────────┐
    │        B Data Members         │
    ├───────────────────────────────┤
    │ Pointer to virtual base class ├─┐
    ├───────────────────────────────┤ │
    │        C Data Members         │ │
    ├───────────────────────────────┤ │
  ┌─┤ Pointer to virtual base class │ │
  │ ├───────────────────────────────┤ │
  │ │        D Data Members         │ │
  │ ├───────────────────────────────┤ │
  └&amp;gt;│        A Data Members         │&amp;lt;┘
    └───────────────────────────────┘
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Combining virtual base class with virtual table pointers introduced in &amp;ldquo;Cost of vptr&amp;rdquo; above, the memory layout for an object of type &lt;code&gt;D&lt;/code&gt; could look like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    ┌───────────────────────────────┐
    │        B Data Members         │
    ├───────────────────────────────┤
    │             _vptr_            │
    ├───────────────────────────────┤    
    │_Pointer to virtual base class_│
    ├───────────────────────────────┤
    │        C Data Members         │
    ├───────────────────────────────┤
    │             _vptr_            │    
    ├───────────────────────────────┤    
    │_Pointer to virtual base class_│
    ├───────────────────────────────┤
    │        D Data Members         │
    ├───────────────────────────────┤
    │        A Data Members         │
    ├───────────────────────────────┤    
    │             _vptr_            │
    └───────────────────────────────┘
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Notice that in the above diagram there are only thre vptrs while four classes are involved, this is because  &lt;code&gt;D&lt;/code&gt; can share the vptr with &lt;code&gt;B&lt;/code&gt;. Most implementations take use of this to reduce the compiler-generated overhead.&lt;/p&gt;

&lt;h1 id=&#34;rtti&#34;&gt;RTTI&lt;/h1&gt;

&lt;blockquote&gt;
&lt;p&gt;RTTI (Runtime type identification) lets us discover information about objects and classes at runtime. The information is stored in an object of type &lt;code&gt;type_+info&lt;/code&gt;, which can be accessed by using the &lt;code&gt;typeid&lt;/code&gt; operator.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;For each class, there only needs to be a single copy of the RTTI, and the language specification states that an object&amp;rsquo;s dynamic type information is guaranteed accurate only if that type has at least one virtual funciton. This may end up with such a design that RTTI was implemented in terms of a class&amp;rsquo;s vtbl.&lt;/p&gt;

&lt;p&gt;For example, index 0 of a vtbl array might contain a pointer to the &lt;code&gt;type_info&lt;/code&gt; object for the class corresponding to that vtbl:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;C1&#39;s vtbl
┌──┐
│  │--&amp;gt; C1&#39;s type_info object
├──┤
│  │--&amp;gt; impl. of C1::~C1
├──┤
│  │--&amp;gt; impl. of C1::f1
├──┤
│  │--&amp;gt; impl. of C1::f2
├──┤
│  │--&amp;gt; impl. of C1::f3
└──┘
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;With this implementation, the space cost of RTTI is an additional entry in each class vtbl plus the cost of the storage for the &lt;code&gt;type_info&lt;/code&gt; object for each class, which is unlikely to be noticeable for most applications.&lt;/p&gt;
&lt;div class=&#34;footnotes&#34;&gt;

&lt;hr /&gt;

&lt;ol&gt;
&lt;li id=&#34;fn:1&#34;&gt;For vendors who provide an integrated environment containing both compiler and linker, there is another brute-force starategy: generate a copy of the vtbl in each object file that might need it, and let linker strip out duplicate copies, leading to a single instance of each vtbl in the final executable or library.
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:1&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;</description>
    </item>
    
    <item>
      <title>[MECpp]Item-23 Consider Alternative Libraries</title>
      <link>http://nianze.tk/2018/04/consider-alternative-libraries/</link>
      <pubDate>Thu, 19 Apr 2018 13:32:15 -0400</pubDate>
      
      <guid>http://nianze.tk/2018/04/consider-alternative-libraries/</guid>
      <description>&lt;p&gt;Different libraries offering similar functionality often feature different performance trade-offs, so we might be able to remove bottlenecks by replacing one library with another.
&lt;/p&gt;

&lt;p&gt;Ideally, a library is small, fast, powerful, flexible, extensible, intuitive, universally available, well supported, free of use restriction, and bug-free.&lt;/p&gt;

&lt;p&gt;In reality, libraries optimized for size and speed are typically not portable; libraries with rich functionality are rarely intuitive; bug-free libraries are limited in scope. In a word, we can&amp;rsquo;t get everything.&lt;/p&gt;

&lt;p&gt;Different designers assign different priorities to these criteria, leading to the result that two libraries offering similar functionality have different performance profiles.&lt;/p&gt;

&lt;p&gt;Take &lt;code&gt;iostream&lt;/code&gt; and &lt;code&gt;stdio&lt;/code&gt; for example:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#ifndef STDIO
#include &amp;lt;stdio.h&amp;gt;
#else
#include &amp;lt;iostream&amp;gt;
#include &amp;lt;iomanip&amp;gt;
using namespace std;
#endif

const int VALUES = 30000;  // # of values to read/write

int main() {
    double d;
    for (int n = 1; n &amp;lt;= VALUES; ++n) {
#ifdef STDIO
        scanf(&amp;quot;%lf&amp;quot;, &amp;amp;d);
        printf(&amp;quot;%10.5f&amp;quot;, d);
#else
        cin &amp;gt;&amp;gt; d;
        cout &amp;lt;&amp;lt; setw(10)                      // set field width
             &amp;lt;&amp;lt; setprecision(5)               // set decimal places
             &amp;lt;&amp;lt; setiosflags(ios::showpoint)   // keep trailing 
             &amp;lt;&amp;lt; setiosflags(ios::fixed)
             &amp;lt;&amp;lt; d;    
#endif
        if (n % 5 == 0) {
#ifdef STDIO
            printf(&amp;quot;\n&amp;quot;);
#else
            cout &amp;lt;&amp;lt; &#39;\n&#39;;
        }
#endif
    }
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Running this program on several combinations of machines, operating systems, and compilers, and we should get a brief insight into the comparative performance difference between these two libraries. It is probable that the stdio version is faster, and the size of the executable using stdio tends to be smaller. However, it is also possible that iostream implementation is faster than stdio, because iostreams determine the types of their iperands during compilation, while stdio functions typically parse a format string at runtime.&lt;/p&gt;

&lt;p&gt;Anyway, the main point is that, because different libraries embody different design decisions regarding efficiency, extensibility, portability, type safety, and other issues, different libraries offeringg similar functionality often feature different performance trade-offs. Thus, once we&amp;rsquo;ve identified the bottlenecks in our software (via profiling, MECpp item 16), we can sometimes significantly improve the efficiency of our software by switching to libraries whose designer gave more weight to performance consideration than to other factors.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>[MECpp]Item-22 Consider Using op= Instead of Stand Alone op</title>
      <link>http://nianze.tk/2018/04/consider-using-op-instead-of-stand-alone-op/</link>
      <pubDate>Wed, 18 Apr 2018 14:09:10 -0400</pubDate>
      
      <guid>http://nianze.tk/2018/04/consider-using-op-instead-of-stand-alone-op/</guid>
      <description>&lt;p&gt;Assignment versions of operators (such as &lt;code&gt;operator+=&lt;/code&gt;) tend to be more efficient than stand-alone versions of those operators (e.g., &lt;code&gt;operator+&lt;/code&gt;).

&lt;!-- toc --&gt;&lt;/p&gt;

&lt;h1 id=&#34;efficiency-difference-between-op-and-stand-alone-op&#34;&gt;Efficiency difference between &lt;code&gt;op=&lt;/code&gt; and stand-alone &lt;code&gt;op&lt;/code&gt;&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;In general, assignment versions of operators are more effiecient than stand-alone versions, because

&lt;ol&gt;
&lt;li&gt;stand-alone versions must typically return a new object, and that costs us the construction and destruction of a temporary (MECpp item 19 and 20)&lt;/li&gt;
&lt;li&gt;assignment versions of operators write to their left-hand argument, so there is no need to generate a temporary to hold the operator&amp;rsquo;s return value&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;By offering assignment versions of operators as well as stand-alone versions, we allow clients of our classes to make the different trade-off between efficiency and convenience:&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;Rational a, b, c, d, result;
...
result = a + b + c + d;  // 3 potential temporary objects, one for each call to operator+
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This version is easy to write, debug, and maintain, and it offers acceptable performance about 80% of the time (MECpp item 16).&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;result = a;    // no temporary
result += b;   // no temporary
result += c;   // no temporary
result += d;   // no temporary
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This version is more efficient.&lt;/p&gt;

&lt;p&gt;In summary, as a library designer, we should offer both, and as an application developer, we should consider using assignment versions of operators instead of stand-alone versions when trying to deal with the critical 20% code.&lt;/p&gt;

&lt;h1 id=&#34;relationship-between-op-and-stand-alone-op&#34;&gt;Relationship between &lt;code&gt;op=&lt;/code&gt; and stand-alone &lt;code&gt;op&lt;/code&gt;&lt;/h1&gt;

&lt;p&gt;To ensure the natural relationship between the assignment version of an operator (e.g., &lt;code&gt;operator+=&lt;/code&gt;) and the stand-alone version (e.g., &lt;code&gt;operator+&lt;/code&gt;) exists, we can implement the latter in terms of the former (MECpp item 6):&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class Rational {
public:
    ...
    Rational&amp;amp; operator+=(const Rational&amp;amp; rhs);
};

const Rational operator+(const Rational&amp;amp; lhs, const Rational&amp;amp; rhs)
{
    return Rational(lhs) += rhs;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Further more, if we don&amp;rsquo;t mind putting all stand-alone operators at global scope, we can use templates to eliminate the need to write the stand-alone functions:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;template&amp;lt;class T&amp;gt;
const T operator+(const T&amp;amp; lhs, const T&amp;amp; rhs)
{
    return T(lhs) += rhs;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A few points worth noting in this implementation of &lt;code&gt;operator+&lt;/code&gt;:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;operator+=&lt;/code&gt; is implemented (elsewhere) from scratch, and &lt;code&gt;operator+&lt;/code&gt; calls it to provide its functionality, so that only the assignment versions need to be maintained.&lt;/li&gt;
&lt;li&gt;Assuming the assignment version is in the class&amp;rsquo;s public interface, there is no need for the stand-alone operators to be friends of the class.&lt;/li&gt;
&lt;li&gt;Without any named object, this implementation may take use of the return value optimization (MECpp item 20) &lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:1&#34;&gt;&lt;a href=&#34;#fn:1&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;footnotes&#34;&gt;

&lt;hr /&gt;

&lt;ol&gt;
&lt;li id=&#34;fn:1&#34;&gt;Although it is possible that &lt;code&gt;return T(lhs) += rhs;&lt;/code&gt; may be more complex than most compilers are willing to subject to the return value optimization.
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:1&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;</description>
    </item>
    
    <item>
      <title>[MECpp]Item-21 Overload to Avoid Implicit Type Conventions</title>
      <link>http://nianze.tk/2018/04/overload-to-avoid-implicit-type-conventions/</link>
      <pubDate>Tue, 17 Apr 2018 15:42:12 -0400</pubDate>
      
      <guid>http://nianze.tk/2018/04/overload-to-avoid-implicit-type-conventions/</guid>
      <description>&lt;p&gt;Overloading to avoid temporaries.
&lt;/p&gt;

&lt;p&gt;Consider following code:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class UPInt {  // unlimited precision integers
public:
    UPInt();
    UPInt(int value);
    ...
};

const UPInt operator+(const UPInt&amp;amp; lhs, const UPInt&amp;amp; rhs);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And following statements:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;UPInt upi1, upi2;

UPInt upi3 = upi1 + 10;
UPInt upi4 = 10 + upi2;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;These statements succeed by the creation of temporary objects to convert the integer 10 into &lt;code&gt;UPInts&lt;/code&gt; (MECpp item 19).&lt;/p&gt;

&lt;p&gt;It is convenient to have compilers perform such kinds of conversions, but the we do pay the cost of implicit type conversion. If we want to eliminate this cost, we cancel the type conversions by function overloading;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;const UPInt operator+(const UPInt&amp;amp; lhs, const UPInt&amp;amp; rhs);
const UPInt operator+(const UPInt&amp;amp; lhs, int);
const UPInt operator+(int, const UPInt&amp;amp; rhs);
...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Notice that &lt;code&gt;const UPInt operator+(int, int);&lt;/code&gt; is not allowed: C++ rules that every overloaded operator must take at leas one argument of a user-defined type. &lt;code&gt;int&lt;/code&gt; isn&amp;rsquo;t a user-defined type, so we can&amp;rsquo;t overload this &lt;code&gt;operator+&lt;/code&gt; in this form.&lt;/p&gt;

&lt;p&gt;Still, before doing such optimizations, it&amp;rsquo;s important to follow the 80-20 rule (MECpp item 16) to make sure it will make a noticeable improvement in the overall efficiency of the programs.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>[MECpp]Item-20 Facilitate the Return Value Optimization</title>
      <link>http://nianze.tk/2018/04/facilitate-the-return-value-optimization/</link>
      <pubDate>Mon, 16 Apr 2018 00:00:00 +0000</pubDate>
      
      <guid>http://nianze.tk/2018/04/facilitate-the-return-value-optimization/</guid>
      <description>&lt;p&gt;Take use of the &lt;em&gt;return value optimization&lt;/em&gt; in compilers.
&lt;/p&gt;

&lt;p&gt;Some functions (such as &lt;code&gt;operator*&lt;/code&gt;) have to return objects:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;if returning pointers, the caller is responsible to delete the pointer, which usually leads to resource leaks.&lt;/li&gt;
&lt;li&gt;if returning references, then we&amp;rsquo;re returning a reference to a local object, which no longer exists when the caller has it.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Although we can&amp;rsquo;t eliminate by-value returns from functions that require them, we can still reduce the cost of returning objects: by the help of compilers, we can eliminate the cost of the temporaries by returning &lt;em&gt;constructor arguments&lt;/em&gt; instead of objects:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;const Rational operator*(const Rational&amp;amp; lhs, const Rational&amp;amp; rhs)
{
    return Rational(lhs.numerator() * rhs.numerator(),
                    lhs.denominator() * rhs.denominator());
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here we&amp;rsquo;re creating an anonymous temporary &lt;code&gt;Rational&lt;/code&gt; object through a constructor expression, ant it is this temporary object the function is copying for its return value. When we use this efficient version of &lt;code&gt;operator*&lt;/code&gt; under the use case below:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;Rational a = 10;
Rational b(1, 2);

Rational c = a * b;  // operator* is called
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The rules for C++ allow compilers to optimize such &lt;em&gt;anonymous&lt;/em&gt; temporary objects out of existence by constructing the temporary &lt;em&gt;inside the memory allotted for the object&lt;/em&gt; &lt;code&gt;c&lt;/code&gt;. Thus, if compilers do this optimization, both the temporary inside &lt;code&gt;operator*&lt;/code&gt; and the temporary returned by &lt;code&gt;operator*&lt;/code&gt; are eliminated, and we only pay for one constructor call - the one to create &lt;code&gt;c&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Further more, we can eliminate the overhead of the call to &lt;code&gt;operator*&lt;/code&gt; by declaring this function &lt;code&gt;inline&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;// most efficient way to write a function returning an object
inline const Rational operator*(const Rational&amp;amp; lhs, const Rational&amp;amp; rhs)
{
    return Rational(lhs.numerator() * rhs.numerator(),
                    lhs.denominator() * rhs.denominator());
}
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>[MECpp]Item-19 Understand the Origin of Temporary Objects</title>
      <link>http://nianze.tk/2018/04/understand-the-origin-of-temporary-objects/</link>
      <pubDate>Fri, 13 Apr 2018 17:06:28 -0400</pubDate>
      
      <guid>http://nianze.tk/2018/04/understand-the-origin-of-temporary-objects/</guid>
      <description>&lt;p&gt;Unnamed non-heap objects are invisible temporary objects in C++.

&lt;!-- toc --&gt;&lt;/p&gt;

&lt;p&gt;Temporary objects arise in two situations:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;when implicit type conversions are applied to make function calls succeed&lt;/li&gt;
&lt;li&gt;when functions return objects&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;It&amp;rsquo;s important to understand how and why these temporary objects are created and destroyed because their construction and destruction can have noticeable impact on the performance of the program.&lt;/p&gt;

&lt;h1 id=&#34;implicit-conversion&#34;&gt;Implicit conversion&lt;/h1&gt;

&lt;p&gt;When the type of object passed to a function is not the same as the type of the parameter to which it is being bound, temporary objects are created during the implicit conversion to make function calls succeed.&lt;/p&gt;

&lt;p&gt;For example,&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;size_t countChar(const string&amp;amp; str, char ch);

char buffer[MAX_STRING_LEN];
char c;

// read in a char and a string; use setw to avoid 
// overflowing buffer when reading the string
cin &amp;gt;&amp;gt; c &amp;gt;&amp;gt; setw(MAX_STRING_LEN) &amp;gt;&amp;gt; buffer;
cout &amp;lt;&amp;lt; &amp;quot;There are &amp;quot; &amp;lt;&amp;lt; countChar(buffer, c)
     &amp;lt;&amp;lt; &amp;quot; occurrences of the character &amp;quot; &amp;lt;&amp;lt; c
     &amp;lt;&amp;lt; &amp;quot; in &amp;quot; &amp;lt;&amp;lt; buffer &amp;lt;&amp;lt; endl;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here is what will happen:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;By passing a &lt;code&gt;char&lt;/code&gt; array into function &lt;code&gt;countChar&lt;/code&gt; which expects a &lt;code&gt;const string&amp;amp;&lt;/code&gt;, compilers will create a temporary object of type &lt;code&gt;string&lt;/code&gt; constructed by calling the &lt;code&gt;string&lt;/code&gt; constructor with &lt;code&gt;buffer&lt;/code&gt; as its argument.&lt;/li&gt;
&lt;li&gt;The &lt;code&gt;str&lt;/code&gt; parameter of &lt;code&gt;countChar&lt;/code&gt; is then bound to this temporary &lt;code&gt;string&lt;/code&gt; object.&lt;/li&gt;
&lt;li&gt;When the statement containing the call to &lt;code&gt;countChar&lt;/code&gt; finishes executing, the temporary object is automatically destroyed.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Needless to say, such implicit conversion (with pointless construction and destruction of temporary objects)  is not efficient and should be eliminated:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;by redesigning the code to forbid such implicit conversion, MECpp item 5&lt;/li&gt;
&lt;li&gt;by modifying the code the same as described in MECpp item 21&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;restrictions-on-implicit-conversion&#34;&gt;Restrictions on implicit conversion&lt;/h2&gt;

&lt;p&gt;These conversions occur only when passing objects by value or when passing to a reference-to-&lt;code&gt;const&lt;/code&gt; parameter, so when passing an object to a reference-to-non-&lt;code&gt;const&lt;/code&gt; parameter, there is no implicit conversion. For example,&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;void uppercasify(string&amp;amp; str);
char bookTitle[] = &amp;quot;Effective C++&amp;quot;;
uppercasify(bootTitle);  // error!
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here, temporary would not be created for parameter &lt;code&gt;str&lt;/code&gt;, which is declared to be of type &amp;ldquo;non-&lt;code&gt;const&lt;/code&gt; reference&amp;rdquo;, because it is the &lt;code&gt;bookTitle&lt;/code&gt; that is supposed to be updated, instead of a newly created temporary.&lt;/p&gt;

&lt;h1 id=&#34;function-return-value&#34;&gt;Function return value&lt;/h1&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;const Number operator+(const Number&amp;amp; lhs, const Number&amp;amp; rhs);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The return value of &lt;code&gt;operator+&lt;/code&gt; is a temporary, because it is just the function&amp;rsquo;s return value and has no name, and we must pay to construct and destruct this object each time we call the function. (&lt;code&gt;const&lt;/code&gt; is added for the same reason in MECpp item 6);&lt;/p&gt;

&lt;p&gt;To avoid such costs,&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;switch to a similar function &lt;code&gt;operator+=&lt;/code&gt;, MECpp item 22&lt;/li&gt;
&lt;li&gt;if, in most cases, conceptually the construction and destruction can not be avoided, we optimize the program using the technique &lt;code&gt;return value optimization&lt;/code&gt; instroduced in MECpp item 20&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>[MECpp]Item-18 Amortize the Cost of Expected Computations</title>
      <link>http://nianze.tk/2018/04/amortize-the-cost-of-expected-computations/</link>
      <pubDate>Thu, 12 Apr 2018 15:31:55 -0400</pubDate>
      
      <guid>http://nianze.tk/2018/04/amortize-the-cost-of-expected-computations/</guid>
      <description>&lt;p&gt;The old Computer Science story: trade space for time&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:1&#34;&gt;&lt;a href=&#34;#fn:1&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;.

&lt;!-- toc --&gt;&lt;/p&gt;

&lt;p&gt;In order to improve program efficiency, we may use lazy evaluation (MECpp item 17), which is a technique for improving the efficiency of programs where results are not always needed. On the other side, when we must support operations whose results are almost always needed or whose results are often needed more than once, we may adopt &amp;ldquo;over-eager evaluation to amortize the cost of anticipated computations, such as caching and prefetching.&lt;/p&gt;

&lt;h1 id=&#34;caching&#34;&gt;Caching&lt;/h1&gt;

&lt;p&gt;Say we&amp;rsquo;re writing a program to provide information about employees, and one of the pieces of information we expect to request frequently is an employee&amp;rsquo;s cubicle number, which is stored in a database, but the database is not optimized to find it. In this case, we could cache the cubicle numbers to save the subsequent database lookups.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;int findCubicleNumber(const string&amp;amp; employeeName)
{
    typedef map&amp;lt;string, int&amp;gt; CubicleMap;
    static CubicleMap cubes;
    CubicleMap::iterator it = cubes.find(employeeName);
    if (it == cubes.end()) {
        int cubicle = // db query for the cubicle number
        cubes[employeeName] = cubicle;
        return cubicle;
    }
    else {
        return it-&amp;gt;second; // or &amp;quot;(*it).second&amp;quot; if compiler does not support &amp;quot;-&amp;gt;&amp;quot; for &amp;quot;it&amp;quot; object
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;prefetching&#34;&gt;Prefetching&lt;/h1&gt;

&lt;p&gt;According to the infamous &lt;em&gt;locality of reference&lt;/em&gt; phenomenon, if data in one place is requested, it&amp;rsquo;s quite common to want nearby data, too, which justifies disk caches, memory caches for both instructions and data, and instruction prefetches.&lt;/p&gt;

&lt;p&gt;Adopting similar concept, we can use similar strategy when writing a template for dynamic arrays, which will automatically extend themselves:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;template&amp;lt;class T&amp;gt;
class DynArray {...};

template&amp;lt;class T&amp;gt;
T&amp;amp; DynArray&amp;lt;T&amp;gt;::operator[](int index)
{
    if (index &amp;lt; 0) {
        throw an exception;
    }
    if (index &amp;gt; the current maximum index value) {
        int diff = index - the current maximum index value;
        call new to allocate enough additional memory so that (index+diff) is valid;
    }
    return the indexth element of the array;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This &lt;code&gt;operator[]&lt;/code&gt; function allocates twice as much memory as needed each time the array must be extended, so that it saves one memory allocation when its logical size is extended twice in the following case:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;DynArray&amp;lt;double&amp;gt; a;  // only a[0] is valid
a[22] = 3.5;         // new is called to expand a&#39;s storage through index 44, 
                     // a&#39;s logical size is 23
a[32] = 0;           // a&#39;s logical size is now 33, without new being called
&lt;/code&gt;&lt;/pre&gt;
&lt;div class=&#34;footnotes&#34;&gt;

&lt;hr /&gt;

&lt;ol&gt;
&lt;li id=&#34;fn:1&#34;&gt;Not always. Using large objects means fewer fit on a virtual memory or cache page. In rare cases, making objects bigger &lt;em&gt;reduces&lt;/em&gt; the performance of the software due to the increased paging activity and/or the decreased cache hit rate.
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:1&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;</description>
    </item>
    
    <item>
      <title>[MECpp]Item-17 Consider Using Lazy Evaluation</title>
      <link>http://nianze.tk/2018/04/consider-using-lazy-evaluation/</link>
      <pubDate>Wed, 11 Apr 2018 14:02:18 -0400</pubDate>
      
      <guid>http://nianze.tk/2018/04/consider-using-lazy-evaluation/</guid>
      <description>&lt;p&gt;The best computations are those we never perform at all.

&lt;!-- toc --&gt;&lt;/p&gt;

&lt;p&gt;Lazy evaluation is applicable in an enormous variety of application areas.&lt;/p&gt;

&lt;h1 id=&#34;reference-counting&#34;&gt;Reference Counting&lt;/h1&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class String {...};

String s1 = &amp;quot;Hello&amp;quot;;

String s2 = s1;  // call String copy ctor
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The lazy approach: instead of giving &lt;code&gt;s2&lt;/code&gt; a copy of &lt;code&gt;s1&lt;/code&gt;&amp;rsquo;s value, we have &lt;code&gt;s2&lt;/code&gt; share &lt;code&gt;s1&lt;/code&gt;&amp;rsquo;s value to save the cost of a call to &lt;code&gt;new&lt;/code&gt; and the expense of copying anything, until any one is modified (i.e., &lt;code&gt;s2.convertToUpperCase();&lt;/code&gt; will change only &lt;code&gt;s2&lt;/code&gt;&amp;rsquo;s value by making a private copy of shared value before modification). Refer to MECpp item 29 for implementation details.&lt;/p&gt;

&lt;h1 id=&#34;distinguishing-reads-from-writes&#34;&gt;Distinguishing Reads from Writes&lt;/h1&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;cout &amp;lt;&amp;lt; s[2];  // read
s[2] = &#39;x&#39;;    // write
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;For &lt;code&gt;operator[]&lt;/code&gt;, we&amp;rsquo;d like to distinguish the read call from the write so that a reference-counted string reading is cheap. In order to determine whether &lt;code&gt;operator[]&lt;/code&gt; has been called in a read or in a write context, we use lazy evaluation and proxy classes as described in MECpp item 30.&lt;/p&gt;

&lt;h1 id=&#34;lazy-fetching&#34;&gt;Lazy Fetching&lt;/h1&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class LargeObject {
public:
    LargeObject(ObjectID id);

    const string&amp;amp; field1() const;
    int field2() const;
    double field3() const;
    const string&amp;amp; field4() const;
    ...
private:
    ObjectID oid;
    mutable string *field1Value;
    mutable int *field2Value;
    mutable double *field3Value;
    mutable string *field4Value;
    ...    
};

LargeObject::LargeObject(ObjectID id)
: oid(id), field1Value(0), field2Value(0), field3Value(0), field4Value(0)...
{}

const string&amp;amp; LargeObject::field1() const
{
    if (field1Value == 0) {
        read the data for field 1 from the database
        and make field1Value point to it;
    }
    return *field1Value;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Because &lt;code&gt;LargeObject&lt;/code&gt; instances are big, getting all the data at once is a costly database operation. The lazy approach to this problem is to create only a skeleton of an object, without reading any data from disk when a &lt;code&gt;LargeObject&lt;/code&gt; instance is created. Each field in the object is represented as a pointer to the necessary data, initialized as null pointers, which signify fields that have not yet been read from the database.&lt;/p&gt;

&lt;p&gt;Since null pointers may need to be initialized to point to real data from inside any member function, including &lt;code&gt;const&lt;/code&gt; member functions like &lt;code&gt;field1&lt;/code&gt;, we declare the pointer fields &lt;code&gt;mutable&lt;/code&gt; to tell compilers that they can be modified inside any member function.&lt;/p&gt;

&lt;p&gt;As an alternative, we can replace pointers with smart pointers (MECpp item 28), which does not need to be declared as &lt;code&gt;mutable&lt;/code&gt;.&lt;/p&gt;

&lt;h1 id=&#34;lazy-expression-evaluation&#34;&gt;Lazy Expression Evaluation&lt;/h1&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;template&amp;lt;class T&amp;gt;
class Matrix { ... };

Matrix&amp;lt;int&amp;gt; m1(1000, 1000);  // a 1000 by 1000 matrix
Matrix&amp;lt;int&amp;gt; m2(1000, 1000);  // a 1000 by 1000 matrix
...
Matrix&amp;lt;int&amp;gt; m3 = m1 + m2;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Instead of compute and return the sum of &lt;code&gt;m1&lt;/code&gt; and &lt;code&gt;m2&lt;/code&gt; (which cost 1,000,000 additions and corresponding memory allocation), lazy evaluation sets up a data structure inside &lt;code&gt;m3&lt;/code&gt; indicating that &lt;code&gt;m3&lt;/code&gt;&amp;rsquo;s value is the sum of &lt;code&gt;m1&lt;/code&gt; and &lt;code&gt;m2&lt;/code&gt; (which may just consisting of two pointers to each of &lt;code&gt;m1&lt;/code&gt; and &lt;code&gt;m2&lt;/code&gt; and an enum indicating the additional operation). In most scenarios, we need only &lt;em&gt;part&lt;/em&gt; of a computation (i.e., &lt;code&gt;cout &amp;lt;&amp;lt; m3[4];&lt;/code&gt; instead of &lt;code&gt;cout &amp;lt;&amp;lt; m3;&lt;/code&gt;), so laziness generally pays off.&lt;/p&gt;

&lt;p&gt;However, due to these dependencies between values, there are extra maintainence to notice: when one of the matrices on which &lt;code&gt;m3&lt;/code&gt; is dependent is to be modified, we have to make sure the correctness:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;m3 = m1 + m2;
m1 = m4; // m3 is the sum of m2 and the old value of m1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Inside the &lt;code&gt;Matrix&amp;lt;int&amp;gt;&lt;/code&gt; assignment opertaor, we might compute &lt;code&gt;m3&lt;/code&gt;&amp;rsquo;s value prior to changing &lt;code&gt;m1&lt;/code&gt; or we may take a copy of the old value of &lt;code&gt;m1&lt;/code&gt; and make &lt;code&gt;m3&lt;/code&gt; dependent on that.&lt;/p&gt;

&lt;p&gt;Those extra mentainence efforts often ends up saving significant amounts of time and space during program runs, which is a payoff that justifies the lazy evaluation.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>[MECpp]Item-16 Remember 80-20 Rule</title>
      <link>http://nianze.tk/2018/04/remember-80-20-rule/</link>
      <pubDate>Tue, 10 Apr 2018 13:37:45 -0400</pubDate>
      
      <guid>http://nianze.tk/2018/04/remember-80-20-rule/</guid>
      <description>&lt;p&gt;The 80-20 rule states that 80 percent of a program&amp;rsquo;s resources are used by about 20 percent of the code.
&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;80% of the runtime is spent in approximately 20% of the code&lt;/li&gt;
&lt;li&gt;80% of the memory is used by some 20% of the code&lt;/li&gt;
&lt;li&gt;80% of the disk accesses are performed for about 20% of the code&lt;/li&gt;
&lt;li&gt;80% of the maintenance effort is devoted to around 20 percent of the code&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;To locate the critical pockets of code that are causing the problem, we should use the right way: using profilers.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;we want profilers the directly measures the resources we are interested in (how much time is being spent in different parts of the program)&lt;/li&gt;
&lt;li&gt;knowing how often statements are executed or functions are called may sometimes yield insight into what our software is doing&lt;/li&gt;
&lt;li&gt;feed the profiler with representative input data - profiler can only tell how a program behaved on a particular run&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>[MECpp]Item-15 Understand the Costs of Exception Handling</title>
      <link>http://nianze.tk/2018/04/understand-the-costs-of-exception-handling/</link>
      <pubDate>Mon, 09 Apr 2018 18:10:06 -0400</pubDate>
      
      <guid>http://nianze.tk/2018/04/understand-the-costs-of-exception-handling/</guid>
      <description>&lt;p&gt;Exception handling has costs, and we pay at least some of them even if we never use the keywords &lt;code&gt;try&lt;/code&gt;, &lt;code&gt;throw&lt;/code&gt;, or &lt;code&gt;catch&lt;/code&gt;.
&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;If we never use any exception-handling features:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;we pay for the space used by the data structures needed to keep track of which objects are fully constructed (MECpp item 10)&lt;/li&gt;
&lt;li&gt;we pay for the time needed to keep these data structures up to date&lt;/li&gt;
&lt;li&gt;Programs compiled with support for exceptions are typically slower and larger than their counterparts compiled without support for exceptions&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;If we include &lt;code&gt;try-catch&lt;/code&gt; blocks:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;the cost varies from compiler to compiler.&lt;/li&gt;
&lt;li&gt;roughly, the overall code size increases by 5-10%, assuming no exceptions are thrown&lt;/li&gt;
&lt;li&gt;roughly, the overall runtime goes up by 5-10%, assuming no exceptions are thrown&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;If we include exception specifications:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;they generally incurs about the same cost as a &lt;code&gt;try&lt;/code&gt; block&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The cost of throwing an exception:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Compared to a normal function return, returning from a function by throwing an exception may be as much as &lt;em&gt;three orders of magnitude&lt;/em&gt; slower&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;solution&#34;&gt;Solution&lt;/h3&gt;

&lt;p&gt;To minimize the exception-related costs,&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;compile without support for exceptions when that is feasible;&lt;/li&gt;
&lt;li&gt;limit the use of &lt;code&gt;try&lt;/code&gt; blocks, and exception specifications to locations where we really need them;&lt;/li&gt;
&lt;li&gt;throw exceptions only under conditions that are truly exceptional;&lt;/li&gt;
&lt;li&gt;profile the software (MECpp item 16) to determine if exception support is the bottleneck

&lt;ul&gt;
&lt;li&gt;If it is, consider switching to different compilers, ones that provide more efficient implementations of C++&amp;rsquo;s exception-handling features.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>[MECpp]Item-14 Use Exception Specifications Judiciously</title>
      <link>http://nianze.tk/2018/04/use-exception-specifications-judiciously/</link>
      <pubDate>Sun, 08 Apr 2018 23:51:00 -0400</pubDate>
      
      <guid>http://nianze.tk/2018/04/use-exception-specifications-judiciously/</guid>
      <description>&lt;p&gt;Exception specifications provide a documentation aid and an enforcement mechanism for constraints on exception usage, but they are only partly checked by compilers and they are easy to violate inadvertently.

&lt;!-- toc --&gt;&lt;/p&gt;

&lt;h1 id=&#34;the-good-points&#34;&gt;The good points&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Explicitly state what exception a function may throw&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Compilers are sometimes able to detect inconsistent exception specfications during compilation&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;If the inconsistency is not found during compilation but detected at runtime, the special funciton &lt;code&gt;unexpected&lt;/code&gt; is automatically invoked to constrain exception usage.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;There is a reason for compilers to &lt;em&gt;partially&lt;/em&gt; check exception usage for consistency with exception: the language standard &lt;em&gt;prohibits&lt;/em&gt; compilers from rejecting a call to a function that &lt;em&gt;might&lt;/em&gt; violate the exception specification of the function making the call in order to integrate with older code lacking such specifications:&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;extern void f1();  // might throw anything
void f2() throw (int)
{
    ...
    f1();  // legal even if f1 might throw sth other than an int
    ...
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;the-unwanted-points&#34;&gt;The unwanted points&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;The default behavior for &lt;code&gt;unexpected&lt;/code&gt; is to call &lt;code&gt;terminate&lt;/code&gt;, which by default will call &lt;code&gt;abort&lt;/code&gt;, preventing possible high-level exception handlers from dealing with unexpected exceptions.&lt;/p&gt;

&lt;p&gt;Sometimes the default behavior of immediate program termination is not what we want. For example, like the example code below, when an unanticipated exception propagates from inside the &lt;code&gt;logDestruction&lt;/code&gt; (which isn&amp;rsquo;t supposed to happen due to the assertion &lt;code&gt;throw()&lt;/code&gt; in exception specification after &lt;code&gt;logDestruction&lt;/code&gt;, but it&amp;rsquo;s possible due to a call to some other function that throws), by default, &lt;code&gt;unexpected&lt;/code&gt; will be called, and that will result in termination of the program, without letting the high-level destructor to catch and deal with the exception.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class Session {
public:
    ~Session();
    ...
private:
    static void logDestruction(Session *objAddr) throw();
};

Session::~Session()
{
    try {
        logDestruction(this);
    }
    catch (...) {}
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;the-solution&#34;&gt;The solution&lt;/h1&gt;

&lt;p&gt;To avoid calls to &lt;code&gt;unexpected&lt;/code&gt;:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;A good way to start is to avoid putting exception specifications on templates that take type argements, because there&amp;rsquo;s no way to know anything about the exceptions thrown by a template&amp;rsquo;s type parameters.&lt;/li&gt;
&lt;li&gt;A second technique is to omit exception specifications on functions making calls to functions that themselves lack exception specifications.&lt;/li&gt;
&lt;li&gt;A third technique is to handle exceptions &amp;ldquo;the system&amp;rdquo; may throw, such as &lt;code&gt;bad_alloc&lt;/code&gt; thrown by &lt;code&gt;operator new&lt;/code&gt; and &lt;code&gt;operator new[]&lt;/code&gt; when a memory allocation fails (MECpp item 8).&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;To cope with unexpected exceptions:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Exploit the fact that C++ allows us to replace unexpected exceptions with exceptions of a different type (&lt;code&gt;UnexpectedException&lt;/code&gt;), and add this type in the exception specification.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class UnexpectexException {};  // all unexpected exception obj. will be replaces
                               // by obj. of this type
void convertUnexpected()       // function to call is an unexpected exception is thrown
{
    throw UnexpectedException();
}

set_unexpected(convertUnexpected); // replace the default `unexpected` function with `convertUnexpected`
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Another way is to translate unexpected exceptions into &lt;code&gt;bad_exception&lt;/code&gt; by rethrowing the current exception in the customized &lt;code&gt;unexpected&lt;/code&gt; function, and include &lt;code&gt;bad_exception&lt;/code&gt; or its base class &lt;code&gt;exception&lt;/code&gt; in the exception specifications.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;void convertUnexpected()       // function to call is an unexpected exception is thrown
{
    throw;  // just rethrow the current exception
}

set_unexpected(convertUnexpected); // install convertUnexpected as the unexpected replacement
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>[MECpp]Item-13 Catch Exceptions by Reference</title>
      <link>http://nianze.tk/2018/04/catch-exceptions-by-reference/</link>
      <pubDate>Thu, 05 Apr 2018 18:57:13 -0400</pubDate>
      
      <guid>http://nianze.tk/2018/04/catch-exceptions-by-reference/</guid>
      <description>&lt;p&gt;If catching by reference, we sidestep the questions about object deletion, avoid slicing exception objects, retain the ability to catch standard exceptions, and limit the number of times exception objects being copied.

&lt;!-- toc --&gt;&lt;/p&gt;

&lt;h1 id=&#34;catch-by-pointer&#34;&gt;Catch by pointer&lt;/h1&gt;

&lt;p&gt;In order to catch by pointer, programmers need to define exception objects in a way that &lt;strong&gt;guarantees the objects exist&lt;/strong&gt; after control leaves the &lt;code&gt;throw&lt;/code&gt; site. Global and static objects work fine, but it&amp;rsquo;s easy for programmers to forget the constraint:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;void someFunction()
{
    exception ex;
    ...
    throw &amp;amp;ex;   // throw a pointer to an object 
    ...          // that&#39;s about to be destroyed
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;An alternative is to throw a pointer to a new heap object:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;void someFunction()
{
    ...
    throw new exception; // throw a pointer to a new heap-based object 
    ...  // hopefully the objerator new will not itself throw any exception
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This design will make a hard time for authors of &lt;code&gt;catch&lt;/code&gt; clauses: &lt;strong&gt;to delete or not to delete&lt;/strong&gt; the pointer they receive? In the &lt;code&gt;catch&lt;/code&gt; site, we can&amp;rsquo;t tell if an exception object is allocated on the heap or defined as a global (or static) object.&lt;/p&gt;

&lt;p&gt;Furthermore, catch-by-pointer runs &lt;strong&gt;contrary to the convention&lt;/strong&gt; of the language: the four standard exception&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:1&#34;&gt;&lt;a href=&#34;#fn:1&#34;&gt;1&lt;/a&gt;&lt;/sup&gt; - &lt;code&gt;bad_alloc&lt;/code&gt;, &lt;code&gt;bad_cast&lt;/code&gt;, &lt;code&gt;bad_typeid&lt;/code&gt;, and &lt;code&gt;bad_exception&lt;/code&gt; are all objects, rather than pointers to objefts, so we have to catch them by value or by reference.&lt;/p&gt;

&lt;h1 id=&#34;catch-by-value&#34;&gt;Catch by value&lt;/h1&gt;

&lt;p&gt;Catch-by-value requires exception objects be copied &lt;em&gt;twice&lt;/em&gt; each time they thrown (MECpp item 12), and it also has &lt;strong&gt;&lt;em&gt;slicing problem&lt;/em&gt;&lt;/strong&gt;: derived class exception objects caught as base class exceptions have their derivedness &amp;ldquo;sliced off&amp;rdquo; : they lack derived class data members, and resolve to base class virtual functions (the same behavior as when an object is passed to a function by value)&lt;/p&gt;

&lt;h1 id=&#34;catch-by-reference&#34;&gt;Catch by reference&lt;/h1&gt;

&lt;p&gt;Catch-by-reference suffers from none of the problems:
* Unlike catch-by-pointer, the question of object deletion fails to arise, and there&amp;rsquo;s no difficulty in catching the standard exception types
* Unlike catch-by-value, there is no slicing problem, and exception objects are copied only once.&lt;/p&gt;

&lt;p&gt;Of course, if there&amp;rsquo;s no need to change the exception object in the &lt;code&gt;catch&lt;/code&gt; site, we&amp;rsquo;d catch not just reference, but by reference to &lt;code&gt;const&lt;/code&gt;.&lt;/p&gt;
&lt;div class=&#34;footnotes&#34;&gt;

&lt;hr /&gt;

&lt;ol&gt;
&lt;li id=&#34;fn:1&#34;&gt;&lt;code&gt;bad_alloc&lt;/code&gt;: thrown when &lt;code&gt;operator new&lt;/code&gt; can&amp;rsquo;t satisfy a memory request (MECpp item 8); &lt;code&gt;bad_cast&lt;/code&gt;: thrown when a &lt;code&gt;dynamic_cast&lt;/code&gt; to a reference fails (MECpp item 2); &lt;code&gt;bad_typeid&lt;/code&gt;: thrown when &lt;code&gt;typeid&lt;/code&gt; is applied to a dereferenced null pointer; and &lt;code&gt;bad_exception&lt;/code&gt;: available for unexpected exceptions (MECpp item 14)
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:1&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;</description>
    </item>
    
    <item>
      <title>[MECpp]Item-12 Understand How Throwing an Exception Differs From Passing a Parameter or Calling a Virtual Function</title>
      <link>http://nianze.tk/2018/04/understand-how-throwing-an-exception-differs-from-passing-a-parameter-or-calling-a-virtual-function/</link>
      <pubDate>Wed, 04 Apr 2018 11:28:07 -0400</pubDate>
      
      <guid>http://nianze.tk/2018/04/understand-how-throwing-an-exception-differs-from-passing-a-parameter-or-calling-a-virtual-function/</guid>
      <description>&lt;p&gt;There are three primary ways in which passing an object to a function or using that object to invoke a virtual function differs from throwing the object as an exception.

&lt;!-- toc --&gt;&lt;/p&gt;

&lt;h1 id=&#34;similarity&#34;&gt;Similarity&lt;/h1&gt;

&lt;p&gt;There is similarity between passing an argument from a function call site to the function&amp;rsquo;s parameter and passing an exception from a &lt;code&gt;throw&lt;/code&gt; site to a &lt;code&gt;catch&lt;/code&gt; clause:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class Widget {...}

void f1(Widget w);
void f2(Widget&amp;amp; w);
void f3(const Widget&amp;amp; w);
void f4(Widget *pw);
void f5(const Widget *pw);

catch (Widget w) ...
catch (Widget&amp;amp; w) ...
catch (const Widget&amp;amp; w) ...
catch (Widget *pw) ...
catch (const Widget *pw) ...
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;differences&#34;&gt;Differences&lt;/h1&gt;

&lt;p&gt;However, there are still three difference:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;exception objects are always copied (when caught by value, they are copied twice), while objects passed to function parameters need not be copied at all.&lt;/li&gt;
&lt;li&gt;objects thrown as exceptions are subject to fewer forms of type conversion than are objects passed to functions.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;catch&lt;/code&gt; clauses are examined in the order in which they appear in the source code, and the first one that can succeed is selected for execution, while a virtual funciton invoked by an object is the one that provides the &lt;em&gt;best&lt;/em&gt; match for the type of the object, even if it&amp;rsquo;s not the first one listed in the source code.&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;difference-in-augument-passing&#34;&gt;Difference in augument passing&lt;/h2&gt;

&lt;p&gt;The first difference essentially grows out of the fact that when we call a function, control eventually returns to the call site, but when we throw an exception, constrol does &lt;em&gt;not&lt;/em&gt; return to the &lt;code&gt;throw&lt;/code&gt; site. For example:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;void throwWidget()
{
    Widget localWidget;
    throw localWidget; // throw localWidget as an exception
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In this typical case where &lt;code&gt;localWidget&lt;/code&gt; will go out of scope once control leaves &lt;code&gt;throwWidget&lt;/code&gt;, its destructor will be called, so C++ specifies that an object thrown as an exception is copied (even if the object being thrown is not in danger of being destroyed). This mandatory copying of exception objects leads to two implication:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;It is not possible for the &lt;code&gt;catch&lt;/code&gt; block to modify &lt;code&gt;localWidget&lt;/code&gt;; it can only modify a &lt;em&gt;copy&lt;/em&gt; of &lt;code&gt;localWidget&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Throwing an exception is typically much slower than parameter passing.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;copying-based-on-static-type&#34;&gt;Copying based on static type&lt;/h3&gt;

&lt;p&gt;It is worth noting that in C++ copying is always based on an object&amp;rsquo;s static type (MECpp item 25 shows a technique to copy based on dynamic type). Thus,&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class Widget {...};
class SpecialWidget: public Widget {...};

void throwWidget()
{
    SpecialWidget localSpecialWidget;
    Widget&amp;amp; rw = localSpecialWidget // rw refers to a SpecialWidget
    throw rw;  // this throws an exception of type Widget
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;rethrow&#34;&gt;Rethrow&lt;/h3&gt;

&lt;p&gt;Another impact caused from copying exceptions objects is that there&amp;rsquo;s difference between different rethrow statements:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;catch (Widget&amp;amp; w)  // catch Widget exceptions
{
    ...
    throw;  // rethrow the exception so it continues to propagate
}

catch (Widget&amp;amp; w)  // catch Widget exceptions
{
    ...
    throw w;  // propagate a copy of the caught exception
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here, the first block rethrows the current exception, while the second one throws a new copy of the current exception. Apart from performance cost of the additional copy operation in the second block, there&amp;rsquo;s another suble difference: if the exception originally thrown was of type &lt;code&gt;SpecialWidget&lt;/code&gt;, the first block would propagate a &lt;code&gt;SpecialWidget&lt;/code&gt; exception (even though &lt;code&gt;w&lt;/code&gt;&amp;rsquo;s static type is &lt;code&gt;Widget&lt;/code&gt;) and no copy is made during &lt;code&gt;throw;&lt;/code&gt;, while the second &lt;code&gt;catch&lt;/code&gt; block throws a &lt;em&gt;new&lt;/em&gt; exception being the type of &lt;code&gt;Widget&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;In general, we&amp;rsquo;ll want to use the&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;throw;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;syntax to rethrow the current exception for its consistency and efficiency.&lt;/p&gt;

&lt;h3 id=&#34;different-catch-syntax&#34;&gt;Different &lt;code&gt;catch&lt;/code&gt; syntax&lt;/h3&gt;

&lt;p&gt;There are three kinds of &lt;code&gt;catch&lt;/code&gt; clauses for exception of type &lt;code&gt;Widget&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;catch (Widget w) ...  // catch by value
catch (Widget&amp;amp; w) ... // catch by reference
catch (const Widget&amp;amp; w) ... // catch by reference-to-const
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A few points to note:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;A thrown object (which is always a copied temporary) may be caught by simple reference, but it is not allowed in function calls (item 19) to pass a temporary object to a non-&lt;code&gt;const&lt;/code&gt; reference parameter.&lt;/li&gt;
&lt;li&gt;The first statement (catch by value) leads to &lt;em&gt;two&lt;/em&gt; copies of the thrown object, one to create the temporary that all exceptions generate, the other to copy that temporary into &lt;code&gt;w&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;For the catch by reference and catch by reference-to-const, we expect to pay for one copy of the exception. In contrast, when we pass function parameters by reference (or reference-to-const), no copying takes place.&lt;/li&gt;
&lt;li&gt;Throw by pointer is equivalent to pass by pointer. Either way, a copy of the pointer is passed. Just remember not to throw a pointer to a local object.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;difference-in-type-matching&#34;&gt;Difference in type matching&lt;/h2&gt;

&lt;p&gt;Implicit conversions (such from &lt;code&gt;int&lt;/code&gt; to &lt;code&gt;double&lt;/code&gt;) are not applied when matching exceptions to &lt;code&gt;catch&lt;/code&gt; clauses:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;void f(int value)
{
    try {
        if (someFunction()) {
            throw value;
        }
        ...
    }
    catch (double d) { // handle double type exceptions
        ...
    }
    ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In this case, the &lt;code&gt;int&lt;/code&gt; exception thrown in &lt;code&gt;try&lt;/code&gt; block will never be caught by the &lt;code&gt;catch&lt;/code&gt; clause taking a &lt;code&gt;double&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Basically, two kinds of conversions are applied during &lt;code&gt;catch&lt;/code&gt; matching:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;inheritance-based conversions
For example, &lt;code&gt;range_error&lt;/code&gt;, &lt;code&gt;underflow_error&lt;/code&gt;, and &lt;code&gt;overflow_error&lt;/code&gt; are derived types from &lt;code&gt;runtime_error&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;catch (runtime_error) ...         // can catch errors of type
catch (runtime_error&amp;amp;) ...        // runtime_error,
catch (const runtime_error&amp;amp;) ...  // range_error, or overflow_error
    
catch (runtime_error*) ...        // can catch errors of type runtime_error*
catch (const runtime_error*) ...  // range_error*, or overflow_error*
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;from a typed to an untyped pointer&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;catch (const void*) ...   // catches any exception that&#39;s a pointer
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;difference-in-fitting-strategy&#34;&gt;Difference in fitting strategy&lt;/h2&gt;

&lt;p&gt;Catch clauses are always tried in the order of their appearance (employing a &amp;ldquo;first fit&amp;rdquo; strategy). For exampel:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;try {
    ...
}
catch (logic_error&amp;amp; ex) {  // this block will catch all logic_error exceptions
    ...                    // including invalid_argument exception, which is derived type
}
catch (invalid_argument&amp;amp; ed) {
    ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;on the contrary, when we call a virtual function, the function invoked is the one in the class &lt;code&gt;closest&lt;/code&gt; to the dynamica type of the object invoking the function (employing a &amp;ldquo;best fit&amp;rdquo; algorithm).&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>[MECpp]Item-11 Prevent Exceptions From Leaving Destructors</title>
      <link>http://nianze.tk/2018/04/prevent-exceptions-from-leaving-destructors/</link>
      <pubDate>Tue, 03 Apr 2018 10:54:39 -0400</pubDate>
      
      <guid>http://nianze.tk/2018/04/prevent-exceptions-from-leaving-destructors/</guid>
      <description>&lt;p&gt;Keep exceptions from propagating out of destructors to prevent C++ calling &lt;code&gt;terminate&lt;/code&gt; during the statck-unwinding part of exception propagation and ensure that every neccessary cleanup is accomplished.
&lt;/p&gt;

&lt;p&gt;Destructor is called in two situations:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;when an object is destroyed under &amp;ldquo;normal&amp;rdquo; conditions, e.g., when it goes out of scope, or is explicitly &lt;code&gt;delete&lt;/code&gt;d.&lt;/li&gt;
&lt;li&gt;when an object is destroyed by the exception-handling mechanism during the stackunwinding part of exception propagation.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;According to C++:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;When control leaves a destructor due to an exception while another exception is active, C++ calls the &lt;code&gt;termiante&lt;/code&gt; function immediately, and any remaining local objects may not get a chance to be destroyed.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;For example, consider a &lt;code&gt;Session&lt;/code&gt; class that will record object creations and destructions:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class Session {
public:
    Session();
    ~Session();
    ...
private:
    static void logCreation(Session *objAddr);
    static void logDestruction(Session *objAddr);
};

Session::~Session()
{
    logDestruction(this);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Because there&amp;rsquo;s no &lt;code&gt;try...catch&lt;/code&gt; statement, any exception inside the destructor will be propagated to the caller of the destructor. Thus once &lt;code&gt;logDestructoin&lt;/code&gt; throws an exception during a special case when the destructor itself is called due to some other exception, the &lt;code&gt;terminate&lt;/code&gt; function would automatically be invoked. So we prefer this design:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;Session::~Session()
{
    try {
        logDestruction(this);
    }
    catch (...) {}  // do nothing!
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The point here is that the &lt;code&gt;catch&lt;/code&gt; block shouldn&amp;rsquo;t hold any statement that has potential of throwing exception, and its only purpose here is to prevent exception thrown from &lt;code&gt;logDestruction&lt;/code&gt; from propagating beyond &lt;code&gt;Session&lt;/code&gt;&amp;rsquo;s destructor. Another good reason of catching the exception and prevent the propagation is to make sure the destructor will run to completion, so that any leftover cleanup code after the exception-thrown statement is able to run properly, without being interrupted by the excpetion propagation.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>[MECpp]Item-10 Prevent Resource Leaks in Constructors</title>
      <link>http://nianze.tk/2018/04/prevent-resource-leaks-in-constructors/</link>
      <pubDate>Mon, 02 Apr 2018 15:56:25 -0400</pubDate>
      
      <guid>http://nianze.tk/2018/04/prevent-resource-leaks-in-constructors/</guid>
      <description>&lt;p&gt;Replace pointer class members with their corresponding smart pointer objects to fortify the constructors against resource leaks in the presence of exceptions, to eliminate the need to manually deallocate resources in destructors, and to allow &lt;code&gt;const&lt;/code&gt; member pointers to be handled in the smae graceful fashion as non-&lt;code&gt;const&lt;/code&gt; pointers.

&lt;!-- toc --&gt;&lt;/p&gt;

&lt;h1 id=&#34;example&#34;&gt;Example&lt;/h1&gt;

&lt;p&gt;Suppose we want to develop a software for a multimedia address book that might hold information of a person&amp;rsquo;s name, address, phone numbers, a picture of the person and, the sound of their voice:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class Image {  // for holding image data
public:
    Image (const string&amp;amp; imageDataFileName);
    ...
};

class AudioClip {  // for holding audio data
public:
    AudioClip(const string&amp;amp; sudioDataFileName);
    ...
};

class PhoneNumber {...}; // for holding phone numbers

class BookEntry {
public:
    BookEntry(const string&amp;amp; name,  // name data is mandatory for BookEntry, other fields are optional
              const string&amp;amp; address = &amp;quot;&amp;quot;,
              const string&amp;amp; imageFileName = &amp;quot;&amp;quot;,
              const string&amp;amp; audioClipFileName = &amp;quot;&amp;quot;);
    ~BookEntry();
    void addPhoneNumber(const PhoneNumber&amp;amp; number); // phone numbers are added via this function
    ...
private:
    string theName;
    string theAddress;
    list&amp;lt;PhoneNumber&amp;gt; thePhones;
    Image *theImage;
    AudioClip *theAudioClip;
};
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;naive-implementation&#34;&gt;Naive implementation&lt;/h1&gt;

&lt;p&gt;A straightforward implementation for constructor and destructor:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;BookEntry::BookEntry(const string&amp;amp; name,
                     const string&amp;amp; address,
                     const string&amp;amp; imageFileName,
                     const string&amp;amp; audioClipFileName)
: theName(name), theAddress(address),
  theImage(0), theAudioClip(0)
{
    if (imageFileName != &amp;quot;&amp;quot;) {
        theImage = new Image(imageFileName);
    }
    if (audioClipFileName != &amp;quot;&amp;quot;) {
        theAudioClip = new AudioClip(audioClipFileName);
    }
}

BookEntry::~BookEntry()
{
    delete theImage;  // C++ guarantees it&#39;s safe to delete null pointers
    delete theAudoClip;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Everything looks good, however, there is potential resource leak under abnormal conditions: when an exception is thrown duringg exectuion of &lt;code&gt;theAudioClip = new AudioClip(audioClipFileName);&lt;/code&gt;:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;An exception might arise because &lt;code&gt;operator new&lt;/code&gt; (MECpp item 8) is unable to allocate enough memory for an &lt;code&gt;AudioClip&lt;/code&gt; object, or coming from &lt;code&gt;AudioClip&lt;/code&gt; constructor who throws an exception itself, ending up with a exception propagated to the site where the &lt;code&gt;BookEntry&lt;/code&gt; object is being created&lt;/li&gt;
&lt;li&gt;C++ destroys only &lt;em&gt;fully constructed&lt;/em&gt; objects, and an object isn&amp;rsquo;t fully constructed until its construtor has run to completion.&lt;/li&gt;
&lt;li&gt;The exception propagated from &lt;code&gt;new AudioClip(audioClipFileName&lt;/code&gt; interrupts the construction of the &lt;code&gt;BookEntry&lt;/code&gt; object, so the &lt;code&gt;BookEntry&lt;/code&gt;&amp;rsquo;s destructor will never be called, and nobody will delete the object that &lt;code&gt;theImage&lt;/code&gt; already points to.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Note that adding &lt;code&gt;try...catch&lt;/code&gt; outside of the &lt;code&gt;BookEntry&lt;/code&gt; constructor does not help:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;void testBookEntryClass()
{
    BookEntry *pb = 0;
    try {
        pb = new BookEntry(&amp;quot;Sherlock Holmes&amp;quot;, &amp;quot;221B Baker Street&amp;quot;);
        ...
    }
    catch (...) {  // catch all exceptions
        delete pb; // delete pb when an exception is thrown
        throw;     // propagate exception to caller
    }
    delete pb;     // delete pb normally
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If &lt;code&gt;BookEntry&lt;/code&gt;&amp;rsquo;s constructor throws an exception, no assignment is made to &lt;code&gt;pb&lt;/code&gt; and &lt;code&gt;pb&lt;/code&gt; will be a null pointer, so deleting it in the &lt;code&gt;catch&lt;/code&gt; block does nothing except make us feel better about ourselves.&lt;/p&gt;

&lt;h1 id=&#34;workable-but-inelegant-implementation&#34;&gt;Workable (but inelegant) implementation&lt;/h1&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;BookEntry::BookEntry(const string&amp;amp; name,
                     const string&amp;amp; address,
                     const string&amp;amp; imageFileName,
                     const string&amp;amp; audioClipFileName)
: theName(name), theAddress(address),
  theImage(0), theAudioClip(0)
{
    try {
        if (imageFileName != &amp;quot;&amp;quot;) {
            theImage = new Image(imageFileName);
        }
        if (audioClipFileName != &amp;quot;&amp;quot;) {
            theAudioClip = new AudioClip(audioClipFileName);
        }
    }
    catch (...) {               // catch any exception
        delete theImage;        // perform necessary cleanup actions
        delete theAudioClip;
        throw;                  // propagate the exception
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;For non-pointer data members such as &lt;code&gt;theName&lt;/code&gt;, &lt;code&gt;theAddress&lt;/code&gt;, and &lt;code&gt;thePhones&lt;/code&gt;, they are automatically initialized before a class&amp;rsquo;s constructor is called, so if a &lt;code&gt;BookEntry&lt;/code&gt; constructor body begins exewcuting, they have already been fully constructed. As fully constructed objects, they will also be automatically destroyed even if an exception arises in  the &lt;code&gt;BookEntry&lt;/code&gt; constructor.&lt;/p&gt;

&lt;p&gt;Considering code duplication, we may move the common resource cleanup code into a private helper funciton and have both the constructor and the destructor call it:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class BookEntry {
public:
    ... // as before
private:
    ... 
    void cleanup();  // common cleanup statement
};

void BookEntry::cleanup()
{
    delete theImage;
    delete theAudioClip;
}

BookEntry::BookEntry(const string&amp;amp; name,
                     const string&amp;amp; address,
                     const string&amp;amp; imageFileName,
                     const string&amp;amp; audioClipFileName)
: theName(name), theAddress(address),
  theImage(0), theAudioClip(0)
{
    try {
        ...
    }
    catch (...) {               // catch any exception
        cleanup();
        throw;                  // propagate the exception
    }
}

BookEntry::~BookEntry()
{
    cleanup();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;h1 id=&#34;for-both-constant-and-non-const-pointers&#34;&gt;For both &lt;code&gt;constant&lt;/code&gt; and non-&lt;code&gt;const&lt;/code&gt; pointers&lt;/h1&gt;

&lt;p&gt;What if &lt;code&gt;BookEntry&lt;/code&gt; class interface is designed differently, with &lt;code&gt;theImage&lt;/code&gt; and &lt;code&gt;theAudioClip&lt;/code&gt; defined as &lt;code&gt;constant&lt;/code&gt; pointers, which must be initialized via the member initialization lists:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class BookEntry {
public:
    ...
private:
    ...
    Image * const theImage;
    AudioClip * const theAudioClip;
};
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;naive-implementation-1&#34;&gt;Naive implementation&lt;/h2&gt;

&lt;p&gt;We may be tempted to initit &lt;code&gt;theImage&lt;/code&gt; and &lt;code&gt;theAudioClip&lt;/code&gt; like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;// an implementation that may leak resources if an exception is thrown
BookEntry::BookEntry(const string&amp;amp; name,
                     const string&amp;amp; address,
                     const string&amp;amp; imageFileName,
                     const string&amp;amp; audioClipFileName)
: theName(name), theAddress(address),
  theImage(imageFileName != &amp;quot;&amp;quot;
           ? new Image(imageFileName)
           : 0), 
  theAudioClip(audioClipFileName != &amp;quot;&amp;quot;
               ? new AudioClip(audioClipFileNAme)
               : 0)
{}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;but this leads to the problem of potential resource leak: if an exception is thrown during initialization of &lt;code&gt;theAudioClip&lt;/code&gt;, the object pointed to by &lt;code&gt;theImage&lt;/code&gt; is never destroyed.&lt;/p&gt;

&lt;h2 id=&#34;workable-design&#34;&gt;Workable design&lt;/h2&gt;

&lt;p&gt;In order to add &lt;code&gt;try&lt;/code&gt; and &lt;code&gt;catch&lt;/code&gt; to perform cleanup tasks in a member initialization list, we may consider put them inside private member functions that return pointers:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class BookEntry {
public:
    ...
private:
    ...
    Image * initImage(const string&amp;amp; imageFileName);
    AudioClip * initAudioClip(const string&amp;amp; audioClipFileName);
};

BookEntry::BookEntry(const string&amp;amp; name,
                     const string&amp;amp; address,
                     const string&amp;amp; imageFileName,
                     const string&amp;amp; audioClipFileName)
: theName(name), theAddress(address),
  theImage(initImage(imageFileName)),
  theAudioClip(initAudioClip(audioClipFileName))
{}

// theImage is init. first, so there&#39;s no need to worry about a resource leak
// if this initialization fails.
Image * BookEntry::initImage(const string&amp;amp; imageFileName)
{
    if (imageFileName != &amp;quot;&amp;quot;) return new Image(imageFileName);
    else return 0;
}

// theAudioClip is initialized second, so it must take care of theImage&#39;s resources
// if an exception is thrown during initialization of theAudioClip 
AudioClip * BookEntry::initAudioClip(const string&amp;amp; audioClipFileName)
{
    try {
        if (audioClipFileName != &amp;quot;&amp;quot;) {
            return new AudioClip(audioClipFileName);
        }
        else return 0;
    }
    catch (...) {
        delete theImage;
        throw;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This design works, but the drawback is that code that conceptually belongs in a constructor is now dispersed across several functions, and that&amp;rsquo;s a maitenance headache.&lt;/p&gt;

&lt;h2 id=&#34;better-design&#34;&gt;Better design&lt;/h2&gt;

&lt;p&gt;A better design is to adopt the advise of MECpp Item 9 (as well as item 13):&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;treat the objects pointed to by &lt;code&gt;theImage&lt;/code&gt; and &lt;code&gt;theAudioClip&lt;/code&gt; as resources to be managed by local objects (specifically, smart pointers).&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Since the resource here is of pointer types, we can use smart pointers to manage them. Take &lt;code&gt;auto_ptr&lt;/code&gt; for example:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class BookEntry {
public:
    ...
private:
    ...
    const auto_ptr&amp;lt;Image&amp;gt; theImage;
    const auto_ptr&amp;lt;AudioClip&amp;gt; theAudioClip;
};

BookEntry::BookEntry(const string&amp;amp; name,
                     const string&amp;amp; address,
                     const string&amp;amp; imageFileName,
                     const string&amp;amp; audioClipFileName)
: theName(name), theAddress(address),
  theImage(imageFileName != &amp;quot;&amp;quot;
           ? new Image(imageFileName)
           : 0), 
  theAudioClip(audioClipFileName != &amp;quot;&amp;quot;
               ? new AudioClip(audioClipFileNAme)
               : 0)
{}

BookEntry::~BookEntry()  // nothing to do
{}                       
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In this design, if an exception is thrown during initialization of &lt;code&gt;theAudioClip&lt;/code&gt;, &lt;code&gt;theImage&lt;/code&gt; is already a fully constructed object, so it will automatically be destroyed, jsut like &lt;code&gt;theName&lt;/code&gt;, &lt;code&gt;theAddress&lt;/code&gt;, and &lt;code&gt;thePhones&lt;/code&gt;. Furthermore, because &lt;code&gt;theImage&lt;/code&gt; and &lt;code&gt;theAudioClip&lt;/code&gt; are now objects, they&amp;rsquo;ll be destroyed automatically when the &lt;code&gt;BookEntry&lt;/code&gt; object containing them is destroyed.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Vocaloid调教初始：空奏列车</title>
      <link>http://nianze.tk/2018/04/kuusou-ressha/</link>
      <pubDate>Sun, 01 Apr 2018 00:00:00 +0000</pubDate>
      
      <guid>http://nianze.tk/2018/04/kuusou-ressha/</guid>
      <description>&lt;p&gt;首次尝试调教星尘。
&lt;/p&gt;

&lt;p&gt;一直想试下作些流行曲玩玩，所以就选了蜜柑星的这首空奏列车试了下。 发现果然调教是挺麻烦的事情，很多细节需要仔细去抠，而且网上的相关讨论资源比较杂，会有很多坑需要自己去踩了才知道。再加上Vocaloid editor没有原生mac版本，和DAW交互也不太方便。&lt;/p&gt;

&lt;p&gt;看到有帖子介绍说piapro studio插件可以跟logic pro联动，但是几经尝试没有发现可以成功安装的版本（目前只是纯玩玩还不太想买正版），所以只好先用Wine移植版本的Vocaloid4 editor凑合用了。&lt;/p&gt;

&lt;p&gt;本次除了尝试调教，也尝试了下作词翻译。大体上是按照原歌词的意思在编，不过也加入了一些自己的想法。&lt;/p&gt;

&lt;hr /&gt;

&lt;iframe src=&#34;//player.bilibili.com/player.html?aid=21509629&amp;cid=35407666&amp;page=1&#34; scrolling=&#34;no&#34; border=&#34;0&#34; height=&#34;415&#34; width=&#34;544&#34; frameborder=&#34;no&#34; framespacing=&#34;0&#34; allowfullscreen=&#34;true&#34;&gt; &lt;/iframe&gt;

&lt;pre&gt;&lt;code&gt;海上 黎明 地平线
风平浪静

来吧 向前直线穿越
这变幻莫测的未来

昨天今天明天
该怀揣怎样心愿
才不忘曾经伤感
心中惴惴不安

世上一切早已有了定数 
总是在 疲于应付
就像 永不停止向前 的世界航班
从不等人闲
逾时离站

然而此刻依然向明天急赶
定能通向梦终点站
开始奔走 就无法停止向前
恍惚间回现 空奏和弦

不只今天全力冲线
明天后天就是今天
心中所想未来画面
越来越清晰可见

回首过去那些冒险
至今为止的暧昧伤感
再也不能哭泣离线 
是时候告别说再见

不存在唯一答案
弹奏出来吧啊 
属于自己的和弦
每个不曾翩翩起舞的瞬间
都是对生命辜负誓言

明日之空已展现
化成风吧 吹向那地平线另一边
曾经祈愿 的那个夏天海边 扬帆出航前
再续前缘 

化成风吧 我的歌声 yeah... wow...
如此坚持 我就是我 别样的歌 不一样的颜色

心中幻境 如此渴望 yeah... wow...
终点站的倒计时针 也逐渐来到 最后的时刻

世上一切早已有了定数
总是在 疲于应付
就像 这不停向前的 时代列车般
从不等人闲
逾时离站

然而此刻依然要向明天急赶
定能通向梦终点站
开始奔走 就无法停止向前
恍惚间回现 空奏和弦
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>[MECpp]Item-9 Use Destructors to Prevent Resource Leaks</title>
      <link>http://nianze.tk/2018/04/use-destructors-to-prevent-resource-leaks/</link>
      <pubDate>Sun, 01 Apr 2018 00:00:00 +0000</pubDate>
      
      <guid>http://nianze.tk/2018/04/use-destructors-to-prevent-resource-leaks/</guid>
      <description>&lt;p&gt;To avoid resource leaks in the presence of exceptions, we can encapsulate resources inside objects.

&lt;!-- toc --&gt;&lt;/p&gt;

&lt;h1 id=&#34;using-objects-to-manage-pointer-based-resource&#34;&gt;Using objects to manage pointer-based resource&lt;/h1&gt;

&lt;p&gt;Suppose we&amp;rsquo;re writing software for a shelter names Adorable Little Animals, an organization that finds homes for puppies and kittens. Each day the shelter creates a file containing information on the adoptions it arranged that day, so we need to read these files and do the approgriate procesing for each adoption.&lt;/p&gt;

&lt;p&gt;A reasonable design will use polymorphism: an abstract base class &lt;code&gt;ALA&lt;/code&gt; (&amp;ldquo;adorable little animal&amp;rdquo;), with two concrete derived classes for puppies and kittens, and a virtual function &lt;code&gt;processAdoption&lt;/code&gt; to handle the necessary species-specific processing:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class ALA {
public:
    virtual void processAdoption() = 0;
    ...
};

class Puppy: public ALA {
public:
    virtual void processAdoption();
    ...
};

class Kitten: public ALA {
public:
    virtual void processAdoption();
    ...
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Another thing we need is a &lt;em&gt;virtual constructor&lt;/em&gt; (MECpp item 25), which reads information from a file and produce either a &lt;code&gt;Puppy&lt;/code&gt; object or a &lt;code&gt;Kitten&lt;/code&gt; object, depending on the information in the file:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;ALA * readALA(istream&amp;amp; s);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Finally, the key processing part of the program looks like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;void processAdoptions(istream&amp;amp; dataSource)
{
    while (dataSource) {
        ALA *pa = readALA(dataSource);
        pa-&amp;gt;processAdoption();
        delete pa;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;However, there&amp;rsquo;s a potential resource leak: if &lt;code&gt;pa-&amp;gt;processAdoption&lt;/code&gt; threw an exception, all statements in &lt;code&gt;processAdoptions&lt;/code&gt; after this statement would be skipped, ending up with &lt;code&gt;pa&lt;/code&gt; never getting deleted. To solve it, an ungly design would be:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;void processAdoptions(istream&amp;amp; dataSource)
{
    while (dataSource) {
        ALA *pa = readALA(dataSource);
        try {
        pa-&amp;gt;processAdoption();
        }
        catch (...) {
            delete pa;   // avoid resource leak when encountering exception
            throw;       // propagate exception to caller
        }
        delete pa;       // delete pa in normal condition
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The duplication in cleanup code is annoying to write and difficult to maintain. Remember that&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Local objects are always destroyed when leaving a function, regardless of how that function is exited &lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:1&#34;&gt;&lt;a href=&#34;#fn:1&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;So we can move the &lt;code&gt;delete&lt;/code&gt; into a destructor for an object local to &lt;code&gt;processAdoptions&lt;/code&gt;, which is exactly the functionaltity smart pointers in standard C++ library provide. For example, the essential of &lt;code&gt;auto_ptr&lt;/code&gt; (item 13, MECpp item 28) boils down to following definition:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;template&amp;lt;class T&amp;gt;
class auto_ptr {
public:
    auto_ptr(T *p = 0): ptr(p) {}  // save ptr to object
    ~auto_ptr() { delete ptr; }    // delete ptr to object
private:
    T *ptr;                        // raw ptr to object
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;New &lt;code&gt;processAdoptions&lt;/code&gt; using an &lt;code&gt;auto_ptr&lt;/code&gt; object instead of a raw pointer:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;void processAdoptions(istream&amp;amp; dataSource)
{
    while (dataSource) {
        auto_ptr&amp;lt;ALA&amp;gt; pa(readALA(dataSource));
        pa-&amp;gt;processAdoption();
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;!-- toc --&gt;

&lt;h1 id=&#34;using-objects-to-manage-other-resources&#34;&gt;Using objects to manage other resources&lt;/h1&gt;

&lt;p&gt;The idea behind &lt;code&gt;auto_ptr&lt;/code&gt; is to use an object to store a resource that needs to be automatically released via the object&amp;rsquo;s destructor, which applis to broader ranges of resource types as well. For example, in a GUI application that needs to create a window to display some information:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;void displayInfo(const Information&amp;amp; info) 
{
    WINDOW_HANDLE w(createWindow());
    display &amp;quot;info&amp;quot; in window corresponding to &amp;quot;w&amp;quot;;
    destroyWindw(w);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The functions &lt;code&gt;createWindow&lt;/code&gt; and &lt;code&gt;destroyWindow&lt;/code&gt; for acquiring and releasing window resources should be packaged in an object to avoid resource leak in the situations where an exception is thrown during process of displaying &lt;code&gt;info&lt;/code&gt; in &lt;code&gt;w&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;// class for acquiring and releasing a window handle
class WindowHandle {
public:
    WindowHandle(WINDOW_HANDLE handle): w(handle) {}
    ~WindowHandle() { destroyWindow(w); }

    operator WINDOW_HANDLE() { return w; }  // implicit convertion operator to turn a WindowHandle into a WINDOW_HANDLE
private:
    WINDOW_HANDLE w;
    WindowHandle(const WindowHandle&amp;amp;); // prevent multiple copies
    WindowHandle&amp;amp; operator=(const WindowHandle&amp;amp;);  // prevent multiple copies
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note that the implicit conversion operator is essential to the practical application of a &lt;code&gt;WindowHandle&lt;/code&gt; object, becauce it means we can use a &lt;code&gt;WindowHandle&lt;/code&gt; just about anywhere we would normally use a raw &lt;code&gt;WINDOW_HANDLE&lt;/code&gt; (refer to MECpp item 5 for downsides of doing so).&lt;/p&gt;

&lt;p&gt;Given this &lt;code&gt;WindowHandle&lt;/code&gt; class, we can rewrite &lt;code&gt;desplayInfo&lt;/code&gt; as follows:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;void displayInfo(const Information&amp;amp; info) 
{
    WindowHandle w(createWindow());
    display &amp;quot;info&amp;quot; in window corresponding to &amp;quot;w&amp;quot;;
}  // the window handled by &amp;quot;w&amp;quot; will always be released even if an exception is thrown
&lt;/code&gt;&lt;/pre&gt;
&lt;div class=&#34;footnotes&#34;&gt;

&lt;hr /&gt;

&lt;ol&gt;
&lt;li id=&#34;fn:1&#34;&gt;The only exception to this rule is when we call &lt;code&gt;longjmp&lt;/code&gt;, and this shortcoming of &lt;code&gt;longjmp&lt;/code&gt; is the primary reason why C++ has support for exceptions in the first place.
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:1&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;</description>
    </item>
    
    <item>
      <title>[MECpp]Item-8 Understand the Different Meanings of New and Delete</title>
      <link>http://nianze.tk/2018/03/understand-the-different-meanings-of-new-and-delete/</link>
      <pubDate>Fri, 30 Mar 2018 17:09:04 -0400</pubDate>
      
      <guid>http://nianze.tk/2018/03/understand-the-different-meanings-of-new-and-delete/</guid>
      <description>&lt;p&gt;The behaviors of &lt;code&gt;new&lt;/code&gt; operator and &lt;code&gt;operator new&lt;/code&gt; is different.

&lt;!-- toc --&gt;&lt;/p&gt;

&lt;h1 id=&#34;relationship-between-new-operator-and-operator-new&#34;&gt;Relationship between &amp;lsquo;&lt;code&gt;new&lt;/code&gt; operator&amp;rsquo; and &amp;lsquo;&lt;code&gt;operator new&lt;/code&gt;&amp;lsquo;&lt;/h1&gt;

&lt;p&gt;Consider the following code:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;string *ps = new string(&amp;quot;Memory Management&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;new&lt;/code&gt; operator here is built into the language and always does the same two things:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;first, it calls &lt;code&gt;operator new&lt;/code&gt; to allocate enough memory to hold an object of the type requested.&lt;/li&gt;
&lt;li&gt;second, it calls a constructor to initialize an object in the memory that was allocated.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Thus, when compiler sees the code above, they must generate code equivalent to this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;void *memory = operator new(sizeof(string)); // get raw memory for a string object
call string::string(&amp;quot;Memory Management&amp;quot;) on *memory // init. the object in the memory. 
                                                    // as programmer, directly calling the ctor is prohibited
string *ps = static_cast&amp;lt;stirng*&amp;gt;(memory);  // make ps point to the new object
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So if we want to create an object on the heap, use the &lt;code&gt;new&lt;/code&gt; operator and it both allocates memory and calls a constructor for the object.&lt;/p&gt;

&lt;p&gt;However, if we want to do some customized behaviors, we may consider following options:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;if we only want to allocate memory, just call &lt;code&gt;operator new&lt;/code&gt; directly:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;void *rawMemory = operator new(sizeof(string));
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;if we want to customize the memory allocation that takes place when heap objects are created, write our own version of &lt;code&gt;operator new&lt;/code&gt; and use the &lt;code&gt;new&lt;/code&gt; operator, which will automatically invoke the custom version of &lt;code&gt;operator new&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;if we want to construct an object in memory we&amp;rsquo;ve already got a pointer to, use &lt;strong&gt;placement &lt;code&gt;new&lt;/code&gt;&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;A special version of &lt;code&gt;oeprator new&lt;/code&gt; called &lt;em&gt;placement &lt;code&gt;new&lt;/code&gt;&lt;/em&gt; allows us to construct an object in the memory that&amp;rsquo;s already been allocated, which is helpful for applications using shared memory or memory-mapped I/O, where objects must be placed at specific addresses or in memory allocated by special routines:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class Widget {
public:
    Widget(int widgetSize);
    ...
};

Widget * constructWidgetInBuffer(void *buffer, int widgetSize)
{
    return new (buffer) Widget(widgetSize);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here, an additional argument (&lt;code&gt;buffer&lt;/code&gt;) is being specified for the implicit call that the &lt;code&gt;new&lt;/code&gt; operator makes to a special version of &lt;code&gt;operator new&lt;/code&gt; known as placement &lt;code&gt;new&lt;/code&gt; in standard C++ library&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:1&#34;&gt;&lt;a href=&#34;#fn:1&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;void * operator new(size_t, void *location)
{
    return location;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;All placement &lt;code&gt;new&lt;/code&gt; has to do is return the pointer that&amp;rsquo;s passed into it, because the memory for the object is already known. The unused (but mandatory) &lt;code&gt;size_t&lt;/code&gt; parameter has no name to keep compilers from complaining about its not being used (MECpp item 6).&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&#34;deletion-and-memory-deallocation&#34;&gt;Deletion and memory deallocation&lt;/h1&gt;

&lt;p&gt;The &lt;code&gt;delete&lt;/code&gt; operator also includes two steps: destructing the object and deallocating the memory occupied by that object. The second part of memory deallocation is performed by the &lt;code&gt;operator delete&lt;/code&gt; function:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;void operator delete(void *memoryToBeDeallocated);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Hence, for a pointer to string &lt;code&gt;ps&lt;/code&gt;, &lt;code&gt;delete ps;&lt;/code&gt; causes compilers to generate code that approximately corresponds to this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;ps-&amp;gt;~string();         // call the object&#39;s dtor
operator delete(ps);   // deallocate the memory the object occupied
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Some implications:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;If we want to deal with raw, uninitialized memory&lt;/strong&gt;, we should call &lt;code&gt;operator new&lt;/code&gt; to get memory and &lt;code&gt;operator delete&lt;/code&gt; to return it to the system (the C++ equivalent of calling &lt;code&gt;malloc&lt;/code&gt; and &lt;code&gt;free&lt;/code&gt;):&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;void *buffer = operator new (50*sizeof(char)); // allocate enough memory to hold 50 chars, call no ctor
...
operator delete(buffer); // deallocate the memory; call no dtor
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;If we use placement &lt;code&gt;new&lt;/code&gt; to create an object in some memory&lt;/strong&gt;, we should avoid using the &lt;code&gt;delete&lt;/code&gt; operator on that memory:&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;// function to allocating and deallocating memory in shared memory
void * mallocShared(size_t size);
void freeShared(void *memory);

void *sharedMemory = mallocShared(sizeof(Widget));
Widget *pw = constructWidgetInBuffer(sharedMemory, 10); // as above
...
delete pw; // undefined! sharedMemory came from mallocShared, not operator new
pw-&amp;gt;~Widget();  // fine. destructs the Widget pointed to by pw, no memory deallocation performed
freeShared(pw);  // fine, deallocate the memory pointed to by pw, but calls no dtor
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;arrays&#34;&gt;Arrays&lt;/h1&gt;

&lt;p&gt;For array allocation:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;string *ps = new string[10]; // allocate an array of objects
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;new&lt;/code&gt; being used is still the &lt;code&gt;new&lt;/code&gt; operator, but the behavior here is slightly different from the case for single-object creation:
* in the first step, memory is allocated by &lt;code&gt;operator new[]&lt;/code&gt; instead of &lt;code&gt;operator new&lt;/code&gt;
* in the second step, the constructor is called for &lt;em&gt;each object&lt;/em&gt; in the array, so here the default constructor for &lt;code&gt;string&lt;/code&gt; is called 10 times.&lt;/p&gt;

&lt;p&gt;Similarly, when the &lt;code&gt;delete&lt;/code&gt; operator is used on an array, it calls a destructor for each array element and then calls &lt;code&gt;operator delete[]&lt;/code&gt; to deallocate the memory.&lt;/p&gt;

&lt;p&gt;Just as we can replace or overload &lt;code&gt;operator new&lt;/code&gt; and &lt;code&gt;operator delete&lt;/code&gt;, we can do the same trick to &lt;code&gt;operator new []&lt;/code&gt; and &lt;code&gt;operator delete []&lt;/code&gt; to seize the control of memrory allocation and deallocation for arrays.&lt;/p&gt;
&lt;div class=&#34;footnotes&#34;&gt;

&lt;hr /&gt;

&lt;ol&gt;
&lt;li id=&#34;fn:1&#34;&gt;To use placement &lt;code&gt;new&lt;/code&gt;, all we have to do is is &lt;code&gt;#include &amp;lt;new&amp;gt;&lt;/code&gt;.
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:1&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;</description>
    </item>
    
    <item>
      <title>[MECpp]Item-7 Never Overload &#39;&amp;&amp;&#39;, &#39;||&#39;, or &#39;,&#39;</title>
      <link>http://nianze.tk/2018/03/never-overload-and-or-comma-operator/</link>
      <pubDate>Thu, 29 Mar 2018 11:18:24 -0400</pubDate>
      
      <guid>http://nianze.tk/2018/03/never-overload-and-or-comma-operator/</guid>
      <description>&lt;p&gt;If we don&amp;rsquo;t have a good reason for overloading an operator, don&amp;rsquo;t overload it. In the case of &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt;, &lt;code&gt;||&lt;/code&gt;, and &lt;code&gt;,&lt;/code&gt;, it&amp;rsquo;s difficult to have a good reason: we can&amp;rsquo;t make them behave the way they&amp;rsquo;re supposed to.

&lt;!-- toc --&gt;&lt;/p&gt;

&lt;h1 id=&#34;overloading-operator-and-operator&#34;&gt;Overloading &lt;code&gt;operator&amp;amp;&amp;amp;&lt;/code&gt; and &lt;code&gt;operator||&lt;/code&gt;&lt;/h1&gt;

&lt;p&gt;C++ employs short-circuit evaluation of boolean expressions: once the truth or falsehood of an expression has been determined, evaluation of the expression ceases, even if somem parts of the expression haven&amp;rsquo;t yet been examined.&lt;/p&gt;

&lt;p&gt;The operators associated with short-circuit evaluation are &lt;code&gt;||&lt;/code&gt; and &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt;, which C++ allows us to customize for user-defined types. However, once we overloading the functions &lt;code&gt;operator&amp;amp;&amp;amp;&lt;/code&gt; and &lt;code&gt;operator||&lt;/code&gt; (at the global scope or on a  per-class basis), we are replacing short-circuit semantics with &lt;em&gt;function call&lt;/em&gt; semantics, ending up changing the rules of the game quite radically. For example, after we overload &lt;code&gt;operator&amp;amp;&amp;amp;&lt;/code&gt;, the following code:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;if (expression1 &amp;amp;&amp;amp; expression2)  ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;looks to compilers like one of these:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;if (expression1.operator&amp;amp;&amp;amp;(expression2)) ... // when operator&amp;amp;&amp;amp; is a member function

if (operator&amp;amp;&amp;amp;(expression1, expression2)) ... // when operator&amp;amp;&amp;amp; is a global function
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In two crucial ways, the funciton call semantics differ from short-circuit semantics:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;when a funciton all is made, &lt;em&gt;all&lt;/em&gt; parameters must be evaluated. Thus there is no short circuit.&lt;/li&gt;
&lt;li&gt;the order of evaluation of parameters to a function all is undefined, so there is no way of knowing whether &lt;code&gt;expression1&lt;/code&gt; or &lt;code&gt;expression2&lt;/code&gt; will be evaluated first.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;As a result, overloaded &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; or &lt;code&gt;||&lt;/code&gt; will never offer programmers the behavior they both exprect and have come to depend on. So do not overload &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; or &lt;code&gt;||&lt;/code&gt;.&lt;/p&gt;

&lt;h1 id=&#34;overloading-operator&#34;&gt;Overloading &lt;code&gt;operator,&lt;/code&gt;&lt;/h1&gt;

&lt;p&gt;The comma operator is used for &lt;em&gt;expressions&lt;/em&gt;, and we&amp;rsquo;re most likely to run across it in the update part of a &lt;code&gt;for&lt;/code&gt; loop:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;void reverse(char s[]) 
{
    for (int i = 0, j = strlen(s)-1;
    i &amp;lt; j;
    ++i, --j)  // the comma operator
    {
        int c = s[i];
        s[i] = s[j];
        s[j] = c;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;An expression containing a comma is evaluated by first evaluating the part of the expression to the left of the comma, then evaluating the expression to the right of the comma; the result of the overall comma expression is the value of the expression on the right. So the result for &lt;code&gt;++i, --j&lt;/code&gt; is the value returned from &lt;code&gt;--j&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Unfortunately, when writing our own comma operator, we can&amp;rsquo;t mimic this behavior for the same reason as the case in overriding &lt;code&gt;||&lt;/code&gt; and &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt;:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;if we write &lt;code&gt;operator,&lt;/code&gt; as a non-member function, then both operands around &lt;code&gt;,&lt;/code&gt; will be passed as arguments in a function call, and there&amp;rsquo;s no way to control over the order in which a funciton&amp;rsquo;s arguments are evaluated.&lt;/li&gt;
&lt;li&gt;if we write &lt;code&gt;operator,&lt;/code&gt; as a member function, we still can&amp;rsquo;t rely on the left-hand operand to the comma being evaluated first, because compilers are not constrained to do thing that way.&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;limits-on-operator-overloading&#34;&gt;Limits on operator overloading&lt;/h1&gt;

&lt;p&gt;According to C++, following operators can&amp;rsquo;t be overloaded:&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;center&#34;&gt;&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;&lt;code&gt;.&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;code&gt;.*&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;code&gt;::&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;code&gt;?:&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;&lt;code&gt;new&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;code&gt;delete&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;code&gt;sizeof&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;code&gt;typeid&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;&lt;code&gt;static_cast&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;code&gt;dynamic_cast&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;code&gt;const_cast&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;code&gt;reinterpret_cast&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;We can overload these:&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;center&#34;&gt;&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;&lt;code&gt;operator new&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;code&gt;operator delete&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;code&gt;operator new[]&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;code&gt;operator delete[]&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;&lt;code&gt;+&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;code&gt;-&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;code&gt;*&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;code&gt;/&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;&lt;code&gt;%&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;code&gt;^&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;code&gt;&amp;amp;&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;|&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;&lt;code&gt;~&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;code&gt;!&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;code&gt;&amp;lt;&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;code&gt;&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;&lt;code&gt;+=&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;code&gt;-=&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;code&gt;*=&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;code&gt;/=&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;&lt;code&gt;%=&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;code&gt;^=&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;code&gt;&amp;amp;&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;`&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;&lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;code&gt;&amp;gt;&amp;gt;=&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;code&gt;&amp;lt;&amp;lt;=&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;&lt;code&gt;==&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;code&gt;!=&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;code&gt;&amp;lt;=&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;code&gt;&amp;gt;=&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;&lt;code&gt;-&amp;gt;*&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;code&gt;-&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;code&gt;++&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;code&gt;--&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;&lt;code&gt;,&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;||&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;&lt;code&gt;()&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;code&gt;[]&lt;/code&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;Just because we can overload there operators is no reason to run off and do it. The purpose of operator overloading is to make programs easier to read, write, and understand. If we don&amp;rsquo;t have a good reason for overloading an operator, don&amp;rsquo;t overload it, as is the case for &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt;, &lt;code&gt;||&lt;/code&gt;, and &lt;code&gt;,&lt;/code&gt;.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>[MECpp]Item-6 Distinguish Between Prefix and Postfix Forms of Increment and Decrement Operators</title>
      <link>http://nianze.tk/2018/03/distinguish-between-prefix-and-postfix-forms-of-increment-and-decrement-operators/</link>
      <pubDate>Wed, 28 Mar 2018 13:03:10 -0400</pubDate>
      
      <guid>http://nianze.tk/2018/03/distinguish-between-prefix-and-postfix-forms-of-increment-and-decrement-operators/</guid>
      <description>&lt;p&gt;The prefix and postfix forms of increment and decrement operators return &lt;em&gt;different types&lt;/em&gt;: prefix forms return a reference, while postfix forms return a &lt;em&gt;const&lt;/em&gt; object. For efficiency, prefer prefix forms unless the behavior of postfix ones is necessary. To guarantee consistency, implement postfix operators in terms of the prefix operators.

&lt;!-- toc --&gt;&lt;/p&gt;

&lt;h1 id=&#34;case-study&#34;&gt;Case Study&lt;/h1&gt;

&lt;p&gt;Overloaded functions are differentiated on the basis of the parameter types they take, but neither prefix nor postfix increment or decrement takes an argument. To surmount this linguistic pothole, it was decreed that postfix forms take in &lt;code&gt;int&lt;/code&gt; argument, and compilers silently pass 0 as that &lt;code&gt;int&lt;/code&gt; when those functions are called:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class UPInt {  // customized &amp;quot;unlimited precisioin int&amp;quot;
public:
    UPInt&amp;amp; operator++();           // prefiex ++
    const UPInt operator++(int);   // postfix ++

    UPInt&amp;amp; operator--();           // prefiex --
    const UPInt operator--(int);   // postfix --
    
    UPInt&amp;amp; operator+=(int);        // += operator for UPInts and ints
    ...    
};

UPInt i;

++i;  // calls i.operator++();
i++;  // calls i.operator++(0);

--i;  // calls i.operator--();
i--;  // calls i.operator--(0);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The return types difference is caused by the different behavior between prefix forms and postfix forms. For &lt;code&gt;++operator&lt;/code&gt;:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Prefix form is &amp;ldquo;increment and fetch&amp;rdquo;&lt;/li&gt;
&lt;li&gt;Postfix form is &amp;ldquo;fetch and increment&amp;rdquo;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;// prefix form: increment and fetch
UPInt&amp;amp; UPInt::operator++()
{
    *this += 1;    // increment
    return *this;  // fetch
}

// postfix form: fetch and increment
const UPInt UPInt::operator++(int)
{
    const UPInt oldVal = *this;  // fetch
    ++(*this);                   // increment
    return oldVal;               // return what was fetched
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Apart from the obvious inefficiency resulting from the fact that postfix increment function creates a temporary object for its return value (MECpp item 19), as well as the explicit temporary object &lt;code&gt;oldVal&lt;/code&gt; that has to be constructed and destructed, leading to the conclusion that prefix increment should be used whenever possible for its inherently higher efficiency, there are three points worth noting for the implementation of postfix form of &lt;code&gt;operator++&lt;/code&gt;:&lt;/p&gt;

&lt;h2 id=&#34;1-omit-the-parameter-name&#34;&gt;1. Omit the parameter name&lt;/h2&gt;

&lt;p&gt;Since the purpose of the parameter is only to distinguish prefix from postfix function invocation, the postfix operator makes no use of its parameter. Omitting parameter names avoids warnings from some compilers who insist that we use named parameters in the body of the function to which they apply.&lt;/p&gt;

&lt;h2 id=&#34;2-return-a-const-object&#34;&gt;2. Return a &lt;code&gt;const&lt;/code&gt; object&lt;/h2&gt;

&lt;p&gt;There are two reasons to return a &lt;code&gt;const&lt;/code&gt; object:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;it&amp;rsquo;s consistent with the behavior of the built-in types, since &lt;code&gt;int&lt;/code&gt;s most certainly do not allow double application of postfix increment:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;int i;
i++++;  // error!
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;if return value is not const, the behavior will be counterintuitive and confusing: after applying &lt;code&gt;i++++&lt;/code&gt;, the second &lt;code&gt;operator++&lt;/code&gt; changes the value of the object returned from the first invocation, instead of the value of the original object. Hence, &lt;code&gt;i&lt;/code&gt; ends up being incremented only once.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;3-implement-postfix-operators-in-terms-of-the-prefix-ones&#34;&gt;3. Implement postfix operators in terms of the prefix ones&lt;/h2&gt;

&lt;p&gt;Both the prefix and postfix increment operators do the same thing: incrementing a value. In order to guarantee implementation won&amp;rsquo;t diverge over time, postfix increment and decrement should be implemented &lt;em&gt;in terms of&lt;/em&gt; their prefix counterparts. Then we only need to maintain the prefix versions.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>[MECpp]Item-5 Be Wary of User Defined Conversion Functions</title>
      <link>http://nianze.tk/2018/03/be-wary-of-user-defined-conversion-functions/</link>
      <pubDate>Tue, 27 Mar 2018 18:53:56 -0400</pubDate>
      
      <guid>http://nianze.tk/2018/03/be-wary-of-user-defined-conversion-functions/</guid>
      <description>&lt;p&gt;Implicit type conversions usually lead to more harm than good, so don&amp;rsquo;t provide conversion functions unless we&amp;rsquo;re sure we want them.

&lt;!-- toc --&gt;&lt;/p&gt;

&lt;p&gt;There are two kinds of functions allowing compilers to perform implicit type conversions:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;implicit type conversion operators&lt;/li&gt;
&lt;li&gt;non-explicit single-argument constructors&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;implicit-type-conversion-operators&#34;&gt;Implicit type conversion operators&lt;/h1&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class Rational {
public:
    ...
    operator double() const; // converts Rational to double
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This implicit type conversion function will be automatically invoked in contexts like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;Rational r(1, 2);    // r has a value 1/2
double d = 0.5 * r;  // converts r to a double, then do multiplication
count &amp;lt;&amp;lt; r;          // will print a floating point number instead of 1/2 if lacking difinition of operator&amp;lt;&amp;lt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Suppose we forget to write an &lt;code&gt;operator&amp;lt;&amp;lt;&lt;/code&gt; for &lt;code&gt;Rational&lt;/code&gt; objects, and expect the attempt to print &lt;code&gt;r&lt;/code&gt; would fail due to the lack of appropriate &lt;code&gt;operator&amp;lt;&amp;lt;&lt;/code&gt; to call. However, in the lack of &lt;code&gt;operator&amp;lt;&amp;lt;&lt;/code&gt;, compilers are happy to find an acceptable sequence of implicit type conversions they could apply to make the call succeed. In this case, they will discover they could make the call succeed by implicitly converting &lt;code&gt;r&lt;/code&gt; to a &lt;code&gt;double&lt;/code&gt; by calling &lt;code&gt;Rational::operator double&lt;/code&gt;, leading to &lt;em&gt;wrong&lt;/em&gt; (often unexpected) function being called.&lt;/p&gt;

&lt;p&gt;Solution: replace the implicit type conversion operators with equivalent functions that don&amp;rsquo;t have the syntactically magic names, just like the explicit member function &lt;code&gt;c_str&lt;/code&gt; in &lt;code&gt;string&lt;/code&gt; type from standard C++ library (MECpp item 35):&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class Rational {
public:
    ...
    double asDouble() const;  // converts Rational to double
};
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;Rational r(1, 2);

cout &amp;lt;&amp;lt; r; // error! no operator&amp;lt;&amp;lt; for Rationals
cout &amp;lt;&amp;lt; r.asDouble();  // fine, prints r as a double
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;single-argument-constructor&#34;&gt;Single-argument constructor&lt;/h1&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;template&amp;lt;class T&amp;gt;
class Array {
public:
    Array(int lowBound, int highBound); // specify a range of array indices, ineligible for type-conversion
    Array(int size);  // specify the number of elements in the array, can be used as a type conversion function
    
    T&amp;amp; operator[](int index);
    ...
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The problem of implicit type conversion occurs in following condition:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;bool operator==(const Array&amp;lt;int&amp;gt;&amp;amp; lhs, const Array&amp;lt;int&amp;gt;&amp;amp; rhs);
Array&amp;lt;int&amp;gt; a(10);
Array&amp;lt;int&amp;gt; b(10);
...
for (int i = 0; i &amp;lt; 10; ++i) {  // oops! &amp;quot;a&amp;quot; should be &amp;quot;a[i]&amp;quot;
    if (a == b[i]) {
        ....
    } else {
        ...
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here, we mistakenly omitted the subscripting syntax when typing &lt;code&gt;a&lt;/code&gt;. We expect this will cause compilers complaining, but they will not:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Compilers see a call to &lt;code&gt;operator==&lt;/code&gt; taking type &lt;code&gt;Array&amp;lt;int&amp;gt;&lt;/code&gt; (for &lt;code&gt;a&lt;/code&gt;) and &lt;code&gt;int&lt;/code&gt; (for &lt;code&gt;b[i]&lt;/code&gt;), and fail to find the corresponding function&lt;/li&gt;

&lt;li&gt;&lt;p&gt;There&amp;rsquo;s a &lt;code&gt;operator==&lt;/code&gt; taking two &lt;code&gt;Array&amp;lt;int&amp;gt;&lt;/code&gt; type arguments, and compilers are able to convert the &lt;code&gt;int&lt;/code&gt; into an &lt;code&gt;Array&amp;lt;int&amp;gt;&lt;/code&gt; object by calling &lt;code&gt;Array&amp;lt;int&amp;gt;&lt;/code&gt; constructor that taking a single &lt;code&gt;int&lt;/code&gt; as an argument, ending up with something like this&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:1&#34;&gt;&lt;a href=&#34;#fn:1&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;for (int i = 0; i &amp;lt; 10; ++i) {
    if (a == static_cast&amp;lt; Array&amp;lt;int&amp;gt; &amp;gt;(b[i])) ...
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Each iteration through the loop compares the contents of &lt;code&gt;a&lt;/code&gt; with the contents of a temporary array of size &lt;code&gt;b[i]&lt;/code&gt; (whose contents are presumably undefined and will be created and destroyed in every loop, see MECpp item 19), which is both unwanted and tremendously inefficient behavior.&lt;/p&gt;

&lt;p&gt;There are two solutions: use keyword &lt;code&gt;explicit&lt;/code&gt; or creating proxy classes.&lt;/p&gt;

&lt;h2 id=&#34;solution-1-keyword-explicit&#34;&gt;Solution 1: Keyword &lt;code&gt;explicit&lt;/code&gt;&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;template&amp;lt;class T&amp;gt;
class Array {
public:
    ...
    explicit Array(int size);  // use &amp;quot;explicit&amp;quot; to prevent implicit type conversion    
    ...    
};
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;solution-2-proxy-classes&#34;&gt;Solution 2: Proxy classes&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;template&amp;lt;class T&amp;gt;
class Array {
public:
    class ArraySize {
    public:
        ArraySize(int numElements): theSize(numElements) {}
        int size() const { return theSize; }
    private:
        int theSize;
    };

    Array(int lowBound, int highBound);
    Array(ArraySize size);  // new declaration
    ...
};
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;Array&amp;lt;int&amp;gt; a(10); // convert 10 to a temp. ArraySize object, then feed that temp. object to Array&amp;lt;int&amp;gt; ctor.

for (int i = 0; i &amp;lt; 10; ++i) {
    if (a == b[i]) ...   // error now!
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;One of the rules governing implicit type conversions is that no sequence of conversions is allowed to contain more than one user-defined conversion (i.e., a call to a single-argument constructor or an implicit type conversion operator). The above class difinition adopting a general technique called &lt;em&gt;proxy classes&lt;/em&gt; takes advantage of this rule, ending up with ideal behavior that the object constructions we want to allow are legal, but the implicit conversions we don&amp;rsquo;t want to allow are illegal (compilers in one implicit conversion can&amp;rsquo;t call two user-defined conversions, one from &lt;code&gt;int&lt;/code&gt; to &lt;code&gt;ArraySize&lt;/code&gt; and one from &lt;code&gt;ArraySize&lt;/code&gt; to &lt;code&gt;Array&amp;lt;int&amp;gt;&lt;/code&gt;).&lt;/p&gt;

&lt;p&gt;Proxy objects can give us control over aspects of software&amp;rsquo;s behavior that is otherswise beyond our grasp. For more detail, refer to MECpp item 30.&lt;/p&gt;
&lt;div class=&#34;footnotes&#34;&gt;

&lt;hr /&gt;

&lt;ol&gt;
&lt;li id=&#34;fn:1&#34;&gt;The space separating the two &amp;ldquo;&amp;gt;&amp;rdquo; characters has its purpose: without it, the statement will be like &lt;code&gt;static_cast&amp;lt;Array&amp;lt;int&amp;gt;&amp;gt;(b[i])&lt;/code&gt;, and some C++ compilers parsing &amp;ldquo;&amp;gt;&amp;gt;&amp;rdquo; as a single token, ending up with a syntax error.
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:1&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;</description>
    </item>
    
    <item>
      <title>[MECpp]Item-4 Avoid Gratuitous Default Constructors</title>
      <link>http://nianze.tk/2018/03/avoid-gratuitous-default-constructors/</link>
      <pubDate>Mon, 26 Mar 2018 11:21:08 -0400</pubDate>
      
      <guid>http://nianze.tk/2018/03/avoid-gratuitous-default-constructors/</guid>
      <description>&lt;p&gt;Including meaningless default constructors affects the efficiency of classes, so avoiding them in classes guarantees fully-initialized objects, with the cost of some limits on how such classes can be used.

&lt;!-- toc --&gt;&lt;/p&gt;

&lt;p&gt;For many objects, there is no reasonable way to perform a complete initialization in the absence of outside information. Consider a class for company equipment in which the corporate ID number of the quipment is a mandatory constructor argument:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class EquipmentPiece {
public:
    EquipmentPiece(int IDNumber);
    ...
};
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;with-default-constructor&#34;&gt;With default constructor&lt;/h1&gt;

&lt;p&gt;Some people believe &lt;em&gt;all&lt;/em&gt; classes should include a default constructors, even if a default constructor doesn&amp;rsquo;t have enough information to fully initialize objects of the class. Adherents to this philosophy will modify &lt;code&gt;EquipmentPiece&lt;/code&gt; as follows:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class EquipmentPiece {
public:
    EquipmentPiece(int IDNumber = UNSPECIFIED);
    ...
private:
    static const int UNSPECIFIED; // magic ID num. value meaning no ID was specified
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;There are two downsides after including a default constructor in a class where none was warranted:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;There&amp;rsquo;s no longer any guarantee that the fields of an &lt;code&gt;EquipmentPiece&lt;/code&gt; object have been meaningfully initialized, so member functions must check if each object has valid &lt;code&gt;IDNumber&lt;/code&gt; before using it. If not, clients must find a solution to deal with the situation - sometimes they simply throw an exception or terminates the program, which may degrade the overall quality of the software.&lt;/li&gt;
&lt;li&gt;The meaningless default constructors affects the efficiency of classes: member functions have to include extra code to test object&amp;rsquo;s validness and deal with the failure tests, and clients of those functions have to pay for the time those tests take as well as the space the extra code occupies.&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&#34;without-default-constructor&#34;&gt;Without default constructor&lt;/h1&gt;

&lt;p&gt;If a class lacks a default constructor, there are restrictions on how you can use that class. Specifically, in three constexts:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Creation of arrays&lt;/li&gt;
&lt;li&gt;Ineligible for some template-based container classes&lt;/li&gt;
&lt;li&gt;Virtual base classes&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;1-creation-of-arrays&#34;&gt;1. Creation of arrays&lt;/h2&gt;

&lt;p&gt;There is, in general, no way to specify constructor arguments for objects in arrays:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;EquipmentPiece bestPieces[10];  // error! No way to call EquipmentPiece ctors.
EquipmentPiece *bestPieces = new EquipmentPiece[10];  // error! same problem
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;There are three ways to get around the restriction:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Provide the necessary arguments when array is defined&lt;/p&gt;

&lt;p&gt;This solution works only for non-heap arrays:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;int ID1, ID2, ID3, ..., ID10;  // variables to hold equipment ID numbers
...
EquipmentPiece bestPieces[] = {  // fine, ctor arguments are provided
    EquipmentPiece(ID1);
    EquipmentPiece(ID2);
    ...
    EquipmentPiece(ID10);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Use an array of &lt;em&gt;pointers&lt;/em&gt; instead of an array of objects&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;typedef EquipmentPiece* PEP;     // a PEP is a pointer to an EuipmentPiece
PEP bestPieces[10];              // fine, no ctor called
PEP *bestPieces = new PEP[10];   // fine, no ctor called

for (int i = 0; i &amp;lt; 10; ++i) {
    bestPieces[i] = new EquipmentPiece( ID Number );
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The disadvantages to this approach is:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;We have to remember to delete all the objects pointed to by the array. Otherwise there&amp;rsquo;s resource leak.&lt;/li&gt;
&lt;li&gt;The total amount of memory increases due to the extra space for the pointers&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Use &amp;ldquo;placement &lt;code&gt;new&lt;/code&gt;&amp;rdquo; (item 8)&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;// allocate enough memory for an array of 10 EuipmentPiece obj.
void *rawMemory = operator new[](10*sizeof(EquipmentPiece));

// make bestPieces point to the memory so it can be treated as an EquipmentPiece array
EquipmentPiece *bestPieces = static_cast&amp;lt;EquipmentPiece*&amp;gt; (rawMemory);

// construct the EquipmentPiece objects in the memory using placement new
for (int i = 0; i &amp;lt; 10; ++i) {
    new (bestPieces+i) EquipmentPiece( ID Number );
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This design avoids the spece penalty of extra pointers, but the downside is that we must manually call destructors on the objects in the array, then manually deallocate the raw memory by calling &lt;code&gt;operator delete[]&lt;/code&gt; (item 8), which is unfamiliar by most programmers&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:1&#34;&gt;&lt;a href=&#34;#fn:1&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;// destruct the objects in bestPieces in the inverse order
for (int i = 9; i &amp;gt;= 0; --i) {
    bestPieces[i].~EquipmentPiece();    
}
// deallocate the raw memory
operator delete[](rawMemory);
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;2-ineligible-for-some-template-based-container-classes&#34;&gt;2. Ineligible for some template-based container classes&lt;/h2&gt;

&lt;p&gt;Some templates requires that the type used to instantiate the template proved a default constructor for purpose such as createing an array of the template parameter type inside the template:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;template&amp;lt;class T&amp;gt;
class Array {
public:
    Array(int size);
    ...
private:
    T *data;
};

Template&amp;lt;class T&amp;gt;
Array&amp;lt;T&amp;gt;::Array(int size)
{
    data = new T[size];  // calls T::T() for each elem. of the array
    ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Although careful template design can eliminate the need for a default constructor (such as &lt;code&gt;vector&lt;/code&gt; template), there are templates designed with that requirement. That being the case, classes without default constructors will be incompatible with such templates.&lt;/p&gt;

&lt;h2 id=&#34;3-virtual-base-classes&#34;&gt;3. Virtual base classes&lt;/h2&gt;

&lt;p&gt;Arguments for virtual base class construcctors must be provided by the most derived class of the object being constructed. As a result, a virtual base class lacking a default constructor requires that &lt;em&gt;all&lt;/em&gt; classes derived from that class must know about, understand the meaning of, and provide for the virtual base class&amp;rsquo;s constructors&amp;rsquo; arguments, which is neigher expected not appreciated by authors of derived classes.&lt;/p&gt;
&lt;div class=&#34;footnotes&#34;&gt;

&lt;hr /&gt;

&lt;ol&gt;
&lt;li id=&#34;fn:1&#34;&gt;If we forget this requirement and use the normal array-deletion syntax &lt;code&gt;delete[] bestPieces&lt;/code&gt;, the program will behave unpredictably, because deleting a pointer that didn&amp;rsquo;t come from the &lt;code&gt;new&lt;/code&gt; operator is undefined.
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:1&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;</description>
    </item>
    
    <item>
      <title>[MECpp]Item-3 Never Treat Arrays Polymorphically</title>
      <link>http://nianze.tk/2018/03/never-treat-arrays-polymorphically/</link>
      <pubDate>Fri, 23 Mar 2018 18:59:16 -0400</pubDate>
      
      <guid>http://nianze.tk/2018/03/never-treat-arrays-polymorphically/</guid>
      <description>&lt;p&gt;Array operations almost always involve pointer arithmetic, so arrays and polymorphism don&amp;rsquo;t mix.
&lt;/p&gt;

&lt;p&gt;C++ allows us to manipulate &lt;em&gt;arrays&lt;/em&gt; of derived class objects through base class pointers and references, but it almost nerver works athe way we want it to.&lt;/p&gt;

&lt;p&gt;For example, suppose following base class &lt;code&gt;BST&lt;/code&gt; (binary search tree objects) and its derived class &lt;code&gt;BalancedBST&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class BST {...};
class BalancedBST: public BST {...};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;For a function working with an array of &lt;code&gt;BST&lt;/code&gt;s, it works fine when we pass it an array of &lt;code&gt;BST&lt;/code&gt; objects:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;void printBSTArray(ostream&amp;amp; s, const BST array[], int numElements)
{
    for (int i = 0; i &amp;lt; numElements; ++i) {
        s &amp;lt;&amp;lt; array[i]; // assumes operator&amp;lt;&amp;lt; is defined for BST objects
    }
}

BST BSTArray[10];
...
printBSTArray(cout, BSTArray, 10);  // work fine
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;However, when passing an array of &lt;code&gt;BalancedBST&lt;/code&gt; objects:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;BalancedBST bBSTArray[10];
...
printBSTArray(cout, bBSTArray, 10);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The compilers will accept this function call without complaint, but then for &lt;code&gt;array[i&lt;/code&gt;]`, they will generate code involving pointer arithmetic:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;array[i]&lt;/code&gt; is just shorthand for expression &lt;code&gt;*(array+i)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;the distance between the memory location pointed to by &lt;code&gt;array&lt;/code&gt; and by &lt;code&gt;array+i&lt;/code&gt; is calculated through &lt;code&gt;i*sizeof(object in the array)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;the parameter &lt;code&gt;array&lt;/code&gt; is declared to be of type &lt;code&gt;array-of-BST&lt;/code&gt;, so each element of the array is regard as &lt;code&gt;BST&lt;/code&gt;, and thus the distance is &lt;code&gt;i*sizeof(BST)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;the size of an object of type &lt;code&gt;BalancedBST&lt;/code&gt; usually is larger than their base class ones&amp;rsquo; size, because derived class usually has extra data members&lt;/li&gt;
&lt;li&gt;If it is, the ointer arithmetic generated for &lt;code&gt;printBSTArray&lt;/code&gt; will be wrong for arrays of &lt;code&gt;BalancedBST&lt;/code&gt; objects&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;p&gt;Another problem will pop up if we try to delete an array of derived class objects through a base class pointer:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;void deleteArray(ostream&amp;amp; logStream, BST array[])
{
    logStream &amp;lt;&amp;lt; &amp;quot;Deleting array at address &amp;quot;
              &amp;lt;&amp;lt; static_cast&amp;lt;void*&amp;gt;(array) &amp;lt;&amp;lt; &#39;\n&#39;;
    delete [] array;
}

BalancedBST *balTreeArray = new BalancedBST[50]; // create a BalancedBST array
...
deleteArray(cout, balTreeArray);  // log its deletion
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;There&amp;rsquo;s pointer arithmetic going on here, too: when compilers see the statement &lt;code&gt;delete [] array;&lt;/code&gt;, they will generate code that looks like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;for (int i = the number of elements in the array - 1; i &amp;gt;= 0; --i) 
{
    array[i].BST::~BST(); // call array[i]&#39;s destructor
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now we understand why the language specification says that the result of deleting an array of derived class objects through a base class pointers is undefined: here, again, polymorphism meets pointer arithmetic.&lt;/p&gt;

&lt;p&gt;In the point of software designing, as MECpp-item 33 suggests, we&amp;rsquo;re unlikely to make the mistake of treating an array polymorphically if we avoid having a concrete class (like &lt;code&gt;BalancedBST&lt;/code&gt;) inherit from another concrete class (such as &lt;code&gt;BST&lt;/code&gt;).&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>[MECpp]Item-1 Distinguish Between Pointers and References</title>
      <link>http://nianze.tk/2018/03/distinguish-between-pointers-and-references/</link>
      <pubDate>Thu, 22 Mar 2018 16:47:15 -0400</pubDate>
      
      <guid>http://nianze.tk/2018/03/distinguish-between-pointers-and-references/</guid>
      <description>&lt;p&gt;More effective C++: Use references when we already have something to refer to and never want to refer to anything else, or when implementing operators whose syntactic requires us to do so.

&lt;!-- toc --&gt;&lt;/p&gt;

&lt;p&gt;Both pointers and references refer to other objects indirectly, and we should distinguish their differences.&lt;/p&gt;

&lt;h1 id=&#34;no-null-reference&#34;&gt;No null reference&lt;/h1&gt;

&lt;p&gt;A reference must &lt;em&gt;always&lt;/em&gt; refer to some object, which implies that references must be initialized:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;string&amp;amp; rs; // error! References must be initialized
string *ps; // valid but risky uninitialized pointer
string s(&amp;quot;abc&amp;quot;);
string&amp;amp; rs = s; // fine
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Having known this, if we have a variable whose purpose is to refer to another object, but it is possible that there might be no object to refer to, we should make the variable a pointer; on the other hand, if the design requires that the variable must always refer to a non-null object, we choose the reference.&lt;/p&gt;

&lt;p&gt;As an implication, reference&amp;rsquo;s never-nullable property save us from the burden of testing the validity before using it:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;void printRefDouble(const double&amp;amp; rd)
{
    cout &amp;lt;&amp;lt; rd; // no need to test rd.
}

void printPointDouble(const double *pd)
{
    if (pd) {  // check for null pointer
        cout &amp;lt;&amp;lt; *p;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;no-reassignment-for-reference&#34;&gt;No reassignment for reference&lt;/h1&gt;

&lt;p&gt;Another difference is that we can reassign pointers to refer to different objects, while reference &lt;em&gt;always&lt;/em&gt; refers to the one it is initialized:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;string s1(&amp;quot;Nancy&amp;quot;);
string s2(&amp;quot;Clancy&amp;quot;);

string&amp;amp; rs = s1;  // rs refers to s1
string *ps = s1;  // ps points to s1

rs = s2;   // rs  still refers to s1, but s1&#39;s value updates to &amp;quot;Clancy&amp;quot;, equiv. to *ps = s2
ps = &amp;amp;s2;  // ps now points to s2, s1 remains unchanged
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In general, use pointers when&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;it&amp;rsquo;s possible that there&amp;rsquo;s nothing to refer to (set pointers to null), or&lt;/li&gt;
&lt;li&gt;it&amp;rsquo;s needed to refer to different things at different times (reassign where the pointer points)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;use reference when we know there will always be an object to refer to and we will never refer to anything else other than the initial object.&lt;/p&gt;

&lt;h1 id=&#34;use-reference-for-some-operators&#34;&gt;Use reference for some operators&lt;/h1&gt;

&lt;p&gt;Another situation to prefer reference is when we&amp;rsquo;re implementing certain operators such as &lt;code&gt;operator[]&lt;/code&gt;, which needs to return something that can be used as the target of an assignment:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;vector&amp;lt;int&amp;gt; v(10);
v[5] = 10;  // the target of this assignment is the return value of operator[]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If &lt;code&gt;operator[]&lt;/code&gt; returned a pointer, last statement would be changed to this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;*v[5] = 10;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This makes &lt;code&gt;v&lt;/code&gt; look like a vector of pointers, which it&amp;rsquo;s not. Thus we may prefer using a reference as the return type of &lt;code&gt;operator[]&lt;/code&gt; (for an exception, see MECpp-item 30).&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Item-52 Write placement delete if you write placement new</title>
      <link>http://nianze.tk/2018/03/write-placement-delete-if-you-write-placement-new/</link>
      <pubDate>Wed, 21 Mar 2018 15:48:12 -0400</pubDate>
      
      <guid>http://nianze.tk/2018/03/write-placement-delete-if-you-write-placement-new/</guid>
      <description>&lt;p&gt;When we write a placement version of &lt;code&gt;operator new&lt;/code&gt;, be sure to write the corresponding placement version of &lt;code&gt;operator delete&lt;/code&gt; to avoid subtle, intermittent memory leaks. When we do so, pay attention not to unintentionally hide the normal versions of &lt;code&gt;new&lt;/code&gt; and &lt;code&gt;delete&lt;/code&gt;

&lt;!-- toc --&gt;&lt;/p&gt;

&lt;h1 id=&#34;placement-version-of-new&#34;&gt;Placement version of &lt;code&gt;new&lt;/code&gt;&lt;/h1&gt;

&lt;p&gt;When an &lt;code&gt;operator new&lt;/code&gt; function takes extra parameters (other than the mandatory &lt;code&gt;size_t&lt;/code&gt; argument), that function is known as a &lt;em&gt;placement version of &lt;code&gt;new&lt;/code&gt;&lt;/em&gt;. For example:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;void* operator new(std::size_t, void *pMemory) throw(); // placement new
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This specific version of placement &lt;code&gt;new&lt;/code&gt; is in C++&amp;rsquo;s standard library (access through &lt;code&gt;#include&amp;lt;new&amp;gt;&lt;/code&gt;) and is the original placement &lt;code&gt;new&lt;/code&gt;. Later, people also use the term &amp;ldquo;placement &lt;code&gt;new&lt;/code&gt;&amp;rdquo; to refer any version of &lt;code&gt;operator new&lt;/code&gt; that takes extra arguments. The phrace &amp;ldquo;placement &lt;code&gt;delete&lt;/code&gt;&amp;rdquo; also derives from this version.&lt;/p&gt;

&lt;h1 id=&#34;to-avoid-subtle-memory-leak&#34;&gt;To avoid subtle memory leak&lt;/h1&gt;

&lt;p&gt;Suppose we want to write a class-specific &lt;code&gt;operator new&lt;/code&gt; that requires specification of an &lt;code&gt;ostream&lt;/code&gt; to which allocation information should be logged:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class Widget {
public:
    ...
    static void* operator new(std::size_t size, std::ostream&amp;amp; logStream) throw(std::bad_alloc) // non-normal form of new
    static void operator delete(void *pMemory, std::size_t size) throw();  // normal class-specific form of delete
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And we call it this to log allocation informatino to &lt;code&gt;cerr&lt;/code&gt; when dynamically creating a &lt;code&gt;Wdiget&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;Widget *pw = new (std::cerr) Widget; // call operator new, passing cerr as the ostream; cause memory leak when Widget constructor throws
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Let&amp;rsquo;s consider a special subtle situation: if memory allocation succeeds and the &lt;code&gt;Widget&lt;/code&gt; constructor throws an exception, since &lt;code&gt;pw&lt;/code&gt; not yet assigned and client code can&amp;rsquo;t deallocate the memory, the runtime system is responsible for undoing the allocation that &lt;code&gt;operator new&lt;/code&gt; performed. However, we&amp;rsquo;re now using a non-normal version of &lt;code&gt;operator new&lt;/code&gt;, unless it finds a version of &lt;code&gt;operator delete&lt;/code&gt; that takes &lt;em&gt;the same number and types of extra arguments&lt;/em&gt; as &lt;code&gt;operator new&lt;/code&gt;, the runtime system choose to do nothing, so no &lt;code&gt;operator delete&lt;/code&gt; will be called, ending up with memory leak.&lt;/p&gt;

&lt;p&gt;To eliminate the memory leak in this situation, we need to match the placement &lt;code&gt;new&lt;/code&gt; with a placement &lt;code&gt;delete&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class Widget {
public:
    ...
    static void* operator new(std::size_t size, std::ostream&amp;amp; logStream) throw(std::bad_alloc) // non-normal form of new
    static void operator delete(void *pMemory, std::size_t size) throw();
    static void operator delete(void *pMemory, std::ostream&amp;amp; logStream) throw(); corresponding non-normal form of delete
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now following code will work without leak:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;Widget *pw = new (std::cerr) Widget; // no potential leak
delete pw;  // invokes the normal operator delete
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;do-not-hide-normal-form-of-new-and-delete&#34;&gt;Do not hide normal form of &lt;code&gt;new&lt;/code&gt; and &lt;code&gt;delete&lt;/code&gt;&lt;/h1&gt;

&lt;p&gt;By default, C++ offers the following forms of &lt;code&gt;operator new&lt;/code&gt; (and corresponding &lt;code&gt;operator delete&lt;/code&gt;) at global scope:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;void* operator new(std::size_t) throw(std::bad_alloc); // normal new
void* operator new(std::size_t, void*) throw(std::bad_alloc); // placement new
void* operator new(std::size_t, const std::nothrow_t&amp;amp;) throw(); // nothrow new, item 49
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;According to item 33, member function names hide functions with the same names in outer scopes, so we want to avoid having class-specific &lt;code&gt;new&lt;/code&gt;s hide other &lt;code&gt;new&lt;/code&gt;s that our client expect. For example, if the base class declares only a placement &lt;code&gt;new&lt;/code&gt;, clients will find the normal version of &lt;code&gt;new&lt;/code&gt; unavailable:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class Base {
public:
    ...
    static void* operator new(std::size_t size, std::ostream&amp;amp; logStream) throw(std::bad_alloc); // hide the normal global form
    ...
};

Base *pb = new Base; // error! the normal form is hidden
Base *pb = new (std::cerr) Base;  // fine, call the placement new
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Similarly, redeclaring &lt;code&gt;operator new&lt;/code&gt; in derived classes hide both global and inherited versions of &lt;code&gt;operator new&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class Derived: public Base {
public:
    ...
    static void* operator new(std::size_t size) throw(std::bad_alloc); // redeclare the normal form
    ...
};

Derived *pd = new (std::clog) Derived; // error! Base&#39;s placement new is hidden
Derived *pd = new Derived; // fine, call Derived&#39;s operator new
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In order to make normal version of &lt;code&gt;operator new&lt;/code&gt; accessible in addition to customed ones, we need to declare all forms (both standard version and placement version) in our class. If we want class-specific standard versions to behave in the usual way, just have the them call the global versions. An easy way to do this is to create a base class containing all the normal forms of &lt;code&gt;new&lt;/code&gt; and &lt;code&gt;delete&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class StandardNewDeleteForm {
public:
    // normal new/delete
    static void* operator new(std::size_t size) throw(std::bad_alloc) 
    { return ::operator new(size); }
    static void operator delete(void *pMemory) throw()
    { ::operator delete(pMemory); }

    // placement new/delete
    static void* operator new(std::size_t size, void *ptr) throw(std::bad_alloc) 
    { return ::operator new(size, ptr); }
    static void operator delete(void *pMemory, void *ptr) throw()
    { ::operator delete(pMemory, ptr); }

    // nothrow new/delete
    static void* operator new(std::size_t size, const std::nothrow_t&amp;amp; nt) throw() 
    { return ::operator new(size, nt); }
    static void operator delete(void *pMemory, const std::nothrow_t&amp;amp; nt) throw()
    { ::operator delete(pMemory, nt); }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Clients who want to augment the standard forms with custom forms can just use inheritance and &lt;code&gt;using&lt;/code&gt; declarations (item 33) to get all forms accessible:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class Widget: public StandardNewDeleteForms { // inherit std forms
public:
    using StandardNewDeleteForms::operator new;     // make std forms of new visible
    using StandardNewDeleteForms::operator delete;  // make std forms of delete visible

    static void* operator new(std::size_t size, std::ostream&amp;amp; logStream) throw(std::bad_alloc);  // custom placement new
    static void operator delete(void *pMemory, std::ostream&amp;amp; logStream) throw(); // corresponding placement delete
    ...
};
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>Item-51 Adhere to convention when writing new and delete</title>
      <link>http://nianze.tk/2018/03/adhere-to-convention-when-writing-new-and-delete/</link>
      <pubDate>Tue, 20 Mar 2018 14:32:24 -0400</pubDate>
      
      <guid>http://nianze.tk/2018/03/adhere-to-convention-when-writing-new-and-delete/</guid>
      <description>&lt;p&gt;&lt;code&gt;operator new&lt;/code&gt; should contain an infinite loop trying to allocate memory, should call the new-handler if it can&amp;rsquo;t satisfy a memory request, and should handle requests for zero bytes; class-specific versions should handle requests for larger blocks than expected. &lt;code&gt;operator delete&lt;/code&gt; should do nothing if passed a pointer that is null; class specific versions should handle blocks that are larger than expected.

&lt;!-- toc --&gt;&lt;/p&gt;

&lt;p&gt;When write our own versions of &lt;code&gt;operator new&lt;/code&gt; and &lt;code&gt;operator delete&lt;/code&gt;, there are conventions we must follow.&lt;/p&gt;

&lt;h1 id=&#34;1-operator-new&#34;&gt;1. operator new&lt;/h1&gt;

&lt;p&gt;Implementing a conformant &lt;code&gt;operator new&lt;/code&gt; requires:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;having the right return value&lt;/li&gt;
&lt;li&gt;calling the new-handling function when insufficient memory is available (item 49)&lt;/li&gt;
&lt;li&gt;being prepared to cope with requests for no memory&lt;/li&gt;
&lt;li&gt;avoiding hiding the &amp;ldquo;normal&amp;rdquo; form of &lt;code&gt;new&lt;/code&gt; (item 52)&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;have-the-right-return-value&#34;&gt;Have the right return value&lt;/h2&gt;

&lt;p&gt;If succeeding to supply the requested memory, return a pointer to it.&lt;/p&gt;

&lt;h2 id=&#34;call-the-new-handler&#34;&gt;Call the new-handler&lt;/h2&gt;

&lt;p&gt;If failing to supply the requested memory, follow the rule in item 49 to call the new-handling function after each fauilure. It is assumed that new-handling function might be able to free up some memory. Throw an exception of type &lt;code&gt;bad_alloc&lt;/code&gt; only when the pointer to the new-handler is null.&lt;/p&gt;

&lt;h2 id=&#34;cope-with-request-for-no-memory&#34;&gt;Cope with request for no memory&lt;/h2&gt;

&lt;p&gt;C++ requires that &lt;code&gt;operator new&lt;/code&gt; return a legitimate pointer even when zero bytes are requested (because this simplifies things else where in the language), so pseudocode for a non-member &lt;code&gt;operator new&lt;/code&gt; looks like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;void* operator new(std::size_t size) throw(std::bad_alloc)
{
    using namespace std;
    if (size == 0) {
        size = 1;  // handle 0-byte requests by treating them as 1-byte requests
    }
    while(true) {
        attempt to allocate size bytes
        if (succeed to allocate)
            return (a pointer to the memory);
        // allocation fails
        new_handler globalHanlder = set_new_hanlder(0); // find out current 
        set_new_handler(globalHandler);   // new handling-function
        if (globalHandler) (*globaleHandler)();
        else throw std::bad_alloc();
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;avoid-hiding-the-normal-form-of-new&#34;&gt;Avoid hiding the &amp;ldquo;normal&amp;rdquo; form of &lt;code&gt;new&lt;/code&gt;&lt;/h2&gt;

&lt;p&gt;Class specific &lt;code&gt;operator new&lt;/code&gt; member functions are inherited by derived classes, so it is possible that the &lt;code&gt;operator new&lt;/code&gt; tuned for objects of size &lt;code&gt;sizeof(base)&lt;/code&gt; might accidentally be called to allocate memory for an object of a derived class. To handle this situation, do following trick:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class Base {
public:
    static void * operator new(std::size_t size) throw(std::bad_alloc);
    ... 
};

class Derived:public Base  // Derived doesn&#39;t declare operator new
{...};

void * Base::operator new(std::size_t size) throw(std::bad_alloc)
{
    if (size != sizeof(Base))
        return ::operator new(size); // if size is &amp;quot;wrong&amp;quot;, call standard operator new
    ...  // otherwise do the Base-specific operation
}

Derived *p = new Derived; // calls Base::operator new
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note that &lt;code&gt;sizeof(Base)&lt;/code&gt; can never be zero - freestanding objects have non-zero size (item 39) - so the zero-size memory request will be forwarded to &lt;code&gt;::operator new&lt;/code&gt; to handle in a reasonable fashion.&lt;/p&gt;

&lt;h2 id=&#34;control-memory-allocation-for-operator-new&#34;&gt;Control memory allocation for &lt;code&gt;operator new[]&lt;/code&gt;&lt;/h2&gt;

&lt;p&gt;To control allocation for arrays on a per-class basis, we need to implement &lt;code&gt;operator new[]&lt;/code&gt; - all we can do is allocating a chunk of raw memory. The point here is that we can not do any assumption about the as-yet-nonexistent objects in the array:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;it is possible to allocate memory for an array of derived class objects via base class&amp;rsquo;s &lt;code&gt;operator new[]&lt;/code&gt; through inheritance, and the size of derived class objects are usually bigger than base class objects, so the number of objects in the array is no neccessarily &lt;code&gt;(bytes requested) / sizeof(Base)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;size_t&lt;/code&gt; parameter passed to &lt;code&gt;operator new[]&lt;/code&gt; may be for more memory than will be filled with objects, because dynamically allocated arrays may include extra space to store the number of array elements (item 16).&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&#34;2-operator-delete&#34;&gt;2. operator delete&lt;/h1&gt;

&lt;p&gt;C++ guarantees it&amp;rsquo;s always safe to delete the null pointer, so things are easier in terms of implementing &lt;code&gt;operator delete&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;// non-member operator delete
void operator delete(void *rawMemory) throw()
{
    if (rawMemory == 0) return;  // do nothing if the null pointer is being deleted
    deallocate the memory pointed to by rawMemory
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;// class-specific operator delete
class Base {  // same as before, except that operator delete is declared
public:
    static void * operator new(std::size_t size) throw(std::bad_alloc);
    static void operator delete(void *rawMemory, std::size_t size) throw();
    ...
}

void Base::opearator delete(void *rawMemory, std::size_t size) throw()
{
    if (rawMemory == 0) return;
    if (size != sizeOf(Base)) {        // if size is &amp;quot;wrong&amp;quot;, 
        ::operator delete(rawMemory);  // use standard operator delete to handle the request
    }
    deallocate the memory pointed to by rawMemory;
    return;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;BTW, the &lt;code&gt;size_t&lt;/code&gt; value C++ passes to &lt;code&gt;operator delete&lt;/code&gt; may be incorrect if object being deleted was derived from a base class lacking a virtual destructor, which is another reason to support the argument in item 7 that &lt;code&gt;operator delete&lt;/code&gt; may not work correctly if virtual destructors is omitted in base classes.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Item-50 Understand when it makes sense to replace new and delete</title>
      <link>http://nianze.tk/2018/03/understand-when-it-makes-sense-to-replace-new-and-delete/</link>
      <pubDate>Mon, 19 Mar 2018 10:54:04 -0400</pubDate>
      
      <guid>http://nianze.tk/2018/03/understand-when-it-makes-sense-to-replace-new-and-delete/</guid>
      <description>&lt;p&gt;There are many valid reasons for writing custom versions of &lt;code&gt;new&lt;/code&gt; and &lt;code&gt;delete&lt;/code&gt;, including improving performance, debugging heap usage errors, and collecting heap usage information.
&lt;/p&gt;

&lt;p&gt;Some most common reasons to replace the compiler-provided versions of &lt;code&gt;operator new&lt;/code&gt; and &lt;code&gt;operator delete&lt;/code&gt;:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;To detect usage errors&lt;/strong&gt;:

&lt;ul&gt;
&lt;li&gt;By having &lt;code&gt;operator new&lt;/code&gt; keep a list of allocated addresses and &lt;code&gt;operator delete&lt;/code&gt; remove addresses from the list, it&amp;rsquo;s easy to detect usage errors such as memory leaks (fail to &lt;code&gt;delete&lt;/code&gt; memory conjured up by &lt;code&gt;new&lt;/code&gt;) or over-&lt;code&gt;delete&lt;/code&gt;(using more than one &lt;code&gt;delete&lt;/code&gt; on &lt;code&gt;new&lt;/code&gt;ed memory)&lt;/li&gt;
&lt;li&gt;By customizing &lt;code&gt;operator new&lt;/code&gt; to overallocate blocks so there&amp;rsquo;s room to put known byte patterns (&amp;ldquo;signatures) before and after the memory made avaiblable to clients, &lt;code&gt;operator delete&lt;/code&gt;s can check to see if the signatures are still intact, so that the abnormal pattern resulted from overrun (writing beyond the end of an allocated block) or underrun (writing prior to the begining of an allocated block) could be logged down, along with the value of the offending pointer.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;To collect usage statistics about dynamically allocated memory&lt;/strong&gt;:

&lt;ul&gt;
&lt;li&gt;Custome versions of &lt;code&gt;operator new&lt;/code&gt; and &lt;code&gt;operator delete&lt;/code&gt; make it easy to collect following information:

&lt;ul&gt;
&lt;li&gt;the distribution of allocated block sizes and their lifetimes&lt;/li&gt;
&lt;li&gt;the order of allocation and deallocation (FIFO, LIFO, or random)&lt;/li&gt;
&lt;li&gt;usage patterns change over time (e.g., different allocation/deallocation patterns in different stages of execution)&lt;/li&gt;
&lt;li&gt;the maximum amount of dynamically allocated memory in use at any one time (e.g., its &amp;ldquo;high water mark&amp;rdquo;)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;To improve efficiency&lt;/strong&gt;:

&lt;ul&gt;
&lt;li&gt;The &lt;code&gt;operator new&lt;/code&gt;s and &lt;code&gt;operator delete&lt;/code&gt;s that ship with compilers are designed for general-purpose use, which means they work reasonably well for everybody, but optimally for nobody.

&lt;ul&gt;
&lt;li&gt;&lt;em&gt;To increase the speed of allocation and deallocation&lt;/em&gt;: custom versions of &lt;code&gt;operator new&lt;/code&gt; and &lt;code&gt;operator delete&lt;/code&gt; are often faster, especially for fixed-size allocators such as those offered by Boost&amp;rsquo;s Pool library. If our application is signle-threaded, but our compiler&amp;rsquo;s default memory management routines are thread-safe, we may be able to win measurable speed improvements by writing thread-unsafe allocators (be sure to profile the program before speeding up though).&lt;/li&gt;
&lt;li&gt;&lt;em&gt;To reduce the space overhead of default memory management&lt;/em&gt;: general-purpose memory managers often use more memory to incur some overhead for each allocated block. Allocators tuned for small objects (such as those in Boost&amp;rsquo;s Pool library) essentially eliminate such overhead.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;To compensate for suboptimal alignment in the default allocator&lt;/strong&gt;:

&lt;ul&gt;
&lt;li&gt;Many architectures require that data of particular types be placed in memory at particular kinds of address (otherwise it leads to hardware exceptions at runtime), while other architectures, thought accepting misaligned data, will offer better performance if alignment preferences are satisfied. For example, it&amp;rsquo;s faster to access &lt;code&gt;double&lt;/code&gt;s on x86 architecture when they are &lt;em&gt;eight-byte aligned&lt;/em&gt;.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;To cluster related objects near one another&lt;/strong&gt;:

&lt;ul&gt;
&lt;li&gt;if some particular data structures are generally used together and we&amp;rsquo;d like to minimize the frequency of page faults when working on the data, it makes sense to create a separate heap for the data structures so they are clustered together on as few pages as possible. For example, placement versions of &lt;code&gt;new&lt;/code&gt; and &lt;code&gt;delete&lt;/code&gt; (item 52) makes it possible to achieve such clustering.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;To obtain unconventinal behavior&lt;/strong&gt;:

&lt;ul&gt;
&lt;li&gt;For example, we might want to allocate and deallocate blocks in shared memory only through a C API to mange the memory, so we can write custome versions of &lt;code&gt;new&lt;/code&gt; and &lt;code&gt;delete&lt;/code&gt; (probably placement versions, item 52) to drape the C API in C++ clothing.&lt;/li&gt;
&lt;li&gt;For another example, we might write a custom &lt;code&gt;operator delete&lt;/code&gt; that overwrites deallocated memory with zeros in order to increase the security of application data.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Writing a custom memory manager that almost works is pretty easy, but writing one that works &lt;em&gt;well&lt;/em&gt; is a lot harder. For example, here&amp;rsquo;s a quick first pass at a global &lt;code&gt;operator new&lt;/code&gt; that facilitates the detection of under- and overruns.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;static const int signature = 0xDEADBEEF;

typedef unsigned char Byte;

// this code has several flaws
void* operator new(std::size_t size) throw (std::bad_alloc)
{
    using namespace std;

    size_t realSize = size + 2 * sizeof(int); // increase size of request so 2 signatures will also fit inside
    void *pMem = malloc(realSize); // call malloc to get the actual memory
    if (!pMem) throw bad_alloc();
    // write signature into first and last parts of the memory
    *(static_cast&amp;lt;int*&amp;gt;(pMem)) = signature;
    *(reinterpret_cast&amp;lt;int*&amp;gt;(static_cast&amp;lt;Byte*&amp;gt;(pMem)+realSize-sizeof(int))) = signature;
    // return a pointer to the memory just past the first signature
    return static_cast&amp;lt;Byte*&amp;gt;(pMem) + sizeof(int);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;One obvious shortcoming of this &lt;code&gt;operator new&lt;/code&gt; is its failure to adhere to the C++ conventions for &lt;code&gt;operator new&lt;/code&gt; - item 51 explains that all &lt;code&gt;operator new&lt;/code&gt; should contain a loop calling a new-handling function, but this one above doesn&amp;rsquo;t.&lt;/p&gt;

&lt;p&gt;Another subtle issue is &lt;em&gt;alignment&lt;/em&gt;: C++ requires that all &lt;code&gt;operator new&lt;/code&gt; and &lt;code&gt;malloc&lt;/code&gt; return pointers that are suitably aligned for &lt;em&gt;any&lt;/em&gt; data type. In this version of &lt;code&gt;operator new&lt;/code&gt;, we&amp;rsquo;re returning a pointer we got from malloc &lt;em&gt;offset by the size of an int&lt;/em&gt;. If we are running on a manchine where &lt;code&gt;int&lt;/code&gt;s were four bytes in size but &lt;code&gt;double&lt;/code&gt;s were required to be eight-byte aligned, we&amp;rsquo;d probably return a pointer with improper alignment when &lt;code&gt;operator new&lt;/code&gt; is called to get enough memory for a &lt;code&gt;double&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;As a general rule, do not attempt writing a custom memory manager unless we have to. In fact, in many cases, we don&amp;rsquo;t have to:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;some compilers have switches that enable debugging and logging functionality in their memory management functions.&lt;/li&gt;
&lt;li&gt;on many platforms, commercial products can replace the memory management functions that ship with compilers (all we need is to buy and relink).&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Even if we decide to write our own &lt;code&gt;new&lt;/code&gt;s and &lt;code&gt;delete&lt;/code&gt;s, it&amp;rsquo;s helpful to look at open source versions first to gain insights into the easy-to-overlook details that separate almost working from really working. One such open source allocator is the Pool library from Boost (item 55).&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;The pool library offers allocators tuned for one of the most common situations in which custom memory management is helpful: allocation of a large number of small objects. Real libraries tend to have code that&amp;rsquo;s robust in terms of pesky details such as portability and alignment considerations, thread safety, etc.&lt;/p&gt;
&lt;/blockquote&gt;</description>
    </item>
    
    <item>
      <title>Item-49 Understand the behavior of the new handler</title>
      <link>http://nianze.tk/2018/03/understand-the-behavior-of-the-new-handler/</link>
      <pubDate>Fri, 16 Mar 2018 19:52:09 -0400</pubDate>
      
      <guid>http://nianze.tk/2018/03/understand-the-behavior-of-the-new-handler/</guid>
      <description>&lt;p&gt;&lt;code&gt;set-new-handler&lt;/code&gt; allows you to specify a function to be called when memory allocation requests cannot be satisfied.

&lt;!-- toc --&gt;&lt;/p&gt;

&lt;h1 id=&#34;the-basic&#34;&gt;The basic&lt;/h1&gt;

&lt;p&gt;If &lt;code&gt;operator new&lt;/code&gt; can&amp;rsquo;t satisfy a memory allocation request, it will call a client-specifiable error-handling function called a &lt;code&gt;new-handler&lt;/code&gt; before throwing a &lt;code&gt;bad_alloc&lt;/code&gt; exception. To specify this out-of-memory-handling function, clients call &lt;code&gt;set_new_handler&lt;/code&gt;, a standard library function declared in &lt;code&gt;&amp;lt;new&amp;gt;&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;namespace std {
    typedef void (*new_handler)();
    new_handler set_new_handler(new_handler p) throw();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;throw()&lt;/code&gt; here is an exception specification, telling us that function &lt;code&gt;set_new_handler&lt;/code&gt; won&amp;rsquo;t throw any exceptions (though there&amp;rsquo;s more truth, refer to item 29).&lt;/p&gt;

&lt;p&gt;&lt;code&gt;set_new_handler&lt;/code&gt;&amp;rsquo;s parameter is the new &lt;code&gt;new_handler&lt;/code&gt; we want to specify, which is a pointer to the function &lt;code&gt;operator new&lt;/code&gt; should call if it fails to allocate the requested memory, and the return value if the previous &lt;code&gt;new_handler&lt;/code&gt;. Once &lt;code&gt;operator new&lt;/code&gt; fails to fulfill a memory request, it calls the &lt;code&gt;new_handler&lt;/code&gt; function repeatedly until it &lt;em&gt;succeeds&lt;/em&gt; to find enough memory (more details in item 51), so this default behavior gives us following conclusion - a well-designed new-handler function must do one of the following:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Make more memory available&lt;/strong&gt; to allow the next memory allocation attempt inside &lt;code&gt;operator new&lt;/code&gt; to succeed&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:1&#34;&gt;&lt;a href=&#34;#fn:1&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Install a different new-handler&lt;/strong&gt; that may be capable to make more memory &lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:2&#34;&gt;&lt;a href=&#34;#fn:2&#34;&gt;2&lt;/a&gt;&lt;/sup&gt;. A variation is to modify the behavior of current &lt;code&gt;new-handler&lt;/code&gt; (via modifying static, namespace specific, or global data the affects the new-handler&amp;rsquo;s behavior)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Deinstall the new-handler&lt;/strong&gt;, i.e., pass the null pointer to &lt;code&gt;set_new_handler&lt;/code&gt;, which leads to &lt;code&gt;operator new&lt;/code&gt; throwing a &lt;code&gt;bad_alloc&lt;/code&gt; exception.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Throw an exception&lt;/strong&gt; of type &lt;code&gt;bad_alloc&lt;/code&gt; or some type derived from &lt;code&gt;bad_alloc&lt;/code&gt;, which will firstly be caught by &lt;code&gt;operator new&lt;/code&gt; and then propagate to the site originating the request for memory.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Not return&lt;/strong&gt;, typically by calling &lt;code&gt;abort&lt;/code&gt; or &lt;code&gt;exit&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;For example, to use &lt;code&gt;set-new-handler&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;// new handler to install
void outOfMem()
{
    std::cerr &amp;lt;&amp;lt; &amp;quot;Unable to satisfy request for memory\n&amp;quot;;
    std::about();
}

int main()
{
    std::set_new_handler(outOfMem);
    int *pBigDataArray = new int[100000000L];
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;customize-the-new-handler-per-class&#34;&gt;Customize the &lt;code&gt;new-handler&lt;/code&gt; per class&lt;/h1&gt;

&lt;p&gt;C++ has no support for class-specific new-handlers, so we implement this by ourselves: we have each class provide its own versions of &lt;code&gt;set_new_handler&lt;/code&gt; (which allows clients to specify the customized &lt;code&gt;new-handler&lt;/code&gt;) and &lt;code&gt;operator new&lt;/code&gt; (which ensures the class-specific &lt;code&gt;new-handler&lt;/code&gt; is used in place of the global &lt;code&gt;new-handler&lt;/code&gt; when memory allocation request fails).&lt;/p&gt;

&lt;p&gt;To make thie ensurance confirmed, this class-specific &lt;code&gt;operator new&lt;/code&gt; should do the following stuff:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Call the standard &lt;code&gt;set_new_handler&lt;/code&gt; to install &lt;code&gt;Widget&lt;/code&gt;&amp;rsquo;s own error-handling function as the global new-handler.&lt;/li&gt;
&lt;li&gt;Call the global &lt;code&gt;operator new&lt;/code&gt; to perform the actual memory allocation. Two things may happen during this step:

&lt;ul&gt;
&lt;li&gt;if allocation ultimately fails and a &lt;code&gt;bad_alloc&lt;/code&gt; is thrown by the global &lt;code&gt;operator new&lt;/code&gt;, restore the original global new-handler, and then propagate the exception&lt;/li&gt;
&lt;li&gt;if allocation succeeds, return a pointer to the allocated memory, and then restore the original global new-handler prior to the call to &lt;code&gt;Widget::operator new&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;To ensure that the original new-handler is always reinstalled, we can treat the global new-handler as a resource and follow the advice of item 13 to use resource-managing objects to prevent resource leaks:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class NewHandlerHolder {
public:
    explicit NewHandlerHolder(std::new_handler nh) // aquire the original new-handler
    :handler(nh) {}
    ~NewHandlerHolder()
    { std::set_new_handler(handler); }  // release the original new-handler
private:
    std::new_handler handler;  // remember the original new-handler
    NewHandlerHolder(const NewHandlerHolder&amp;amp;); // prevent copying see item 14
    NewHandlerHolder&amp;amp; operator=(const NewHandlerHolder&amp;amp;); // prevent copying see item 14
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Since the behavior of setting a class-specific new-handler is the same regardless of the class, we can reuse the setting procedure by creating a &amp;ldquo;mixin-style&amp;rdquo; base class (i.e., a base class that&amp;rsquo;s designed to allow derived classes to inherit a single specific capability), so that each derived class not only inherits the &lt;code&gt;set_new_handler&lt;/code&gt; and &lt;code&gt;operator new&lt;/code&gt; functions from the base class, but also gets a different class-specific &lt;code&gt;new-handler&lt;/code&gt; from the template.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;template&amp;lt;typename T&amp;gt;      // &amp;quot;mixin-style&amp;quot; base class 
class NewHandlerSupport { // for class-specific set_new_handler support
public:
    static std::new_handler set_new_handler(std::new_handler p) throw();
    static void* operator new(std::size_t size) throw(std::bad_alloc);
    ... // other versions of op. new - see item 52
private:
    static std::new_handler currentHandler;
};
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;template&amp;lt;typename T&amp;gt;
std::new_handler NewHandlerSupport&amp;lt;T&amp;gt;::set_new_handler(std::new_handler p) throw()
{
    std::new_handler oldHandler = currentHandler;
    currentHandler = p;
    return oldHandler;
}

template&amp;lt;typename T&amp;gt;
void* NewHandlerSupport&amp;lt;T&amp;gt;::operator new(std::size_t size) throw(std::bad_alloc)
{
    NewHandlerHolder h(std::set_new_handler(currentHandler)); // install new-handler
    return ::operator new(size);  // allocate memory or throw
} // restore global new-handler

template&amp;lt;typename T&amp;gt;
std::new_handler NewHanderSupport&amp;lt;T&amp;gt;::currentHandler = 0; // init.  currentHandler to null
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;With this class template, adding &lt;code&gt;set_new_handler&lt;/code&gt; support to &lt;code&gt;Widget&lt;/code&gt; is easy: &lt;code&gt;Widget&lt;/code&gt; just inherits from &lt;code&gt;NewHandlerSupport&amp;lt;Widget&amp;gt;&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class Widget: public NewHandlerSupport&amp;lt;Widget&amp;gt; {
public:
    ... // without declaration for set_new_handler or operator new
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;One interesting point for this design is that  &lt;code&gt;Widget&lt;/code&gt; inheriting from a templatized base class that takes &lt;code&gt;Widget&lt;/code&gt; itself as a type parameter, and this technique has a straightforwart name: &lt;em&gt;curiously recurring template pattern (CRTP)&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Another point worth noting is that the &lt;code&gt;NewHandlerSupport&lt;/code&gt; template never uses its type parameter &lt;code&gt;T&lt;/code&gt;, because it doesn&amp;rsquo;t need to: all we need is a different copy of static data member &lt;code&gt;currentHJandler&lt;/code&gt; for each class inheriting from &lt;code&gt;NewHandlerSupport&lt;/code&gt;, and template parameter &lt;code&gt;T&lt;/code&gt; just makes it possible to distinguish these derived classes - the template mechanism automatically generates a copy of &lt;code&gt;currentHandler&lt;/code&gt; for each &lt;code&gt;T&lt;/code&gt; with which &lt;code&gt;NewHandlerSupport&lt;/code&gt; is instantiated.&lt;/p&gt;

&lt;p&gt;Finally, let&amp;rsquo;s take a look at how to use the new-handling capabilities in &lt;code&gt;Widget&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;void outOfMem(); // decl. of class-specific new-handler func.
Widget::set_new_handler(outOfMem); // set outOfMem as Widget&#39;s new-handler
Widget *pw1 = new Widget; // if mem. alloc. fails, call outOfMem
std::string *ps = new std::string; // if mem. alloc. fails, call the original global new-handler (if there is one)
Widget::set_new_handler(0);  // set the Widget-specific new-handler to nothing (null)
Widget *pw2 = new Widget;  // there&#39;s no new-handling func. for Widget now, so if mem. alloc. fails, throw an exception immediately
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;traditional-failure-yields-null-alternative-for-operator-new&#34;&gt;Traditional failure-yields-null alternative for &lt;code&gt;operator new&lt;/code&gt;&lt;/h1&gt;

&lt;p&gt;Althought now it is specified to throw a &lt;code&gt;bad_alloc&lt;/code&gt; exception, until 1993, C++ required that &lt;code&gt;operator new&lt;/code&gt; return null when it way unable to allocate the requested memory. Unwilling to abandon the traditional behavior, the C++ standardization committee provided an alternative form of &lt;code&gt;operator new&lt;/code&gt; called &amp;ldquo;nothrow&amp;rdquo; forms, in part because the forms employ &lt;code&gt;nothrow&lt;/code&gt; objects defined in the header &lt;code&gt;&amp;lt;new&amp;gt;&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class Widget {...};
Widget *pw1 = new Widget;  // throws bad_alloc if allocation fails
if (pw1 == 0) ... // this test must fail
Widget *pw2 = new (std::nothrow) Widget; // returns 0 if allocation fails
if (pw2 == 0) ... // this test may succeed
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;However, using &lt;code&gt;new (std::nothrow) Widget&lt;/code&gt; only guarantees that &lt;code&gt;operator new&lt;/code&gt; won&amp;rsquo;t throw, not the whole expression: after the nothrow versoin of &lt;code&gt;operator new&lt;/code&gt; succeeds to allocate enough memory for a &lt;code&gt;Widget&lt;/code&gt; object, and then the &lt;code&gt;Widget&lt;/code&gt; constructor is called, chances are that the &lt;code&gt;Widget&lt;/code&gt; constructor might itself new up some memory and throw, and then the exception will be propagated as usual.&lt;/p&gt;

&lt;p&gt;Conclusion: we never have a need for nothrow new.&lt;/p&gt;
&lt;div class=&#34;footnotes&#34;&gt;

&lt;hr /&gt;

&lt;ol&gt;
&lt;li id=&#34;fn:1&#34;&gt;One way to achieve this strategy is to allocate a large block of memory at program start-up, then release it for use in the program the first time the new-handler is invoked.
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:1&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:2&#34;&gt;The strategy may be implemented by calling &lt;code&gt;set_new_handler&lt;/code&gt; inside current &lt;code&gt;new-handler&lt;/code&gt;. The next time &lt;code&gt;operator new&lt;/code&gt; call the &lt;code&gt;new-handler&lt;/code&gt; function, it will get the one most recently installed.
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:2&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;</description>
    </item>
    
    <item>
      <title>Item-48 Be aware of template metaprogramming</title>
      <link>http://nianze.tk/2018/03/be-aware-of-template-metaprogramming/</link>
      <pubDate>Thu, 15 Mar 2018 23:00:22 -0400</pubDate>
      
      <guid>http://nianze.tk/2018/03/be-aware-of-template-metaprogramming/</guid>
      <description>&lt;p&gt;Template metaprogramming can shift work from runtime to compile-time (thus enabling earlier error dettection and higher runtime performance), can be used to generate custom code based on combinations of policy choices, and can also be used to avoid generating code inappropriate for particular types.

&lt;!-- toc --&gt;&lt;/p&gt;

&lt;p&gt;Template metaprogramming (TMP) is the process of writing template-based C++ programs that execute inside the C++ compiler, ending up with pieces of C++ source code instantiated from templates, which are then compiled as usual. TMP was discovered, not designed, in the early 1990s, and has later been shown to be Turing-complete, which means that it is powerful enough to compute anything (declare variables, perform loops, write and call functions, etc).&lt;/p&gt;

&lt;h1 id=&#34;strength-of-tmp&#34;&gt;Strength of TMP&lt;/h1&gt;

&lt;p&gt;TMP has two great strengths:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;it makes some things easy that would otherwise be hard or impossiblle&lt;/li&gt;
&lt;li&gt;it shifts work from runtime to compile-time&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:1&#34;&gt;&lt;a href=&#34;#fn:1&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;By making use of TMP, we can expect following good consequences:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Some kinds of errors originally detected at runtime could be found during compilation&lt;/li&gt;
&lt;li&gt;C++ progrmas become more efficient in about every way: smaller executables, shorter runtimes, lesser memory requirements&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;To take a glimpse into how things work in TMP, let&amp;rsquo;s look at two examples.&lt;/p&gt;

&lt;h2 id=&#34;examples&#34;&gt;Examples&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Ex1: &lt;code&gt;if...else&lt;/code&gt; conditionals in TMP&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;As item 47 shows, &lt;code&gt;if...else&lt;/code&gt; conditionals in TMP are expressed via templates and template specializations&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:2&#34;&gt;&lt;a href=&#34;#fn:2&#34;&gt;2&lt;/a&gt;&lt;/sup&gt;. Let&amp;rsquo;s take a comparason between the &amp;ldquo;normal&amp;rdquo; C++ (using &lt;code&gt;typeid&lt;/code&gt;) and TMP (using traits) based on implementing the pseudo part of &lt;code&gt;if (iter is a random access iterator)&lt;/code&gt; from STL&amp;rsquo;s &lt;code&gt;advance&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Below is the &amp;ldquo;normal&amp;rdquo; C++ approach, which evaluates at runtime:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;template&amp;lt;typename IterT, typename DistT&amp;gt;
void advance(IterT&amp;amp; iter, DistT d)
{
    if (typeid(typename std::iterator_traits&amp;lt;IterT&amp;gt;::iterator_categoray) == 
        typeid(std::random_access_iterator_tag)) {
            iter += d; // use iterator arithmetic for random access iters
    }
    else {
        if (d &amp;gt;= 0) { while(d--) ++iter; }
        else { while(d++) --iter; }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Compared to the one using traits, the &lt;code&gt;typeid&lt;/code&gt;-based approach has following issues:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;less efficient: testing occurs at runtime; executable is larger (since the code to do the testing must be present in the executable)&lt;/li&gt;
&lt;li&gt;introduce compilation problems: if &lt;code&gt;iter&lt;/code&gt; isn&amp;rsquo;t a random access iterator, &lt;code&gt;iter&lt;/code&gt; will not support operator &lt;code&gt;+=&lt;/code&gt;, so &lt;code&gt;iter += d&lt;/code&gt; will not be valid, but compilers will still check this part of code and complain about its invalidation, because they are obliged to make sure that all source code is valid, even if it&amp;rsquo;s not executed.&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;Ex2: loops in TMP&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;TMP has no real looping construct, so the effect of loops is accomplished via recursion, or more specifically, recursive &lt;em&gt;template instantiations&lt;/em&gt;. As an example, TMP factorial computation demonstates how it works:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;template&amp;lt;unsigned n&amp;gt;  // general case: the value of Factorial&amp;lt;n&amp;gt; is n times the value of Factorial&amp;lt;n-1&amp;gt;
struct Factorial {
    enum { value = n * Factorial&amp;lt;n-1&amp;gt;::value };
};

template&amp;lt;&amp;gt;
struct Factorial&amp;lt;0&amp;gt; {
    enum { value = 1 };
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The looping part of the code occurs where the template instantiation &lt;code&gt;Factorial&amp;lt;n&amp;gt;&lt;/code&gt; references the tempalte instantiation &lt;code&gt;Factorial&amp;lt;n-1&amp;gt;&lt;/code&gt;, until hitting the special case, &lt;code&gt;Factorial&amp;lt;0&amp;gt;&lt;/code&gt;, that causes the recursion to terminate.&lt;/p&gt;

&lt;p&gt;Each instantiation of the &lt;code&gt;Factorial&lt;/code&gt; template is a struct, and each struct uses the enum hack (item 2) to declare a TMP variable named &lt;code&gt;value&lt;/code&gt;, which holds the current value of the factorial computation. After recursive template instantiation, each instantiation gets its own copy of &lt;code&gt;value&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;To use &lt;code&gt;Factorial&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;int main()
{
    std::cout &amp;lt;&amp;lt; Factorial&amp;lt;5&amp;gt;::value;  // prints 120
    std::cout &amp;lt;&amp;lt; Factorial&amp;lt;10&amp;gt;::value; // prints 3628800
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To sum up the technique keywords: templates and specializations and recursive instantiations and enum hacks.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;what-can-be-accomplished-in-tmp&#34;&gt;What can be accomplished in TMP&lt;/h1&gt;

&lt;h2 id=&#34;1-ensuring-dimensional-unit-correctness&#34;&gt;1. Ensuring dimensional unit correctness&lt;/h2&gt;

&lt;p&gt;In scientific and engineering applications, it&amp;rsquo;s essential that dimensional units (e.g., mass, distance, time, etc.) be combined correctly. Using TMP, it&amp;rsquo;s possible to ensure (during compilation) that all dimensional unit combinations in a program are correct, no matter how complex the calculations - good example for early error detection.&lt;/p&gt;

&lt;h2 id=&#34;2-optimizang-matrix-operations&#34;&gt;2. Optimizang matrix operations&lt;/h2&gt;

&lt;p&gt;Consider the following code,&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;typedef SqureMatrix&amp;lt;double, 10000&amp;gt; BigMatrix;
BigMatrix m1, m2, m3, m4, m5;  // create matrices
... // give them values
BigMatrix result = m1 * m2 * m3 * m4 * m5; // compute the product
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Calculating &lt;code&gt;result&lt;/code&gt; in the &amp;ldquo;normal&amp;rdquo; way calls for the creation of four temporary matrices, one for the reuslt of each call to &lt;code&gt;operator*&lt;/code&gt;. Furthermore, the independent multiplications generate a sequence of four loops over the matrix elements.&lt;/p&gt;

&lt;p&gt;Using an advanced template technology related to TMP called &lt;em&gt;expression templates&lt;/em&gt;, it&amp;rsquo;s possible to eliminate the temporaries and merge the loops, without changing the syntax of the client code above while enabling the program consume less memory and run dramatically fast.&lt;/p&gt;

&lt;h2 id=&#34;3-generating-custom-design-pattern-implementations&#34;&gt;3. Generating custom design pattern implementations&lt;/h2&gt;

&lt;p&gt;Design patterns like Strategy (item 35), Observer, Visitor, etc. can be implemented in many ways. Using a TMP-based technology called &lt;code&gt;policy-based design&lt;/code&gt;, it&amp;rsquo;s possible to create templates representing independent design choices (&amp;ldquo;policies&amp;rdquo;) that can be combined in arbitrary ways to yield pattern implementations with custom behavior.&lt;/p&gt;

&lt;p&gt;Generalized beyond the domain of programming artifacts like design patterns, this technology is a basis for what&amp;rsquo;s known as &lt;em&gt;generative programming&lt;/em&gt;.&lt;/p&gt;
&lt;div class=&#34;footnotes&#34;&gt;

&lt;hr /&gt;

&lt;ol&gt;
&lt;li id=&#34;fn:1&#34;&gt;Programs using TMP may take &lt;em&gt;much&lt;/em&gt; longer to compile than their non-TMP counterparts.
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:1&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:2&#34;&gt;Basic constructs, such as declaring variables, performing loops, and calling function, may look very different from their &amp;ldquo;normal&amp;rdquo; C++ counterparts, but that&amp;rsquo;s assembly-level TMP - it&amp;rsquo;s worth to know that libraries for TMP (e.g., Boost&amp;rsquo;s MPL, item 55) offer a higher-level syntax.
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:2&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;</description>
    </item>
    
    <item>
      <title>Item-47 Use traits classes for information about types</title>
      <link>http://nianze.tk/2018/03/use-traits-classes-for-information-about-types/</link>
      <pubDate>Wed, 14 Mar 2018 18:49:03 -0400</pubDate>
      
      <guid>http://nianze.tk/2018/03/use-traits-classes-for-information-about-types/</guid>
      <description>&lt;p&gt;Implemented by templates and template specializations, traits classes make information about types available during compilation. Combining traints with overloading, it is possible to perform compile-time &lt;code&gt;if...else&lt;/code&gt; tests on types.

&lt;!-- toc --&gt;&lt;/p&gt;

&lt;p&gt;In this item, let&amp;rsquo;s look at how STL supports the utility template &lt;code&gt;advance&lt;/code&gt;, which moves a specified iterator a specified distance:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;template&amp;lt;typename IterT, typename DistT&amp;gt;  
void advance(IterT&amp;amp; iter, DistT d); // move iter d units forward; if d &amp;lt; 0, move iter backward
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Before we step into the field of &lt;code&gt;advance&lt;/code&gt; implementation, we should be familiar about STL iterator categoryies, because different iterators support different operations.&lt;/p&gt;

&lt;h1 id=&#34;five-iterator-categories&#34;&gt;Five iterator categories&lt;/h1&gt;

&lt;p&gt;According to the operations they support, there are five categories of iterators&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:1&#34;&gt;&lt;a href=&#34;#fn:1&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;&lt;em&gt;Input iterators&lt;/em&gt;&lt;/strong&gt; can move only one step forward at a time, can only read, and can read what they&amp;rsquo;re pointing to only once (e.g., &lt;code&gt;istream_iterator&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;em&gt;Output iterators&lt;/em&gt;&lt;/strong&gt; can move only one step forwrad at a time, can only write, and can write what they&amp;rsquo;re pointing to only once (e.g., &lt;code&gt;ostream_iterator&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;em&gt;Forward iterators&lt;/em&gt;&lt;/strong&gt; can do whatever input and output iterators can do, and they can read or write what they point to momre than once (e.g., singly linked list or iterators into TR1&amp;rsquo;s hashed containers (item 54) may be in the forward category)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;em&gt;Bidirectional iterators&lt;/em&gt;&lt;/strong&gt; add to forward iterators the ability to move backward as well as forward (e.g., iterators for &lt;code&gt;list&lt;/code&gt;, &lt;code&gt;set&lt;/code&gt;, &lt;code&gt;multiset&lt;/code&gt;, &lt;code&gt;map&lt;/code&gt;, &lt;code&gt;multimap&lt;/code&gt; in STL)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;em&gt;Random access iterators&lt;/em&gt;&lt;/strong&gt; are the most powerful ones: they add to bidirectional iterators the ability to perform &amp;ldquo;iterator arithmetic&amp;rdquo; - to jump forward or backward an arbitrary distance in constant time, which is similar to pointer arithmetic (e.g., iterators for &lt;code&gt;vector&lt;/code&gt;, &lt;code&gt;deque&lt;/code&gt;, &lt;code&gt;string&lt;/code&gt;)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;For each of the five iterator categories, C++ has a &amp;ldquo;tag struct&amp;rdquo; in the standard library that serves to identify it:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;struct input_iterator_tag {};
struct output_iterator_tag {};
struct forward_iterator_tag: public input_iterator_tag {};
struct bidirectional_iterator_tag: public forward_iterator_tag {};
struct random_access_iterator_tag: public bidirectional_iterator_tag {};
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;pseudocode-for-advance&#34;&gt;Pseudocode for &lt;code&gt;advance&lt;/code&gt;&lt;/h1&gt;

&lt;p&gt;Knowing that different categories support different operations, &lt;code&gt;advance&lt;/code&gt; will essentially be implemented like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;template&amp;lt;typename IterT, typename DistT&amp;gt;
void advance(IterT&amp;amp; iter, DistT d)
{
    if (iter is a random access iterator) {
        iter += d; // use iterator arithmetic for random access iters
    }
    else {
        if (d &amp;gt;= 0) { while (d--) ++iter; } // use iterative calls 
        else { while (d++) --iter; }        // to ++ or -- for other iterator categories
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;How to determine whether &lt;code&gt;iter&lt;/code&gt; is a random access iterator? Here comes the technique of &lt;em&gt;traits&lt;/em&gt;, which allow us to get type information during compilation.&lt;/p&gt;

&lt;h1 id=&#34;traits&#34;&gt;Traits&lt;/h1&gt;

&lt;p&gt;Traits aren&amp;rsquo;t a keyword or a predefined construct in C++, but simply a technique and a convention followed by C++ programmers. It has some requirements, one of which asks that it has to work as well for built-in types as it does for user-defined types. This demand leads to the conclusion that the traits information for a type must be external to the type&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:2&#34;&gt;&lt;a href=&#34;#fn:2&#34;&gt;2&lt;/a&gt;&lt;/sup&gt;.&lt;/p&gt;

&lt;h2 id=&#34;for-user-defined-types&#34;&gt;For user-defined types&lt;/h2&gt;

&lt;p&gt;The standard technique is to put the information into a template and one or more specializations of that template. For iterators, the template in the standard library is named &lt;code&gt;iterator_traits&lt;/code&gt;&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:3&#34;&gt;&lt;a href=&#34;#fn:3&#34;&gt;3&lt;/a&gt;&lt;/sup&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;// the iterator_category for type IterT is whatever IterT says it is
// see item 42 for info on the use of &amp;quot;typedef typename&amp;quot;
template&amp;lt;typename IterT&amp;gt;
struct iterator_traits {
    typedef typename IterT::iterator_category iterator_category;
    ...
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;How does &lt;code&gt;iterator_traits&lt;/code&gt; work? Since &lt;code&gt;iterator_traits&lt;/code&gt; just parrots back a typedef called &lt;code&gt;iterator_category&lt;/code&gt; inside the iterator class, it requires that any user-defined iterator type must contain this nested typedef named &lt;code&gt;iterator_category&lt;/code&gt;, which identifies the appropriate tag struct. For example, &lt;code&gt;deque&lt;/code&gt; iterators belong to random access category, and &lt;code&gt;list&lt;/code&gt;&amp;rsquo;s iterators are bidirectional:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;template&amp;lt;...&amp;gt;
class deque {
public:
    class iterator {
    public:
        typedef random_access_iterator_tag iterator_category;
        ...
    };
    ...
};
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;template&amp;lt;...&amp;gt;
class list {
public:
    class iterator {
    public:
        typedef bidirectional_iterator_tag iterator_category;
        ...
    };
    ...
};
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;for-pointer-types&#34;&gt;For pointer types&lt;/h2&gt;

&lt;p&gt;The code above works well for user-defined types, but it doasn&amp;rsquo;t work for iterators that are pointers, since there&amp;rsquo;s no such thing as a nested typedef inside a built-in pointer. To make it work, &lt;code&gt;iterator_traits&lt;/code&gt; need to offer a &lt;em&gt;partial template specialization&lt;/em&gt; for pointer types:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;template&amp;lt;typename IterT&amp;gt;  // partial template specialization
struct iterator_traits&amp;lt;IterT*&amp;gt; // for built-in pointer types
{
    typedef random_access_iterator_tag iterator_category; // pointers act as random access iterators
    ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;workflow-for-designing-and-implementing-a-traits-class&#34;&gt;Workflow for designing and implementing a traits class&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Identify some information about types we&amp;rsquo;d like to make available (e.g., iterator category for iterator types)&lt;/li&gt;
&lt;li&gt;Choose a name to identify that information (e.g., &lt;code&gt;iterator_category&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;Provide a template and set of specializations (e.g., &lt;code&gt;iterator_traits&lt;/code&gt;) that contain the information for the types we want to support&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;implementing-advance&#34;&gt;Implementing &lt;code&gt;advance&lt;/code&gt;&lt;/h1&gt;

&lt;p&gt;Given &lt;code&gt;std::iterator_traits&lt;/code&gt;, we can refine our pseudocode for &lt;code&gt;advance&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;template&amp;lt;typename IterT, typename DistT&amp;gt;
void advance(IterT&amp;amp; iter, DistT d)
{
    if (typeid(typename std::iterator_traits&amp;lt;IterT&amp;gt;::iterator_category) ==
        typeid(std::random_access_iterator_tag))
        ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Sadly, this is not what we want: for one thing, it will lead to compilation problems (refer to item 48); anther issue, which is more fundamental, is that &lt;code&gt;if&lt;/code&gt; statement is evaluated at runtime but &lt;code&gt;iterator_traits&amp;lt;IterT&amp;gt;::iterator_category&lt;/code&gt; can be determined during compilation already. There&amp;rsquo;s no point to move the evaluation from compile-time to runtime to waste time and bloat the executable.&lt;/p&gt;

&lt;h2 id=&#34;template-metaprogramming&#34;&gt;Template metaprogramming&lt;/h2&gt;

&lt;p&gt;What we want is a conditional construct for types that is evaluated during compilation. Actually this demand brings us to the realm of template metaprogramming (item 48), but the technique we&amp;rsquo;ll use turns out to be quit familiar: &lt;em&gt;overloading&lt;/em&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;template&amp;lt;typename IterT, typename DistT&amp;gt; // use this impl for random access iterators
void doAdvance(IterT&amp;amp; iter, DistT d, std::random_access_iterator_tag)
{
    iter += d;
}

template&amp;lt;typename IterT, typename DistT&amp;gt; // use this impl for bidirectional iterators
void doAdvance(IterT&amp;amp; iter, DistT d, std::bidirectional_iterator_tag)
{
    if (d &amp;gt;= 0) { while(d--) ++iter; }
    else { while(d++) --iter; }
}

template&amp;lt;typename IterT, typename DistT&amp;gt; // use this impl for input iterators, also applies to inherited forward_iterator_tag
void doAdvance(IterT&amp;amp; iter, DistT d, std::input_iterator_tag)
{
    if (d &amp;lt; 0) {
        throw std::out_of_range(&amp;quot;Negative distance&amp;quot;); 
    }
    while(d--) ++iter;
}

template&amp;lt;typename IterT, typename DistT&amp;gt;
void advance(IterT&amp;amp; iter, DistT d)
{
    doAdvance(iter, d, 
        typename std::iterator_traits&amp;lt;IterT&amp;gt;::iterator_category());
};
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;summary&#34;&gt;Summary&lt;/h2&gt;

&lt;p&gt;How to use a traits class:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Create a set of overloaded &amp;ldquo;worker&amp;rdquo; functions or function templates (e.g., doAdvance) that differ in a traits parameter. Implement each function in accrod with the traits information passed.&lt;/li&gt;
&lt;li&gt;Create a &amp;ldquo;master&amp;rdquo; function or function template (e.g., advance) that calls the workers, passing information provided by a traits class.&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;footnotes&#34;&gt;

&lt;hr /&gt;

&lt;ol&gt;
&lt;li id=&#34;fn:1&#34;&gt;Input and output iterators, as two least powerful iterator categories, are modeled on the read (into an input file) and write (into an output file) pointer, suitable only for one-pass algorithm. Forward (and higher level iterators) can do multi-pass algoritms. The most powerful random access iterators are modeled on built-in pointers.
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:1&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:2&#34;&gt;For example, if &lt;code&gt;advance&lt;/code&gt; is called with a pointer &lt;code&gt;const char*&lt;/code&gt; and an &lt;code&gt;int&lt;/code&gt;, since traits technique must apply to built-in types like &lt;code&gt;const char*&lt;/code&gt;, and there&amp;rsquo;s no way to nesting information inside pointers, thus the traits information for a type must be external to the type.
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:2&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:3&#34;&gt;By convention, traits are always implemented as structs, but that  structs are called &amp;ldquo;traits classes&amp;rdquo; - not joking.
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:3&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;</description>
    </item>
    
    <item>
      <title>Item-46 Define non-member function inside templates when type conversions are desired</title>
      <link>http://nianze.tk/2018/03/define-non-member-function-inside-templates-when-type-conversions-are-desired/</link>
      <pubDate>Tue, 13 Mar 2018 12:23:40 -0400</pubDate>
      
      <guid>http://nianze.tk/2018/03/define-non-member-function-inside-templates-when-type-conversions-are-desired/</guid>
      <description>&lt;p&gt;When writing a class template that offers functions related to the template that support implicit type conversions on all parameters, define those functions as friends inside the class template.

&lt;!-- toc --&gt;&lt;/p&gt;

&lt;p&gt;If we want  to do implicit type conversion on all arguments, we should use non-member functions (item 24). Now we want a templatized version of &lt;code&gt;Rational&lt;/code&gt; class to support the same mixed-mode arithmetic as shown in item 24, and the code could start like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;template&amp;lt;typename T&amp;gt;
class Rational {
public:
    Rational(const T&amp;amp; numerator = 0, // see item 20 for why params are passed by ref
             const T&amp;amp; denominator = 1);
    const T numerator() const;    // see item 28 for why return values are passed by value
    const T denominator() const;  // see item 3 for why return values are const
};

template&amp;lt;typename T&amp;gt;
const Rational&amp;lt;T&amp;gt; operator*(const Rational&amp;lt;T&amp;gt;&amp;amp; lhs,
                            const Rational&amp;lt;T&amp;gt;&amp;amp; rhs)
{...}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;However, this simple update to templatized version will not compile for following code:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;Rational&amp;lt;int&amp;gt; oneHalf(1, 2);
Rational&amp;lt;int&amp;gt; result = oneHalf * 2;  // error! won&#39;t compile
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The problem here is that &lt;strong&gt;implicit type conversion functions are &lt;em&gt;never&lt;/em&gt; considered during template argument deduction&lt;/strong&gt;. This means it is impossible for the compilers to convert the second parameter &lt;code&gt;2&lt;/code&gt; into a &lt;code&gt;Rational&amp;lt;int&amp;gt;&lt;/code&gt; using non-explicit constructor, so compilers can&amp;rsquo;t figure out what &lt;code&gt;T&lt;/code&gt; is for this function template named &lt;code&gt;operator*&lt;/code&gt; taking two parameters of type &lt;code&gt;Rational&amp;lt;T&amp;gt;&lt;/code&gt;, can&amp;rsquo;t deduce parameter types for this function templates, and thus can&amp;rsquo;t instantiate the appropriate functions. In the end, the function we want to call fails to be declared, before we could apply implicit type conversions during a later function call.&lt;/p&gt;

&lt;h1 id=&#34;solve-the-compiling-issue&#34;&gt;Solve the compiling issue&lt;/h1&gt;

&lt;p&gt;How to declare the &lt;code&gt;operator*&lt;/code&gt; properly? Notice that class templates don&amp;rsquo;t depend on template argument deduction (this process only applies to function templates), so &lt;code&gt;T&lt;/code&gt; is always known at the time the class &lt;code&gt;Rational&amp;lt;T&amp;gt;&lt;/code&gt; is instantiated. Combine this knowledge with another fact that a &lt;code&gt;friend&lt;/code&gt; declaration in a template class refers to a specific &lt;em&gt;function&lt;/em&gt; (not a function &lt;em&gt;template&lt;/em&gt;), so as part of the class instantiation process, the friend function will be automatically declared. Taking advantage of these 2 points, we could update the code to a new version&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:1&#34;&gt;&lt;a href=&#34;#fn:1&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;template&amp;lt;typename T&amp;gt;
class Rational {
public:
    ...
    friend  // declare operator* function
    const Rational operator*(const Rational&amp;amp; lhs, 
                             const Rational&amp;amp; rhs);
};
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;template&amp;lt;typename T&amp;gt;  // define operator* function
const Rational&amp;lt;T&amp;gt; operator*(const Rational&amp;lt;T&amp;gt;&amp;amp; lhs,  
                            const Rational&amp;lt;T&amp;gt;&amp;amp; rhs)
{...}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;When the &lt;code&gt;oneHalf&lt;/code&gt; is declared to be of type &lt;code&gt;Rational&amp;lt;int&amp;gt;&lt;/code&gt;, the class &lt;code&gt;Rational&amp;lt;int&amp;gt;&lt;/code&gt; is instantiated, and the friend function &lt;code&gt;operator*&lt;/code&gt; that takes &lt;code&gt;Rational&amp;lt;int&amp;gt;&lt;/code&gt; parameters is then declared automatically. As a declared function, compilers can use implicit conversion functions (such as &lt;code&gt;Rational&lt;/code&gt;&amp;rsquo;s non-explicit constructor) when calling it, making the mixed-mode call compile.&lt;/p&gt;

&lt;h1 id=&#34;solve-the-linking-issue&#34;&gt;Solve the linking issue&lt;/h1&gt;

&lt;p&gt;Yes, the code compiles. Yet it won&amp;rsquo;t link.&lt;/p&gt;

&lt;p&gt;This time, the problem is that the target function &lt;code&gt;operator*&lt;/code&gt; is only &lt;em&gt;declared&lt;/em&gt; inside &lt;code&gt;Rational&lt;/code&gt;, not &lt;em&gt;defined&lt;/em&gt; there. Indeed, the &lt;code&gt;operator*&lt;/code&gt; template outside the class is intended to provide that definition, but things don&amp;rsquo;t work this way, and linkers can&amp;rsquo;t find the definition.&lt;/p&gt;

&lt;p&gt;To solve it, the simplest thing is to put the function body into its declaration:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;template&amp;lt;typename T&amp;gt;
class Rational {
public:
    ...
    friend 
    const Rational operator*(const Rational&amp;amp; lhs, 
                             const Rational&amp;amp; rhs)
    {
        return Rational(lhs.numerator() * rhs.numerator(),
                        lhs.denominator() * rhs.denominator()); // same impl as item 24
    }

};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This works as intended: mixed-mode calls to &lt;code&gt;operator*&lt;/code&gt; now compiles, link, and run.&lt;/p&gt;

&lt;p&gt;This design is, in some sense, kind of unconventional, because the use of friendship has nothing to do with a need to access non-public parts of the class. We declared it as &lt;code&gt;friend&lt;/code&gt; because it is the only choise we have:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;to make type conversions possible on all arguments, we need a non-member function (item 24)&lt;/li&gt;
&lt;li&gt;to have the proper function automatically instantiated, we need to declare the function inside the class&lt;/li&gt;
&lt;li&gt;the only way to declare a non-member function inside a class is to make it a friend&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;have-the-friend-call-a-helper&#34;&gt;Have the friend call a helper&lt;/h1&gt;

&lt;p&gt;Such functions as &lt;code&gt;operator*&lt;/code&gt; defined inside a class are implicitly declared &lt;code&gt;inline&lt;/code&gt; (item 30), so we may minimize the impact of such &lt;code&gt;inline&lt;/code&gt; declarations by having &lt;code&gt;operator*&lt;/code&gt; do nothing but call a helper function defined outside of the class, especially when the function body is complex.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;template&amp;lt;typename T&amp;gt; class Raional;  // declare Rational template

template&amp;lt;typename T&amp;gt;  // helper template
const Rational&amp;lt;T&amp;gt; doMultiply(const Rational&amp;lt;T&amp;gt;&amp;amp; lhs,
                             const Rational&amp;lt;T&amp;gt;&amp;amp; rhs); 
template&amp;lt;typename T&amp;gt;
class Rational {
public:
    ...
    friend // have friend call helper
    const Rational operator*(const Rational&amp;amp; lhs, 
                             const Rational&amp;amp; rhs)
    { return doMultiply(lhs, rhs); }
    ...
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Many compilers force us to put all template definitions in header files, so we may need to define &lt;code&gt;doMultiply&lt;/code&gt; in the header as well:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;template&amp;lt;typename T&amp;gt; 
const Rational&amp;lt;T&amp;gt; doMultiply(const Rational&amp;lt;T&amp;gt;&amp;amp; lhs,
                             const Rational&amp;lt;T&amp;gt;&amp;amp; rhs)
{
    return Rational&amp;lt;T&amp;gt;(lhs.numerator() * rhs.numerator(),
                       lhs.denominator() * rhs.denominator());
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here, &lt;code&gt;doMultiply&lt;/code&gt; is a template, so it won&amp;rsquo;t support mixed-mode multiplication. The workflow is like this:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;The friend function &lt;code&gt;operator*&lt;/code&gt; supports mixed-mode operations and is in charge of necessary type conversions, ending with two &lt;code&gt;Rational&lt;/code&gt; objects passed to &lt;code&gt;doMultiply&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;These two objects are feed to an appropriate instantiation of the &lt;code&gt;doMultiply&lt;/code&gt; helper &lt;em&gt;template&lt;/em&gt;, which then do the actual multiplication&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;footnotes&#34;&gt;

&lt;hr /&gt;

&lt;ol&gt;
&lt;li id=&#34;fn:1&#34;&gt;It is worth to know the syntax used to decalre &lt;code&gt;operator*&lt;/code&gt; inside &lt;code&gt;Rational&lt;/code&gt;. Inside a class template, the name of the template can be used as shorthand for the template and its parameters, so inside &lt;code&gt;Rational&amp;lt;T&amp;gt;&lt;/code&gt;, we can write &lt;code&gt;Rational&lt;/code&gt; instead of &lt;code&gt;Rational&amp;lt;T&amp;gt;&lt;/code&gt;. It will be the same effect if we declare &lt;code&gt;operator*&lt;/code&gt; inside &lt;code&gt;Rational&amp;lt;T&amp;gt;&lt;/code&gt; like this: &lt;code&gt;friend const Rational&amp;lt;T&amp;gt; operator*(const Rational&amp;lt;T&amp;gt;&amp;amp; lhs,  const Rational&amp;lt;T&amp;gt;&amp;amp; rhs)&lt;/code&gt;.
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:1&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;</description>
    </item>
    
    <item>
      <title>Item-45 Use member function templates to accept all compatible types</title>
      <link>http://nianze.tk/2018/03/use-member-function-templates-to-accept-all-compatible-types/</link>
      <pubDate>Mon, 12 Mar 2018 20:14:47 -0400</pubDate>
      
      <guid>http://nianze.tk/2018/03/use-member-function-templates-to-accept-all-compatible-types/</guid>
      <description>&lt;p&gt;In order to implicitly convert all compatible types for a template class, we neet not a constructor &lt;em&gt;function&lt;/em&gt; but a constructor &lt;em&gt;template&lt;/em&gt; - &lt;em&gt;member functoin templates&lt;/em&gt; that generate member functions of a class.
&lt;/p&gt;

&lt;p&gt;Implicit conversion is a big convenient advantage offered by pointers: derived class pointers convert into base class pointers implicitly, pointers to non-&lt;code&gt;const&lt;/code&gt; objects convert into pointers to &lt;code&gt;const&lt;/code&gt; implicitly, etc. For a three-level hierarchy, following code makes perfect sense:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class Top {...};
class Middle: public Top {...};
class Bottom: public Middle {...};
Top *pt1 = new Middle;  // convert Middle* -&amp;gt; Top*
Top *pt2 = new Bottom;  // convert Bottom* -&amp;gt; Top*
const Top *pct = pt1;   // convert Top* -&amp;gt; const Top*
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In the world of template, we&amp;rsquo;d really like to emulate such conversions for our user-defined smart pointer classes:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;template&amp;lt;typename T&amp;gt;
class SmartPtr {
public:
    explicit SmartPtr(T *realPtr) // initialized by built-in pointers
    ...
};

SmartPtr&amp;lt;Top&amp;gt; pt1 = SmartPtr&amp;lt;Middle&amp;gt;(new Middle);  // convert SmartPtr&amp;lt;Middle&amp;gt; -&amp;gt; SmartPtr&amp;lt;Top&amp;gt;
SmartPtr&amp;lt;Top&amp;gt; pt2 = SmartPtr&amp;lt;Bottom&amp;gt;(new Bottom);  // convert SmartPtr&amp;lt;Bottom&amp;gt; -&amp;gt; SmartPtr&amp;lt;Top&amp;gt;
SmartPtr&amp;lt;const Top&amp;gt; pct = pt1;  // convert SmartPtr&amp;lt;Top&amp;gt; -&amp;gt; SmartPtr&amp;lt;const Top&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;However, there&amp;rsquo;s no inherent relationship among different instantiations of the same template, so compilers view &lt;code&gt;SmartPtr&amp;lt;Middle&amp;gt;&lt;/code&gt; and &lt;code&gt;SmartPtr&amp;lt;Top&amp;gt;&lt;/code&gt; as completely different classes. We need to write smart pointer constructors that is not only able to construct &lt;code&gt;SmartPtr&amp;lt;Top&amp;gt;&lt;/code&gt; from &lt;code&gt;SmartPtr&amp;lt;Middle&amp;gt;&lt;/code&gt;, but also capable to convert any compatible types in the hierarchy (we may extend the hierarchy in the future and add &lt;code&gt;class BelowBottom: public Bottom&lt;/code&gt;). In principle, such constructors are countless.&lt;/p&gt;

&lt;p&gt;Considering the fact that a template can be instantiated to generate an unlimited number of functions, what we need here is not a constructor &lt;em&gt;function&lt;/em&gt;, but a constructor &lt;em&gt;template&lt;/em&gt;, the &lt;em&gt;member function templates&lt;/em&gt; (also known as &lt;em&gt;member templates&lt;/em&gt;) that generate member functions of a class:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;template&amp;lt;typename T&amp;gt;
class SmartPtr {
public:
    template&amp;lt;typename U&amp;gt;  // member template for a &amp;quot;generalized copy constructor&amp;quot;
    SmartPtr(const SmartPtr&amp;lt;U&amp;gt;&amp;amp; other);  // not declared as &amp;quot;explicit&amp;quot; for implicit conversion
    ...
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Constructors like this - ones that create one object from anothe object whose type is a different instantiation of the same template (e.g., create a &lt;code&gt;SmartPtr&amp;lt;T&amp;gt;&lt;/code&gt; from a &lt;code&gt;SmartPtr&amp;lt;U&amp;gt;&lt;/code&gt;) - are known as &lt;em&gt;generalized copy constructors&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;However, this member template will generate more member functions than we need: as declared, it is possible to create a &lt;code&gt;SmartPtr&amp;lt;Bottom&amp;gt;&lt;/code&gt; from a &lt;code&gt;SmartPtr&amp;lt;Top&amp;gt;&lt;/code&gt;, which is contrary to the meaning of public inheritance (item 32). We need to restrict the conversions to those we want:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;template&amp;lt;typename T&amp;gt;
class SmartPtr {
public:
    template&amp;lt;typename U&amp;gt;
    SmartPtr(const SmartPtr&amp;lt;U&amp;gt;&amp;amp; other)  // initialize this held ptr with other&#39;s held ptr
    : heldPtr(other.get()) {...}
    T* get() const { return heldPtr; }
    ...
private:         
    T *heldPtr; // built-in ptr held by the smartPtr
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Since we initialize &lt;code&gt;SmartPtr&amp;lt;T&amp;gt;&lt;/code&gt;&amp;rsquo;s data member of type &lt;code&gt;T*&lt;/code&gt; with the pointer of type &lt;code&gt;U*&lt;/code&gt; held by &lt;code&gt;SmartPtr&amp;lt;U&amp;gt;&lt;/code&gt;, the code above will compile only if there is an implicit conversion from a &lt;code&gt;U*&lt;/code&gt; pointer to a &lt;code&gt;T*&lt;/code&gt; pointer, and this is exactly what we want.&lt;/p&gt;

&lt;p&gt;Apart from constructors, we can also apply member function tmeplates to assignment. A good example is from TR1&amp;rsquo;s &lt;code&gt;shared_ptr&lt;/code&gt; (item 13):&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;template&amp;lt;class T&amp;gt; class shared_ptr {
public:
    shared_ptr(shared_ptr const&amp;amp; r);  // &amp;quot;normal&amp;quot; copy constructor
    template&amp;lt;class Y&amp;gt;
      explicit shared_ptr(Y * p);  // generalized copy constructor from any compatible built-in pointer
    template&amp;lt;class Y&amp;gt;
      shared_ptr(shared_ptr&amp;lt;Y&amp;gt; const&amp;amp; r);  // from compatible shared_ptr
    template&amp;lt;class Y&amp;gt;
      explicit shared_ptr(weak_ptr&amp;lt;Y&amp;gt; const&amp;amp; r);  // from compatible weak_ptr
    template&amp;lt;class Y&amp;gt;
      explicit shared_ptr(auto_ptr&amp;lt;Y&amp;gt;&amp;amp; r);  // from compatible auto_ptr

    shared_ptr&amp;amp; operator=(shared_ptr const&amp;amp; r); // &amp;quot;normal&amp;quot; copy assignment
    template&amp;lt;class Y&amp;gt;
      shared_ptr&amp;amp; operator=(shared_ptr&amp;lt;Y&amp;gt; const&amp;amp; r);  // generalized copy assign from any compatible shared_ptr
    template&amp;lt;class Y&amp;gt;
      shared_ptr&amp;amp; operator=(auto_ptr&amp;lt;Y&amp;gt;&amp;amp; r);  // assign from any compatible auto_ptr
    ...
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note that&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;the generalized copy constructor is not declared &lt;code&gt;explicit&lt;/code&gt; in order to support implicit conversion from one type of &lt;code&gt;shared_ptr&lt;/code&gt; to another.&lt;/li&gt;
&lt;li&gt;All other constructors are &lt;code&gt;explicit&lt;/code&gt;, so &lt;em&gt;implicit&lt;/em&gt; conversion from a built-in pointer or other smart pointer type is not permitted (explicit conversion via a cast is okey).&lt;/li&gt;
&lt;li&gt;&lt;code&gt;auto_ptr&lt;/code&gt; passed to &lt;code&gt;tr1::shared_ptr&lt;/code&gt; constructors and assignment operators are not declared &lt;code&gt;const&lt;/code&gt;, because &lt;code&gt;auto_ptr&lt;/code&gt; will be modifies when they&amp;rsquo;re copyed (item 13).&lt;/li&gt;
&lt;li&gt;both a generalized copy constructor (and assignment) as well as the &amp;ldquo;normal&amp;rdquo; copy constructor (and copy assignment) are declared, because declaring a generalized copy constructor (a member template) in a class doesn&amp;rsquo;t keep compilers from generating their own copy constructor (a non-template version), so if we want to control all aspect of copy construction, we declare both.&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>Item-44 Factor parameter-independent code out of templates</title>
      <link>http://nianze.tk/2018/03/factor-parameter-independent-code-out-of-templates/</link>
      <pubDate>Sat, 10 Mar 2018 20:24:42 -0500</pubDate>
      
      <guid>http://nianze.tk/2018/03/factor-parameter-independent-code-out-of-templates/</guid>
      <description>&lt;p&gt;Templates generate multiple classes and multiple functions, so any template code not dependent on a template parameter (either non-type template parameters or type parameters) causes bloat: eliminate bloat due to non-type template parameters by replacing template parameters with function parameters or class data members; reduce bloat caused from type parameters by sharing implementations for instantiation types with identical binary representations.

&lt;!-- toc --&gt;&lt;/p&gt;

&lt;p&gt;When writing templates, since there&amp;rsquo;s only one copy of the template source code, we have to analyze it carefully to avoid the implicit replication that may take place when a template is instantiated multiple times.&lt;/p&gt;

&lt;h1 id=&#34;bloat-due-to-non-type-template-parameters&#34;&gt;Bloat due to non-type template parameters&lt;/h1&gt;

&lt;p&gt;For example, suppose we&amp;rsquo;d like to write a template for fixed-size square matrices that support matrix inversion:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;template&amp;lt;typename T, std::size_t n&amp;gt;  // template for n*n matrices of obejcts of type T
class SquareMatrix{
pubic:
    void invert();  // invert the matrix in place
    ...
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This template takes a type parameter &lt;code&gt;T&lt;/code&gt; as well as a &lt;em&gt;non-type parameter&lt;/em&gt; &lt;code&gt;n&lt;/code&gt; of type &lt;code&gt;size_t&lt;/code&gt;. This example is actually a classic way for template-induced code bloat:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;SquareMatrix&amp;lt;double, 5&amp;gt; sm1;
sm1.invert();  // call SquareMatrix&amp;lt;double, 5&amp;gt;::invert
SquareMatrix&amp;lt;double, 10&amp;gt; sm2;
sm2.invert();  // call SquareMatrix&amp;lt;double, 10&amp;gt;::invert
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In the statements above, two copies of &lt;code&gt;invert&lt;/code&gt; will be instantiated, and these two version of &lt;code&gt;invert&lt;/code&gt; are character-for-character identical except for the use of 5 in one version and 10 in the other. To reduce the code bloat, we could redesign and call a parameterized function instead.&lt;/p&gt;

&lt;h2 id=&#34;replace-with-function-parameters&#34;&gt;Replace with function parameters&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;template&amp;lt;typename T&amp;gt;     // size-independent base class for square matrices
class SquareMatrixBase{  // all matrices holding a givin type of object will share a single base class with a single copy of this base class&#39;s version of invert
protected: 
    // intend only to be a way for derived classes to avoid code replication, so declared as protected instaend of public
    void invert(std::size_t matrixSize); // invert matrix of the given size
    ...
};

template&amp;lt;typename T, std::size_t n&amp;gt;
class SqureMatrix: private SquareMatrixBase&amp;lt;T&amp;gt; { // not a is-a relationship, using private inheritance only for base class implementation, item 39
private:
    using SquareMatrixBase&amp;lt;T&amp;gt;::invert;  // avoid hiding base version of invert, item 33
public:
    ...                                 // make inline call to base class version of invert:
    void invert() { this-&amp;gt;invert(n); }  // 1. it&#39;s implicit inline, so there&#39;s no addictional cost of calling it, item 30
    ...                                 // 2. use &amp;quot;this-&amp;gt;&amp;quot; so that function names in templatized base classes are revealed in derived classes, item 43
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This design addressed the issue of code bloat, but it also introduces a problem: &lt;code&gt;SquareMatrixBase::invert&lt;/code&gt; only knows the size of the data, but it does not know where the data for a particular matrix is, because only the derived class knows that. We could add another parameter to &lt;code&gt;SquareMatrixBase::invert&lt;/code&gt;, such as a pointer to the beginning of a chunk of memory that stores the matrix&amp;rsquo;s data.&lt;/p&gt;

&lt;p&gt;However, an alternative and possibly better solution will be to have &lt;code&gt;SquareMatrixBase&lt;/code&gt; store both a pointer to the memory for the matrix values, as well as the matrix size, so that any other functions asking for the matrix memory address or matrix size can be written in a address-independent-and-size-independent manner, and moved into &lt;code&gt;SquareMatrixBase&lt;/code&gt;.&lt;/p&gt;

&lt;h2 id=&#34;replace-with-class-data-members&#34;&gt;Replace with class data members&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;template&amp;lt;typename T&amp;gt;
class SquareMatrixBase {
protected:
    SquareMatrixBase(std::size_t n, T *pMem)  // store matrix size and a ptr to matrix values
    : size(n), pData(pMem) {}
    void setDataPtr(T *ptr) { pData = ptr; }  // reassign pData
    ...
private:
    std::size_t size;  // size of matrix
    T *pData;  // pointer to matrix values
};
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;template&amp;lt;typename T, std::size_t n&amp;gt;
class SquareMatrix: private SqureMatrixBase&amp;lt;T&amp;gt; {
public:
    SquareMatrix()  // send matrix size and data ptr to base class
    : SquareMatrixBase&amp;lt;T&amp;gt;(n, data) {} 
    ...
private:
    T data[n*n];
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Objects of such type have no need for dynamic memory allocation, but the objects could be very large. An alternative would be to put the data for each matrix on the heap:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;template&amp;lt;typename T, std::size_t n&amp;gt;
class SquareMatrix: private SqureMatrixBase&amp;lt;T&amp;gt; {
public:
    SquareMatrix()  
    : SquareMatrixBase&amp;lt;T&amp;gt;(n, 0),         // set base class ptr to null
      pData(new T[n*n])                  // allocate memory for matrix values and save a ptr to the memory
    { this-&amp;gt;setDataPtr(pData.get()); }   // give a copy of the ptr to the base class
    ...
private:
    boost::scoped_array&amp;lt;T&amp;gt; pData;  // see item 13 for info on boost::scoped_array
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;No matter where the matrix value data is stored, the result from a bloat point of view is that many &lt;code&gt;SquareMatrix&lt;/code&gt;&amp;rsquo;s member functions can be simple inline calls to base class versions that are shared with all other matrices holding the same type of data, regardless of their size.&lt;/p&gt;

&lt;h2 id=&#34;efficiency-concerns&#34;&gt;Efficiency concerns&lt;/h2&gt;

&lt;p&gt;In terms of efficiency, it is possible that the version of &lt;code&gt;invert&lt;/code&gt; with the matrix sizes hardwired into them generates better code than the shared version whose size is passed as a function parameter or is stored in the object: in the size-specific versions, the sizes would be compile-time constants, hence eligible for optimizations such as constant propagation (they&amp;rsquo;ll be folded into the generated instructions as imeediate operands), which can&amp;rsquo;t be done in the size-independent version.&lt;/p&gt;

&lt;p&gt;On the other side, the size-independent version decreases the size of executable by having only one version of &lt;code&gt;invert&lt;/code&gt; for multiple matrix sizes, and this could reduce the program&amp;rsquo;s working set size and improve locality of reference in the instruction cache, which may in term compensating for any lost optimizations in size-specific versions of &lt;code&gt;invert&lt;/code&gt;. The only way to tell which version is better one is to try them both and observe the behavior on the particular platform and on representative data sets.&lt;/p&gt;

&lt;h2 id=&#34;other-trade-offs&#34;&gt;Other trade-offs&lt;/h2&gt;

&lt;p&gt;Speaking of size of objects, we should observe that there&amp;rsquo;s an extra size of a pointer in each &lt;code&gt;SquareMatrix&lt;/code&gt; object, because, as the derived class, &lt;code&gt;SquareMatrix&lt;/code&gt; could get to the data by alternative designs such as having the base class store a &lt;code&gt;protected&lt;/code&gt; pointer to the matrix data. However, this new design also has some disadvantages:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;it may lead to the loss of encapsulation described in item 22&lt;/li&gt;
&lt;li&gt;it may also lead to resource management complications: since derived class may either dynamically alloacate the matrix data, or physically store the data inside the derived class object, if we only let the base class store a pointer to that data, it is hard for base class to determine whether the pointer should be deleted or not.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;At some point, a little code replication seems like a mercy to keep away from complication.&lt;/p&gt;

&lt;h1 id=&#34;bloat-due-to-type-parameters&#34;&gt;Bloat due to type parameters&lt;/h1&gt;

&lt;p&gt;On many platforms, &lt;code&gt;int&lt;/code&gt; and &lt;code&gt;long&lt;/code&gt; have the same binary representation, so the member functions for &lt;code&gt;vector&amp;lt;int&amp;gt;&lt;/code&gt; and &lt;code&gt;vector&amp;lt;long&amp;gt;&lt;/code&gt; would likely be identical. Some linkers will merge identical function implementations, but some will not, and that means that some templates instantiated on both &lt;code&gt;int&lt;/code&gt; and &lt;code&gt;long&lt;/code&gt; could cause code bloat in some environments.&lt;/p&gt;

&lt;p&gt;Similarly, on most platforms, all pointer types have the same binary representation, so templates holding pointer types (e.g., &lt;code&gt;list&amp;lt;int*&amp;gt;&lt;/code&gt;, &lt;code&gt;list&amp;lt;const int*&amp;gt;&lt;/code&gt;, &lt;code&gt;list&amp;lt;SquareMatrix&amp;lt;long, 3&amp;gt;*&amp;gt;&lt;/code&gt;, etc.) should be able to use a single underlying implementation for each member function. Typically, this is achieved by implementing member functions that work with strongly typed pointers (i.e., &lt;code&gt;T*&lt;/code&gt; pointers) by having them call functions that work with untyped pointers (i.e., &lt;code&gt;void*&lt;/code&gt; pointers), which is how some of standart C++ library do for templates like &lt;code&gt;vector&lt;/code&gt;, &lt;code&gt;deque&lt;/code&gt;, and &lt;code&gt;list&lt;/code&gt;.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Item-43 Know how to access names in templatized base classes</title>
      <link>http://nianze.tk/2018/03/know-how-to-access-names-in-templatized-base-classes/</link>
      <pubDate>Fri, 09 Mar 2018 21:48:26 -0500</pubDate>
      
      <guid>http://nianze.tk/2018/03/know-how-to-access-names-in-templatized-base-classes/</guid>
      <description>&lt;p&gt;In derived class templates, refer to names in base class templates via a &lt;code&gt;this-&amp;gt;&lt;/code&gt; prefix, via &lt;code&gt;using&lt;/code&gt; declarations, or via an explicit base class qualification.

&lt;!-- toc --&gt;&lt;/p&gt;

&lt;h1 id=&#34;case-study&#34;&gt;Case Study&lt;/h1&gt;

&lt;p&gt;Sometimes when we cross from Object-oriented C++ to Template C++ (item 1), inheritance seem to stop working. For example, we&amp;rsquo;d like to log some information for the &lt;code&gt;sendMsg&lt;/code&gt; function in base class &lt;code&gt;MsgSender&lt;/code&gt;, so we make following derived class &lt;code&gt;LoggingMsgSender&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class CompanyA {
public:
    ...
    void sendClearText(const std::string&amp;amp; msg);
    ...
};

class CompanyB {
public:
    ...
    void sendClearText(const std::string&amp;amp; msg);
    ...
}

class MsgInfo {...};  // class for holding information used to create msg

template&amp;lt;typename Company&amp;gt;
class MsgSender {
public:
    ...  // ctor, dtor, etc.
    void sendClear(const MsgInfo&amp;amp; info)
    {
        std::string msg;
        // create msg from info;
        Company c;
        c.sendClearText(msg);
    }
    ...
};

template&amp;lt;typename Company&amp;gt;
class LoggingMsgSender: public MsgSender&amp;lt;Company&amp;gt; {
public:
    ... // ctor, dtor, etc.
    void sendClearMsg(const MsgInfo&amp;amp; info)
    {
        // write &amp;quot;before sending&amp;quot; info to the log
        sendClear(info);  // call base class function -&amp;gt; not compile
        // write &amp;quot;after sending&amp;quot; info to the log
    }
    ...
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note that the message-sending function in the derived class has a different name &lt;code&gt;sendClearMsg&lt;/code&gt; from its counterpart &lt;code&gt;sendClear&lt;/code&gt; in the base class: this is good design for two reasongs:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;it avoids the issue of hiding inherited names (item 33)&lt;/li&gt;
&lt;li&gt;it side-steps the problems inherent in redefining an inherited non-virtual function (item 36)&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;However, the code above will not compile, because, by default, compilers will not look for the function &lt;code&gt;sendClear&lt;/code&gt; in the base class. The behavior seems to break our expected inheritance concept from Object-oriented world, but compilers do this for a good reason: they will not know what the base class &lt;code&gt;MsgSender&amp;lt;Company&amp;gt;&lt;/code&gt; really looks like until when &lt;code&gt;LoggingMsgSender&lt;/code&gt; is instantiated, so it is possible that there&amp;rsquo;s a special template parameter class &lt;code&gt;CompanyC&lt;/code&gt; that, instead of providing function &lt;code&gt;sendClearText&lt;/code&gt;, only supports &lt;code&gt;sendEncrypted&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class CompanyZ {  // this class offers no sendClearText Fucntion
public:
    ...
    void sendEncrypted(const std::string&amp;amp; msg);
    ...
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In this case, &lt;code&gt;sendClear&lt;/code&gt; function in &lt;code&gt;MsgSender&lt;/code&gt; base class will make no sense. To rectify the problem, we can create a specialized version of &lt;code&gt;MsgSender&lt;/code&gt; for &lt;code&gt;CompanyZ&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;template&amp;lt;&amp;gt;  // signifies this is neither a template nor a standalone class
class MsgSender&amp;lt;CompanyZ&amp;gt; { // but a total specialization of MsgSender
public:
    ... // the same as the general template, except sendCleartext is omitted
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This syntax is known as a &lt;em&gt;total template specialization&lt;/em&gt;: the template &lt;code&gt;MsgSender&lt;/code&gt; is specialized for the type &lt;code&gt;CompanyZ&lt;/code&gt;, and the specialization is &lt;em&gt;total&lt;/em&gt; - once the type parameter has been defined to be &lt;code&gt;CompanyZ&lt;/code&gt;, no other aspect of the template&amp;rsquo;s parameters can vary.&lt;/p&gt;

&lt;p&gt;Since base class templates may be specialized and that such specializations may not offer the same interface as the general template, C++ generally  refuses to look in templatized base classes for inherited names. That&amp;rsquo;s why we say inheritance stops working in Template C++ wolrd.&lt;/p&gt;

&lt;p&gt;To force C++ to look in templatized base classes, there are three ways:&lt;/p&gt;

&lt;h2 id=&#34;1-call-with-this&#34;&gt;1. Call with &amp;ldquo;this-&amp;gt;&amp;rdquo;&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;template&amp;lt;typename Company&amp;gt;
class LoggingMsgSender: public MsgSender&amp;lt;Company&amp;gt; {
public:
    ... // ctor, dtor, etc.
    void sendClearMsg(const MsgInfo&amp;amp; info)
    {
        // write &amp;quot;before sending&amp;quot; info to the log
        this-&amp;gt;sendClear(info);  // assumes that sendClear will be inherited
        // write &amp;quot;after sending&amp;quot; info to the log
    }
    ...
};
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;2-employ-a-using-declaration&#34;&gt;2. Employ a &amp;ldquo;using&amp;rdquo; declaration&lt;/h2&gt;

&lt;p&gt;This is the same trick we use in item 33, which explains how &lt;code&gt;using&lt;/code&gt; declaration brings hidden base class names into a derived class&amp;rsquo;s scope&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:1&#34;&gt;&lt;a href=&#34;#fn:1&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;template&amp;lt;typename Company&amp;gt;
class LoggingMsgSender: public MsgSender&amp;lt;Company&amp;gt; {
public:
    using MsgSender&amp;lt;Company&amp;gt;::sendClear;  // tell compilers to assume that sendClear is in the base class
    ... // ctor, dtor, etc.
    void sendClearMsg(const MsgInfo&amp;amp; info)
    {
        // write &amp;quot;before sending&amp;quot; info to the log
        sendClear(info);  // assumes that sendClear will be inherited
        // write &amp;quot;after sending&amp;quot; info to the log
    }
    ...
};
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;3-explicitly-specify-the-base-class-qualification&#34;&gt;3. Explicitly specify the base class qualification&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;template&amp;lt;typename Company&amp;gt;
class LoggingMsgSender: public MsgSender&amp;lt;Company&amp;gt; {
public:
    ... // ctor, dtor, etc.
    void sendClearMsg(const MsgInfo&amp;amp; info)
    {
        // write &amp;quot;before sending&amp;quot; info to the log
        MsgSender&amp;lt;Company&amp;gt;::sendClear(info);  // assumes that sendClear will be inherited
        // write &amp;quot;after sending&amp;quot; info to the log
    }
    ...
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This approach is less desirable, because if the function being called is virtual, explicit qualification turns off the virtual binding behavior.&lt;/p&gt;

&lt;h1 id=&#34;summary&#34;&gt;Summary&lt;/h1&gt;

&lt;p&gt;From a name visibility point of view, each of these approaches does the same thing: it promises  compilers that any subsequent specializations of the base class template will support the interface  offered by the general template. However, if the promise turns out to be unfounded, the subsequent compilation will still diagnose invalid references to base class members and reveal the truth:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;LoggingMsgSender&amp;lt;CompanyZ&amp;gt; zMsgSender;

MsgInfo msgData;
... // put info in msgData
zMsgSender.sendClearMsg(msgData);  // error! won&#39;t compile. Compilers know the base class MsgSender&amp;lt;CompanyZ&amp;gt; 
                                   // doesn&#39;t offer the sendClear function for this template specilization
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;Fundamentally, compilers will diagnose invalid references to base class members sooner (when derived class template definitions are parsed) or later (when templates are instantiated with specific template arguments). C++&amp;rsquo;s policy is to prefer early diagnoses, and that&amp;rsquo;s why it assumes it knows nothing about the contents of base classes when those classes are instantiated from templates.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class=&#34;footnotes&#34;&gt;

&lt;hr /&gt;

&lt;ol&gt;
&lt;li id=&#34;fn:1&#34;&gt;Note that there&amp;rsquo;s difference between the problem solved in this item from that in item 33: here, the problem is that compilers don&amp;rsquo;t search base class scopes unless we explicitly specify it; in item 33, it is due to the derived class names that hide base class names.
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:1&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;</description>
    </item>
    
    <item>
      <title>Item-42 Understand the two meanings of typename</title>
      <link>http://nianze.tk/2018/03/understand-the-two-meanings-of-typename/</link>
      <pubDate>Thu, 08 Mar 2018 19:19:28 -0500</pubDate>
      
      <guid>http://nianze.tk/2018/03/understand-the-two-meanings-of-typename/</guid>
      <description>&lt;p&gt;When declaring template parameters, both &lt;code&gt;class&lt;/code&gt; and &lt;code&gt;typename&lt;/code&gt; are interchangeable. When identifying nested dependent type names, use &lt;code&gt;typename&lt;/code&gt;, except in base class lists or as a base class identifier in a member initialization list.

&lt;!-- toc --&gt;&lt;/p&gt;

&lt;h1 id=&#34;in-template-parameter-declaration&#34;&gt;In template parameter declaration&lt;/h1&gt;

&lt;p&gt;In the template declarations such as below:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;template&amp;lt;class T&amp;gt; class Widget;  // uses &amp;quot;class&amp;quot;
template&amp;lt;typename T&amp;gt; class Widget;  // uses &amp;quot;typename&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;There&amp;rsquo;s no difference between these two declarations, though using &lt;code&gt;typename&lt;/code&gt; may be helpful to imply that the parameter need not be a class type. From C++&amp;rsquo;s point of view, &lt;code&gt;class&lt;/code&gt; and &lt;code&gt;typename&lt;/code&gt; means exactly the same in this case.&lt;/p&gt;

&lt;h1 id=&#34;nested-dependent-type&#34;&gt;Nested dependent type&lt;/h1&gt;

&lt;p&gt;Names in a template that are dependent on a template parameter are called &lt;code&gt;dependent names&lt;/code&gt;. When a dependent name is nested inside a class, we can call it a &lt;em&gt;nested dependent name&lt;/em&gt;. For example, considering following code, which actually won&amp;rsquo;t compile due to the lack of &lt;code&gt;typename&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;template&amp;lt;typename C&amp;gt;  // print 2nd element in container
void print2nd(const C&amp;amp; container)
{
    if (container.size() &amp;gt;= 2){
        C::const_iterator iter(container.begin()); // get iterator to 1st element
        ++iter;  // move iter to 2nd element
        int value = *iter;  // copy the 2nd element to an int
        std::cout &amp;lt;&amp;lt; value;  // print the int
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In this example, &lt;code&gt;C::const_iterator&lt;/code&gt; is not only a dependent name on the template parameter &lt;code&gt;C&lt;/code&gt;, but also a nested dependent name, or more specifically, a &lt;em&gt;nested dependent type name&lt;/em&gt; (a nested dependent name that refers to a type). As a comparason, local variable &lt;code&gt;value&lt;/code&gt; is of type int, independent of any template parameter, which is known as &lt;code&gt;non-dependent name&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;The reason why the code above doesn&amp;rsquo;t compile is that, without &lt;code&gt;typename&lt;/code&gt;, it is difficult to parse those nested dependent names. For example, if we make following declaration:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;template&amp;lt;typename C&amp;gt;
void print2nd(const C&amp;amp; container)
{
    C::const_iterator * x;
    ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;There are multiple possible ways to interprete this statement:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;We assume &lt;code&gt;C::const_iterator&lt;/code&gt; is a type, thus we&amp;rsquo;re declaring &lt;code&gt;x&lt;/code&gt; as a local variable that&amp;rsquo;s a pointer to a &lt;code&gt;C::const_iterator&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;We assume &lt;code&gt;C&lt;/code&gt; has a static member that happens to be named &lt;code&gt;const_iterator&lt;/code&gt;, and &lt;code&gt;x&lt;/code&gt; happens to be the name of a global variable, so this statement is a multiplication of &lt;code&gt;C::const_iterator&lt;/code&gt; by &lt;code&gt;x&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;To resolve this ambiguity, C++ rules that the parser should not assume a nested dependent name in a template as a &lt;em&gt;type&lt;/em&gt;, unless we explicitly specify it through &lt;code&gt;typename&lt;/code&gt; keyword. Thus, the valid code for the above example should be like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;template&amp;lt;typename C&amp;gt;  // print 2nd element in container
void print2nd(const C&amp;amp; container)
{
    if (container.size() &amp;gt;= 2){
        typename C::const_iterator iter(container.begin()); // get iterator to 1st element
        ...
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;real-world-usecase&#34;&gt;Real world usecase&lt;/h2&gt;

&lt;p&gt;In real code, it&amp;rsquo;s representative that sometimes &lt;code&gt;typename&lt;/code&gt; shows with another keyword &lt;code&gt;typedef&lt;/code&gt; to save some typing time:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;template&amp;lt;typename IterT&amp;gt;
void workWithIterator(IterT iter)
{
    typedef typename std::iterator_traits&amp;lt;IterT&amp;gt;::value_type value_type;
    value_type temp(*iter);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Basically, this statement is to declare a local variable &lt;code&gt;temp&lt;/code&gt; of the same type as what &lt;code&gt;IterT&lt;/code&gt; objects point to, and it initializes &lt;code&gt;temp&lt;/code&gt; with the object that &lt;code&gt;iter&lt;/code&gt; points to. Here, the standard traits class (item 47) is to represent the type of thing pointed to by objects of type &lt;code&gt;IterT&lt;/code&gt;. For example, if &lt;code&gt;IterT&lt;/code&gt; is &lt;code&gt;list&amp;lt;string&amp;gt;::iterator&lt;/code&gt;, then &lt;code&gt;temp&lt;/code&gt; is of type &lt;code&gt;string&lt;/code&gt;. Since &lt;code&gt;value_type&lt;/code&gt; is nested inside &lt;code&gt;iterator_traits&amp;lt;IterT&amp;gt;&lt;/code&gt;, and &lt;code&gt;IterT&lt;/code&gt; is a template parameter, we must precede it by &lt;code&gt;typename&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;It is also worth noting that &lt;code&gt;typename&lt;/code&gt; should be used to identify only nested dependent type names; other names shouldn&amp;rsquo;t have it:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;template&amp;lt;typename C&amp;gt;                  // typename allowed (class also allowed): template parameter declaration
void f(const C&amp;amp; container,            // typename not allowed: C is not a nested dependent type name
       typename C::iterator iter);    // typename required: iter is a nested dependent type name
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In summary, the general rule is: anytime we refer to a nested dependent type name in a template, we must immediately precede it by the word &lt;code&gt;typename&lt;/code&gt;, except for the following two cases:&lt;/p&gt;

&lt;h2 id=&#34;exception&#34;&gt;Exception&lt;/h2&gt;

&lt;p&gt;There are two exception cases where &lt;code&gt;typename&lt;/code&gt; must not precede nested dependent type names:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;in a list of base classes&lt;/li&gt;
&lt;li&gt;as a base class idenfifier in a member initialization list&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;For example:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;template&amp;lt;typename T&amp;gt;
class Derived: public Base&amp;lt;T&amp;gt;::Nested{  // case 1 - base class list: typename not allowd
public:
    explicit Derived(int x)            
    : Base&amp;lt;T&amp;gt;::Nested(x)    // case 2 - base class identifier in mem init. list: typename not allowd
    {
        typename Base&amp;lt;T&amp;gt;::Nested temp; // typename required: nested dependent type not in the two exception cases
        ...
    }
    ...
};
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;P.S.: Actually, enforcement of the rules surrounding &lt;code&gt;typename&lt;/code&gt; vary from compiler to compiler. Some compilers accept code where &lt;code&gt;typename&lt;/code&gt; is required but missing; some accept code where &lt;code&gt;typename&lt;/code&gt; is present but not allowd. This means the interaction of &lt;code&gt;typename&lt;/code&gt; and nested dependent type names can lead to some portability headaches.&lt;/p&gt;
&lt;/blockquote&gt;</description>
    </item>
    
    <item>
      <title>Item-41 Understand inplicit interfaces and compile time polymorphism</title>
      <link>http://nianze.tk/2018/03/understand-inplicit-interfaces-and-compile-time-polymorphism/</link>
      <pubDate>Wed, 07 Mar 2018 14:21:33 -0500</pubDate>
      
      <guid>http://nianze.tk/2018/03/understand-inplicit-interfaces-and-compile-time-polymorphism/</guid>
      <description>&lt;p&gt;Classes support explicit interfaces based on function signatures, as well as runtime polymorphism through virtual functions; templates support implicit interfaces based on valid expressions, as well as compile-time polymorphism through template instantiation and function overloading resolution.

&lt;!-- toc --&gt;&lt;/p&gt;

&lt;h1 id=&#34;interface-and-polymorphism-in-oop&#34;&gt;Interface and Polymorphism in OOP&lt;/h1&gt;

&lt;p&gt;The world of object-oriented programming revolves around &lt;em&gt;explicit&lt;/em&gt; interfaces and &lt;em&gt;runtime&lt;/em&gt; polymorphism. For example:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class Widget {
public:
    Widget();
    virtual ~Widget();

    virtual std::size_t size() const;
    virtual void normalize();
    void swap(Widget&amp;amp; other);  // see item 25
    ...
};
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;void doProcessing(Widget&amp;amp; w)
{
    if (w.size() &amp;gt; 10 &amp;amp;&amp;amp; w != someNastyWidget){
        Widget temp(w);
        temp.normalize();
        temp.swap(w);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Regarding the &lt;code&gt;w&lt;/code&gt; in &lt;code&gt;doProcessing&lt;/code&gt;, we could conclude:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;em&gt;explicit interface&lt;/em&gt;: &lt;code&gt;w&lt;/code&gt; is of type &lt;code&gt;Widget&lt;/code&gt;, so it must support the &lt;code&gt;Widget&lt;/code&gt; interface, which is an &lt;em&gt;explicit interface&lt;/em&gt;, because it is explicitly visible in the source code (e.g., the .h file for &lt;code&gt;Widget&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;&lt;em&gt;runtime polymorphism&lt;/em&gt;: &lt;code&gt;w&lt;/code&gt;&amp;rsquo;s call to some of its virtual member functions exhibits &lt;em&gt;runtime polymorphism&lt;/em&gt;, because the specific function to call will be determined at runtime based on &lt;code&gt;w&lt;/code&gt;&amp;rsquo;s dynamic type (item 37)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Specifically, the explicit interface of &lt;code&gt;Widget&lt;/code&gt; consists of its function signatures: a constructor, a destructor, and the functions &lt;code&gt;size&lt;/code&gt;, &lt;code&gt;normalize&lt;/code&gt;, and &lt;code&gt;swap&lt;/code&gt;, along with the parameter types, return types, and constnesses of these functions, as well as compilter-generated copy constructor and copy assignment operator (item 5). Potentially, it could also include typedefs, and data members.&lt;/p&gt;

&lt;h1 id=&#34;interface-and-polymorphism-in-templates-and-generic-programming&#34;&gt;Interface and Polymorphism in templates and generic programming&lt;/h1&gt;

&lt;p&gt;In the world of templates and generic programming, the explicit interfaces and runtime polymorphism continue to exist, but we also have to consider &lt;em&gt;implicit interfaces&lt;/em&gt; and &lt;em&gt;compile-time polymorphism&lt;/em&gt;. As a comparison, let&amp;rsquo;s take a look at the template version of &lt;code&gt;doProcessing&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;template&amp;lt;typename T&amp;gt;
void doProcessing(T&amp;amp; w)
{
    if (w.size() &amp;gt; 10 &amp;amp;&amp;amp; w != someNasyWidget) {
        T temp(w);
        temp.normalize();
        temp.swap(w);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;For &lt;code&gt;w&lt;/code&gt; in the template &lt;code&gt;doProcessing&lt;/code&gt;:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;em&gt;implicit interface&lt;/em&gt;: &lt;code&gt;w&lt;/code&gt; must support all the operations performed on it, but there is no explicit function signatures to follow. Rather, there&amp;rsquo;s an implicit interface consists of valid &lt;em&gt;expressions&lt;/em&gt; that set constraints on &lt;code&gt;w&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;&lt;em&gt;compile-time polymorphism&lt;/em&gt;: &lt;code&gt;w&lt;/code&gt; is one of the parameters in &lt;code&gt;operator&amp;gt;&lt;/code&gt; and &lt;code&gt;operator!=&lt;/code&gt;, which may involve instantiating function templates with different template parameters, leading to different functions being called during compilation. This is similar to the process to determine which of a set of overloaded functions should be called during compilation.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Specifically, let&amp;rsquo;s take a look those constrains on &lt;code&gt;w&lt;/code&gt;&amp;rsquo;s type &lt;code&gt;T&lt;/code&gt; in the implicit interface:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;whatever &lt;code&gt;w.size() &amp;gt; 10 &amp;amp;&amp;amp; w != someNasyWidget&lt;/code&gt; yields, the expression as a whole must be compatible with &lt;code&gt;bool&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;calls to the copy constructor, to &lt;code&gt;normalize&lt;/code&gt;, and to &lt;code&gt;swap&lt;/code&gt; must be valid for objects of type &lt;code&gt;T&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;However, inside the expression &lt;code&gt;w.size() &amp;gt; 10 &amp;amp;&amp;amp; w != someNasyWidget&lt;/code&gt;, constraints on compatibal type regarding the functions &lt;code&gt;size&lt;/code&gt;, &lt;code&gt;operator&amp;gt;&lt;/code&gt;, &lt;code&gt;operator&amp;amp;&amp;amp;&lt;/code&gt;, or &lt;code&gt;operator!=&lt;/code&gt; are pretty flexible, thanks to the possibility of operator overloading and implicit conversion:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;there&amp;rsquo;s no requirement that &lt;code&gt;size&lt;/code&gt; returns an integral value - it may simply return an object of some type &lt;code&gt;X&lt;/code&gt; such that there is an &lt;code&gt;operator&amp;gt;&lt;/code&gt; that can be called with an object of type &lt;code&gt;X&lt;/code&gt; and an &lt;code&gt;int&lt;/code&gt; (10 is of type int)&lt;/li&gt;
&lt;li&gt;there&amp;rsquo;s no requirement that &lt;code&gt;operator&amp;gt;&lt;/code&gt; take a parameter of type &lt;code&gt;X&lt;/code&gt; - it may take a parameter of type &lt;code&gt;Y&lt;/code&gt;, as long as there were an implicit conversion from objects of type X to objects of type &lt;code&gt;Y&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;there&amp;rsquo;s no requirement that &lt;code&gt;T&lt;/code&gt; support &lt;code&gt;operator!=&lt;/code&gt; - it would be just as acceptable for &lt;code&gt;operator!=&lt;/code&gt; to take one object of type &lt;code&gt;X&lt;/code&gt; and one object of type &lt;code&gt;Y&lt;/code&gt;, as long as &lt;code&gt;T&lt;/code&gt; can be converted to &lt;code&gt;X&lt;/code&gt; and &lt;code&gt;someNastyWidget&lt;/code&gt;&amp;rsquo;s type can be converted to &lt;code&gt;Y&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;potentially, even &lt;code&gt;operator&amp;amp;&amp;amp;&lt;/code&gt; could be overloaded, changing the meaning of the above expression from a conjunction to something quite different&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Anyway, the implicit interfaces imposed on a template&amp;rsquo;s parameters are just as real as the explicit interfaces imposed on a class&amp;rsquo;s objects, and both are checked during compilation.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Item-40 Use multiple inheritance judiciously</title>
      <link>http://nianze.tk/2018/03/use-multiple-inheritance-judiciously/</link>
      <pubDate>Tue, 06 Mar 2018 17:35:59 -0500</pubDate>
      
      <guid>http://nianze.tk/2018/03/use-multiple-inheritance-judiciously/</guid>
      <description>&lt;p&gt;Being more complex than single inheritance, Multiple inheritance (MI) can lead to ambiguity issues and to the need for virtual inheritance, the latter of which imposes costs in size, speed, and complexity of initialization and assignment, so it&amp;rsquo;s more practical to make &amp;ldquo;empty&amp;rdquo; virtual base classes.

&lt;!-- toc --&gt;&lt;/p&gt;

&lt;h1 id=&#34;ambiguity&#34;&gt;Ambiguity&lt;/h1&gt;

&lt;p&gt;In the realm of MI, one thing worth noting is that it becomes possible to inherit the same name (e.g., function, typedef, etc.) from more than one base class:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class BorrowableItem {  // something a library lets you borrow
public:
    void checkOut();  // check the item out from the library
    ...
};

class ElectronicGadget {
private:
    bool checkOut() const; // perfom self-test, return whether test succeeds
    ...
};

class MP3Player:  // Multiple inheritance
    public BorrowableItem,
    public ElectronicGadget
{...};
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;MP3Player mp;
mp.checkOut();  // ambiguous!
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In the example above, even though only the public one in &lt;code&gt;BorrowableItem&lt;/code&gt; of the two &lt;code&gt;checkOut&lt;/code&gt; functions is accessible, the call to &lt;code&gt;checkOut&lt;/code&gt; is ambiguous, because before seeing whether a function is accessible, C++ first identifies the function that&amp;rsquo;s the best match for the call, and in this case both &lt;code&gt;checkOut&lt;/code&gt;s are equally good matches, so there&amp;rsquo;s no best match. The accessibility of &lt;code&gt;ElectronicGadget::checkOut&lt;/code&gt; is never examined.&lt;/p&gt;

&lt;p&gt;To resolve the ambiguity, specify which base class&amp;rsquo;s function to call:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;mp.BorrowableItem::checkOut();
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;virtual-inheritance&#34;&gt;Virtual inheritance&lt;/h1&gt;

&lt;p&gt;It is not uncommon in the world of MI to encounter the classical case of &amp;ldquo;deadly MI diamond&amp;rdquo;, where there are more than one path between a base class and a derived class:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class File {...};
class InputFile: public File{...};
class OutputFile: public File{...};
class IOFile: public InputFile,
              public OutputFile
{...};
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;          File
        ↗      ↖
InputFile       OutputFile
        ↖      ↗
         IOFile
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here, between &lt;code&gt;File&lt;/code&gt; and &lt;code&gt;IOFile&lt;/code&gt;, we&amp;rsquo;ve found two paths either through &lt;code&gt;InputFile&lt;/code&gt; or &lt;code&gt;OutputFile&lt;/code&gt;, and we come to the following question:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Do we want the data members in the base class to be replicated for each of the paths?&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;By default, C++ performs the replication, so if there&amp;rsquo;s a data member named &lt;code&gt;fileName&lt;/code&gt; in the &lt;code&gt;File&lt;/code&gt;, &lt;code&gt;IOFile&lt;/code&gt; will inherits a copy from each of its base classes &lt;code&gt;InputFile&lt;/code&gt; and &lt;code&gt;OutputFile&lt;/code&gt;, resulting in two &lt;code&gt;fielName&lt;/code&gt; data members in &lt;code&gt;IOFile&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;If this is not what we want, we must make the &lt;code&gt;File&lt;/code&gt; a &lt;em&gt;virtual base class&lt;/em&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class File {...};
class InputFile: virtual public File{...};
class OutputFile: virtual public File{...};
class IOFile: public InputFile,
              public OutputFile
{...};
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;           File
(virtual)↗      ↖(virtual)
InputFile       OutputFile
         ↖      ↗
         IOFile
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;From the viewpoint of correct behavior, public inheritance should always be virtual. However, inheritance costs both in terms of memory and runtime: compared to their counterparts without virtual inheritance, objects created from clases using virtual inheritance are generally larger, and access to data members in virtual base classes is also slower.&lt;/p&gt;

&lt;p&gt;To make things more complicated, it is required that the responsibility for initializing a virtual base is borne by the &lt;em&gt;most derived class&lt;/em&gt; in the hierarchy, which implies:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;classes derived from virtual bases that requires initialization must be awared of their virtual bases&lt;/li&gt;
&lt;li&gt;when a new derived class is added to the hierarchy, it must assume initialization responsibilities for its virtual bases (both direct and indirect).&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;To make things easier to handle, we could adopt following strategy:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Use non-virtual by default, and don&amp;rsquo;t use virtual bases unless we need to&lt;/li&gt;
&lt;li&gt;If we must use a virtual base classes, avoid putting data in them&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:1&#34;&gt;&lt;a href=&#34;#fn:1&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;example-of-legitimate-mi-usecase&#34;&gt;Example of legitimate MI usecase&lt;/h1&gt;

&lt;p&gt;Multiple inheritance does have legitimate uses. One scenario involves combining public inheritance from an Interface class with private inheritance from a class that provides help of implementation.&lt;/p&gt;

&lt;p&gt;For example, we want to implement the following C++ Interface class (from item 31) to model persons:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class IPerson {
public:
    virtual: ~IPerson();

    virtual std::string name() const = 0;
    virtual std::string birthDate() const = 0;
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We want to create a concrete class &lt;code&gt;CPerson&lt;/code&gt;, and luckily, we find following old database-specific class &lt;code&gt;PersonInfo&lt;/code&gt; offering the essense of what &lt;code&gt;CPerson&lt;/code&gt; needs:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class PersonInfo {
public:
    explicit PersonInfo(DatabaseID pid);
    virtual ~PersonInfo();

    virtual const char * theName() const;
    virtual const char * theBirthDate() const;
    ...
private:
    virtual const char * valueDelimOpen() const;
    virtual const char * valueDelimClose() const;
    ...
};

const char * PersonInfo::valueDilimOpen() const
{
    return &amp;quot;[&amp;quot;;  // default opening delimiter
}

const char * PersonInfo::valueDilimClose() const
{
    return &amp;quot;]&amp;quot;;  // default closing delimiter
}

const char * PersonInfo::theName() const
{
    // reserve buffer for return value, 
    // it&#39;s automatically init. to all zeros due to static
    static char value[Max_Formatted_Field_Value_Length];

    // write opening delimiter
    std::strcpy(value, valueDelimOpen());

    append this obj.&#39;s name fields to the string in value

    // write closing delimiter
    std::strcat(value, valueDelimClose());

    return value;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This design of &lt;code&gt;PersonInfo::theName&lt;/code&gt; is antiquated indeed: it use a fix-size static buffer, which is rife for both overrun and threading problems (item 21). Let&amp;rsquo;s set such imperfection aside, and focus on &lt;code&gt;theName&lt;/code&gt;, which calls virtual function &lt;code&gt;valueDelimOpen&lt;/code&gt; and &lt;code&gt;valueDelimClose&lt;/code&gt;, so the result returnd by &lt;code&gt;theName&lt;/code&gt; is dependent not only on &lt;code&gt;PersonInfo&lt;/code&gt; but also on the classes derived from &lt;code&gt;PersonInfo&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Apparently, the relationship between &lt;code&gt;CPerson&lt;/code&gt; and &lt;code&gt;PersonInfo&lt;/code&gt; is &lt;code&gt;is-implemented-in-terms-of&lt;/code&gt; (we just want to re-use some of the code. That&amp;rsquo;s all). Also, suppose that we want our target class &lt;code&gt;CPerson&lt;/code&gt; to return unadorned values (return &amp;ldquo;Name&amp;rdquo; instead of &amp;ldquo;[Name]&amp;ldquo;), which requires redefining of the virtual functions in &lt;code&gt;PersonInfo&lt;/code&gt;. Thus between the composition (item 38) and private inheritance (item 39) we prefer private inheritance, because simple composition will not let us redefine the virtual functions in &lt;code&gt;PersonInfo&lt;/code&gt;&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:2&#34;&gt;&lt;a href=&#34;#fn:2&#34;&gt;2&lt;/a&gt;&lt;/sup&gt;.&lt;/p&gt;

&lt;p&gt;Thus, we could make following reasonable multiple inheritance:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class IPerson {...}; // the interface. same as above

class DatabaseID {...}; // used below

class PersonInfo {...};  // used for implementing the IPerson interface

class CPerson: public IPerson, private PersonInfo {
public:
    explicit CPerson(DatabaseID pid()): PersonInfo(pid) {}
    virtual std::string name() const
    { return PersonInfo::theName(); }  // implementing the IPerson member function
    virtual std::string birthDate() const
    { return PersonInfo::theBirthDate(); } // implementing the IPerson member function
private:
    const char * valueDelimOpen() const { return &amp;quot;&amp;quot;; } // inherited virtual delimiter functions
    const char * valueDelimClose() const { return &amp;quot;&amp;quot;; } // inherited virtual delimiter functions
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In UML, the design looks like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;     IPerson   PersonInfo
        ↖      ↗(private)
         IOFile
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;summary&#34;&gt;Summary&lt;/h1&gt;

&lt;p&gt;Compared to single inheritance (SI), multiple inheritance (MI) is typically more complicated to use and more complicated to understand, so if SI design is more or less equivalent to an MI design, we prefer the SI design. Sometimes, though, MI is the clearest, most maintainable, most reasonable way to get the job done. When that&amp;rsquo;s the case, just use it, with judiciousness.&lt;/p&gt;
&lt;div class=&#34;footnotes&#34;&gt;

&lt;hr /&gt;

&lt;ol&gt;
&lt;li id=&#34;fn:1&#34;&gt;Without any standalone data, we don&amp;rsquo;t worry about oddities in the initialization and assignment rules for the virtual bases. This is exactly why the Interfaces in Java and .NET, which are in many ways comparable to virtual base classes in C++, are not allowed to contain any data.
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:1&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:2&#34;&gt;Complex composition that is combined with public inheritance, as showed in item 39, may also meed our needs, but here we just use private inheritance because it&amp;rsquo;s easy to understand.
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:2&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;</description>
    </item>
    
    <item>
      <title>Item-39 Use private inheritance judiciously</title>
      <link>http://nianze.tk/2018/03/use-private-inheritance-judiciously/</link>
      <pubDate>Mon, 05 Mar 2018 18:42:43 -0500</pubDate>
      
      <guid>http://nianze.tk/2018/03/use-private-inheritance-judiciously/</guid>
      <description>&lt;p&gt;Private inheritance means is-implemented-in-terms-of. It is usually inferior to composition, but it makes sense when a derived class needs access to protected base members or needs to redefine inherited virtual functions. For library developers who strive to minimize object sizes, it also offers the ability of empty base optimization.

&lt;!-- toc --&gt;&lt;/p&gt;

&lt;p&gt;The behavior of private inheritance is that&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Compilers will generally &lt;em&gt;not&lt;/em&gt; convert a derived class object into a base class object&lt;/li&gt;
&lt;li&gt;members inherited from a private base class (protected or public ones) become private members of the derived class&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;With such behaviors, private inheritance means is-implemented-in-terms-of. Thus, private-inherited derived class D has no conceptual relationship with the base class B - private inheritance is purely an implementation technique in the &lt;em&gt;implementation domain&lt;/em&gt;. Using the terms introduced in item 34:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;private inheritance means to ignore interface, and &lt;strong&gt;only&lt;/strong&gt; inherit implementation.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Compared to the composition, which also has the meaning of &amp;ldquo;is-implemented-in-terms-of&amp;rdquo;, the preference is simple:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;use composition whenever we can, and use private inheritance whenever we must.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;When must we?&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Primarily when we need to inherit protected members and/or virtual functions&lt;/li&gt;
&lt;li&gt;Sometimes when we want to take advance of empty base optimization (which is the edge case)&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;typical-usage&#34;&gt;Typical usage&lt;/h1&gt;

&lt;p&gt;Let&amp;rsquo;s see a typical usecase for private inheritance. Suppose we want to periodically examine the the internal status of class &lt;code&gt;Widget&lt;/code&gt;, and we&amp;rsquo;d like to reuse the following utility class:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class Timer {
public:
    explicit Timer(int tickFrequency);
    virtual void onTick() const;  // automatically called for each tick
    ...
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A &lt;code&gt;Timer&lt;/code&gt; object can be configured to tick with whatever frequency we need, and on each tick, it calls a virtual function, which we can redefine so that it examines the current state of the &lt;code&gt;Widget&lt;/code&gt; object. In order to redefine a virtual function, &lt;code&gt;Widget&lt;/code&gt; must inherit from &lt;code&gt;Timer&lt;/code&gt;. But public inheritance is inappropriate in this case: it&amp;rsquo;s not true that a &lt;code&gt;Widget&lt;/code&gt; is-a &lt;code&gt;Timer&lt;/code&gt;, because &lt;code&gt;Widget&lt;/code&gt; clients should not be able to call &lt;code&gt;onTick&lt;/code&gt; on a &lt;code&gt;Widget&lt;/code&gt;&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:1&#34;&gt;&lt;a href=&#34;#fn:1&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;.&lt;/p&gt;

&lt;p&gt;Public inheritance is not a valid option here. Instead, we inherit privately:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class Widget: private Timer {
private:
    virtual void onTick() const; // look at Widget usage data, etc.
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;After private inheritance, &lt;code&gt;Timer&lt;/code&gt;&amp;rsquo;s public &lt;code&gt;onTick&lt;/code&gt; function becomes private in &lt;code&gt;Widget&lt;/code&gt;, so keep it as private when we redeclare it&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:2&#34;&gt;&lt;a href=&#34;#fn:2&#34;&gt;2&lt;/a&gt;&lt;/sup&gt;.&lt;/p&gt;

&lt;h2 id=&#34;alternatives&#34;&gt;Alternatives&lt;/h2&gt;

&lt;p&gt;This is a nice design, but it&amp;rsquo;s worth noting that private inheritance isn&amp;rsquo;t strictly necessary - we could use composition instead:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class Widget {
private:
    class WidgetTimer: public Timer {
    public:
        virtual void onTick() const;
        ...
    };
    WidgetTimer timer;
    ...
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This design is more complicated involving both (public) inheritance and composition, but we do get two more advantages from its complixity:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Because &lt;code&gt;Widget&lt;/code&gt;&amp;rsquo;s derived classes have no access to the private &lt;code&gt;WidgetTimer&lt;/code&gt; data member, we prevent derived classes from redefining &lt;code&gt;onTick&lt;/code&gt;&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:3&#34;&gt;&lt;a href=&#34;#fn:3&#34;&gt;3&lt;/a&gt;&lt;/sup&gt;.&lt;/li&gt;
&lt;li&gt;We&amp;rsquo;ve minimized &lt;code&gt;Widget&lt;/code&gt;&amp;rsquo;s compilation dependencies: if &lt;code&gt;Widget&lt;/code&gt; inherits from &lt;code&gt;Timer&lt;/code&gt;, &lt;code&gt;Timer&lt;/code&gt;&amp;rsquo;s definition must be available when &lt;code&gt;Widget&lt;/code&gt; is compiled, so we probably has to &lt;code&gt;#include Timer.h&lt;/code&gt;. If &lt;code&gt;WidgetTimer&lt;/code&gt; is moved out of &lt;code&gt;Widget&lt;/code&gt; and &lt;code&gt;Widget&lt;/code&gt; only contains a pointer to  a &lt;code&gt;WidgetTimer&lt;/code&gt;, we only need to simply forward decalare the &lt;code&gt;WidgetTimer&lt;/code&gt; class without &lt;code&gt;#include&lt;/code&gt; anything. Such decouplings can be important for large systems (details in item 31).&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&#34;edge-case&#34;&gt;Edge case&lt;/h1&gt;

&lt;p&gt;The edge case, as the name suggests, is edgy indeed: it applies only when we&amp;rsquo;re dealing with a class that has no data in it: no non-static data members; no virtual functions (which introduces &lt;code&gt;vptr&lt;/code&gt; to each object, item 7); and no virual base classes (which also incurs a size overhead, item 40). Conceptually, such an &lt;em&gt;empty&lt;/em&gt; class should use no space, but C++ requires that freestanding objects must have non-zero size for some technical reasons. That being said,&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class Empty {}; // has no data, so obj. should use no memory

class HoldsAnInt {
private:
    int x;
    Empty e;  // should use no memory
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We&amp;rsquo;ll find that  &lt;code&gt;sizeof(HoldsAnInt) &amp;gt; sizeof(int)&lt;/code&gt;, so &lt;code&gt;Empty&lt;/code&gt; data member does require extra memory. With most compilers, &lt;code&gt;sizeof(Empty)&lt;/code&gt; is 1, which is a silently inserted &lt;code&gt;char&lt;/code&gt; inside the &lt;code&gt;Empty&lt;/code&gt; objects to satisfy C++&amp;rsquo;s requirements. However, alignment requirements (see item 50) may casue compilers to add padding to &lt;code&gt;HoldsAnInt&lt;/code&gt; classes, so the objects of &lt;code&gt;HoldsAnInt&lt;/code&gt; may gain more than just the size of a char - they would actually enlarge enough to hold a second int.&lt;/p&gt;

&lt;p&gt;Now comes the point of using private inheritance: rather than containing &amp;ldquo;freestanding&amp;rdquo; objects that can not have zero size, we could inherit from &lt;code&gt;Empty&lt;/code&gt; type:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class HoldsAnInt: private Empty {
private:
    int x;
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now &lt;code&gt;sizeof(HoldsAnInt) == sizeof(int)&lt;/code&gt;, thanks to &lt;em&gt;empty base optimization (EBO)&lt;/em&gt;, which is typically supported by most compilersp&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:4&#34;&gt;&lt;a href=&#34;#fn:4&#34;&gt;4&lt;/a&gt;&lt;/sup&gt;.&lt;/p&gt;

&lt;p&gt;In practice, &amp;ldquo;empty&amp;rdquo; base classes often contain typedefs, enums, static data members, or non-virtual functions, such as those in the STL that contains useful members (usually typedefs), and thus classes for user-defined function objects may inherit from them without worrying about size increase thanks to EBO.&lt;/p&gt;

&lt;h1 id=&#34;in-summary&#34;&gt;In summary&lt;/h1&gt;

&lt;p&gt;Private inheritance is most likely to be a legitimate design strategy when we&amp;rsquo;re dealing with two classes not related by is-a where one either needs access to the protected members of another or needs to redefine one or more of its virtual functions. Even in this case, however, a mixture of public inheritance and composition can often yield the expected behavior, albeit with more design complexity.&lt;/p&gt;

&lt;p&gt;Most classes aren&amp;rsquo;t empty, so the EBO is rarely a legitimate justification for private inheritance.&lt;/p&gt;

&lt;p&gt;Using private inheritance &lt;em&gt;judiciously&lt;/em&gt; means employing it when, having considered all the alternatives, it&amp;rsquo;s the best way to express the relationship between two classes.&lt;/p&gt;
&lt;div class=&#34;footnotes&#34;&gt;

&lt;hr /&gt;

&lt;ol&gt;
&lt;li id=&#34;fn:1&#34;&gt;Allowing adding &lt;code&gt;onTick&lt;/code&gt; into the conceptual &lt;code&gt;Widget&lt;/code&gt; interface would make it easy for clients to use the &lt;code&gt;Widget&lt;/code&gt; interface incorrectly, a clear violation of item 18&amp;rsquo;s advice to make interfaces easy to use correctly and hard to use incorrectly.
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:1&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:2&#34;&gt;Putting &lt;code&gt;onTick&lt;/code&gt; in the public side will not change its accessibility, only to mislead clients into thinking they could call it, and this, again, violates item 18&amp;rsquo;s advice.
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:2&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:3&#34;&gt;If &lt;code&gt;Widget&lt;/code&gt; inherits directly from &lt;code&gt;Timer&lt;/code&gt;, &lt;code&gt;Widget&lt;/code&gt;&amp;rsquo;s derived classes may redefine &lt;code&gt;onTick&lt;/code&gt; even if &lt;code&gt;onTick&lt;/code&gt; is private (recall item 35 that derived classes may redefine virtual functions even if they are not permitted to call them). By the way, Java or C# would not have such trouble due to their keyword &lt;code&gt;final&lt;/code&gt; or &lt;code&gt;sealed&lt;/code&gt;.
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:3&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:4&#34;&gt;It is worth knowing that the EBO is generally viable only under insgle inheritance, and can&amp;rsquo;t be applied to derived classes taht have more than one base.
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:4&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;</description>
    </item>
    
    <item>
      <title>Item-38 Model &#39;has-a&#39; or &#39;is-implemented-in-terms-of&#39; through composition</title>
      <link>http://nianze.tk/2018/03/model-has-a-or-is-implemented-in-terms-of-through-composition/</link>
      <pubDate>Sun, 04 Mar 2018 15:49:31 -0500</pubDate>
      
      <guid>http://nianze.tk/2018/03/model-has-a-or-is-implemented-in-terms-of-through-composition/</guid>
      <description>&lt;p&gt;In the application domain, composition means has-a. In the implementation domain, it means is-implemented-in-terms-of.
&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Composition&lt;/em&gt; is the relationship where objects of one type contain objects of another type. It&amp;rsquo;s also known as &lt;em&gt;layering&lt;/em&gt;, &lt;em&gt;containment&lt;/em&gt;, &lt;em&gt;aggregation&lt;/em&gt;, and &lt;em&gt;embedding&lt;/em&gt;. As public inheritance means &amp;ldquo;is-a&amp;rdquo;, there&amp;rsquo;re are two meanings for composition:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&amp;ldquo;has-a&amp;rdquo; in the application domain (where we model things in the world with objects, such as people, vehicles, video frames, etc.)&lt;/li&gt;
&lt;li&gt;&amp;ldquo;is-implemented-in-terms-of&amp;rdquo; in the implementation domain (where the objects are purely implementation artifacts, e.g., buffers, mutexes, search trees, etc)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;While the has-a relationship is easy enough to understand, the distinction between is-a and is-implemented-in-terms-of is sometimes troublesome. For example, suppose we&amp;rsquo;d like to (re)use the &lt;code&gt;list&lt;/code&gt; template in the standard C++ library to represent fairly small sets of objeccts, i.e., collections without duplicates.&lt;/p&gt;

&lt;p&gt;In the first glimpse, we may consider the following implementation:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;template&amp;lt;typename T&amp;gt;   // the wrong way to use list for Set
class Set: public std::list&amp;lt;T&amp;gt; {...};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As item 32 explains, if D is-a B, everything true of B is also true of D. However, a list object may contains duplicates, but a Set may not contain duplicates. It is thus untrue that a Set is-a list, and public inheritance is the wrong way to model this relationship.&lt;/p&gt;

&lt;p&gt;The right relationship between the Set and the list should be &lt;strong&gt;is-implemented-in-terms-of&lt;/strong&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;template&amp;lt;typename T&amp;gt;
class Set {
public:
    bool member(const T&amp;amp; item) const;
    void insert(const T&amp;amp; item);
    void remove(const T&amp;amp; item);
    std::size_t size() const;
private:
    std::list&amp;lt;T&amp;gt; rep;  / representation for Set data
};
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;template&amp;lt;typename T&amp;gt;
bool Set&amp;lt;T&amp;gt;::member(const T&amp;amp; item) const
{
    return std:find(rep.begin(), rep.end(), item) != rep.end();
}

template&amp;lt;typename T&amp;gt;
void Set&amp;lt;T&amp;gt;::insert(const T&amp;amp; item)
{
    if (!member(item)) rep.push_back(item);
}

template&amp;lt;typename T&amp;gt;
void Set&amp;lt;T&amp;gt;::remove(const T&amp;amp; item)
{
    typename std::list&amp;lt;T&amp;gt;::iterator it =   // see item 42 for info on typename
        std::find(rep.begin(), rep.end(), item);
    if (it != rep.end()) rep.erase(it);
}

template&amp;lt;typename T&amp;gt;
std::size_t Set&amp;lt;T&amp;gt;::size() const
{
    return rep.size();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As above shows, Set&amp;rsquo;s member functions can lean heavily on functionality already offered by &lt;code&gt;list&lt;/code&gt; and other parts of the standard library. Since they are so simple, they make reasonable candidates for inlining (refer to item 30 before confirming doing so).&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Item-37 Never redefine a function&#39;s inherited default parameter value</title>
      <link>http://nianze.tk/2018/03/never-redefine-a-functions-inherited-default-parameter-value/</link>
      <pubDate>Fri, 02 Mar 2018 21:15:36 -0500</pubDate>
      
      <guid>http://nianze.tk/2018/03/never-redefine-a-functions-inherited-default-parameter-value/</guid>
      <description>&lt;p&gt;Defaul parameter values are statically bound, while virtual function - the only functions we should be overriding - are dynamically bound.
&lt;/p&gt;

&lt;p&gt;As item 36 suggests, we should never redefine an inherited non-virtual function, so we only need to focus on the case where we inherit a virtual function with a default parameter value.&lt;/p&gt;

&lt;p&gt;To make things clear, first we need to understand the difference between static and dynamic binding:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;an object&amp;rsquo;s &lt;em&gt;static type&lt;/em&gt; is the type we declare it to have in the program text&lt;/li&gt;
&lt;li&gt;an object&amp;rsquo;s &lt;em&gt;dynamic type&lt;/em&gt; is determined by the type of the object to which it currently refers.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;For example:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;// a class for geometric shapes
class Shape {
public:
    enum ShapeColor {Red, Green, Blue};
    // all shapes must offer a function to draw themselves
    virtual void draw(ShapeColor color = Red) const = 0;
    ...
};

class Rectangle: public Shape {
public:
    // different default parameter value -&amp;gt; bad
    virtual void draw(ShapeColor color = Green) const;
    ...
};

class Circle: public Shape {
public:
    virtual void draw(ShapeColor color) const;
    ...
};
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;Shape *ps;  // static type = Shape*, no dynamic type (no object referred to)
Shape *pr = new Rectangle // static type = Shape*, dynamic type = Rectangle*
Shape *pc = new Circle;  // static type = Shape*, dynamic type = Circle*
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Notice that the static type of &lt;code&gt;ps&lt;/code&gt;, &lt;code&gt;pr&lt;/code&gt;, and &lt;code&gt;pr&lt;/code&gt; are all &amp;ldquo;pointer-to-&lt;code&gt;Shape&lt;/code&gt;&amp;rdquo;, and that it makes no difference what they&amp;rsquo;re &lt;em&gt;really&lt;/em&gt; pointing to.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Dynamic types&lt;/em&gt; , as their name suggests,  can change as a program runs, typically through assignments:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;ps = pr;  // ps&#39;s dynamic type is now Rectangle*
ps = pc;  // ps&#39;s dynamic type is now Circle*
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Virtual functions are &lt;em&gt;dynamically bound&lt;/em&gt;, meaning that the particular function called is determined by the dynamic type of the object through which it&amp;rsquo;s invoked:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;pc-&amp;gt;draw(Shape::Red); // calls Circle::draw(Shape::Red)
pr-&amp;gt;draw(Shape::Red); // calls Rectangle::draw(Shape::Red)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;However, since default parameters are statically bound, when calling a virtual function defined in a &lt;em&gt;derived class&lt;/em&gt;, it is possible that the default parameter value we are using is from a &lt;em&gt;base class&lt;/em&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;pr-&amp;gt;draw();  // calls Rectangle::draw(Shape::Red)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In this case, even though the virtual function is called according to dynamic type &lt;code&gt;Rectangle*&lt;/code&gt;, the default parameter value is taken from the &lt;code&gt;Shape&lt;/code&gt; class (&lt;code&gt;Shape::Red&lt;/code&gt;) rather than the derived &lt;code&gt;Rectangle&lt;/code&gt; class (&lt;code&gt;Shape::Green&lt;/code&gt; is expected). This result is almost certainly unanticipated.&lt;/p&gt;

&lt;p&gt;The problem here is that the default parameter value of virtual function &lt;code&gt;draw&lt;/code&gt; is redefined in a derived class. This inconsistency between the function call&amp;rsquo;s dynamic binding and the default parameter value&amp;rsquo;s statical binding is mainly due to C++&amp;rsquo;s insistence on runtime efficiency.&lt;/p&gt;

&lt;p&gt;When we&amp;rsquo;re having trouble making a virtual function behave the way we&amp;rsquo;d like, it&amp;rsquo;s wise to consider alternative designs, which item 35 happens to offer. One of the alternatives is the &lt;em&gt;non-virtual-interface idiom&lt;/em&gt;:&lt;br /&gt;
in order to make clear that the default value for &lt;code&gt;draw&lt;/code&gt;&amp;rsquo;s color parameter should always be &lt;code&gt;Red&lt;/code&gt;, we could declare a public non-virtual function in the base class calling a private virtual function that derived classes may redefine. According to item 36, such an non-virtual function should never be overridden by derived classes. Thus, simply specify the default parameter in the non-virtual function, and we&amp;rsquo;re done:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class Shape {
public:
    enum ShapeColor {Red, Green, Blue};
    void draw(ShapeColor color = Red) const  // now non-virtual
    {
        doDraw(color);  // calls the private virtual
    }
    ...
private:
    virtual void doDraw(ShapeColor color) const = 0;  // the actual work is done in this func
};

class Rectangle: public Shape {
public:
    ...
private:
    virtual void doDraw(ShapeColor color) const; // note lack of a default param value
};
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>Item-36 Never redefine an inherited non-virtaul function</title>
      <link>http://nianze.tk/2018/03/never-redefine-an-inherited-non-virtaul-function/</link>
      <pubDate>Thu, 01 Mar 2018 20:22:17 -0500</pubDate>
      
      <guid>http://nianze.tk/2018/03/never-redefine-an-inherited-non-virtaul-function/</guid>
      <description>&lt;p&gt;A generalized basic rule from item 7.
&lt;/p&gt;

&lt;p&gt;Suppose we have an inheritance hierarchy defined like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class B {
public:
    void mf();
    ...
};

class D: public B {
public: 
    void mf();  // hide B::mf
    ...
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;According to item 33, this will lead to following behavior:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cp&#34;&gt;D x;  // x is an object of type D
B *pB = &amp;amp;x;  // get pointer to x
D *pD = &amp;amp;x;  // get pointer to x

pB-&amp;gt;mf();  // calls B::mf
pD-&amp;gt;mf();  // calls D::mf
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The reason for this two-faced behavior if that non-virtual functions like &lt;code&gt;B::mf&lt;/code&gt; and &lt;code&gt;D::mf&lt;/code&gt; are statically bound (item 37), which means that non-virtual functions invoked through pB will &lt;em&gt;always&lt;/em&gt; be those defined for class B, even if pB points to an object of a class derived from &lt;code&gt;B&lt;/code&gt;. This mismatched behavior exhibits inconsistent behavior, since any given D object may act like either a B or a D (depending on the pointer type) when &lt;code&gt;mf&lt;/code&gt; is called.&lt;/p&gt;

&lt;p&gt;On the other hand, virtual functions are dynamically bound (item 37), so if &lt;code&gt;mf&lt;/code&gt; were a virtual function, a call to &lt;code&gt;mf&lt;/code&gt; through either pB or pD would result in an invocation of &lt;code&gt;D::mf&lt;/code&gt;, because pB and pD &lt;em&gt;really&lt;/em&gt; point to is an object of type D.&lt;/p&gt;

&lt;p&gt;Worse than the inconsistent behavior problem in the real world, the example above basically shows a contradiction in class design, theoretically:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;public inheritance means is-a (item 32), so everything that applies to B object also applies to D object&lt;/li&gt;
&lt;li&gt;a non-virtual function in the base class establishes an invariant over specialization that classes derived from &lt;code&gt;B&lt;/code&gt; must inherit both the interface &lt;em&gt;and&lt;/em&gt; the implementation (item 34), and &lt;code&gt;mf&lt;/code&gt; is such an non-virtual function in &lt;code&gt;B&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;As long as we redefine the &lt;code&gt;mf&lt;/code&gt;, an inherited non-virtual function, one of the conditions above will break, leading to two solutions: either make the &lt;code&gt;mf&lt;/code&gt; virtual, or change the class relationship from &amp;lsquo;is-a&amp;rsquo; to something else.&lt;/p&gt;

&lt;p&gt;In fact, this is exactly the same argument in item 7, which exlains why destructors in polymophic base classes should be virtual. In essence, item 7 is nothing more than a special case of this item.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Item-35 Consider Alternatives to Virtual Functions</title>
      <link>http://nianze.tk/2018/02/consider-alternatives-to-virtual-functions/</link>
      <pubDate>Wed, 28 Feb 2018 20:27:02 -0500</pubDate>
      
      <guid>http://nianze.tk/2018/02/consider-alternatives-to-virtual-functions/</guid>
      <description>&lt;p&gt;Alternatives to virtual functions include the NVI idiom (as an example of the Template Method design pattern) and various forms of the Strategy design pattern.

&lt;!-- toc --&gt;&lt;/p&gt;

&lt;p&gt;Suppose we want to implement a member function named &lt;code&gt;healthValue&lt;/code&gt;, which will calculate the health value for different characters in differen ways in a video game. Declaring &lt;code&gt;healthValue&lt;/code&gt; virtual seems the obvious way to design things:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class GameCharacter {
public:
    // return character&#39;s health value rating; derived classes may redefine this
    // impure virtual suggests there&#39;s a default impl. (item 34)
    virtual int healthValue() const;  
    ...                               
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Actually, except from this obvious design, there exists some alternatives. To name a few:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Use the &lt;strong&gt;non-virtual interface idiom (NVI idiom)&lt;/strong&gt;, a form of the &lt;strong&gt;Template Method design pattern&lt;/strong&gt; that wraps public non-virtual member functions around less accessible virtual functoins&lt;/li&gt;
&lt;li&gt;Use the &lt;strong&gt;Strategy design pattern&lt;/strong&gt;, specifically:&lt;br /&gt;

&lt;ul&gt;
&lt;li&gt;Replace virtual function with &lt;strong&gt;function pointer data members&lt;/strong&gt; - a stripped-down manifestation of Strategy design pattern&lt;/li&gt;
&lt;li&gt;Replace virtual function with &lt;strong&gt;tr1::function data members&lt;/strong&gt;, which allows use of any callable entity with a signature compatible with what we need - a more general form of the stripped-down representation of Strategy design pattern&lt;/li&gt;
&lt;li&gt;Replace virtual functions in one hierarchy with &lt;strong&gt;virtual functions in another hierarchy&lt;/strong&gt; - the conventional implementation of the Strategy design pattern&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Let&amp;rsquo;s take a look at the pros and cons of these alternatives.&lt;/p&gt;

&lt;h1 id=&#34;the-template-method-pattern-via-the-non-virtual-interface-idiom&#34;&gt;The template method pattern via the non-virtual interface idiom&lt;/h1&gt;

&lt;p&gt;The &lt;em&gt;non-virtual interface (NVI) idiom&lt;/em&gt; argues that clients should call private virtual functions indirectly through public non-virtual member functions, which act like a &lt;em&gt;wrapper&lt;/em&gt; around the virtual functions. This is a particular manifestation of the more general design pattern known as Template Method&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:1&#34;&gt;&lt;a href=&#34;#fn:1&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class GameCharacter {
public:
    int healthValue() const  // derived classes do not redefine
    {
        ...  // do &amp;quot;before&amp;quot; stuff
        int retVal = doHealthValue();  // do the real work
        ...  // do &amp;quot;after  stuff
        return retVal;
    }
    ...
private:
    virtual int doHealthValue() const  // derived classes may redefine this
    {
        ...  // default algorithm for calculating character&#39;s health
    }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The NVI idiom involves derived classes redefining private virtual functions that they can&amp;rsquo;t call - this seemingly contradictory rule is allowed by C++ and actually makes perfect sense: redefining a virtual function specifies &lt;em&gt;how&lt;/em&gt; something is to be done, while calling a virtual function specifies &lt;em&gt;when&lt;/em&gt; it will be done, and these two concerns are independent.&lt;/p&gt;

&lt;p&gt;However, it&amp;rsquo;s not strictly necessary to declare the virtual functions &lt;code&gt;private&lt;/code&gt;: in the cases where the derived class implementations of a virtual function are expected to invoke their base class counterparts, we have to declare the virtuals &lt;code&gt;protected&lt;/code&gt;. Sometimes a virtual function even has to be &lt;code&gt;public&lt;/code&gt; (e.g., destructors in polymorphic base classes, item 7), but then the NVI idiom can&amp;rsquo;t really be applied.&lt;/p&gt;

&lt;p&gt;The advantage of the NVI idiom is in the &amp;ldquo;&amp;ldquo;do &amp;lsquo;before&amp;rsquo; stuff&amp;rdquo; and  &amp;ldquo;do &amp;lsquo;after&amp;rsquo; stuff&amp;rdquo; part in the code above, which enable the wrapper abilities to ensure that before a virtual function is called, the proper context is set up (e.g., locking a mutex, making a log entry, verifying the class invariants and function pereconditions, etc), and after the call is over, the context is cleaned up (e.g., unlocking a mutex, verifying function postconditions, etc). If letting clients call virtual functions directly, there&amp;rsquo;s no good way to do these stuff.&lt;/p&gt;

&lt;h1 id=&#34;the-strategy-pattern&#34;&gt;The strategy pattern&lt;/h1&gt;

&lt;p&gt;The NVI idiom is still using virtual functions to calculate a character&amp;rsquo;s health. A more dramatic design assertion, such as the strategy pattern, says that calculating a character&amp;rsquo;s health is independent of the character&amp;rsquo;s type - the calculation need not to be part of the character.&lt;/p&gt;

&lt;p&gt;It is worth noting that, due to its being outside the &lt;code&gt;GameCharacter&lt;/code&gt; hierarchy, the calculation has no special access to the internal parts of the object whose health it&amp;rsquo;s calculating, so this design pattern works only if a character&amp;rsquo;s health can be calculated based purely on information available through the character&amp;rsquo;s public interface. Thus it may require the class&amp;rsquo;s encapsulation to be weakened (e.g., make the non-member functions to be &lt;code&gt;friend&lt;/code&gt;, or offer public accessor functions for class implementation that is previously hidden).&lt;/p&gt;

&lt;h2 id=&#34;the-strategy-pattern-via-function-pointers&#34;&gt;The strategy pattern via function pointers&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class GameCharacter; // forward declaration

// function for default health calculation algorithm
int defaultHealthCalc(const GameCharacter&amp;amp;);

class GameCharacter {
public:
    typedef int(*HealthCalcFunc)(const GameCharacter&amp;amp;);

    explicit GameCharacter(HealthCalcFunc hcf = defaultHealthCalc)
    : healthFunc(hcf)
    {}

    int healthValue() const
    { return healthFunc(*this); }
    ...
private:
    HealthCalcFunc healthFunc;
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The advantage of this approach is some interesting flexibility:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;different instances of the same character type can have different health calculation functions installed&lt;/li&gt;
&lt;li&gt;health calculation functions for a particular character may be changed at runtime. For example, &lt;code&gt;GameCharacter&lt;/code&gt; might offer a member function &lt;code&gt;setHealthCalculator&lt;/code&gt; that allowed replacement of the current health calculation function.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;the-strategy-pattern-via-tr1-function&#34;&gt;The strategy pattern via &lt;code&gt;TR1::function&lt;/code&gt;&lt;/h2&gt;

&lt;p&gt;To generalized the approach above, we could replace the function pointer &lt;code&gt;healthFunc&lt;/code&gt; with an object of type &lt;code&gt;tr1::function&lt;/code&gt;. As item 54 explains, such objects may hold &lt;em&gt;any callable entity&lt;/em&gt; (e.g., function pointer, function object, member function pointer) whose signature is compatible&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:2&#34;&gt;&lt;a href=&#34;#fn:2&#34;&gt;2&lt;/a&gt;&lt;/sup&gt; with the given target signature:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class GameCharacter; // forward declaration

// function for default health calculation algorithm
int defaultHealthCalc(const GameCharacter&amp;amp;);

class GameCharacter {
public:
   // HealthCalcFunc is any callable entity that can be called with anything 
   // compatible with a GameCharracter and that returns anything 
   // compatible with an int
    typedef std::tr1::function&amp;lt;int (const GameCharacter&amp;amp;)&amp;gt; HealthCalcFunc;

    explicit GameCharacter(HealthCalcFunc hcf = defaultHealthCalc)
    : healthFunc(hcf)
    {}

    int healthValue() const
    { return healthFunc(*this); }
    ...
private:
    HealthCalcFunc healthFunc;
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The advantage of this approach is that clients may have more flexibility in specifying health calculation functions with various compatible callable entities:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;short calcHealth(const GameCharacter&amp;amp;); // function; non-int return type
struct HealthCalculator { // class for health calculation function objects
    ...
};
class GameLevel {
public:
    float health(const GameCharacter&amp;amp;) const; // member function; non-int return type
    ...
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To use these callable entities:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class EvilBadGuy: public GameCharacter {
public:
    explicit EvilBadGuy(HealthCalcFunc hcf = defaultHealthCalc)
    : GameCharacter(hcf)
    {...}
    ...
};

class EyeCandyCharacter: public GameCharacter {
    ...  // similar constructor as EvilBadGuy
};

EvilBadGuy ebg1(calcHealth);  // character using a health calculation function
EyeCandyCharacter ecc1(HealthCalculator()); // character using a health calculation function object
GameLevel currentLevel;
...
EvilBadGuy ebg2(  // character using a health calculation member function
    std::tr1::bind(&amp;amp;GameLevel::health,
                    currentLevel,
                    _1)
);

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here, the purpose of calling &lt;code&gt;tr1::bind&lt;/code&gt; is that:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;it adapts the &lt;code&gt;GameLevel::health&lt;/code&gt; member function (which takes two parameters: an implicit &lt;code&gt;GameLevel&lt;/code&gt; parameter that &lt;code&gt;this&lt;/code&gt; points to, as well as another reference to a &lt;code&gt;GameCharacter&lt;/code&gt; parameter) into the expected function signature (which should only take a single paramter: the &lt;code&gt;GameCharacter&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;by passing &lt;code&gt;_1&lt;/code&gt;, it specifies that when calling &lt;code&gt;GameLevel::health&lt;/code&gt; for &lt;code&gt;ebg2&lt;/code&gt;, always use &lt;code&gt;currentLevel&lt;/code&gt; as the first parameter of &lt;code&gt;GameLevel&lt;/code&gt; object&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;the-classic-strategy-pattern&#34;&gt;The &amp;ldquo;Classic&amp;rdquo; strategy pattern&lt;/h2&gt;

&lt;p&gt;The conventional approach to Strategy design pattern would be to make the health-calculation function a virtual member function of a separate health-calculation hierarchy with root being &lt;code&gt;HealthCalcFunc&lt;/code&gt;, so that different health calculation algorithm could be implemented in the derived classes in this inheritance hierarchy. Each object of type &lt;code&gt;GameCharacter&lt;/code&gt; just contains a pointer to an object from the &lt;code&gt;HealthCalcFunc&lt;/code&gt; hierarchy:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class GameCharacter;  // forward declaration

class HealthCalcFunc {
public:
    ...
    virtual int calc(const GameCharacter&amp;amp;) const
    {...}
    ...  
};

HealthCalcFunc defaultHealthCalc;

class GameCharacter {
public:
    explicit GameCharacter(HealthCalcFunc *phcf = &amp;amp;defaultHealthCalc)
    : pHealthCalc(phcf)
    {}
    ...
private:  
    HealthCalcFunc *pHealthCalc;
};
&lt;/code&gt;&lt;/pre&gt;
&lt;div class=&#34;footnotes&#34;&gt;

&lt;hr /&gt;

&lt;ol&gt;
&lt;li id=&#34;fn:1&#34;&gt;Template Method design pattern has nothing to do with C++ template.
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:1&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:2&#34;&gt;Here, the &amp;ldquo;target signature&amp;rdquo; is &amp;ldquo;function taking a reference to a &lt;code&gt;const GameCharacter&lt;/code&gt; and returning an &lt;code&gt;int&lt;/code&gt;&amp;rdquo;, so any callable entity whose parameter can be implicitly converted to a &lt;code&gt;const GameCharacter&amp;amp;&lt;/code&gt; and whose return type can be implicitly converted to an &lt;code&gt;int&lt;/code&gt; is compatible with an object of the declared &lt;code&gt;tr1::function&lt;/code&gt; type.
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:2&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;</description>
    </item>
    
    <item>
      <title>Item-34 Differentiate between inheritance of interface and inheritance of implementation</title>
      <link>http://nianze.tk/2018/02/differentiate-inheritance-of-interface-from-inheritance-of-implementation/</link>
      <pubDate>Tue, 27 Feb 2018 20:53:53 -0500</pubDate>
      
      <guid>http://nianze.tk/2018/02/differentiate-inheritance-of-interface-from-inheritance-of-implementation/</guid>
      <description>&lt;p&gt;Inheritance of interface is different from inheritance of implementatino.

&lt;!-- toc --&gt;&lt;/p&gt;

&lt;p&gt;Under public inheritance, derived classes always inherit base class interfaces, but may act differently in terms of base class implementation inheritance:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Pure virtual functions specify inheritance of interface only&lt;/li&gt;
&lt;li&gt;Simple (impure) virtual functions specify inheritance of interface plus inheritance of a default implementation&lt;/li&gt;
&lt;li&gt;Non-virtual functions specify inheritance of interface plus inheritance of a mandatory implementation&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;To show the implementation differences above, we can define following classes for an example:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class Shape {  // abstract class
public:
    virtual void draw() const = 0;  // pure virtual function, draws the current obj.
    virtual void error(const std::string&amp;amp; msg); // impure virtual function, called by member functions if they need to report an error
    int objectID() const; // non-virtual function, returns a unique integer identifier for the current obj.
};

class Rectangle: public Shape {...};
class Ellipse: public Shape {...};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Since derived classes &lt;code&gt;Rectangle&lt;/code&gt; and &lt;code&gt;Ellipse&lt;/code&gt; are both public inherited, according to item 32, this means &lt;code&gt;is-a&lt;/code&gt;, so anything that is true of the base class must also apply to derived classes. Thus, the member function &lt;em&gt;interfaces&lt;/em&gt; are always inherited.&lt;/p&gt;

&lt;h1 id=&#34;pure-virtual-functions&#34;&gt;Pure virtual functions&lt;/h1&gt;

&lt;p&gt;For pure virtual functions, there are two features we have to note:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;they &lt;em&gt;must&lt;/em&gt; be redeclared by any concrete class that inherits them&lt;/li&gt;
&lt;li&gt;they typically have no definition in abstract classes&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;From these feature, we can conclude that:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;The purpose of declaring a pure virtual function is to have derived classes inherit a function &lt;em&gt;interface only&lt;/em&gt;.&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Here, the declaration of &lt;code&gt;Shape::draw&lt;/code&gt; says to the client of the &lt;code&gt;Shape&lt;/code&gt; that, &amp;ldquo;you have to provide a &lt;code&gt;draw&lt;/code&gt; function, but I don&amp;rsquo;t know how you&amp;rsquo;re going to implement it.&amp;rdquo;&lt;/p&gt;

&lt;p&gt;Incidentally, C++ allows us to provide an implementation for &lt;code&gt;Shape::draw&lt;/code&gt; (example: pure virtual destructor in item 7). However, the only way to call it would be to qualify the call with the class name:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;Shape *ps = new Shape;  // error! Shape is abstract
Shape *ps1 = new Rectangle;  // fine
ps1-&amp;gt;draw();  // call Rectangle::draw
ps1-&amp;gt;Shape::draw(); // call Shape::draw
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This feature is generally of limited utility, except that it can be employed as a mechanism for providing a safer-than-usual default implementation for simple virtual functions as we&amp;rsquo;ll see below.&lt;/p&gt;

&lt;h1 id=&#34;simple-impure-virtual-functions&#34;&gt;Simple (impure) virtual functions&lt;/h1&gt;

&lt;p&gt;Simple virtual functions provide an implementation that derived classes may override, which means that&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;The purpose of declaring a simple virtual function is to have derived classes inherit a function &lt;em&gt;interface as well as default implementation&lt;/em&gt;.&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;For example, the declaration of &lt;code&gt;error&lt;/code&gt; function tells us that &amp;ldquo;You have to supoort an &lt;code&gt;error&lt;/code&gt; function, but if you don&amp;rsquo;t want to write your own, you can fall back on the default version in the &lt;code&gt;Shape&lt;/code&gt; class.&amp;rdquo;&lt;/p&gt;

&lt;h2 id=&#34;potential-danger&#34;&gt;Potential danger&lt;/h2&gt;

&lt;p&gt;However, in the perspective of class design, there&amp;rsquo;s a potential danger to allow simple virtual functions to specify both a function interface and a default implementation. That is: a derived class is allowed to inherit the default implementation without &lt;strong&gt;explicitly&lt;/strong&gt; saying that it wanted to. For example:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class Airport {...}; // represents airports

class Airplane {
public:
    virtual void fly(const Airport&amp;amp; destination);
    ...
};

void Airplane::fly(const Airport&amp;amp; destination)
{
    default code for flying an airplane to the given destination
}

class ModelA: public Airplane{...};
class ModelB: public Airplane{...};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Suppose both &lt;code&gt;ModelA&lt;/code&gt; and &lt;code&gt;ModelB&lt;/code&gt; inherit the base class &lt;code&gt;Airplane&lt;/code&gt; without re-implementing the simple virtual function &lt;code&gt;fly&lt;/code&gt;. Chances are that &lt;code&gt;ModelB&lt;/code&gt; is actually a new type of model, yet its programmer simply forgets to redefine the &lt;code&gt;fly&lt;/code&gt; function.&lt;/p&gt;

&lt;h2 id=&#34;separate-interface-from-default-implementation&#34;&gt;Separate interface from default implementation&lt;/h2&gt;

&lt;p&gt;To make our design more foolproof, we may separate functions for providing interface and default implementation, such as below:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class Airplane {
public:
    virtual void fly(const Airport&amp;amp; destination) = 0;
    ...
protected:
    void defaultFly(const Airport&amp;amp; destination)
    {
        default code for flying an airplane to the given destination
    }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class ModelA: public Airplane {
public:
    virtual void fly(const Airport&amp;amp; destination)
    { defaultFly(destination); }
    ...
};
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class ModelB: public Airplane {
public;
    virtual void fly(Airport&amp;amp; destination);
    ...
};

void ModelB::fly(const Airport&amp;amp; destination)
{
    special code for flying a ModelB airplane to the given destination
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;take-use-of-pure-virtual-function&#34;&gt;Take use of pure virtual function&lt;/h2&gt;

&lt;p&gt;Some people may feel this design is redundant, arguing that this will polllute the class namespace with a proliferation of closely related function names. Then we may take advantage of the fact that pure virtual functions, which insists on redeclaring in concrete derived classes, may also have implementations of their own:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class Airplane {
public:
    virtual void fly(const Airport&amp;amp; destination) = 0;
    ...
};

void Airplane::fly(const Airport&amp;amp; desination)  // an implementation of a pure virtual function
{
    default code for flying an airplane to the given destination
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class ModelA: public Airplane {
public:
    virtual void fly(const Airport&amp;amp; destination)
    { Airplane::fly(destination); }
    ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class ModelB: public Airplane {
public;
    virtual void fly(Airport&amp;amp; destination);
    ...
};

void ModelB::fly(const Airport&amp;amp; destination)
{
    special code for flying a ModelB airplane to the given destination
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In essence, this design breaks &lt;code&gt;fly&lt;/code&gt; into two fundamental components:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;fly&lt;/code&gt;&amp;rsquo;s declaration specifies its interface, which derived classes &lt;em&gt;must use&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;fly&lt;/code&gt;&amp;rsquo;s definition specifies its default behavior, which derived classes &lt;em&gt;may use&lt;/em&gt; by explicitly request it&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;However, in merging &lt;code&gt;fly&lt;/code&gt; and &lt;code&gt;defaultFly&lt;/code&gt;, we have lost the ability to give the two functions different protection levels: previously &lt;code&gt;protected&lt;/code&gt; code in &lt;code&gt;defaultFly&lt;/code&gt; is now &lt;code&gt;public&lt;/code&gt; in &lt;code&gt;fly&lt;/code&gt;.&lt;/p&gt;

&lt;h1 id=&#34;non-virtual-function&#34;&gt;Non-virtual function&lt;/h1&gt;

&lt;p&gt;A non-virtual member function specifies an &lt;em&gt;invariant over specialization&lt;/em&gt; (a point discussed in item 36), identifying behavior that is not supposed to change, no matter how specialized a derived class becomes. Thus:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;The purpose of declaring a non-virtual function is to have derived classes inherit a function &lt;em&gt;interface as well as&lt;/em&gt; a mandatory implementation.&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;The declaration for &lt;code&gt;Shape::objectId&lt;/code&gt; is basically say, &amp;ldquo;Every &lt;code&gt;Shape&lt;/code&gt; object has a function that yields an object identifier, and that identifier is always conputed the same way. That way is determined by the definition of &lt;code&gt;Shape::objectID&lt;/code&gt;, and no derived class should try to chagne how it&amp;rsquo;s done.&amp;rdquo;&lt;/p&gt;

&lt;h1 id=&#34;summary&#34;&gt;Summary&lt;/h1&gt;

&lt;p&gt;The differences in declarations for pure virtual, simple virtual and non-virtual functions allow us to specify with precision what we want derived classes to inherit: interface only, interface and a default implementation, or interface and a mandatory implementation, respectively.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Item-33 Avoid hiding inherited names</title>
      <link>http://nianze.tk/2018/02/avoid-hiding-inherited-names/</link>
      <pubDate>Mon, 26 Feb 2018 20:18:55 -0500</pubDate>
      
      <guid>http://nianze.tk/2018/02/avoid-hiding-inherited-names/</guid>
      <description>&lt;p&gt;Names in derived classes hide names in base classes, which is not desirable in public inheritance. To fix it, employ &lt;code&gt;using&lt;/code&gt; declarations or forwarding functions to make hidden names visible again.
&lt;/p&gt;

&lt;p&gt;As we all know, names in inner scopes hide (&amp;ldquo;shadow&amp;rdquo;) names in outer scopes. Specifically, whether the names correspond to the same or different types is immaterial. In the world of inheritance, the scope of a derived class is nested inside its base class&amp;rsquo;s scope, so if we define following classes:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class Base {
private:
    int x;
public:
    virtual void mf1() = 0;
    virtual void mf2();
    void mf3();
};
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class Derived: public Base {
public:
    virtual void mf1();
    void mf4();
};

void Derived::mf4()
{
    ...
    mf2();
    ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;When compilers see the use of the name &lt;code&gt;mf2&lt;/code&gt; here, they figure out what it refers to by searching scopes for a declaration of something named &lt;code&gt;mf2&lt;/code&gt; by following order:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;first they look in the local scope of &lt;code&gt;mf4&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;then they search the containing scope, that of the class &lt;code&gt;Derived&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;they move on to the next containing scope, that of the base class (there they found something named &lt;code&gt;mf2&lt;/code&gt;, so the search stops)&lt;/li&gt;
&lt;li&gt;if there were no &lt;code&gt;mf2&lt;/code&gt; in &lt;code&gt;Base&lt;/code&gt;, the search will continue, first to the namespace(s) containing &lt;code&gt;Base&lt;/code&gt;, and finally to the global scope&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Consider again what will happen if the two classes are defined in the following way, with &lt;code&gt;mf1&lt;/code&gt; and &lt;code&gt;mf3&lt;/code&gt; overloaded in &lt;code&gt;Base&lt;/code&gt; and a new &lt;code&gt;mf3&lt;/code&gt; added in &lt;code&gt;Derived&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class Base {
private:
    int x;
public:
    virtual void mf1() = 0;
    virtual void mf1(int);
    virtual void mf2();
    void mf3();
    void mf3(double);
};
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class Derived: public Base {
public:
    virtual void mf1();
    void mf3();
    void mf4();
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;From the perspective of name lookup, &lt;code&gt;Base::mf1&lt;/code&gt; and &lt;code&gt;Base::mf3&lt;/code&gt; are no longer inherited by &lt;code&gt;Derived&lt;/code&gt;, because all functions names &lt;code&gt;mf1&lt;/code&gt; and &lt;code&gt;mf3&lt;/code&gt; in the base class are hidden by the functions names &lt;code&gt;mf1&lt;/code&gt; and &lt;code&gt;mf3&lt;/code&gt; in the derived class. This leads to following behavior:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;Derived d;
int x;
...
d.mf1();  // fine, calls Derived::mf1
d.mf1(x); // error! Derived::mf1 hides Base::mf1
d.mf2();  // fine, calls Base::mf2
d.mf3();  // fine, calls Derived::mf3
d.mf3(x); // error! Derived::mf3 hides Base::mf3
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Even though the functions in the base and derived classes take different parameter types, and no matter those functions are virtual or non-virtual, the name lookup rule applies regardlessly. The rationale behind this behavior is to prevent us from accidentally inheriting overloads from distant base classes when we create a new derived class in a library or application framework. However, sometimes we &lt;em&gt;want&lt;/em&gt; to inherit the overloads&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:1&#34;&gt;&lt;a href=&#34;#fn:1&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;.&lt;/p&gt;

&lt;p&gt;To access the hidden names, we have two ways to go: &lt;code&gt;using&lt;/code&gt; declarations and forwarding function.&lt;/p&gt;

&lt;h3 id=&#34;using-declarations&#34;&gt;&lt;code&gt;using&lt;/code&gt; declarations&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class Base{...}; // the same

class Derived: public Base {
public:
    using Base::mf1;  // make all things in Base named mf1 and mf3 
    using Base::mf3;  // visible (and public) in Derived&#39;s scope

    virtual void mf1();
    void mf3();
    void mf4();
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And now inheritance will work as expected:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;Derived d;
int x;
...
d.mf1();  // fine, calls Derived::mf1
d.mf1(x); // now ok, call Base::mf1
d.mf2();  // fine, calls Base::mf2
d.mf3();  // fine, calls Derived::mf3
d.mf3(x); // now ok, call Base::mf3
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This tells us that&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;if we inherit from a base class with overloaded functions and we want to redefine or override only some of them, we need to include a &lt;code&gt;using&lt;/code&gt; declaration for each name we&amp;rsquo;d otherwise be hiding. If we don&amp;rsquo;t, some of the names we&amp;rsquo;d like to inherit will be hidden.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Unser public inheritance, we always want to inherit all the functions from the base classes to follow public inheritance&amp;rsquo;s is-a relationship between base and derived classes, which is why the &lt;code&gt;using&lt;/code&gt; declarations above are in the public part of the derived class (names that are public in a base class should also be public in a publicly derived class).&lt;/p&gt;

&lt;p&gt;However, under private inherits (item 39), it can make sense to inherit only part of the functions from the base classes. A the &lt;code&gt;using&lt;/code&gt; declaration won&amp;rsquo;t do the trick here, for it makes &lt;em&gt;all&lt;/em&gt; inherited functions with a given name visible in the derived class. We use a different technique: forwarding function.&lt;/p&gt;

&lt;h3 id=&#34;forwarding-function&#34;&gt;Forwarding function&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class Base{...}; // the same

class Derived: public Base {
public:
    virtual void mf1()  // forwarding function; implicitly inline, see item 30
    { Base::mf1(); } 
    ...
};
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;Derived d;
int x;

d.mf1();  // fine, calls Derived::mf1
d.mf1(x); // error! Base::mf1() is hidden
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;For ancient compilers that don&amp;rsquo;t support &lt;code&gt;using&lt;/code&gt; declarations, we also have to use forwarding function technique to import inherited names into the scope of derived classes.&lt;/p&gt;

&lt;p&gt;When inheritance is combined with templates, an entirely different form of the &amp;ldquo;inherited names are hidden&amp;rdquo; issue arises. See item 43 for all the angle-bracket-demarcated details.&lt;/p&gt;
&lt;div class=&#34;footnotes&#34;&gt;

&lt;hr /&gt;

&lt;ol&gt;
&lt;li id=&#34;fn:1&#34;&gt;In fact, in public inheritance, if we don&amp;rsquo;t inherit the overloads, we&amp;rsquo;re violating the is-a relationship between base and derived classes, which, as explained in item 32, is fundamental to public inheritance.
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:1&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;</description>
    </item>
    
    <item>
      <title>Item-32 Make sure public inheritance models &#34;Is-A&#34;</title>
      <link>http://nianze.tk/2018/02/make-sure-public-inheritance-models-is-a/</link>
      <pubDate>Fri, 23 Feb 2018 12:59:53 -0500</pubDate>
      
      <guid>http://nianze.tk/2018/02/make-sure-public-inheritance-models-is-a/</guid>
      <description>&lt;p&gt;Everything that applies to base classes must also apply to derived classes in public inheritance, for every derived class object &lt;em&gt;is&lt;/em&gt; a base class object.
&lt;/p&gt;

&lt;p&gt;There are multiple relationships that can exist between classes:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&amp;ldquo;is-a&amp;rdquo; is talked about in this item.&lt;/li&gt;
&lt;li&gt;&amp;ldquo;has-a&amp;rdquo; is discussed about in item 38.&lt;/li&gt;
&lt;li&gt;&amp;ldquo;is-implemented-in-terms-of&amp;rdquo; is introduced in item 39.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;We should understand the differencea among these relationships.&lt;/p&gt;

&lt;p&gt;For &amp;ldquo;is-a&amp;rdquo;, we should understand it in this way: if the class D (&amp;ldquo;derived&amp;rdquo;) &lt;strong&gt;publicly&lt;/strong&gt; inherits from class B (&amp;ldquo;base), C++ compilers will assume that every object of type D is also an object of type B, but not &lt;em&gt;vice versa&lt;/em&gt;. That is, every D is-a B, but not vice versa &lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:1&#34;&gt;&lt;a href=&#34;#fn:1&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;.&lt;/p&gt;

&lt;p&gt;The concept of is-a sounds simple, but sometimes our intuition may mislead us. Say we want to create class &lt;code&gt;Square&lt;/code&gt; and class &lt;code&gt;Rectangle&lt;/code&gt;. I hear you say:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Everybody knows that a square is a rectangle, but generally not vice versa&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Then consider this code:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class Rectangle {
public:
    virtual void setHeight(int newHeight);
    virtual void setWidth(int newWidth);

    virtual int height() const;  // return current values
    virtual int width() const;
    ...
};

void makeBigger(Rectangle&amp;amp; r)  // function to increase r&#39;s area
{
    int oldHeight = r.height();
    r.setWidth(r.width() + 10);  // add 10 to r&#39;s width
    assert(r.height() == oldHeight);  // assert that r&#39;s height is unchanged
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class Square: public Rectangle {...};

Square s;
...
assert(s.width() == s.height());  // must be true for all squares
makeBigger(s);  // by inheritance, s is-a Rectangle, so we can increase its area
assert(s.width() == s.height());  // must be true for all squares
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now we face a big problem: how can we reconcile the following assertion:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;before calling &lt;code&gt;makeBigger&lt;/code&gt;, &lt;code&gt;s&lt;/code&gt;&amp;rsquo;s height is the same as its width;&lt;/li&gt;
&lt;li&gt;inside &lt;code&gt;makeBigger&lt;/code&gt;, &lt;code&gt;s&lt;/code&gt;&amp;rsquo;s width is changed, but its height is not;&lt;/li&gt;
&lt;li&gt;after returning from &lt;code&gt;makeBigger&lt;/code&gt;, &lt;code&gt;s&lt;/code&gt;&amp;rsquo;s height is again the same as its width&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Here, the instincts we&amp;rsquo;ve develped in mathematics does not serve well. In this case, something applies to a rectangle is not applicable to a square, but public inheritance asserts that &lt;strong&gt;everthing&lt;/strong&gt; that applies to base class object also applies to derived class objects. Thus using public inheritance to model the relationship between &lt;code&gt;Rectangle&lt;/code&gt; and &lt;code&gt;Square&lt;/code&gt; is incorrect.&lt;/p&gt;

&lt;p&gt;With the knowledge of inheritance added into our arsenal of design, we&amp;rsquo;ll have to augment our intuition with new insights to guide us in inheritance&amp;rsquo;s proper application.&lt;/p&gt;
&lt;div class=&#34;footnotes&#34;&gt;

&lt;hr /&gt;

&lt;ol&gt;
&lt;li id=&#34;fn:1&#34;&gt;This is true only for &lt;em&gt;public&lt;/em&gt; inheritance. Private inheritance means somethign entirely different (item 39), and protected inheritance is something beyond understanding.
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:1&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;</description>
    </item>
    
    <item>
      <title>Item-31 Minimize compilation dependencies between files</title>
      <link>http://nianze.tk/2018/02/minimize-compilation-dependencies-between-files/</link>
      <pubDate>Thu, 22 Feb 2018 00:00:00 +0000</pubDate>
      
      <guid>http://nianze.tk/2018/02/minimize-compilation-dependencies-between-files/</guid>
      <description>&lt;p&gt;To minimize compilation dependencies, depend on declarations instead of definitions via techniques such as Handle classes and Interface classes.

&lt;!-- toc --&gt;&lt;/p&gt;

&lt;p&gt;C++ doesn&amp;rsquo;t do a very good job of separating interfaces from implementations. A  class definition specifies not only a class interface but also a fair number of implementation details. For example:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class Person {
public:
    Person(const std::string&amp;amp; name, cnost Data&amp;amp; birthday, const Address&amp;amp; addr);
    std::string name() const;
    std::string birthDate() const;
    std::string address() const;
    ...
private:
    std::string theName; // implementation detail
    Date theBirthdate;   // implementation detail
    Address theAddress;  // implementation detail
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here, to compile &lt;code&gt;Person&lt;/code&gt;, definitions for the data members &lt;code&gt;string&lt;/code&gt;, &lt;code&gt;Date&lt;/code&gt;, and &lt;code&gt;Address&lt;/code&gt; that &lt;code&gt;Person&lt;/code&gt; uses must be provided, typically through &lt;code&gt;#include&lt;/code&gt; directives:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;string&amp;gt;
#include &amp;quot;date.h&amp;quot;
#include &amp;quot;address.h&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Unfortunately, this inclusion sets up a compilation dependency between the file defining &lt;code&gt;Person&lt;/code&gt; and these header files. If any of these header files or the header files&amp;rsquo; dependent header files is changed, the file containing the &lt;code&gt;Person&lt;/code&gt; class must be recompiled, as must any files that use &lt;code&gt;Person&lt;/code&gt;. Such cascading compilation dependencies are annoying, but C++ insists on putting the implementation details of a class in the class definition - we can&amp;rsquo;t separate the implementation details of the class definition simply by forward-declaring everything like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;namespace std {
    class string; // incorrect way of forward declaration
}
class Date;  // forward declaration
class Address;  // forward declaration

class Person {
public:
    Person(const std::string&amp;amp; name, const Date&amp;amp; birthday, const Address&amp;amp; addr);
    std::string name() const;
    std::string birthDate() const;
    std::string address() const;
    ...
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;There&amp;rsquo;re two problems with this idea:&lt;br /&gt;
1. The minor one: &lt;code&gt;string&lt;/code&gt; is not a class but a &lt;code&gt;typedef&lt;/code&gt; for &lt;code&gt;basic_string&amp;lt;char&amp;gt;&lt;/code&gt;. Thus the forward declaration for &lt;code&gt;string&lt;/code&gt; is incorrect&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:1&#34;&gt;&lt;a href=&#34;#fn:1&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;.&lt;br /&gt;
2. The more significant one: compilers need to know the size of objects to allocate enough space (typically on the stack) when they see a difinition for object &lt;code&gt;p&lt;/code&gt;, so the implementation details can not be omited:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;```cpp
int main()
{
    ...
    Person p(params);  // define a Person
    ...
}
```
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The essence of minimizing compilation dependencies it to truly separate interface from implementation, which means we have to replace dependencies on &lt;em&gt;definitions&lt;/em&gt; with dependencies on &lt;em&gt;declarations&lt;/em&gt;.&lt;/p&gt;

&lt;h1 id=&#34;handle-classes&#34;&gt;Handle classes&lt;/h1&gt;

&lt;p&gt;One way to hide the object implementation is through a pointer, in which case compilers allocate only enough space for a &lt;code&gt;pointer&lt;/code&gt; when an object is defined:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;int main()
{
    ...
    Person *p;  // define a pointer to a Person
    ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is how languages like Smaltalk and Java deal with the object difinition, which is also totally legal in C++: we simply separate &lt;code&gt;Person&lt;/code&gt; into two classes, one offering only an interface, the other implementing that interface:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;string&amp;gt;  // standard library components
#include &amp;lt;memory&amp;gt;  // for tr1::shared_ptr
class PersonImpl;  // forward decl of Person impl. class
class Date;        // forward decls of classes used in Person interface
class Address;

class Person{
public:
    Perosn(const std::string&amp;amp; name, const Date&amp;amp; birthday, const Address&amp;amp; addr);
    std::string name() const;
    std::string birthDate() const;
    std::string address() const;
    ...
private:  // ptr to implementation
    std::tr1::shared_ptr&amp;lt;PersonImpl&amp;gt; pImpl; // see item 13 for shared_ptr
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This design is often said to be using the &lt;em&gt;pimpl idiom&lt;/em&gt; (&amp;ldquo;pointer to implementation&amp;rdquo;). With such a design, clients of &lt;code&gt;Person&lt;/code&gt; are divorced from the details of dates, address, and persons. Now, even if the implementations of those classes have been modified, &lt;code&gt;Person&lt;/code&gt;&amp;rsquo;s clients need not recompile.&lt;/p&gt;

&lt;p&gt;In summary:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Avoid using objects when object references and poinnters will do (defining &lt;em&gt;objects&lt;/em&gt; of a type necessitates the presence of the type&amp;rsquo;s definition).&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Depend on class declarations instead of class definitions whenever we can:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class Date:  // class declaration
Date today();  // fine without class definition
void clearAppointments(Date d); // fine. No definition of Date is needed
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Of course, if anybody &lt;em&gt;calls&lt;/em&gt; function &lt;code&gt;today&lt;/code&gt; or &lt;code&gt;clearAppointments&lt;/code&gt;, &lt;code&gt;Date&lt;/code&gt;&amp;rsquo;s definition must have been seen prior to the call. But the point here is:&lt;/p&gt;

&lt;p&gt;By moving the onus of providing class definitions from our library header file of function &lt;em&gt;declarations&lt;/em&gt; to clients&amp;rsquo; files containing function &lt;em&gt;calls&lt;/em&gt;, the client dependiencies on type definitions they don&amp;rsquo;t really need could be eliminated (especially when we have a library containing dozens of function declarations that not everybody calls all of them).&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Provide separate header files for declarations and definitions.&lt;/p&gt;

&lt;p&gt;Instead of forward-declaring something, library clients should always &lt;code&gt;#include&lt;/code&gt; a declaration file, so library authors should provide two header files: one for declarations, the other for definitions. For example,&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;quot;detefwd.h&amp;quot;   // header file declaring (but not defining) class Date
Date today();  // as before
void clearAppointments(Date d);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here, the name of the declaration-only header file &amp;ldquo;datefwd.h&amp;rdquo; is based on the header &lt;iosfwd&gt;&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:2&#34;&gt;&lt;a href=&#34;#fn:2&#34;&gt;2&lt;/a&gt;&lt;/sup&gt; from the standard C++ library (item 54).&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;To employ the pimpl idiom, we just let forward all the function calls in the &lt;em&gt;handle class&lt;/em&gt; &lt;code&gt;Person&lt;/code&gt; to the corresponding implementation class &lt;code&gt;PersonImpl&lt;/code&gt;, which will do the real work. Below is the implementation of &lt;code&gt;Person&lt;/code&gt;&amp;rsquo;s member functions:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;quot;Person.h&amp;quot;      // #inclue Person&#39;s class definition
#include &amp;quot;PersonImpl.h&amp;quot;  // #include PersonImpl&#39;s class definition to call its member functions;
                         // note that interfaces of PersonImpl and Person are identical
Person::Person(const std::string&amp;amp; name, const Date&amp;amp; birthday, const Address&amp;amp; addr)
:pImpl(new PersonImpl(name, birthday, addr))
{}

std::string Person::name() const
{
    return pImpl-&amp;gt;name();
}
...
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;interface-classes&#34;&gt;Interface classes&lt;/h1&gt;

&lt;p&gt;An alternative approach is to make &lt;code&gt;Person&lt;/code&gt; a special kind of abstract base class called an &lt;em&gt;Interface class&lt;/em&gt;, which typically has no data members, no constructors, a virtual destructor (item 7), and a set of pure virtual funcitons that specify the interface. The similar concept could be found in Java and .NET, except that C++ doesn&amp;rsquo;t impose the restrictions on Interface classes as Java and .NET do&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:3&#34;&gt;&lt;a href=&#34;#fn:3&#34;&gt;3&lt;/a&gt;&lt;/sup&gt;.&lt;/p&gt;

&lt;p&gt;An interface class for &lt;code&gt;Person&lt;/code&gt; looks like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class Person {
public:
    virtual ~Person();

    virtual std::string name() const = 0;
    virtual std::string birthDate() const = 0;
    virtual std::string address() const = 0;
    ...
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Like clients of Handle classes, clients of Interface classes need not recompile unless the Interface class&amp;rsquo;s interface is modified.&lt;/p&gt;

&lt;p&gt;In order to use Interface classes:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;clients need to program in terms of &lt;code&gt;Person&lt;/code&gt; pointers and references, for &lt;code&gt;Person&lt;/code&gt;, which contains pure virtual functions, can not be instantiated&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;typically, clients create new &lt;code&gt;Person&lt;/code&gt; objects by calling factory functions (item 13) or &lt;em&gt;virtual constructors&lt;/em&gt;, which return pointers (preferably smart pointers, item 18) to dynamically allocated objects of derived classes that support the interface. Such functions are often declared &lt;code&gt;static&lt;/code&gt; inside the Interface class:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class Person {
public:
    ...
    static std::tr1::shared_ptr&amp;lt;Person&amp;gt;  // return a tr1::shared_ptr to a new
    create(const std::string&amp;amp;  name,     // Person initialized with the 
           const Date&amp;amp; birthday,         // gien params
           const Address&amp;amp; addr);
    ...
};
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;std::string name;
Date dateOfBirth;
Address address;
...
// create an object supporting the Person interface
std::tr1::shared_ptr&amp;lt;Person&amp;gt; pp(Person::create(name, dateOfBirth, address));
...
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;one way to implement the Interface class &lt;code&gt;Person&lt;/code&gt; is to define a concrete derived class that inherits interface specification from &lt;code&gt;Person&lt;/code&gt;, and then implement the functions in the interface:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class RealPerson: public Person {
public:
    RealPerson(const std::string&amp;amp; name, const Date&amp;amp; birthday, const Address&amp;amp; addr)
    : theName(name), theBirthDate(birthday), theAddress(addr)
    {}
    virtual ~RealPerson(){}

    std::string name() const;    
    std::string birthDate() const;
    std::string address() const;
private:
    std::string theName;
    std::string theBirthDate;
    Address theAddress;
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then it is trivial to write &lt;code&gt;Person::create&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;std::tr1::shared_ptr&amp;lt;Person&amp;gt; 
Person::create(const std::string&amp;amp; name, const Date&amp;amp; birthday, const Address&amp;amp; addr)
{
    return std::tr1::shared_ptr&amp;lt;Person&amp;gt;(new RealPerson(name, birthday, addr));
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Of course, a more realistic implementation of &lt;code&gt;Person::create&lt;/code&gt; would create different types of derived class objects, depending on the values of additional parameters.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;another way to implement an Interface class involves multiple inheritance, a topic explored in item 40.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;cost-of-decoupling-interfaces-from-implementations&#34;&gt;Cost of decoupling interfaces from implementations&lt;/h1&gt;

&lt;p&gt;The cost of Handle classes and Interface classes is the usual one in computer science: it costs us some speed at runtime, plus some additional memory per object. In addition, neither of them can get much use out of inline functions (item 30), since inline functions typically exists in header files while this item talks about how to hide implementation details like function bodies in header file.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;For Handle classes&lt;/strong&gt;:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;impact on runtime speed:

&lt;ul&gt;
&lt;li&gt;member functions have to go through the implementation pointer to get to the object&amp;rsquo;s data, which adds one level of indirection per access;&lt;/li&gt;
&lt;li&gt;the implementation object is dynamically allocated during the initialization of implementation pointer, which incurs the overhead of dynamic memory allocation and subsequent deallocation, as well as possible &lt;code&gt;bad_alloc&lt;/code&gt; (out-of-memory) exception.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;impact on memory:

&lt;ul&gt;
&lt;li&gt;we have to add the size of the implementation pointer to the amount of memory required by each object.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;For Interface classes&lt;/strong&gt;:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;impact on runtime speed:

&lt;ul&gt;
&lt;li&gt;every function call is virtual, so we pay the cost of an indirect jump for each function call (item 7).&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;impact on memory:

&lt;ul&gt;
&lt;li&gt;object derived from the Interface class must contain a virtual table pointer (item 7), which may increase the amount of memory needed to store an object (if the Interface class is the exclusive source of virtual functions for the object)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Despite all the costs, consider using these techniques in an evolutionary manner:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;use Handle classes and Interface classes during development to minimize the impact on clients when implementations change&lt;/li&gt;
&lt;li&gt;replace Handle classes and Interface classes with concrete classes for production use when the difference in speed and/or size is significant enough to justify the increased coupling between classes.&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;footnotes&#34;&gt;

&lt;hr /&gt;

&lt;ol&gt;
&lt;li id=&#34;fn:1&#34;&gt;The proper forward declaration of &lt;code&gt;string&lt;/code&gt; is substantiallly complex, because it involves additional templates. Anyway, we shouldn&amp;rsquo;t manually decalre parts of the standard library. Instead, user the proper &lt;code&gt;#include&lt;/code&gt;s and be done with it.
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:1&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:2&#34;&gt;&lt;iosfwd&gt; contains declarations of iostream components whose corresponding definitions are in several different headers, including &lt;sstream&gt;, &lt;streambuf&gt;, &lt;fstream&gt;, and &lt;iostream&gt;. Note that it still makes sense to provide declaration-only headers for templates: although in many build environments, template definitions are typically found in header files (item 30), some build environments still allow template definitons to be in non-headre files; and C++ also offers the &lt;code&gt;export&lt;/code&gt; keyword to allow the separation of template declarations from template definitions (unfortunately compiler support for &lt;code&gt;export&lt;/code&gt; is scanty).
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:2&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:3&#34;&gt;Neither Java nor .NET allow data members or function implementations in Interfaces, but C++ allows so, which could be useful in flexibility. For example, as item 36 explains, the implementation of non-virtual functions should be the same for all classes in a hierarchy, so it makes sense to implement such functions as part of the Interface class.
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:3&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;</description>
    </item>
    
    <item>
      <title>Item-30 Understand ins and outs of inlining</title>
      <link>http://nianze.tk/2018/02/ins-and-outs-of-inlining/</link>
      <pubDate>Wed, 21 Feb 2018 00:00:00 +0000</pubDate>
      
      <guid>http://nianze.tk/2018/02/ins-and-outs-of-inlining/</guid>
      <description>&lt;p&gt;Limit most inlining to small, frequently called functions to facilitate debugging and binary upgradability, minimize potential code bloat, and maximize the chances of greater program speed.

&lt;!-- toc --&gt;&lt;/p&gt;

&lt;h1 id=&#34;performance-benifits&#34;&gt;Performance benifits&lt;/h1&gt;

&lt;p&gt;Inline functions have some wonderful advantages:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;They act like functions.&lt;/li&gt;
&lt;li&gt;Yet we call them without having to incur the overhead of a function call.&lt;/li&gt;
&lt;li&gt;Compilers might perfom context-specific optimizations (such as stretches of the code) on the body of the inline function thanks to the lack &amp;ldquo;outlined&amp;rdquo; function call&lt;/li&gt;
&lt;li&gt;If an inline function body is &lt;em&gt;very&lt;/em&gt; short, the code generated for the function body may be smaller than the code generated for a function call, leading to &lt;em&gt;smaller&lt;/em&gt; object code and a higher instruction cache hit rate.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;However, on the other hand, it is also likely to increase the size of our object code. Overzealous inlining can give rise to programs too big for the available space on machines with limited memory. Even with virtual memory, inline-induced code bloat can lead to additional paging, a reduced instruction cache hit rate, and the performance penalties that accompany these things.&lt;/p&gt;

&lt;h1 id=&#34;details-on-inline-functions&#34;&gt;Details on inline functions&lt;/h1&gt;

&lt;p&gt;There are two ways to give such a request: implicitly or explicitly:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Implicitly inline request&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class Person {
public:
    ...
    int age() const { return theAge; } // an implicit inline request
    ...
private:
    int theAge;
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Apart from the member functions, we can also define friend functions inside classes (item 46), resulting to implicitly inline declaration.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Explicitly inline request (and its relationship with template)&lt;/p&gt;

&lt;p&gt;We can explicitly daclare an inline function with the &lt;code&gt;inline&lt;/code&gt; keyword, such as how the standard &lt;code&gt;max&lt;/code&gt; template from &lt;code&gt;&amp;lt;algorithm&amp;gt;&lt;/code&gt; is implemeted:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;template&amp;lt;typename T&amp;gt;   // an explicit inline
inline const T&amp;amp; std::max(const T&amp;amp; a, const T&amp;amp; b) // request:: std::max is preceded by &amp;quot;inline&amp;quot;
{ return a &amp;lt; b ? b : a;}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It&amp;rsquo;s true that both template and inline functions are typically defined in header files, but this doesn&amp;rsquo;t mean that function templates must be inline. In fact, template instantiation is independent of inlining:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;inline functions must typically be in header files, because most build environments do inlining during compilation. In order to replace a function call with the body of the called function, compilers must know waht the function looks like &lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:1&#34;&gt;&lt;a href=&#34;#fn:1&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;.&lt;/li&gt;
&lt;li&gt;templates are typically in header file, because compilers need to know what a template looks like in order to instantiate it when it&amp;rsquo;s used &lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:2&#34;&gt;&lt;a href=&#34;#fn:2&#34;&gt;2&lt;/a&gt;&lt;/sup&gt;.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Thus, when we&amp;rsquo;re writing a template:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;if we belive that all the functions instantiated from the template should be inlined, declare the template &lt;code&gt;inline&lt;/code&gt; just like what&amp;rsquo;s done with the &lt;code&gt;std::max&lt;/code&gt; implamentation above;&lt;/li&gt;
&lt;li&gt;if we have no reason to want inlined after considering its cost and potential code bloat (which is particularly important for template authors - see item 44), avoid declaring the template inline (either explicitly or implicitly)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;causes-of-un-inlined-inline-function&#34;&gt;Causes of un-inlined inline function&lt;/h2&gt;

&lt;p&gt;Bear in mind that &lt;code&gt;inline&lt;/code&gt; is a &lt;em&gt;request&lt;/em&gt; to compilers, rather than a command, so compilers may ignore it. Whether a given inline function is actually inlined depends on the build environment we&amp;rsquo;re using - primarily on the compiler, and most compilers have a diagnostic level that will result in a warning (item 53) if they fail to inline a function we&amp;rsquo;ve asked them to. When they refuse to inline a function, the typical reasons may be:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;compilers deem the function too complicated (e.g., those containing loogs or are recursive)&lt;/li&gt;
&lt;li&gt;the function is virtual (&lt;code&gt;virtual&lt;/code&gt; means runtime, while &lt;code&gt;inline&lt;/code&gt; usually happens before execution)&lt;/li&gt;
&lt;li&gt;when the program will take the address of an inline function:&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;inline void f(){...} // assume compilers are willing to inline calls to f
void (*pf)() = f;    // pf points to f
...
f();                 // this call will be inlined, for it&#39;s a &amp;quot;normal&amp;quot; call
pf();                // this call probably won&#39;t be, for it&#39;s through a function pointer
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;inline-constructors-and-destructors&#34;&gt;Inline constructors and destructors?&lt;/h2&gt;

&lt;p&gt;Note that even if we never use function pointers, sometimes compilers will generate those pointers: compilers may generate out-of-line copies of constructors and destructors so that they can get pointers to those functions for use during construction and destruction of objects in arrays. Let alone that constructors and destructors are often worse candidates of inlining than a casual examination would indicate:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class Base {
public:
    ...
private:
    std::string bm1, bm2;  // base members 1 and 2
};
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class Derived: public Base {
public:
    Derived(){}   // Derived&#39;s ctor is empty, or is it?
    ...
private:
    std::string dm1, dm2, dm3;  // derived members 1,2,3
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The constructor of &lt;code&gt;Derived&lt;/code&gt; seems empty, so it may seem a good candidate for inlining. But looks can be deceiving:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;C++ makes various guarantees about object construction and corresponding destruction. To name a few: when we create an object, each base class of and each data member in that object is automatically constructed; if an exception is thrown during construction, any parts of the object that have already been fully constructed are automatically destroyed. Similar but reverse process will occur when an object is destroyed.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Therefore, in the example above, extra code will be generated by compilers and added into the empty &lt;code&gt;Derived&lt;/code&gt; constructor in order to offer those guarantees, ending up with some code equivalent to the following conceptual implementation (the real one will certainly be more sophisticated):&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;Derived::Derived()  // conceptual impl. of &amp;quot;empty&amp;quot; Derived ctor
{
    Base::Base();  // init. Base part

    try { dm1.std::string::string(); } // try to construct dm1
    catch (...) {       // if it throws
        Base::~Base();  // destroy base class part and
        throw;          // propagate the exception
    }

    try { dm2.std::string::string();} // try to construct dm2
    catch(...) {                      // if it throws
        dm1.std::string::~string();   // destroy dm1,
        Base::~Base();                // destroy base class part
        throw;                        // and propagate the exception
    }

    try { dm3.std::string::string();}  // try to construct dm3
    catch(...) {                       // if it throws
        dm1.std::string::~string();    // destroy dm1,
        dm1.std::string::~string();    // destroy dm2,
        Base::~Base();                 // destroy base class part
        throw;                         // and propagate the exception
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The same reasoning applies to the &lt;code&gt;Base&lt;/code&gt; constructor, so if &lt;code&gt;Base&lt;/code&gt;&amp;rsquo;s constructor is inlined, and &lt;code&gt;string&lt;/code&gt; constructor also happens to be inlined, the &lt;code&gt;Derived&lt;/code&gt; constructor will gain &lt;em&gt;five&lt;/em&gt; copies of &lt;code&gt;string&lt;/code&gt;&amp;rsquo;s constructor, one for each of the five strings in a &lt;code&gt;Derived&lt;/code&gt; object - that is a big code bloat. Similar considerations apply to &lt;code&gt;Derived&lt;/code&gt;&amp;rsquo;s destructor.&lt;/p&gt;

&lt;h1 id=&#34;other-costs-of-inlining&#34;&gt;Other costs of inlining&lt;/h1&gt;

&lt;p&gt;Apart from the cost of possible code bloat, there are other impact of declaring functions &lt;code&gt;inline&lt;/code&gt;:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;on binary upgradability&lt;/strong&gt;: for library designers, it&amp;rsquo;s impossible to provide binary upgrades to the client visible inline functions in a library, after clients of the library compile the body of &lt;code&gt;inline&lt;/code&gt; function &lt;code&gt;f&lt;/code&gt; into their application. Once the imlementation of &lt;code&gt;f&lt;/code&gt; changes, all clients who&amp;rsquo;ve used &lt;code&gt;f&lt;/code&gt; must recompile.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;on debugging&lt;/strong&gt;: most debuggers have trouble with inline functions: after all, it is hard to set a breakpoint in a function that isn&amp;rsquo;t there&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:3&#34;&gt;&lt;a href=&#34;#fn:3&#34;&gt;3&lt;/a&gt;&lt;/sup&gt;.&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&#34;to-inline-or-not-to-inline&#34;&gt;To inline or not to inline?&lt;/h1&gt;

&lt;p&gt;In summary, the logical strategy of determining which functions should be declared inline and which should not:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;initially don&amp;rsquo;t inline anything&lt;/li&gt;
&lt;li&gt;detect those functions that must be inline (item 46) or are truly trivial (such as &lt;code&gt;Person::age&lt;/code&gt; in this item), inline them cautiously as a hand-applied optimization&lt;/li&gt;
&lt;li&gt;as the empirically determined rule of 80-20 suggests: identify the 20% of your code that can increase your program&amp;rsquo;s overall performance, and try to tweak those critical functions with &lt;code&gt;inline&lt;/code&gt; or other techniques&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;footnotes&#34;&gt;

&lt;hr /&gt;

&lt;ol&gt;
&lt;li id=&#34;fn:1&#34;&gt;There are exceptions: some build environments can inline during linking, and a few can actually inline at runtime (e.g., managed environments based on the .NET Common Language Infrastructure - &lt;code&gt;CLI&lt;/code&gt;). Of course, such exceptions are not the rule, and inlining in most C++ programs is a compile-time activity.
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:1&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:2&#34;&gt;Again, some build environments perform template instantiation during linking. However, compile-time instantiation is more common.
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:2&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:3&#34;&gt;Some build environments manage to support debugging of inlined functions, but many environments simply disable inlining for debug builds.
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:3&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;</description>
    </item>
    
    <item>
      <title>Item-29 Strive for exception-safe code</title>
      <link>http://nianze.tk/2018/02/strive-for-exception-safe-code/</link>
      <pubDate>Tue, 20 Feb 2018 18:23:38 -0500</pubDate>
      
      <guid>http://nianze.tk/2018/02/strive-for-exception-safe-code/</guid>
      <description>&lt;p&gt;Exception-safe functions leak no resources and allow no data structures to become corrupted, even when exceptions are thrown. Such functions offer the basic, strong, and nothrow guarantees.

&lt;!-- toc --&gt;&lt;/p&gt;

&lt;p&gt;For exception-safe functions, there are two requirements when an exception is thrown:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Leak no resources&lt;/li&gt;
&lt;li&gt;Don&amp;rsquo;t allow data structures to become corrupted&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Specifically, from the perspective of data structure corruption, exception-safe functions must offer one of three guarantees below from the weakest to the strongest:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;The &lt;strong&gt;basic guarantee&lt;/strong&gt; promises that if an exception is thrown, everything in the program remains in a valid state - all class invariants are satisfied, but the exact state of the program may not be predictable.&lt;/li&gt;
&lt;li&gt;The &lt;strong&gt;strong guarantee&lt;/strong&gt; promises that if an exception is thrown, the state of the program is unchanged - calls to such functions are &lt;em&gt;atomic&lt;/em&gt; in the sense that if they succeed, they successd completely, and if they fail, the program state is as if they&amp;rsquo;d never been called.&lt;/li&gt;
&lt;li&gt;The &lt;strong&gt;nothrow guarantee&lt;/strong&gt; promises never to throw exceptions - all operators on built-in types (e.g., &lt;code&gt;int&lt;/code&gt;s, pointers, etc.) are nothrow. This is a critical building block of exception-safe code.&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&#34;example&#34;&gt;Example&lt;/h1&gt;

&lt;p&gt;With all these terminologies bear in mind, let&amp;rsquo;s see an example representing exception-unsafe style. Suppose there&amp;rsquo;s a class for GUI menus with background images, and it will be used in a threaded environment, so it has a mutex for concurrency control:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class PrettyMenu {
public:
    ...
    void changeBackGround(std::istream&amp;amp; imgSrc); // change background image
private:
    Mutex mutex;      // mutex for this obejct
    Image *bgImage;   // current background image
    int imageChanges; // # of times image has been changed
};
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;void PrettyMenu::changeBackground(std::istream&amp;amp; imgSrc)
{
    lock(&amp;amp;mutex);   // acquire mutex (item 14)
    delete bgImage; // get rid of old background
    ++imageChanges; // update image change count
    bgImage = new Image(imgSrc); // install new background
    unlock(&amp;amp;mutex); // release mutex 
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Firstly, the code above is likely to encounter resource leak, because if the &lt;code&gt;new Image(imgSrc)&lt;/code&gt; expression yields an exception, the call to &lt;code&gt;unlock&lt;/code&gt; never gets executed, and the mutex is held forever.&lt;/p&gt;

&lt;p&gt;Secondly, this function guarantees none of the 3 promises in terms of data structure corruption above: when &lt;code&gt;new Image(Src)&lt;/code&gt; throws, &lt;code&gt;bgImage&lt;/code&gt; is left pointing to a deleted object, and &lt;code&gt;imageChanges&lt;/code&gt; has been increamented before the new image has been installed, resulting to invalid object state.&lt;/p&gt;

&lt;h2 id=&#34;resource-leak&#34;&gt;Resource leak&lt;/h2&gt;

&lt;p&gt;To address the resource leak issue, we can use objects to manage resources (item 13), and take advantage of &lt;code&gt;Lock&lt;/code&gt; class to ensure that mutexes are released in a timely fashion (item 14):&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;void PrettyMenu::changeBackground(std::istream&amp;amp; imgSrc)
{
    Lock ml(&amp;amp;mutex);   // item 14: acquire mutex and ensure its later release
    delete bgImage; 
    ++imageChanges; // update image change count
    bgImage = new Image(imgSrc); // install new background
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;data-structure-corruption&#34;&gt;Data structure corruption&lt;/h2&gt;

&lt;p&gt;To address the issue of data structure corruption, we may need to determine which guarantee to offer. As a general rule,&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;we want to offer &lt;em&gt;the strongest&lt;/em&gt; guarantee that&amp;rsquo;s &lt;em&gt;practical&lt;/em&gt;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Note the word &lt;em&gt;practical&lt;/em&gt;. We definitely want to offer nothrow guarantee for every functions we write, but it&amp;rsquo;s hard to keep such a promise - to name a common exception: anything using dynamically allocated memory (e.g., all STL containers) runs the risk of a &lt;code&gt;bad_alloc&lt;/code&gt; exception if it can&amp;rsquo;t find enough memory to satisfy a request (item 49). For most functions, the choice for us is between the basic and strong guarantees.&lt;/p&gt;

&lt;p&gt;In the case of &lt;code&gt;changeBackground&lt;/code&gt;, &lt;em&gt;almost&lt;/em&gt; offering the strong guarantee is not difficult:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;firstly, we change the type of &lt;code&gt;bgImage&lt;/code&gt; data member in &lt;code&gt;PrettyMunu&lt;/code&gt; from a built-in &lt;code&gt;Image*&lt;/code&gt; pointer to smart pointer such as &lt;code&gt;tr1::shraed_ptr&lt;/code&gt; (item 13), which benefits us with

&lt;ol&gt;
&lt;li&gt;preventing resource leaks&lt;/li&gt;
&lt;li&gt;offering strong exception safety guarantee&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;secondly, we reorder the statements so that we don&amp;rsquo;t increment &lt;code&gt;imageChanges&lt;/code&gt; until the image has been changed.&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class PrettyMenu {
    ...
    std::tr1::shared_ptr&amp;lt;Imgae&amp;gt; bgImage;
    ...
};
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;void PrettyMenu::changeBackground(std::istream&amp;amp; imgSrc)
{
    Lock ml(&amp;amp;mutex);
    bgImage.reset(new Image(imgSrc)); // replace bgImage&#39;s internal pointer with the
                                      // result of the &amp;quot;new Image&amp;quot; expression
    ++imageChanges;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note how the use of resource magangement object (i.e., the smart pointer here) helps:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;The &lt;code&gt;tr1::shared_ptr::reset&lt;/code&gt; function will be called only if its parameter (the result of &lt;code&gt;new Image(imgSrc)&lt;/code&gt;) is successfully created&lt;/li&gt;
&lt;li&gt;The &lt;code&gt;delete&lt;/code&gt; operation for the old image is inside the &lt;code&gt;reset&lt;/code&gt;, so if the &lt;code&gt;reset&lt;/code&gt; function is never entered (the program somehow fails to create new image), the deletion of the old image will never take place&lt;/li&gt;
&lt;li&gt;As a result, the deletion takes place only if the new image is successfully created&lt;/li&gt;
&lt;li&gt;We don&amp;rsquo;t need to manually &lt;code&gt;delete&lt;/code&gt; the old image, and the length of &lt;code&gt;changeBackground&lt;/code&gt; reduces&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;After these two changes, &lt;code&gt;changeBackground&lt;/code&gt; &lt;em&gt;almost&lt;/em&gt; offer the strong exception safety guarantee. The only weakness now is the parameter &lt;code&gt;imgSrc&lt;/code&gt;: if the &lt;code&gt;Image&lt;/code&gt; constructor throws an exception, it&amp;rsquo;s possible that the read marker for the input stream has been moved, which is a change in state visible to the rest of the program, leading to offering only the basic exception safety guarantee.&lt;/p&gt;

&lt;h3 id=&#34;copy-and-swap-strategy&#34;&gt;Copy-and-&lt;code&gt;swap&lt;/code&gt; strategy&lt;/h3&gt;

&lt;p&gt;There actually is a general design strategy for offering the strong guarantee:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;copy and swap&lt;/strong&gt; strategy:&lt;br /&gt;
Make a copy of the object we want to modify, then make all needed changes to the copy;&lt;br /&gt;
- If all the changes have been successfully completed, swap the modified object with the original in a non-throwing operation (item 25);&lt;br /&gt;
- If any of the modifying operations throws an exception, the original object remains unchanged.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;The strategy is usually implemented by putting all the per-object data from the &amp;ldquo;real&amp;rdquo; object into a separate implementation object, then giving the real object a pointer to its implementation object (know as the &amp;ldquo;pimpl idiom&amp;rdquo;, item 31). For &lt;code&gt;PrettyMenu&lt;/code&gt;, it would look something like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;struct PMImpl {  // PMIpml = &amp;quot;PrettyMenu Impl.&amp;quot;
    std::tr1::shared_ptr&amp;lt;Image&amp;gt; bgImage; 
    int imageChanges; 
};

class PrettyMenu {
...
private:
    Mutex mutex;
    std::tr1::shared_ptr&amp;lt;PMImpl&amp;gt; pImpl;
};
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;void PrettyMenu::changeBackground(std::istream&amp;amp; imgSrc)
{
    using std::swap;  // item 25
    Lock ml(&amp;amp;mutex);  // acquire the mutex
    
    std::tr1::shared_ptr&amp;lt;PMImpl&amp;gt; pNew(new PMImpl(*pImpl));  // copy obj. data
    pNew-&amp;gt;bgImage.reset(new Image(imgSrc)); // modify the copy
    ++pNew-&amp;gt;imageChanges;
    swap(pImpl, pNew);  // swap the new data into place
} // release the mutex
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We don&amp;rsquo;t have to make the struct &lt;code&gt;PMImpl&lt;/code&gt; as a class, because the encapsulation of &lt;code&gt;PrettyMenu&lt;/code&gt; data is assured by &lt;code&gt;pImpl&lt;/code&gt; being private, and it is more convenient to use struct. If desired, &lt;code&gt;PMImpl&lt;/code&gt; could be nested inside &lt;code&gt;PrettyMenu&lt;/code&gt; when considering packaging issues.&lt;/p&gt;

&lt;h3 id=&#34;side-effects-and-efficiency&#34;&gt;Side effects and efficiency&lt;/h3&gt;

&lt;p&gt;Even with the help of copy-and-&lt;code&gt;swap&lt;/code&gt; strategy, there are two possible reasons that downgrade the overall exception safety level from strong to basic: &lt;em&gt;side effects&lt;/em&gt; and &lt;em&gt;efficiency&lt;/em&gt;.&lt;/p&gt;

&lt;h4 id=&#34;1-side-effects&#34;&gt;1. Side effects&lt;/h4&gt;

&lt;p&gt;Suppose &lt;code&gt;someFunc&lt;/code&gt; uses copy-and-&lt;code&gt;swap&lt;/code&gt; and includes calls to two other functions, &lt;code&gt;f1&lt;/code&gt; and &lt;code&gt;f2&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;void someFunc()
{
    ...    // make copy of local state
    f1();
    f2();
    ...    // swap modified state into place
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Apparently, if &lt;code&gt;f1&lt;/code&gt; or &lt;code&gt;f2&lt;/code&gt; is less than strongly exception-safe, it will be hard for &lt;code&gt;someFunc&lt;/code&gt; to be strong exception-safe. For example, suppose &lt;code&gt;f1&lt;/code&gt; offers only the basic guarantee, in order to offer the strong guarantee for &lt;code&gt;someFunc&lt;/code&gt;, we have to write code to determine the state of the entire program before calling &lt;code&gt;f1&lt;/code&gt;, catch all exceptions from &lt;code&gt;f1&lt;/code&gt;, and then store the original state. It&amp;rsquo;s complicated, but it&amp;rsquo;s doable. However, even if &lt;code&gt;f1&lt;/code&gt; and &lt;code&gt;f2&lt;/code&gt; are both strongly exception safe, as long as there are side effects on non-local data, it&amp;rsquo;s much harder to offer the strong guarantee.&lt;/p&gt;

&lt;p&gt;For example, if a side effect of calling &lt;code&gt;f1&lt;/code&gt; is that a database is modified, and there is, in general, no way to undo a database modification that has already been committed; so after successfully calling &lt;code&gt;f1&lt;/code&gt;, if &lt;code&gt;f2&lt;/code&gt; then throws an exception, the state of the program is not the same as it was when calling &lt;code&gt;someFunc&lt;/code&gt;, even though &lt;code&gt;f2&lt;/code&gt; didn&amp;rsquo;t change anything.&lt;/p&gt;

&lt;h4 id=&#34;2-efficiency&#34;&gt;2. Efficiency&lt;/h4&gt;

&lt;p&gt;Copy and &lt;code&gt;swap&lt;/code&gt; strategy requires making a copy of each object to be modified, which takes time and space we may be unable or unwilling to make available. It&amp;rsquo;s just not practical 100% of the time when we want to offer the strong guarantee.&lt;/p&gt;

&lt;p&gt;When it&amp;rsquo;s not, we&amp;rsquo;ll have to offer the basic guarantee. In practice, we can usually offer the strong guarantee for some functions, but the const in efficiency or complexity will make it untenable for many others. For those functions, the basic guarantee is a perfectly resonable choice, as long as we&amp;rsquo;ve made a reasonable effort to offer the strong guarantee whenever it&amp;rsquo;s practical.&lt;/p&gt;

&lt;h1 id=&#34;in-practice&#34;&gt;In practice&lt;/h1&gt;

&lt;p&gt;A software system is either exception-safe or it&amp;rsquo;s not. There&amp;rsquo;s no such thing as a partially exception-safe system. If a system has even a single function that&amp;rsquo;s not exception-safe, the system as a whole is not exception-safe. Unfortunately, much C++ legacy code was written without exception safety in mind, so many system incorporating legacy code today are not exception-safe.&lt;/p&gt;

&lt;p&gt;There&amp;rsquo;s no reason to perpetuate this state of affairs. When writing new code or modifying existing code, think carefully about how to make it exception-safe:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;begin by using objects to manage resources to prevent resource leaks&lt;/li&gt;
&lt;li&gt;follow by determining which of the three exception safety guarantees is the strongest we cound practically offer for each function, settling for no guarantee only if calls to legacy code leave us no choice.&lt;/li&gt;
&lt;li&gt;Document our decisions, both for clients of our functions and for future maintainers - a function&amp;rsquo;s exception-safety guaranteee is a visible part of its interface, so we should choose it as deliberately as we choose all other aspects of a function&amp;rsquo;s interface.&lt;/li&gt;
&lt;/ol&gt;</description>
    </item>
    
    <item>
      <title>Item-28 Avoid returning handles to object internals</title>
      <link>http://nianze.tk/2018/02/avoid-return-handles-to-obejct-internals/</link>
      <pubDate>Fri, 16 Feb 2018 12:26:14 -0500</pubDate>
      
      <guid>http://nianze.tk/2018/02/avoid-return-handles-to-obejct-internals/</guid>
      <description>&lt;p&gt;Avoid returning handles to object internals to increase encapsulation, help &lt;code&gt;const&lt;/code&gt; member functions act &lt;code&gt;const&lt;/code&gt;, and minimize the creation of dangling handles.
&lt;/p&gt;

&lt;p&gt;References, pointers, and iterators are all &lt;em&gt;handlers&lt;/em&gt; (ways to get at other objects), and returning a handle to an object&amp;rsquo;s internals always runs the risk of&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;compromising an object&amp;rsquo;s encapsulation&lt;/li&gt;
&lt;li&gt;making &lt;code&gt;const&lt;/code&gt; member functions act like non-&lt;code&gt;const&lt;/code&gt; ones, allowing an object&amp;rsquo;s state to be modified&lt;/li&gt;
&lt;li&gt;leading to dangling handles&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;To see how handlers result in these resks, let&amp;rsquo;s see an example.&lt;br /&gt;
Suppose we&amp;rsquo;re working with a rectangle class, represented by its upper left corner and lower right corner. To keep a &lt;code&gt;Rectangle&lt;/code&gt; object small, we decide that the corner points should be stored in an auxiliary struct that the &lt;code&gt;Rectangle&lt;/code&gt; points to:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class Point {  // class representing points
public:
    Point(int x, int y);
    ...
    void setX(int newVal);
    void setY(int newVal);
    ...
};
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;struct RectData {  // Rectangle corner point data
    Point ulhc;    // &amp;quot;upper left-hand corner&amp;quot;
    Point lrhc;    // &amp;quot;lower right-hand corner&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class Rectangle {
public:
    Point&amp;amp; upperLeft() const { return pData-&amp;gt;ulhc; }
    Point&amp;amp; lowerRight() const { return pData-&amp;gt;lrhc; }
    ...
private:
    std::tr1::shared_ptr&amp;lt;RectData&amp;gt; pData; // see item 13 for tr1::shared_ptr
    ...
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As item 20 suggests that  passing user-defined types by reference is typically more efficient than passing them by value, the two public member functions return references to the underlying &lt;code&gt;Point&lt;/code&gt; ojects. Yet this design is wrong, for it&amp;rsquo;s self-contradictory:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;on the one side, the two member functions are declared &lt;code&gt;const&lt;/code&gt;, indicating read-only access level of the point they return&lt;/li&gt;

&lt;li&gt;&lt;p&gt;on the other side, returning handles to private internal data lets callers be able to modify that internal data:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;Point coord1(0, 0);
Point coord3(100, 100);
const Rectangle rec(coord1, coord2); // rec is a const rectangle from (0,0) to (100,100)
rec.upperLeft().setX(50); // now (50,0) to (100,100)
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Apparently, by returning handles to the &lt;em&gt;private&lt;/em&gt; &lt;code&gt;ulhc&lt;/code&gt; and &lt;code&gt;lrhc&lt;/code&gt; through the &lt;em&gt;public&lt;/em&gt; member functions &lt;code&gt;upperLeft&lt;/code&gt; and &lt;code&gt;lowerRight&lt;/code&gt;, the overall access level of data member goes to &lt;code&gt;public&lt;/code&gt;, and the encapsulation decreases. This makes the risk 1 above.&lt;/p&gt;

&lt;p&gt;The second risk comes from the fact that if a &lt;code&gt;const&lt;/code&gt; member function returns a reference (or any other handles) to data associated with an object that is stored outside the object itself, the caller of the function can modify that data due to its fallout of the limitation of bitwise constness (item 3).&lt;/p&gt;

&lt;p&gt;You may think the two risks above may be eliminated by applying &lt;code&gt;const&lt;/code&gt; to the return types:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class Rectangle {
public:
    ...
    const Point&amp;amp; upperLeft() const { return pData-&amp;gt;ulhc; }
    const Point&amp;amp; lowerRight() const { return pData-&amp;gt;lrhc; }
    ...
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;With this altered design, the 2 problems above are indeed solved. Even so, the dangling handles in risk 3 are still possible.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Dangling handles: handles that refer to parts of objects that don&amp;rsquo;t exist any longer.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;In fact, function return values are the most common source of dangling handles. Consider a function that returns the bounding box for a GUI object in the form of a rectangle:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class GUIObject {...};
const Rectangle boundingBox(const GUIObject&amp;amp; obj); // returns a rectangle by value; see item 3 for why return type is const
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If client use this function like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;GUIObject *pgo;  // make pgo point to some GUIObject
...
const Point *pUpperLeft = &amp;amp;(boundingBox(*pgo).upperLeft()); // get a ptr to the upper left point of its bounding box
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is a good example for dangling handle. The call to &lt;code&gt;boundingBox&lt;/code&gt; will return a new, temporary &lt;code&gt;Rectangle&lt;/code&gt; object. Let&amp;rsquo;s call it &lt;em&gt;temp&lt;/em&gt;. &lt;code&gt;upperLeft&lt;/code&gt; will then be called on &lt;em&gt;temp&lt;/em&gt;, and that call will return a reference to an internal part of &lt;em&gt;temp&lt;/em&gt; (i.e., the upperLeft corner point), to which &lt;code&gt;pUpperLeft&lt;/code&gt; will then point. The tragedy comes at the end of the statement, when &lt;code&gt;boundongBox&lt;/code&gt;&amp;rsquo;s return value &lt;em&gt;temp&lt;/em&gt; is destroyed, and then it indirectly leads to the destruction of &lt;em&gt;temp&lt;/em&gt;&amp;rsquo;s upperLeft corner point, leaving &lt;code&gt;pUpperLeft&lt;/code&gt; pointing to an object that no longer exists.&lt;/p&gt;

&lt;p&gt;As long as a handle is being returned, we run the risk that the handle will outlive the object it refers to. But this doesn&amp;rsquo;t mean we should &lt;em&gt;never&lt;/em&gt; have a member function that returns a handle. Sometimes we have to - an exception is &lt;code&gt;operator[]&lt;/code&gt; in &lt;code&gt;string&lt;/code&gt; and &lt;code&gt;vector&lt;/code&gt;, which works by returning references to the data in the containers (item 3), and that data will be destroyed when the containers themselves are.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;P.S.: by the way, we generally think of an object&amp;rsquo;s &amp;ldquo;internals&amp;rdquo; as its data members, but member functions not accessible to the general public (&lt;code&gt;private&lt;/code&gt; and &lt;code&gt;protected&lt;/code&gt; ones) are part of an object&amp;rsquo;s internals, too. Thus it&amp;rsquo;s important not to return handles to them (i.e., never have a member function return a pointer to a less accessible member function), otherwise the access level will be that of the more accessible function, just like how the risk 1 shows us.&lt;/p&gt;
&lt;/blockquote&gt;</description>
    </item>
    
    <item>
      <title>Item-27 Minimize_casting</title>
      <link>http://nianze.tk/2018/02/minimize-casting/</link>
      <pubDate>Thu, 15 Feb 2018 17:43:53 -0500</pubDate>
      
      <guid>http://nianze.tk/2018/02/minimize-casting/</guid>
      <description>&lt;p&gt;Avoid casts and develop a cast-free alternative whenever practical, especially &lt;code&gt;dynamic_cast&lt;/code&gt; in performance-sensitive code.
&lt;/p&gt;

&lt;p&gt;Casts subvert the C++ type system, so it is a feature we want to approach with great respect.&lt;/p&gt;

&lt;h3 id=&#34;cast-style&#34;&gt;Cast style&lt;/h3&gt;

&lt;p&gt;There are three different ways to write the same cast:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;C-style casts:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;(T) expression // cast expression to be of type T
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Function-style casts&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;T(expression)  // There&#39;s no difference in meaning between C-style and function-style casts. 
               // Both of them are old-style casts
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;C++-style casts (new-style casts)&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;const_cast&amp;lt;T&amp;gt;(expression)
dynamic_cast&amp;lt;T&amp;gt;(expression)
reinterpret_cast&amp;lt;T&amp;gt;(expression)
static_cast&amp;lt;T&amp;gt;(expression)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Each serves a distinct purpose:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;const_cast&lt;/code&gt; is used to cast away the constness of objects, which is the only C++-style cast that can do this.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;dynamic_cast&lt;/code&gt; is primarily used to perform &amp;ldquo;safe downcasting,&amp;rdquo; i.e., to determine whether an object is of a particular type in an inheritance hierarchy. This is the only cast that cannot be performed using the old-style syntax. It is also the only cast that may have a significant runtime cost.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;reinterpret_cast&lt;/code&gt; in intended for low-level casts that yield implementation-dependent (i.e., unportable) results, e.g., casting a pointer to an &lt;code&gt;int&lt;/code&gt;. Item 50 shows once its usage.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;static_cast&lt;/code&gt; is used to force implicit conversions (e.g., non-&lt;code&gt;const&lt;/code&gt; object to &lt;code&gt;const&lt;/code&gt; object (item3), &lt;code&gt;int&lt;/code&gt; to &lt;code&gt;double&lt;/code&gt;, etc.) as well as some reverse of such conversions (e.g., &lt;code&gt;void*&lt;/code&gt; pointers to typed pointers, pointer-to-base to pointer-to-derived), but it cannot cast from &lt;code&gt;const&lt;/code&gt; to non-&lt;code&gt;const&lt;/code&gt; objects.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;The good points of using new style casts are:&lt;br /&gt;
1. new styles are much easier to identify in code for both humans and for tools like &lt;code&gt;grep&lt;/code&gt;, thus simplifying the process of locating the code during debugging.&lt;br /&gt;
2. The more narrowly specified purpose of each cast makes it possible for compilers to diagnose usage errors.&lt;/p&gt;

&lt;p&gt;Sometimes an old-style cast may &amp;ldquo;feel&amp;rdquo; better: suppose we want to call an &lt;code&gt;explicit&lt;/code&gt; constructor to pass an object to a function:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class Widget {
public:
    explicit Widget(int size);
    ...
};
void doSomeWork(const Widget&amp;amp; w);

doSomeWork(Widget(15));  // create Widget from in with function-style cast
doSomeWork(static_cast&amp;lt;Widget&amp;gt;(15)); // cast with C++-style
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;However, feeling is just feeling. Code that leads to a core dump also feels pretty reasonable when we write it - we&amp;rsquo;d better ignore feelings and use new-style casts all the time.&lt;/p&gt;

&lt;h2 id=&#34;behind-cast&#34;&gt;Behind cast&lt;/h2&gt;

&lt;p&gt;Type conversions often lead to code that is executed at runtime, more than simply telling compilters to treat one type as another:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;int x, y;
...
double d = static_cast&amp;lt;double&amp;gt;(x) / y;  // divide x by y using floating point division
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;the cast from the &lt;code&gt;int x&lt;/code&gt; to a &lt;code&gt;double&lt;/code&gt; almost certainly generates code, because on most architectures, the underlying representation for an &lt;code&gt;int&lt;/code&gt; is different from that for a &lt;code&gt;double&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s see another example:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class Base {...};
class Derived: public Base {...};

Derived d;
Base *pb = &amp;amp;d;  // implicitly convert Derived* to Base*
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;When creating the base class pointer to a derived class object, sometimes, depending on the various compilers, an offset may be applied at runtime to the &lt;code&gt;Derived*&lt;/code&gt; pointer to get the correct &lt;code&gt;Base*&lt;/code&gt; pointer value, and now a single object of type &lt;code&gt;Derived&lt;/code&gt; now have more than one address! This can&amp;rsquo;t happen in Java, or C#, or C, but it &lt;em&gt;does&lt;/em&gt; happen in C++, virtually all the time in the case of multiple inheritance, and some of the times under single inheritance.&lt;/p&gt;

&lt;p&gt;The lesson we learn:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;we should generally avoid making assumptions about how things are laid out in C++, and certainly not perform casts based on such assumptions.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;For example: casting object addresses to &lt;code&gt;char*&lt;/code&gt; pointers and then using pointer arithmetic on them almost always yields undefined behavior.&lt;/p&gt;

&lt;p&gt;Another lesson we may learn from: many application frameworks requires that virtual member function implementations in derived classes call their base class conterparts first, and below is a wrong version to make the &lt;code&gt;SpecialWindow::onResize()&lt;/code&gt; (derived class virtual function) to invoke its base class &lt;code&gt;Window&lt;/code&gt;&amp;rsquo;s conterparts:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class Window {  // baes class
public:
    virtual void onResize();  // base on Resize impl
    ...
};
class SpecialWindow: public Window {  // derived class
public:
    virtual void onResize() {  // derived onResize impl
        static_cast&amp;lt;Window&amp;gt;(*this).onResize(); // cast *this to Window, then call its onResize
        ... // do SpecialWindow-specific stuff
    }
    ...
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The code casts &lt;code&gt;*this&lt;/code&gt; to a &lt;code&gt;Windnow&lt;/code&gt;, so the call to &lt;code&gt;onResize&lt;/code&gt; will invoke &lt;code&gt;Window::onResize&lt;/code&gt;. However, surprisingly, the cast will secretly create a new, temporary &lt;em&gt;copy&lt;/em&gt; of the base class part of &lt;code&gt;*this&lt;/code&gt;, then invoke &lt;code&gt;onResize&lt;/code&gt; on the copy - the &lt;code&gt;Window::onResize&lt;/code&gt; does not apply on the current object, while the &lt;code&gt;SpecialWindow&lt;/code&gt;-specific actions apply on that object, leading to the prospect that the code will leave the current object in an invalid state, if the base class virtual function is supposed to do some modifications on current object but fails to do so.&lt;/p&gt;

&lt;p&gt;The solution is to eliminate the cast, and call the base class version of &lt;code&gt;onResize&lt;/code&gt; on the current object:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class SpecialWindow: public Window {
public:
    virtual void onResize() {
        Window::onResize();  // call Window::onResize on *this
        ...
    }
    ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;cost-of-dynamic-cast&#34;&gt;Cost of &lt;code&gt;dynamic_cast&lt;/code&gt;&lt;/h2&gt;

&lt;p&gt;One common implementatino of &lt;code&gt;dynamic_cast&lt;/code&gt; is based in part on string comparisons of class names, so if we&amp;rsquo;re performing a &lt;code&gt;dynamic_cast&lt;/code&gt; on an object in a single-inheritance hierarchy four levels deep, each &lt;code&gt;dynamic_cast&lt;/code&gt; could cost us up to four calls to &lt;code&gt;strcmp&lt;/code&gt;. A deeper hierarchy or one using multiple inheritance would be more expensive. So for performance-sensitive code, we should be especially leery of &lt;code&gt;dynamic_cast&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;When we need &lt;code&gt;dynamic_cast&lt;/code&gt;? Generally, the need arises because we want to perform derived class operations on a derived class object via a base pointer or base reference. Say in our &lt;code&gt;Window&lt;/code&gt;/&lt;code&gt;SpecialWindow&lt;/code&gt; hierarchy, only &lt;code&gt;SpecialWindow&lt;/code&gt; supports blinking, so we may use &lt;code&gt;dynamic_cast&lt;/code&gt; this way:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class Window {...};
class SpecialWindow: public Window {
public:
    void blink();
    ...
};
typedef std::vector&amp;lt;std::tr1::shared_ptr&amp;lt;Window&amp;gt;&amp;gt; VPW; // item 13 on tr1::shared_ptr

VPW winPtrs;
...
for (VPW::iterator iter = winPtrs.begin();
    iter != winPtrs.end();
    ++iter) {
        if (SpecialWindow *psw = dynamic_cast&amp;lt;SpecialWindow*&amp;gt;(iter-&amp;gt;get())) {
            psw-&amp;gt;blink();
        }
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In order to eliminate the &lt;code&gt;dynamic_cast&lt;/code&gt;, there are two approaches:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Use specific containers&lt;br /&gt;
We could use containers that store pointers to derived class objects directly, so that there&amp;rsquo;s no need to manipulate derived class through base class interfaces:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;typedef std::vector&amp;lt;std::tr1::shared_ptr&amp;lt;SpecialWindow&amp;gt;&amp;gt; VPSW;

VPSW winPtrs;
...
for (VPSW::iterator iter = winPtrs.begin();
    iter != winPtrs.end();
    ++iter) {
        (*iter)-&amp;gt;blink();
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Of course, we cannot store all possible &lt;code&gt;Window&lt;/code&gt; derivatives in the same container under this approach, instead, we may work with multiple type-safe containers.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Use virtual functions&lt;br /&gt;
If we insist on manipulating all possible &lt;code&gt;Window&lt;/code&gt; derivatives through a base class interface, we could declare a useless &lt;code&gt;blink&lt;/code&gt; as a virtual functions in base class (if it makes sense):&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class Window {
public:
    virtual void blink() {}  // default impl is no-op; see item 34 for why a default impl may be a bad idea
    ...
};
class SpecialWindow: public Window {
public:
    virtual void blink() {...};  // do something in blink
    ...
};
typedef std::vector&amp;lt;std::tr1::shared_ptr&amp;lt;Window&amp;gt;&amp;gt; VPW;

VPW winPtrs;  // container holds ptrs to all possible Window types
...
for (VPW::iterator iter = winPtrs.begin();
    iter != winPtrs.end();
    ++iter) {
        (*iter)-&amp;gt;blink();  // no dynamic_cast
    }
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Neigther of two approaches above are universally applicable, but they do provide a viable alternative to &lt;code&gt;dynamic_cast&lt;/code&gt;. As long as they work, we should embrace them.&lt;/p&gt;

&lt;p&gt;Another thing we want to avoid about &lt;code&gt;dynamic_casts&lt;/code&gt; is designs that involve cascading &lt;code&gt;dynamic_casts&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class Window {...};
...  // derived clases
typedef std::vector&amp;lt;std::tr1::shard_ptr&amp;lt;Window&amp;gt;&amp;gt; VPW;

VPW winPtrs;
...
for (VPW::iterator iter = winPtrs.begin(); 
    iter != winPtrs.end(); 
    ++iter) {
        if (SpecialWindow1 *psw1 = 
            dynamic_cast&amp;lt;SpecialWindow1*&amp;gt;(iter-&amp;gt;get())) {...}
        else if (SpecialWindow2 *psw2 = 
            dynamic_cast&amp;lt;SpecialWindow2*&amp;gt;(iter-&amp;gt;get())) {...}
        else if (SpecialWindow3 *psw3 = 
            dynamic_cast&amp;lt;SpecialWindow3*&amp;gt;(iter-&amp;gt;get())) {...} 
        ...        
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This design generates code that is big and slow, and is hard to maintain, for we have to update the condition branch every time we update the base class &lt;code&gt;Window&lt;/code&gt;. Code like this should almost always be replaced with something based on virtual funciton calls.&lt;/p&gt;

&lt;p&gt;In summary, although it&amp;rsquo;s generally not practical to get rid of casts, we should use as few as possible. If we have to use them, like most suspicious constructs, we should isolate casts as much as possible, typically hide them inside functions whose interfaces shiled callers from the work inside.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Item-26 Postpone variable definitions as long as possible</title>
      <link>http://nianze.tk/2018/02/postpone-variable-definitions/</link>
      <pubDate>Wed, 14 Feb 2018 10:50:18 -0500</pubDate>
      
      <guid>http://nianze.tk/2018/02/postpone-variable-definitions/</guid>
      <description>&lt;p&gt;Postponing variable definitions as long as possible increases program clarity and improves progranm efficiency.
&lt;/p&gt;

&lt;p&gt;After defining a variable of a type with a constructor or destructor, there&amp;rsquo;s a cost of construction when control reaches a variable&amp;rsquo;s definition, and a cost of destruction when the variable goes out of scope. If the variable is unused, the cost is wasted, which is the case we want to avoid.&lt;/p&gt;

&lt;p&gt;Nobody declares unused variables on purpose, but chances are we may still encounter them unexpectedly: suppose there&amp;rsquo;s a function that returns an encrypted version of a password as long as the password is long enough and may throw an exception of type &lt;code&gt;logic_error&lt;/code&gt; (defined in standard C++ library, item 54) if the passwod is too short:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;std::string encryptPassword(const std::string&amp;amp; password)
{
    using namespace std;
    string encrypted; // definition is too soon
    if (password.length() &amp;lt; MinimumPasswordLength) {
        throw logic_error(&amp;quot;Password is too short&amp;quot;);
    }
    ...   // do whatever is necessary to place an encrypted version of password in encrypted
    return encrypted;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Apparently, the object &lt;code&gt;encrypted&lt;/code&gt; is unused if an exception is thrown, and we still have to pay the cost of construction and destruction of &lt;code&gt;encrypted&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;A better solution is to postpone &lt;code&gt;encrypted&lt;/code&gt;&amp;rsquo;s definition until we &lt;em&gt;know&lt;/em&gt; we&amp;rsquo;ll need it:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;std::string encryptPassword(const std::string&amp;amp; password)
{
    using namespace std;

    if (password.length() &amp;lt; MinimumPasswordLength) {
        throw logic_error(&amp;quot;Password is too short&amp;quot;);
    }

    string encrypted; // postpones encrypted&#39;s definition until it&#39;s truly necessary
    ...   // do whatever is necessary to place an encrypted version of password in encrypted
    return encrypted;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This code still isn&amp;rsquo;t as tight as it might be, because &lt;code&gt;encrypted&lt;/code&gt; is defined without any initialization arguments, leading to its default constructor getting called and an extra aassignment operation being used later. As item 4 suggests,&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;default-constructing an object and then assigning to it is less efficient than initializing it with the value we really want it to have.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Suppose the hard part of &lt;code&gt;encryptPassword&lt;/code&gt; is performed in this function:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;void encrypt(std::string&amp;amp; s);  // encrypts s in place
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then we&amp;rsquo;d better skip the pointless and potentially expensive default construction, directly initializing &lt;code&gt;encrypted&lt;/code&gt; with &lt;code&gt;password&lt;/code&gt; until right before we have to use the variable:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;std::string encryptPassword(const std::string&amp;amp; password)
{
    using namespace std;

    if (password.length() &amp;lt; MinimumPasswordLength) {
        throw logic_error(&amp;quot;Password is too short&amp;quot;);
    }

    string encrypted(password); // define and initialize via copy constructor right before we have to use it
    encrypt(encrypted);
    return encrypted;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This gives us certain benifits:&lt;br /&gt;
1. we avoid constructing and destructing unneeded obejcts&lt;br /&gt;
2. we avoid unnecessary default constructions&lt;br /&gt;
3. we help document the purpose of variables by initializing them in contexts in which their meaning is clear&lt;/p&gt;

&lt;h2 id=&#34;loop&#34;&gt;Loop&lt;/h2&gt;

&lt;p&gt;If a variable is used only inside a loop, should we define it outside the loop and make an assignment to it on each loop iteration, or to define the variable inside the loop？&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;// Approach A: define outside loop
Widget w;
for (int i = 0; i &amp;lt; n; ++i)
{
    w = some value dependent on i;
    ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;// Approach B: define inside loop
for (int i = 0; i &amp;lt; n; ++i) 
{
    Widget w(some value dependent on i);
    ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Let&amp;rsquo;s see the costs of the two approaches above:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Approach A: 1 constructor + 1 destructor + n assignments&lt;/li&gt;
&lt;li&gt;Approach B: n constructor + n destructors&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Since Approach A makes the name &lt;code&gt;w&lt;/code&gt; visible in a larger scope than Approach B, which is contrary to program comprehensibility and maintainability, generally we choose Approach B as default, unless we know that&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;assignment is less expensive than a constructor-destructor pair&lt;/li&gt;
&lt;li&gt;we&amp;rsquo;re dealing with a performance-sensitive part of our code&lt;/li&gt;
&lt;/ol&gt;</description>
    </item>
    
    <item>
      <title>Item-25 Consider support for a non-throwing swap</title>
      <link>http://nianze.tk/2018/02/support-for-a-non-throwing-swap/</link>
      <pubDate>Tue, 13 Feb 2018 19:11:15 -0500</pubDate>
      
      <guid>http://nianze.tk/2018/02/support-for-a-non-throwing-swap/</guid>
      <description>&lt;p&gt;When &lt;code&gt;std::swap&lt;/code&gt; would be inefficient for your type,provide a non-throwing &lt;code&gt;swap&lt;/code&gt; member function, a non-member &lt;code&gt;swap&lt;/code&gt; calling the member, and possibly a specialized &lt;code&gt;std::swap&lt;/code&gt; for the case of classes (not templates).

&lt;!-- toc --&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;swap&lt;/code&gt;, since its introduction into STL, is useful for exception-safe programming (item 29) and a common mechanism for coping with the possibility of assignment to self (item 11). Due to its importance, it should be implemented properly, which is exactly what this item explores about.&lt;/p&gt;

&lt;h1 id=&#34;customization&#34;&gt;Customization&lt;/h1&gt;

&lt;p&gt;By default, swapping is accomplished via the standard &lt;code&gt;swap&lt;/code&gt; algorithm:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;namesapce std {
    template&amp;lt;typename T&amp;gt;    // typical implementation of std::swap
    void swap(T&amp;amp; a, T&amp;amp; b)   // swaps a&#39;s and b&#39;s values
    {
        T temp(a);
        a = b;
        b = temp;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As long as our types support copying (via copy constructor and copy assignment operator), the default &lt;code&gt;swap&lt;/code&gt; implementation will work. However, for some types, none of these copies are really necessary. For example: there&amp;rsquo;s a common design manifestation called &amp;ldquo;pimpl idiom&amp;rdquo; (&amp;ldquo;pointer to implementation&amp;rdquo;, item 31) that consisting primarily of a pointer to another type that contains the real data:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class WidgetImpl {            // class for Widget data
public:
    ...
private:
    int a, b, c;
    std::vector&amp;lt;double&amp;gt; v;    // possibly lots of data:
    ...                       // expensive to copy
};
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class Widget {                    // class using the pimpl idiom
public:
    Widget(const Widgtet&amp;amp; rhs);
    Widget&amp;amp; operator=(const Widget&amp;amp; rhs)  //to copy a Widget,
    {                             // copy its WidgetImpl object.
        ...                       // for details on operator=, see item 10, 11, 12
        *pImpl = *(rhs.pImpl);
        ...
    }
    ...
private:
    WidgetImpl *pImpl;             // ptr to object with real data
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To swap the value of two &lt;code&gt;Widget&lt;/code&gt; objects, all we need to do is swap their &lt;code&gt;pImpl&lt;/code&gt; pointers instead of copying three &lt;code&gt;Widget&lt;/code&gt;s as well as three underlying &lt;code&gt;WidgetImpl&lt;/code&gt; objects. In order to let default &lt;code&gt;swap&lt;/code&gt; know this information, we need to specialize &lt;code&gt;std::swap&lt;/code&gt; for &lt;code&gt;Widget&lt;/code&gt;:&lt;/p&gt;

&lt;p&gt;namespace std {
template&amp;lt;&amp;gt;              // a specialized version of std::swap
void swap&lt;Widget&gt;(Widget&amp;amp; a, Widget&amp;amp; b)  // for when T is Widget
{
    swap(a.pImpl, b.pImpl);       // won&amp;rsquo;t compile here
}
}&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;template&amp;lt;&amp;gt;&lt;/code&gt; at the begining says that this is a &lt;em&gt;total template specialization&lt;/em&gt; for &lt;code&gt;std::swap&lt;/code&gt;, and the &lt;code&gt;&amp;lt;Widget&amp;gt;&lt;/code&gt; after the name of the function says that the specialization is for when &lt;code&gt;T&lt;/code&gt; is &lt;code&gt;Widget&lt;/code&gt;, so compilter knows that when the general &lt;code&gt;swap&lt;/code&gt; template is applied to &lt;code&gt;Widget&lt;/code&gt;s, this is the implementation to use - although we are not allowed to alter the contents of the &lt;code&gt;std&lt;/code&gt; namespace, it is totally fine to specialize standard templates (like &lt;code&gt;swap&lt;/code&gt;) for our own types (such as &lt;code&gt;Widget&lt;/code&gt;).&lt;/p&gt;

&lt;p&gt;However, this implementation won&amp;rsquo;t compile, because we can&amp;rsquo;t access the private &lt;code&gt;pImpl&lt;/code&gt; pointers inside &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt;. To solve the problem, we declare a public member function called &lt;code&gt;swap&lt;/code&gt; that does the actual swapping, then specialize &lt;code&gt;std::swap&lt;/code&gt; to call the member function:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class Widget { // same as above except for the addition of the swap mem func
public:
    ...
    void swap(Widget&amp;amp; other)
    {
        using std::swap;              // use the std::swap
        swap(pImple, other.pImpl);    // to swap Widgets, swap their pImpl pointers
    }
    ...
};

namespace std {
template&amp;lt;&amp;gt;      // revised version of std::swap
void swap&amp;lt;Widget&amp;gt;(Widget&amp;amp; a, Widget&amp;amp; b)  
{
    a.swap(b);  // to swap Wiidgets, call their swap mem func
}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This implementation will compile and be consistent with the STL container. However, if the &lt;code&gt;Widget&lt;/code&gt; and &lt;code&gt;WidgetImpl&lt;/code&gt; were class &lt;em&gt;template&lt;/em&gt; instead of classes (so that we could parameterize the type of the data stored in &lt;code&gt;WidgetImpl&lt;/code&gt;), things get more complicated:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;template&amp;lt;typename T&amp;gt;
class WidgetImpl {...};

template&amp;lt;typename T&amp;gt;
class Widget {...};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It is still easy to put a &lt;code&gt;swap&lt;/code&gt; member function inside &lt;code&gt;Widget&lt;/code&gt; the same way as before, but there&amp;rsquo;s a trouble with the specialization for &lt;code&gt;std::swap&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;namespace std {
template&amp;lt;typename T&amp;gt;
void swap&amp;lt;Widget&amp;lt;T&amp;gt;&amp;gt;(Widget&amp;lt;T&amp;gt;&amp;amp; a, Widget&amp;lt;T&amp;gt;&amp;amp; b)  // illegal code!
{
    a.swap(b);
}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Apparently we&amp;rsquo;re partially specializing a function template &lt;code&gt;std::swap&lt;/code&gt; here, and the problem is that, although C++ allows partial specialization of class templates, it doesn&amp;rsquo;t allow it for function templates (though some compilers may erroneously accept it).&lt;/p&gt;

&lt;p&gt;The usual approach to &amp;ldquo;partially specialize&amp;rdquo; a function template is to add an overload like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;namespace std {
    template&amp;lt;typename T&amp;gt;   // an overloading of std::swap
    void swap(Widget&amp;lt;T&amp;gt;&amp;amp; a, Widget&amp;lt;T&amp;gt;&amp;amp; b)  // note the lack of &amp;quot;&amp;lt;...&amp;gt;&amp;quot;
    {                                      // after &amp;quot;swap&amp;quot;
        a.swap(b);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;However, rather than overloading a common function template, what we do here is overloading a function template &lt;code&gt;std::swap&lt;/code&gt; in the special &lt;code&gt;std&lt;/code&gt; namesapce, where it&amp;rsquo;s not allowed to add &lt;em&gt;new&lt;/em&gt; templates or classes or functions or anything else into it (the contens of &lt;code&gt;std&lt;/code&gt; are determined solely by the C++ standardization committee). Even though programs that cross the line will almost certainly compile and run, their behavior is undefined.&lt;/p&gt;

&lt;p&gt;Thus in this case, not to declare the non-member function to be a specialization or overloading of &lt;code&gt;std::swap&lt;/code&gt;, we just make a normal non-member &lt;code&gt;swap&lt;/code&gt; function in &lt;code&gt;Widget&lt;/code&gt;-related namespace:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;namespace WidgetStuff {
    ...  // templatized WidgetImpl, etc.
    template&amp;lt;typename T&amp;gt; 
    class Widget {...}; // including the swap member function
    ...
    template&amp;lt;typename T&amp;gt;   // non-member swap function
    void swap(Widget&amp;lt;T&amp;gt;&amp;amp; a, Widget&amp;lt;T&amp;gt;&amp;amp; b)  // not part of the std namespace
    {
        a.swap(b);
    }
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The name lookup rules in C++ (specifically the rules known as &lt;em&gt;argument-dependent lookup&lt;/em&gt; or &lt;em&gt;Koenig lookup&lt;/em&gt;) will guarantee the Widget-specific version of &lt;code&gt;swap&lt;/code&gt; in &lt;code&gt;WidgetStuff&lt;/code&gt; will be invoked if any code calls &lt;code&gt;swap&lt;/code&gt; on two &lt;code&gt;Widget&lt;/code&gt; objects.&lt;/p&gt;

&lt;h1 id=&#34;usage&#34;&gt;Usage&lt;/h1&gt;

&lt;p&gt;Let&amp;rsquo;s look from a client&amp;rsquo;s point of view and see how to use the &lt;code&gt;swap&lt;/code&gt;. Ideally, we want to call a T-specific version of &lt;code&gt;swap&lt;/code&gt; if there is one, but to fall back on the general version in &lt;code&gt;std&lt;/code&gt; if there&amp;rsquo;s not. To fulfill this idea:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;template&amp;lt;typename T&amp;gt;
void doSomething(T&amp;amp; obj1, T&amp;amp; obj2) 
{
    using std::swap;  // make std::swap available in this function
    ...
    swap(obj1, obj2);  // call the best swap for obejcts of type T
    ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;When compilers see the call to &lt;code&gt;swap&lt;/code&gt;, they search for the best &lt;code&gt;swap&lt;/code&gt; to invoke - according to C++&amp;rsquo;s name lookup rules, it follows the order below:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Find any T-specific &lt;code&gt;swap&lt;/code&gt; at global scope or in the same namespace as the type T (if T is &lt;code&gt;Widget&lt;/code&gt; in the namespace &lt;code&gt;WidgetStuff&lt;/code&gt;, compilers will find &lt;code&gt;swap&lt;/code&gt; in &lt;code&gt;WidgetStuff&lt;/code&gt; defined above)&lt;/li&gt;
&lt;li&gt;If no T-specific &lt;code&gt;swap&lt;/code&gt; exists, compilers will use &lt;code&gt;swap&lt;/code&gt; in &lt;code&gt;std&lt;/code&gt;, thanks to the &lt;code&gt;using&lt;/code&gt; declaration that makes &lt;code&gt;std::swap&lt;/code&gt; visible in this function.

&lt;ol&gt;
&lt;li&gt;If there&amp;rsquo;s a T-specific specialization of &lt;code&gt;std::swap&lt;/code&gt;, use the specialized version&lt;/li&gt;
&lt;li&gt;If not, use the general &lt;code&gt;swap&lt;/code&gt; template function.&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;One thing worth noting is to not qualify the call like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;std::swap(obj1, obj2);  // the wrong way to call swap
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;here we force compilers to consider only the &lt;code&gt;swap&lt;/code&gt; in &lt;code&gt;std&lt;/code&gt; (including any template specializations), thus eliminating the possibility of getting a more appropriate T-specific version defined elsewhere. Alas, some misguided programmers (or even some standard library) &lt;em&gt;do&lt;/em&gt; qualify calls to &lt;code&gt;swap&lt;/code&gt; in this way. To make code work as efficiently as possible, we&amp;rsquo;d better totally specialize &lt;code&gt;std::swap&lt;/code&gt; for our classes.&lt;/p&gt;

&lt;h1 id=&#34;summary&#34;&gt;Summary&lt;/h1&gt;

&lt;p&gt;We&amp;rsquo;ve discussed the default &lt;code&gt;swap&lt;/code&gt;, member &lt;code&gt;swap&lt;/code&gt;s, non-member &lt;code&gt;swap&lt;/code&gt;s, specializations of &lt;code&gt;std::swap&lt;/code&gt;, and calls to &lt;code&gt;swap&lt;/code&gt;. Below is a good practice on implementing and using customized &lt;code&gt;swap&lt;/code&gt;:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;If the default implementation of &lt;code&gt;swap&lt;/code&gt; offers acceptable efficiency for our class or class template, nothing needs to be done to specialize the default &lt;code&gt;std::swap&lt;/code&gt;.&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;If not (for class or template using some variation of the pimpl idiom):&lt;br /&gt;

&lt;ol&gt;
&lt;li&gt;offer a public &lt;code&gt;swap&lt;/code&gt; member function that efficiently swaps the value of two objects of our type. This function should never throw an exception&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:1&#34;&gt;&lt;a href=&#34;#fn:1&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;offer a non-member &lt;code&gt;swap&lt;/code&gt; in the same namespace as the class or template&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:2&#34;&gt;&lt;a href=&#34;#fn:2&#34;&gt;2&lt;/a&gt;&lt;/sup&gt;. Have it call the &lt;code&gt;swap&lt;/code&gt; member function&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;if it&amp;rsquo;s a class (not a class template), specialize &lt;code&gt;std::swap&lt;/code&gt; for the class. Have it also call the &lt;code&gt;swap&lt;/code&gt; member function&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;div class=&#34;footnotes&#34;&gt;

&lt;hr /&gt;

&lt;ol&gt;
&lt;li id=&#34;fn:1&#34;&gt;One of most useful applications of &lt;code&gt;swap&lt;/code&gt; is to help classes and class templates offer the strong exception-safety guarantee (See 29 for details). Generally speaking, efficiency and non-exception are two &lt;code&gt;swap&lt;/code&gt; characteristics that always go hand in hand, because highly efficient &lt;code&gt;swap&lt;/code&gt;s are almost always based on operations on built-in types (such as the pointers underlying the pimpl idiom), and operations on built-in types never throw exceptions.
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:1&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:2&#34;&gt;The non-exception constraint can&amp;rsquo;t apply to the non-member version, because the default version of &lt;code&gt;swap&lt;/code&gt; is based on copy construction and copy assignment, and generally both copy functions are allowed to throw exceptions.
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:2&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;</description>
    </item>
    
    <item>
      <title>Item-24 Declare non-member functions when type conversions should apply to all parameters</title>
      <link>http://nianze.tk/2018/02/when-to-declare-non-member-functions/</link>
      <pubDate>Mon, 12 Feb 2018 22:47:20 -0500</pubDate>
      
      <guid>http://nianze.tk/2018/02/when-to-declare-non-member-functions/</guid>
      <description>&lt;p&gt;If we need type conversions on all parameters to a function including the one pointed to by the &lt;code&gt;this&lt;/code&gt; pointer, the function must be a non-member.
&lt;/p&gt;

&lt;p&gt;Having classes support implicit type conversions is generally a bad idea. One good and common exception to the rule is when creating numerical types, for example, we want to allow implicit conversions from integers to user-defined rationals type:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class Rational {
public:
    Rational(int numerator = 0,    // ctor is deliberately not explicit, 
             int denominator = 1); // allowing implicit int-to-Rational conversion
    int numerator() const;     // accessor for numerator
    int denominator() const;   // accessor for denominator, see item 22
private:
    ...
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We&amp;rsquo;d like to support arithmetic operation of multiplication, and one way is to declare it as a member function of &lt;code&gt;Rational&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class Rational {
public:
    ...
    const Rational operator*(const Rational&amp;amp; rhs) const; // return const: item 3; taking a reference-to-const as argument: item 20, 21
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This design is fine to multiply rationals with rationals:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;Rational oneEighth(1, 8);
Rational oneHalf(1, 2);

Rational result = oneHalf * oneEighth;  // fine
result = result * oneEighth;   // fine
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;However, for mixed-mode operations, where &lt;code&gt;Rational&lt;/code&gt;s is multiplied with &lt;code&gt;int&lt;/code&gt;s, there will be a potential error:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;result = oneHalf * 2;  // fine
result = 2 * oneHalf;  // error!
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This problem is clearer for analysis when we rewrite the last two examples in their equivalent functional form:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;result = oneHalf.operator*(2);   // fine
result = 2.operator*(oneHalf);   // error!
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;For the first statement:&lt;br /&gt;
the object oneHalf is an instance of a class that contains an &lt;code&gt;operator*&lt;/code&gt; taking a &lt;code&gt;Rational&lt;/code&gt; as its argument. Compilers know we&amp;rsquo;re passing an &lt;code&gt;int&lt;/code&gt; and that the function requires a &lt;code&gt;Rational&lt;/code&gt;, and they also know they can conjure up a suitable &lt;code&gt;Rational&lt;/code&gt; by implicit type conversion - calling the &lt;code&gt;Rational&lt;/code&gt; constructor with the &lt;code&gt;int&lt;/code&gt; we provided, so compilers will happily call that function as if it had been written like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;const Rational temp(2);  // create a temporary Rational object from 2
result = oneHalf * temp;  // same as oneHalf.operator*(temp);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Of course, compilers are allowed to do this implicit type conversion only because a non-explicit constructor is involved. If we add keyword &lt;code&gt;explicit&lt;/code&gt; before the constructor above, neither of the two mixed-type multiplication statements would compile.&lt;/p&gt;

&lt;p&gt;Now for the second statement:&lt;br /&gt;
it turns out that parameters are eligible for implicit type conversion &lt;em&gt;only if they are listed in the parameter list&lt;/em&gt;. The implicit parameter pointed to by &lt;code&gt;this&lt;/code&gt;, which is also the obejct on which the member function is invoked, is &lt;em&gt;never&lt;/em&gt; eligible for implicit conversions. Back to the second statement, &lt;code&gt;int&lt;/code&gt; type &lt;code&gt;2&lt;/code&gt; does not have associated class containing a function &lt;code&gt;operator*&lt;/code&gt; taking a &lt;code&gt;Rational&lt;/code&gt; type object as its argument, nor is &lt;code&gt;2&lt;/code&gt; listed in the parameter list for an implicit type conversion to &lt;code&gt;Rational&lt;/code&gt;. That is the cause of compilation failure.&lt;/p&gt;

&lt;p&gt;In fact, when compilers fail to find a matching member function, they will also look for non-member &lt;code&gt;operator*&lt;/code&gt;s (i.e., ones at namespace or global scope) that can be called like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;result = operator*(2, oneHalf);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And this is exactly what we want if we&amp;rsquo;d like to support mixed-mode arithmetic: make &lt;code&gt;opeartor*&lt;/code&gt; a non-member function, thus allowing compilers to perform implicit type conversions on &lt;em&gt;all&lt;/em&gt; arguments:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class Rational {
    ...     // contains no operator*
};
const Rational operator*(const Rational&amp;amp; lhs, const Rational&amp;amp; rhs)  // now a non-member function
{
    return Rational(lhs.numerator() * rhs.numerator(),
                    lhs.denominator() * rhs.denominator());
}

Rational oneForth(1, 4);
Rational result;

result = oneForth * 2;  // fine
result = 2 * oneForth;  // it works now
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now comes anoter worry: should &lt;code&gt;operator*&lt;/code&gt; be made a friend of the &lt;code&gt;Rational&lt;/code&gt; class?&lt;br /&gt;
In this case, the answer is no, because &lt;code&gt;operator*&lt;/code&gt; can be implemented entirely through &lt;code&gt;Rational&lt;/code&gt;&amp;rsquo;s public interface. This leads to an important observation:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;The opposite of a member function is a non-member function, not a frient function.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;There&amp;rsquo;s some misunderstanding that if a function is related to a class and should not be a member (due, for example, to type conversions on all arguments), it should be a friend. This reasoning turns out to be flawed. The basic rule is to avoid friend functions whenever we can.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;P.S.: This item contains the truth, but it is not the whole truth. When we cross the line from Object-Oriented C++ into Template C++ (item 1), and make &lt;code&gt;Rational&lt;/code&gt; a class &lt;em&gt;template&lt;/em&gt; instead of a class, refer to item 46 for some new issues to consider, new ways to solve them, and new design implications.&lt;/p&gt;
&lt;/blockquote&gt;</description>
    </item>
    
    <item>
      <title>Item-23 Prefer non-member non-friend function to member function</title>
      <link>http://nianze.tk/2018/02/prefer-non-member-non-friend-function-to-member-function/</link>
      <pubDate>Sun, 11 Feb 2018 21:33:28 -0500</pubDate>
      
      <guid>http://nianze.tk/2018/02/prefer-non-member-non-friend-function-to-member-function/</guid>
      <description>&lt;p&gt;Prefer non-member non-friend functions to member functions for better encapsulation, packaging flexibility, and functional extensibility.
&lt;/p&gt;

&lt;p&gt;Suppose there&amp;rsquo;s a class representing web browsers containing following three functions:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class WebBrowser {
public:
    ...
    void clearCache();
    void clearHistory();
    void removeCookies();
    ...
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Clients may want to perform these three actions together, so &lt;code&gt;WebBrowser&lt;/code&gt; might offer two ways to achieve the goal:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Add a member function&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class WebBrowser {
public:
    ...
    void clearEverything(); // calls clearCache(), clearHistory(), and removeCookies()
    ...
};
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;Add a non-member non-friend function&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;void clearBrowser(WebBrowser&amp;amp; wb) 
{
    wb.clearCache();
    wb.clearHistory();
    wb.removeCookies();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As the title suggests, the non-member approach is better, and below is the reasons:&lt;/p&gt;

&lt;h1 id=&#34;encapsulation&#34;&gt;Encapsulation&lt;/h1&gt;

&lt;p&gt;If something is encapsulated, it&amp;rsquo;s hidden from view. The more something is encapsulated, the fewer things can see it, the fewer impact clients get affected by potential change, and the greater flexibility we have to change the inmplementation.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;As a coarse-grained measure of how much code can see a piese of data, we can count the number of functions that can access that data: the more functions that can access it, the less encapsulated the data.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;According to item 22, data members should all be private, so the number of functions that can access them is the number of member functions of the class plus the number of friend functions. Thus, given a member function &lt;code&gt;clearEverything()&lt;/code&gt; (which can access not only the private data of a class, but also private functions, enums, typedefs, etc) and a non-member non-friend function &lt;code&gt;clearBrower()&lt;/code&gt;, the latter yields greater encapsulation.&lt;/p&gt;

&lt;p&gt;Two more things worth noting are:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Friend functions have the same access to a class&amp;rsquo;s private members, hence the same impact on encapsulation. So from an encapsulation point of view, the choice is between member functions and non-member non-friend functions. (BTW, under the view point of implicit type conversion, item 24, the choice is between member and non-member functions)&lt;/li&gt;
&lt;li&gt;A function being a non-member of one class can still be a member of another class. For example, &lt;code&gt;clearBrowser()&lt;/code&gt; could be declared as a static member function in some utility class. As long as it is not part of (or a friend of) &lt;code&gt;WebBrowser&lt;/code&gt;, it doens&amp;rsquo;t affect the encapsulation of &lt;code&gt;WebBrowser&lt;/code&gt;&amp;rsquo;s private members.&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;packaging-flexibility&#34;&gt;Packaging flexibility&lt;/h2&gt;

&lt;p&gt;In C++, rather than declared in a class, a more natural approach would be to make &lt;code&gt;clearBrowser()&lt;/code&gt; a non-member function in the same namespace as &lt;code&gt;WebBrowser&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;namespace WebBrowserStuff {
class WebBrowser {...};
void clearBrowser {...};
...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Unlike classes, namespace can be spread across multiple source file. For convenience functions like &amp;lsquo;clearBrowser&amp;rsquo;, this is important, because clients will generally be interested in only some of the convenience functions, and there&amp;rsquo;s no reason for them to compile all of the functions including those they don&amp;rsquo;t need. A straight forward way to separate convenience functions by their functionalities is to declare them in different header files:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;// header &amp;quot;webbrowser.h&amp;quot; - header for class WebBrowser itself 
// as well as &amp;quot;core&amp;quot; WebBrowser-related functionality
namespace WebBrowserStuff {
    class WebBrowser {...};
    ...  // &amp;quot;core&amp;quot; related functionality, e.g.: non-member functions almost all clients need
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;// header &amp;quot;webbrowserbookmarks.h&amp;quot;
namespace WebBrowserStuff {
    ...  // bookmark-related convenience functions
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;// header &amp;quot;webbrowsercookies.h&amp;quot;
namespace WebBrowserStuff {
    ...  // cookie-related convenience functions
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is exactly how the standard C++ library is organized: there are dozens of headers (e.g.: &lt;code&gt;&amp;lt;vector&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;algorithm&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;memory&amp;gt;&lt;/code&gt;, etc.), each declaring some of the functionality in &lt;code&gt;std&lt;/code&gt;. This allows clients to be compilation dependent only on the parts of the system they actually use (item 31 shows other ways to reduce compilation dependencies).&lt;/p&gt;

&lt;p&gt;On the other side, partitioning is not possible for member functions, because a class must be defined in its entirety.&lt;/p&gt;

&lt;h2 id=&#34;extensibility&#34;&gt;Extensibility&lt;/h2&gt;

&lt;p&gt;Putting all convenience functions in multiple header files but one namespace also means that clients can easily &lt;em&gt;extend&lt;/em&gt; the set of convenience functions. All they have to do is add more non-member non-friend functions to the namespace, which is another feature classes can&amp;rsquo;t offer, because class definitions are closed to extension by clients. Even though clients can derive new classes, the derived classes have no access to private members in the base class, so such &amp;ldquo;extended functionality&amp;rdquo; has second-class status. Besides, as item 7 explains, not all classes are designed to be base classes.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Item-22 Declare data members private</title>
      <link>http://nianze.tk/2018/02/declare-data-members-private/</link>
      <pubDate>Sat, 10 Feb 2018 00:00:00 +0000</pubDate>
      
      <guid>http://nianze.tk/2018/02/declare-data-members-private/</guid>
      <description>&lt;p&gt;Declaring data members &lt;code&gt;private&lt;/code&gt; gives clients syntactically uniform access to data, affords fine-grained access control, allows invariants to be enforced, and offers class authors implementation flexibility.

&lt;!-- toc --&gt;&lt;/p&gt;

&lt;h1 id=&#34;syntactic-consistency&#34;&gt;Syntactic consistency&lt;/h1&gt;

&lt;p&gt;If data member aren&amp;rsquo;t public, the only way for clients to access an object is via member functions. If everything in the public interface is a function, clients know they will always use parentheses when accessing a member of the class, which is called &amp;ldquo;sysntactic consistency&amp;rdquo;.&lt;/p&gt;

&lt;h1 id=&#34;pricise-control-over-the-accessibility&#34;&gt;Pricise control over the accessibility&lt;/h1&gt;

&lt;p&gt;If we use functions to get or set data member&amp;rsquo;s value, we can implement multiple levels of accessibility:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class AccessLevels {
public:
    ...
    int getReadOnly() const { return readOnly; }
    int getReadWrite() const { return readWrite; }
    void setReadWrite(int value) { readWrite = value; }
    void setWriteOnly(int value) { writeOnly = value; }
private:
    int noAccess;   // no access to this int
    int readOnly;   // read-only access to this int
    int readWrite;  // read-write access to this int
    int writeOnly;  // write-only access to this int
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Since it is rare that every data member need a getter and setter, such fine-grained access control is important.&lt;/p&gt;

&lt;h1 id=&#34;encapsulation&#34;&gt;Encapsulation&lt;/h1&gt;

&lt;p&gt;Encapsulation offers class authors implementation flexibility. Through a function, we can replace a data member with a computationi while nobody using the interface notice the change. For example, suppose we are writing an application monitoring the speed of passing cars, and each passing car&amp;rsquo;s speed will be collected into the class:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class SpeedDataCollection {
    ...
public:
    void addValue(int speed);    // add a new data value
    double averageSoFar() const; // return average speed
    ...
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;There are two ways to implement the member function &lt;code&gt;averageSoFar&lt;/code&gt;:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;have a data member in the classs that is a running average of all the speed data so far collected. &lt;code&gt;averageSoFar&lt;/code&gt; will simply return the value of this data member.&lt;/li&gt;
&lt;li&gt;have &lt;code&gt;averageSoFar&lt;/code&gt; compute its value anew each time it&amp;rsquo;s called by examining each data value in the collection&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Both approaches have pros and cons, and decision on which to use depends on the specific use case:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Method one makes each &lt;code&gt;SpeedDataCollection&lt;/code&gt; object bigger for the extra data member holding the running average, the accumulated total, and the number of data points, but &lt;code&gt;averageSoFar&lt;/code&gt; will be very efficient (it is just an inline function, see item 30). For an application where averages are needed frequently, and memory is not an issue, keeping a running average will be preferable.&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;Method two will make &lt;code&gt;averageSoFar&lt;/code&gt; run slower, but each &lt;code&gt;SpeedDataCollection&lt;/code&gt; object will be smaller. Thus it is preferable in applications where memory is tight (e.g., an embedded roadside device), and where averages are needed only infrequently&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The point is, by encapsulating the average through a member function, we can interchange different implementations, and clients will only have to, at most, recompile (we can even eliminate recompilation by the technique described in item 31). Since only member functions can affect data members, it is ensured that the class invariants are always maintained. Moreover, through function interfaces, we have flexibility for extra capabilities with ease (similar concept of &amp;ldquo;properties&amp;rdquo; in Delphi and C#, albeit with the need to type an extra set of parentheses):&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;to notify other objects when data members are read or written&lt;/li&gt;
&lt;li&gt;to verify class invariants and function pre-and postconditions&lt;/li&gt;
&lt;li&gt;to perform synchronization in threaded environments&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;On the other side, if we don&amp;rsquo;t encapsulate data members from clients, we give up the right to change our future implementation decisions. Even if we own the source code to a class, our ability to chagne anything public is extremely restricted, because too much client code will be broken. Public means unencapsulated, and unencapsulated means unchangeable, which is especailly true for widely used classes.&lt;/p&gt;

&lt;h1 id=&#34;protected-data-members&#34;&gt;&lt;code&gt;protected&lt;/code&gt; data members&lt;/h1&gt;

&lt;p&gt;The argument above is also applicable for &lt;code&gt;protected&lt;/code&gt; data members. In fact, no only the reasoning about syntactic consistency and fine-grained access control is applicable, the argument on encapsulation is also true for them:&lt;br /&gt;
suppose we eliminate a &lt;code&gt;protected&lt;/code&gt; data member, and then all the derived classes using it, typically in an unknowably large amount of size, will be broken, which is exactly the same case for &lt;code&gt;public&lt;/code&gt; data members used by large number of different clients.&lt;/p&gt;

&lt;p&gt;Thus, from an encapsulation point of view, there are really only two access levels:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;code&gt;private&lt;/code&gt;, which offers encapsulation&lt;/li&gt;
&lt;li&gt;everything else, which doesn&amp;rsquo;t&lt;/li&gt;
&lt;/ol&gt;</description>
    </item>
    
    <item>
      <title>Item-21 Don&#39;t return a reference when we have to return an object</title>
      <link>http://nianze.tk/2018/02/do-not-return-a-ref-when-must-return-an-object/</link>
      <pubDate>Fri, 09 Feb 2018 18:02:23 -0500</pubDate>
      
      <guid>http://nianze.tk/2018/02/do-not-return-a-ref-when-must-return-an-object/</guid>
      <description>&lt;p&gt;Never return a pointer or reference to a local stack object, a refenrence to a heap-allocated object, or a pointer or reference to a local static object if there is a change that more than one such object will be needed (item 4 provides a &amp;ldquo;counter&amp;rdquo; example that is reasonable in single-threaded environments).

&lt;!-- toc --&gt;&lt;/p&gt;

&lt;h1 id=&#34;case-study&#34;&gt;Case Study&lt;/h1&gt;

&lt;p&gt;There are some situations where we &lt;strong&gt;must&lt;/strong&gt; return an object, no matter how much effort we want to put into rooting out the evil of pass-by-value to pursue the heighest efficiency. Otherwise, we may invariably make a fatal mistake: pass references to objects that don&amp;rsquo;t exist.&lt;/p&gt;

&lt;p&gt;Consider following class for representing rational numbers with a multiplying function:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class Rational {
public:
    Rational(int numerator = 0,     // see item 24 for why this
            int denominator = 1);   // ctor isn&#39;t declared explicit
...
private:
    int n,d; // numerator and denominator
friend:
    const Rational  // see item 3 for why the return type is const
    operator**(const Rational&amp;amp; lhs,
               const Rational&amp;amp; rhs);
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We may want to remove the cost of construction and destruction from return-by-value, considering using return by reference instead. However, a reference is just a name for some &lt;em&gt;existing&lt;/em&gt; object. In the case of &lt;code&gt;opeartor*&lt;/code&gt;, the product of the two object does not exist before we call the function, so if &lt;code&gt;operator*&lt;/code&gt; want to return a reference to the product, it must create the result itself.&lt;/p&gt;

&lt;p&gt;A function can create a new object in only two ways: on the stack or on the heap.&lt;/p&gt;

&lt;h1 id=&#34;return-a-pointer-or-reference-to-a-local-stack-object&#34;&gt;Return a pointer or reference to a local stack object&lt;/h1&gt;

&lt;p&gt;Creation on the stack is accomplished by defining a local variable:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;const Rational&amp;amp; operator*(const Rational&amp;amp; lhs, const Rational&amp;amp; rhs) // bad code !
{
    Rational result(lhs.n * rhs.n, lhs.d * rhs.d);
    return result;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;There&amp;rsquo;s a serious problem: the function returns a reference to &lt;code&gt;result&lt;/code&gt;, which is a local object, and local objects are destroyed when the function exits, ending to return a reference to an ex-&lt;code&gt;Rational&lt;/code&gt;. Any caller glancing at this return value would instantly enter the realm of undefined behavior.&lt;/p&gt;

&lt;p&gt;The fact is, any function returning a reference (or a pointer) to a local object is brocken.&lt;/p&gt;

&lt;h1 id=&#34;return-a-reference-to-a-heap-allocated-object&#34;&gt;Return a reference to a heap-allocated object&lt;/h1&gt;

&lt;p&gt;Heap-based objects come into being through the use of &lt;code&gt;new&lt;/code&gt;, so the heap-based &lt;code&gt;opearator*&lt;/code&gt; looks like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;const Rational&amp;amp; operation*(const Rational&amp;amp; lhs, const Rational&amp;amp; rhs) // bad code !
{
    Rational *result = new Raional(lhs.n * rhs.n, lhs.d * rhs.d);
    return *result;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now comes a different problem: who will apply &lt;code&gt;delete&lt;/code&gt; matching the use of &lt;code&gt;new&lt;/code&gt;?&lt;/p&gt;

&lt;p&gt;Even if callers are conscientious and well intentioned, there&amp;rsquo;s not much they can do to prevent leaks in reasonable usage scenarios like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;Rational x, y, z;

Rational w = x * y * z; // same as operator*(operator*(x,y),z)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;There are twoe uses of &lt;code&gt;new&lt;/code&gt; that need to be undone with uses of &lt;code&gt;delete&lt;/code&gt;. Yet there&amp;rsquo;s no reasonable way for clients to get at the pointers hidden behind the references being returned from the calls to &lt;code&gt;operator*&lt;/code&gt; and make calls to &lt;code&gt;delete&lt;/code&gt;. This is a guaranteed resource leak.&lt;/p&gt;

&lt;h1 id=&#34;return-a-reference-to-a-local-static-object&#34;&gt;Return a reference to a local static object&lt;/h1&gt;

&lt;p&gt;If, however, we jump outside of the box, considering returning a reference to a &lt;em&gt;static&lt;/em&gt; &lt;code&gt;Rational&lt;/code&gt;, and think that this will avoid all but one initial constructor call without suffering from calling a constructor for each product result returned from &lt;code&gt;operatior*&lt;/code&gt; in above on-the-stack and on-the-heap approaches:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;const Rational&amp;amp; operator*(const Rational&amp;amp; lhs, const Rational&amp;amp; rhs) // bad code !
{
    static Rational result;  // static object
    result = ...; // put the product inside result
    return result;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Like all designs employing the use of static objects, this one immediately raises thread-safety hackles, but there&amp;rsquo;s a deeper flaw: consider following perfectly reasonable client code:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;bool operator==(const Rational&amp;amp; lhs, const Rational&amp;amp; rhs); 
Rational a,b,c,d;
...
if ((a * b) == (c * d)) {
    // do whatever appropriate when the products are equal
} else {
    // do whatever appropriate when the products are unequal
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Problem here is that the expression &lt;code&gt;((a * b) == (c * d))&lt;/code&gt; will &lt;em&gt;always&lt;/em&gt; evaluate to &lt;code&gt;true&lt;/code&gt;, regardless of the values of a, b, c, and d.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s rewrite the code in its equivalent functional form to understand what happened:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;if (operator==(operator*(a, b), operator*(c, d)))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;When &lt;code&gt;operator==&lt;/code&gt; is called, there will already be two active calls to &lt;code&gt;opearator*&lt;/code&gt;, each of which will return a reference to the static &lt;code&gt;Rational&lt;/code&gt; object inside &lt;code&gt;opeartion*&lt;/code&gt;, which, as is a static local object, will always be the exact one, with same value.&lt;/p&gt;

&lt;p&gt;Some may ask,&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Well, if &lt;em&gt;one&lt;/em&gt; static isn&amp;rsquo;t enough, maybe a static &lt;em&gt;array&lt;/em&gt; will do the trick&amp;hellip;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;The problem is, however, it is very hard to implement this arry of size &lt;code&gt;n&lt;/code&gt;:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;if &lt;code&gt;n&lt;/code&gt; is too small, we may run out of places to store return values and fall back to the single-static design situation;&lt;/li&gt;
&lt;li&gt;if &lt;code&gt;n&lt;/code&gt; is too big, we&amp;rsquo;ll decrease the performance of the program, because every object in the array will be constructed the first time the function is called - a cost of &lt;code&gt;n&lt;/code&gt; constructors and equally &lt;code&gt;n&lt;/code&gt; destructors even if the function is called only once.&lt;/li&gt;
&lt;li&gt;how to put the values we need into the array&amp;rsquo;s objects and what is the cost. The most direct way is via assignment, which cost the same as a call to a destructor (to destroy the old value) plus a call to a constructor (to copy over the new value)&lt;/li&gt;
&lt;li&gt;how to decide the position of target result in the array&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;the-right-way-return-by-value&#34;&gt;The right way: return by value&lt;/h1&gt;

&lt;p&gt;The right way to write a function that must return a new object is to have that function reutrn a new object like this or something essentially equivalent:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;inline const Rational operator*(const Rational&amp;amp; lhs, const Rational&amp;amp; rhs)
{
    return Rational(lhs.n * rhs.n, lhs.d * rhs.d);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In the long run, the cost of constructing and destructing &lt;code&gt;operator*&lt;/code&gt;&amp;rsquo;s return value is a small price to pay for correct behavior. What&amp;rsquo;s more, since C++ allows compiler implementers to apply optimizations to immprove the performance of the generated code, it turns out that in some cases, construction and destruction of &lt;code&gt;operator*&lt;/code&gt;&amp;rsquo;s return value can be safely eliminated, so the program will run faster than we expect and still behave correctly as it&amp;rsquo;s supposed to be.&lt;/p&gt;

&lt;p&gt;In summary, when deciding between returning a reference and returning an object, we should make choice that offers correct behavior.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Item-20 Perfer pass-by-reference-to-const to pass-by-value</title>
      <link>http://nianze.tk/2018/02/perfer-pass-by-reference-to-const/</link>
      <pubDate>Thu, 08 Feb 2018 16:26:33 -0500</pubDate>
      
      <guid>http://nianze.tk/2018/02/perfer-pass-by-reference-to-const/</guid>
      <description>&lt;p&gt;Pass by reference-to-&lt;code&gt;const&lt;/code&gt; is typically more efficient than pass by value and avoids the slicing problem.
&lt;/p&gt;

&lt;p&gt;Pass-by-value can be an expensive operation. For example, consider the following class hierarchy:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class Person {
public:
    Person();  // parameters omitted for simplisity
    virtual ~Person();  // item 7 explains why virtual
    ...
private:
    std::string name;
    std::string address;
};

class Student:public Person {
public:
    Student();   // parameters omitted for simplisity
    ~Student();
    ...
private:
    std::string schoolName;
    std::string schoolAddress;
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now consider what will happen if we call a function &lt;code&gt;validateStudent&lt;/code&gt;, which takes a &lt;code&gt;Student&lt;/code&gt; argument (by value) and returns whether it is a real student:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;bool validateStudent(Student s);  // pass a Student object by value
Student plato;
bool platoIsOK = validateStudent(plato); // call the function
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A &lt;code&gt;Student&lt;/code&gt; object has two &lt;code&gt;string&lt;/code&gt; object within it, while its base class &lt;code&gt;Person&lt;/code&gt; contains two additional &lt;code&gt;string&lt;/code&gt; type data members. So the parameter-passing cost of this function is one call to the &lt;code&gt;Student&lt;/code&gt; copy constructor matched with two &lt;code&gt;string&lt;/code&gt; copy constructor, and one call to the base class &lt;code&gt;Person&lt;/code&gt;&amp;rsquo;s copy constructor, which also entails two more &lt;code&gt;string&lt;/code&gt; construction. When the &lt;code&gt;Student&lt;/code&gt; object is destroyed, each constructor call is matched by a destructor call. Overall, the cost of passing a &lt;code&gt;Student&lt;/code&gt; by value is six constructors and six destructors.&lt;/p&gt;

&lt;p&gt;It would be nice is there were a way to bypass all those constructions and destructions. The answer is: pass by reference-to-&lt;code&gt;const&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;bool validateStudent(const Student&amp;amp; s);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Since no new objects are being created, there&amp;rsquo;s no constructor or destructor call. The &lt;code&gt;const&lt;/code&gt; in the revised parameter declaration is important, for it guarantees that the callers would not worry about &lt;code&gt;validateStudent&lt;/code&gt; making changes to the &lt;code&gt;Student&lt;/code&gt; they passed in (when passing by value, &lt;code&gt;validateStudent&lt;/code&gt; would be able to modify only a &lt;em&gt;copy&lt;/em&gt; of the &lt;code&gt;Student&lt;/code&gt; they passed in, so the callers know they are shielded from any changes the function might make to the &lt;code&gt;Student&lt;/code&gt;).&lt;/p&gt;

&lt;p&gt;Apart from efficiency, passing parameters by reference also avoids the &lt;code&gt;slicing problem&lt;/code&gt;: when a derived class object is passed (by value) as a base class object, the base class copy constructor is called, and the extra features in derived class object are &amp;ldquo;sliced&amp;rdquo; off. For example:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class Window {
public:
    ...
    std::string name() const;     // return name of window
    virtual void display() const; // draw window and contents
};

class windowWiScroBars: public Window {
public:
    ...
    virtual void display() const;
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Below is a bad example if you want to write a function to print out a window&amp;rsquo;s name and then display the window:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;void printNameAndDisplay(Window w)
{
    std::cout &amp;lt;&amp;lt; w.name();
    w.displey();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;When you call this functiona with a &lt;code&gt;WindowWithScrollBars&lt;/code&gt; object:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;WindowWithScrollBars wwsb;
printNameAndDisplay(wwsb);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Since it is passed by value, the parameter &lt;code&gt;w&lt;/code&gt; will be constructed as a &lt;code&gt;Window&lt;/code&gt; object. Regardless of the type of object passed to the function, inside &lt;code&gt;printNameAndDisplay&lt;/code&gt;, &lt;code&gt;w&lt;/code&gt; will act like an object of class &lt;code&gt;Window&lt;/code&gt; (it &lt;em&gt;is&lt;/em&gt; an object of class &lt;code&gt;Window&lt;/code&gt; after all), and all the specialized information that made &lt;code&gt;wwsb&lt;/code&gt; act like a &lt;code&gt;WindowWithScrollBars&lt;/code&gt; object will be sliced off.&lt;/p&gt;

&lt;p&gt;However, if we revised the function declaration like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;void printNameAndDisplay(const Window&amp;amp; w)  // fine, parameter won&#39;t be sliced
{
    std::cout &amp;lt;&amp;lt; w.name();
    w.display();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now &lt;code&gt;w&lt;/code&gt; will act like whatever kind of window is actually passed in.&lt;/p&gt;

&lt;h3 id=&#34;exception&#34;&gt;Exception&lt;/h3&gt;

&lt;p&gt;In general, the only types for which we can reasonably assume that pass-by-value is inexpensive are:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;built-in types&lt;/li&gt;
&lt;li&gt;STL iterator&lt;/li&gt;
&lt;li&gt;function object types&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Under the hood of the C++ compiler, a reference is implemented as pointers, so passing by reference usually means passing a pointer. This is why for built-in types (e.g., an &lt;code&gt;int&lt;/code&gt;), it&amp;rsquo;s more efficient to pass it by value than by reference. Also, iterators and function objects in the STL are more efficient to copy and are not subject to the slicing problem because they are designed to be passed by value (this is an example where rules change depending on which part of C++ we are using, see item 0).&lt;/p&gt;

&lt;p&gt;On the other hand, we can not conclude that all small types are necessarily good pass-by-value candidate:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;the user-defined types, despite being small in terms of size, may have expensive copy constructors, such as most STL containers that contain little more than a pointer but leading to copying everything they point to when applying copying operation.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;even if the copy constructors are inexpensive, compilers may treat user-defined small types differently with buiilt-in types: for example, some compilters refuse to put objects consisting of only a &lt;code&gt;double&lt;/code&gt; into a register, even though they will happily place naked &lt;code&gt;double&lt;/code&gt;s there, so we can be better off passing such objects by reference, for compilers will certainly put pointers (the implementation of references) into registers.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;a type that is small now may be bigger in a future release, for its internal implementation may change; things can even change when we switch to a different C++ implementation, for example, some implementations of the standard library&amp;rsquo;s &lt;code&gt;string&lt;/code&gt; type are seven times as big as others.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;In summary, for everything else other than built-in types and STL iterator and function object types, follow the advice and prefer pass-by-reference-to-&lt;code&gt;const&lt;/code&gt; over pass-by-value.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Item-19 Treat class design as type design</title>
      <link>http://nianze.tk/2018/02/class-design-is-type-design/</link>
      <pubDate>Wed, 07 Feb 2018 13:47:07 -0500</pubDate>
      
      <guid>http://nianze.tk/2018/02/class-design-is-type-design/</guid>
      <description>&lt;p&gt;Before definining a new type, be sure to consider all the issues discussed in this item.
&lt;/p&gt;

&lt;p&gt;In object-oriented programming wolrd, defining a new class defines a new type, yet designing good types is challenging. Good types have a natural syntax, intuitive semantics, and one or more efficient implementations. To disign effective classes, we must understand the issues we face, and ask ourselves the following questions to constrain the design:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;How should objects of the new type be created and destroyed?&lt;br /&gt;
This influences the desiggn of the class&amp;rsquo;s constructors and destructors, as well as memory allocation and deallocation functions(&lt;code&gt;operator new&lt;/code&gt;, &lt;code&gt;operator new[]&lt;/code&gt;,&lt;code&gt;operator delete&lt;/code&gt;,&lt;code&gt;operator delete[]&lt;/code&gt;)&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;How should object initialization differ from object assignment?&lt;br /&gt;
Thie determines the behavior of constructor (for initialization) and assignment operator (for assignment).&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;What does it mean for objects of the new type to be passed by value?&lt;br /&gt;
Copy constructor defines how pass-by-value is implemented for a type.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;What are the restrictions on legal values for the new type?&lt;br /&gt;
Valid combinations of values for a class&amp;rsquo;s data member may require some error checking inside member functions such as constructors, assignment operators, and &amp;ldquo;setter&amp;rdquo; functions. It may also affect the exceptions (as well as related exception specification) thrown by member functions.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Does the new type fit into an inheritance graph?&lt;br /&gt;
If the class is inherited from existing classes, it is constrained by the base class (particularly by base class&amp;rsquo;s design on &lt;code&gt;virtual&lt;/code&gt; or &lt;code&gt;non-virtual&lt;/code&gt;, item 34, 36). If the class will be base class of other classes, we should consider whether to declare the functions as &lt;code&gt;virtual&lt;/code&gt; or not (especially the destructor, item 7).&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;What kind of type conversions are allowed for the new type?&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;If we wish to allow object of type &lt;code&gt;T1&lt;/code&gt; to be &lt;em&gt;implicitly&lt;/em&gt; converted into objects of type &lt;code&gt;T2&lt;/code&gt;, we need to write either a type conversion function in class &lt;code&gt;T1&lt;/code&gt; (e.g., &lt;code&gt;operator T2&lt;/code&gt;) or a non-&lt;code&gt;explicit&lt;/code&gt; constructor in class &lt;code&gt;T2&lt;/code&gt; that can be called with a single argument.&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;If we wish to allow &lt;em&gt;explicit&lt;/em&gt; conversions only, we need to write functions to perform the conversions and avoid making type conversion operators or non-&lt;code&gt;explicit&lt;/code&gt; constructors with only one argument (item 15).&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;What operators and functions make sense for the new type?&lt;br /&gt;
This determines which functions will be member functions and which not (item 23, 24, 46).&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;What standard functions should be disallowed?&lt;br /&gt;
This determines the standard functions declared as &lt;code&gt;private&lt;/code&gt; (item 6).&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Who should have access to the members of the new type?&lt;br /&gt;
This determines if a member is &lt;code&gt;public&lt;/code&gt;, &lt;code&gt;protected&lt;/code&gt;, or &lt;code&gt;private&lt;/code&gt;. It also determines which classes and/or functions should be &lt;code&gt;friend&lt;/code&gt;s, as welll as to nest one class inside another.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;What is the &amp;ldquo;undeclared interface&amp;rdquo; of the new type?&lt;br /&gt;
This guarantees the performance, exception safety (item 29), and resource usage (e.g., locks and dynamic memory) clients will expect, which will impose constraints on the class implementation.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;How general is the new type?&lt;br /&gt;
If we&amp;rsquo;re defining a whole family of types, we may want to define a new class &lt;code&gt;template&lt;/code&gt; instead of a new class.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Is a new type really what we need?&lt;br /&gt;
If a new derived class is only added into some functionality to an existing class, maybe a simple definition of one or more non-member functions or templates will be better approach.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Once these questions solved properly, user-defined classes in C++ yield types that are at least as good as the built-in types, which makes all the effort worthwhile.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Item-18 Make interfaces easy to use correctly and hard to use incorrectly</title>
      <link>http://nianze.tk/2018/02/make-interfaces-easy-to-use-correctly/</link>
      <pubDate>Tue, 06 Feb 2018 19:05:53 -0500</pubDate>
      
      <guid>http://nianze.tk/2018/02/make-interfaces-easy-to-use-correctly/</guid>
      <description>&lt;p&gt;Good interfaces are easy to use correctly and hard to use incorrectly.

&lt;!-- toc --&gt;&lt;/p&gt;

&lt;p&gt;To design a good interface, it&amp;rsquo;s always good to make the interface in consistency and behave in compatibility with built-in types. After all, clients already know how types like &lt;code&gt;int&lt;/code&gt; behave, so we should strive to make our types behave the same way. A good (though not perfect) example is the interface to STL containers: every STL container has a &lt;em&gt;member function&lt;/em&gt; named &lt;code&gt;size&lt;/code&gt; that tells how many objects are in the container. On the contrary, in &lt;strong&gt;Java&lt;/strong&gt;, we use the &lt;code&gt;length&lt;/code&gt; &lt;em&gt;property&lt;/em&gt; for arrays, the &lt;code&gt;length&lt;/code&gt; &lt;em&gt;method&lt;/em&gt; for &lt;code&gt;String&lt;/code&gt;s, and the &lt;code&gt;size&lt;/code&gt; &lt;em&gt;method&lt;/em&gt; for &lt;code&gt;List&lt;/code&gt;s; as for &lt;strong&gt;.Net&lt;/strong&gt;, &lt;code&gt;Arrays&lt;/code&gt; have a property named &lt;code&gt;Length&lt;/code&gt;, while &lt;code&gt;ArrayList&lt;/code&gt;s have a property named &lt;code&gt;Count&lt;/code&gt;. No matter how convenient modern IDEs may be, inconsistency imposes mental fricition into a developer&amp;rsquo;s work.&lt;/p&gt;

&lt;p&gt;A good way to think of the interface design is to consider the kinds of mistakes that clients might make, and we could try the following 4 ways:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Creating new types&lt;/li&gt;
&lt;li&gt;Constraining object values&lt;/li&gt;
&lt;li&gt;Restricting operations on types&lt;/li&gt;
&lt;li&gt;Eliminating client resource management responsibilities&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&#34;creating-new-types&#34;&gt;Creating new types&lt;/h1&gt;

&lt;p&gt;Say we&amp;rsquo;re designing the constructor for a class representing dates in time:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class Date {
public:
    Date(int month, int day, int year);
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;There at least two possible errors that clients might easily make:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;the parameters might be passed in the wrong order:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;Date d(30, 3, 1995);  // Should be &amp;quot;3, 30&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;the parameters might be invalid &lt;month, day&gt; pair:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;Date d(2, 30, 1995);  // In the keyboard, `2` is next to &#39;3&#39;, so this kind of silly error is not uncommon
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;To prevent such kind of client errors, we could introduce new types:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;struct Day {
    explicit Day(int d)
    :val(d){}
    
    int val;
};
struct Month {
    explicit Month(int m)
    :val(m){}
    
    int val;
};
struct Year {
    explicit Year(int y)
    :val(y){}
    
    int val;
};
class Date {
public:
    Date(const Month&amp;amp; m, const Day&amp;amp; d, const Year&amp;amp; y);
    ...
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This will prevent some silly interface usage errors effectively:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;Date d(30, 3, 1995); // error: wrong type!
Date d(Day(30), Month(3), Year(1995));  // error: wrong type!
Date d(Month(3), Day(30), Year(1995));  // fine
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;constraining-object-values&#34;&gt;Constraining object values&lt;/h1&gt;

&lt;p&gt;Once the type is right, we may consider adding some restriction on the values of those types. The &lt;code&gt;Month&lt;/code&gt; in example above only has 12 valid values, so the &lt;code&gt;Month&lt;/code&gt; type should reflect this restriction. One way is to use an enum to represent the month, but considering enums can be used like &lt;code&gt;ints&lt;/code&gt; (item 2), it is not as type-safe as we might like. A safer solution is to predefine the set of all valid &lt;code&gt;Month&lt;/code&gt;s:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class Month {
public:
    static Month Jan() {return Month(1);}  // functions returning all
    static Month Feb() {return Month(2);}  // valid Month values
    ...
    static Month Dec() {return Month(12);}
...
private:
    explicit Month(int m);  // prevent creation of new Month values
    ...  // month-specific data
};

Date d(Month::Mar(), Day(30), Year(1995));
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The reason to use functions (returning local static objects) instead of (non-local static) objects to represent specific months is explained in item 4:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;the relative order of initialization of non-local static objects defined in different translation units is undefined.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&#34;restricting-operations-on-types&#34;&gt;Restricting operations on types&lt;/h1&gt;

&lt;p&gt;A good example for restricting operations on types is in item 3 explaining how &lt;code&gt;const&lt;/code&gt; qualifying the return type from &lt;code&gt;operator*&lt;/code&gt; can prevent clients from making following errors for user-defined types:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;if (a * b = c)... // meant to do a comparison
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Again, it is always good to have our types behave consistently with the built-in types. Such kind of operation is illegal for &lt;code&gt;int&lt;/code&gt; type, so unless there&amp;rsquo;s a good reason, it should be illegal for our types, too.&lt;/p&gt;

&lt;h1 id=&#34;eliminating-client-resource-management-responsibilities&#34;&gt;Eliminating client resource management responsibilities&lt;/h1&gt;

&lt;p&gt;Any interface that requires that client remember to do something is prone to incorrect use. A bad example is function &lt;code&gt;createInvestment&lt;/code&gt; in item 13, which returns pointers to dynamically allocated objeects in an &lt;code&gt;Investment&lt;/code&gt; hierarchy.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;Investment* createInvestment();  // parameters omitted for simplicity
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Needless to say, this is prone to resource leak, for chances are that clients either forget to manually &lt;code&gt;delete&lt;/code&gt; the pointer, or delete the same pointer more than once&lt;/p&gt;

&lt;p&gt;Item 13 shows that we could preempt this problem by using smart pointers. But a better solution is to let the function &lt;code&gt;createInvestment&lt;/code&gt; return a smart pointer in the first place:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;std::tr1::shared_ptr&amp;lt;Investment&amp;gt; createInvestment();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Moreover, returning a &lt;code&gt;tr1::shared_ptr&lt;/code&gt; makes it possible to prevent a host of other client errors regarding resource release, for  &lt;code&gt;tr1::shared_ptr&lt;/code&gt; allows a resource-release function (called a &amp;ldquo;deleter&amp;rdquo;) to be bound to the smart pointer when the smart pointer is created (item 14, &lt;code&gt;auto_ptr&lt;/code&gt; does not support this functionality).&lt;/p&gt;

&lt;p&gt;For example, instead of using &lt;code&gt;delete&lt;/code&gt; to release an &lt;code&gt;Investment&lt;/code&gt; object resource, clients may expect to use a function called &lt;code&gt;getRidOfInvestment&lt;/code&gt;. By binding &lt;code&gt;getRidOfInvestment&lt;/code&gt; to &lt;code&gt;tr1::shraed_ptr&lt;/code&gt; as its deleter, and return this smart pointer, clients will not make mistakes such as using the wrong resource-destruction mechanism (using &lt;code&gt;delete&lt;/code&gt; instead of &lt;code&gt;getRidOfInvestment&lt;/code&gt;).&lt;/p&gt;

&lt;p&gt;Thus, in order to bind the deleter, we could define a null &lt;code&gt;tr1::shared_ptr&lt;/code&gt; with &lt;code&gt;getRidofInvestment&lt;/code&gt; as its second argument (the first argument is null because we may not be sure the resource to be managed during initialization), and implement &lt;code&gt;createInvestment&lt;/code&gt; like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;std::tr1::shared_ptr&amp;lt;Investment&amp;gt; createInvestment()
{
    std::tr1::shared_ptr&amp;lt;Investment&amp;gt;      // return a null shared_ptr
    retVal(static_cast&amp;lt;Investment*&amp;gt;(0),   // see item 27 for static_cast
            getRidOfInvestment);          // bind a custom deleter
    ...                                   // make retVal point to the correct object
    return retVal;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Since &lt;code&gt;tr1::shared_ptr&lt;/code&gt; insists on an actual pointer, we use a cast to solve the problem. Of course, it would be better to pass the raw pointer to the smart pointer&amp;rsquo;s constructor if the raw pointer to be managed by &lt;code&gt;retVal&lt;/code&gt; could be determined prior to creating &lt;code&gt;retVal&lt;/code&gt;, rather than to initialize &lt;code&gt;retVal&lt;/code&gt; to null and then making an assignment to it (item 26).&lt;/p&gt;

&lt;p&gt;What&amp;rsquo;s more, another nice feature of &lt;code&gt;tr1::shared_ptr&lt;/code&gt; is that it automatically uses its per-pointer deleter to release resource, which eliminates the &amp;ldquo;cross-DLL problem&amp;rdquo; that shows up when an object its created using &lt;code&gt;new&lt;/code&gt; in one dynamically linked library (DLL) but is &lt;code&gt;deleted&lt;/code&gt; in a different DLL, leading to runtime errors. For example, if &lt;code&gt;Stock&lt;/code&gt; is a class derived from &lt;code&gt;Investment&lt;/code&gt; and &lt;code&gt;createInvestment&lt;/code&gt; is implemented like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;std::tr1::shared_ptr&amp;lt;Investment&amp;gt; createInvestment()
{
    return std::tr1::shared_ptr&amp;lt;Investment&amp;gt;(new Stock);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;the returned &lt;code&gt;tr1::shared_ptr&lt;/code&gt; pointing to the &lt;code&gt;Stock&lt;/code&gt; keeps track of which DLL&amp;rsquo;s &lt;code&gt;delete&lt;/code&gt; should be used when the reference count for the &lt;code&gt;Stock&lt;/code&gt; becomes zero, so there&amp;rsquo;s no more concern for the cross-DLL problem.&lt;/p&gt;

&lt;p&gt;The most common implementation of &lt;code&gt;tr1::shared_ptr&lt;/code&gt; comes from Boost (item 55). Since it is such an easy way to eliminate some client errors, it&amp;rsquo;s worth an overview of the cost of using it: Boost&amp;rsquo;s &lt;code&gt;shared_ptr&lt;/code&gt; is twice the size of a raw pointer, uses dynamically allocated memory for bookkeeping and deleter_specific data, uses a virtual function call when invoking its deleter, and incurs thread synchronization overhead when modifying the reference count in an application it believes is multithreaded.&lt;/p&gt;

&lt;p&gt;Although compared to a raw pointer, the &lt;code&gt;tr1::shared_ptr&lt;/code&gt; is bigger, slower, and uses auxiliary dynamic memory, the reduction in client errors will be apparent， and the additional runtime costs will be unnoticeable in many applications.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>2018进度表</title>
      <link>http://nianze.tk/2018/02/2018-roadmap/</link>
      <pubDate>Tue, 06 Feb 2018 11:44:42 -0500</pubDate>
      
      <guid>http://nianze.tk/2018/02/2018-roadmap/</guid>
      <description>&lt;p&gt;马上春节了，来列一下新年计划吧。
&lt;/p&gt;

&lt;p&gt;虽说计划表这种东西理应是年初就该想好的，但彼时的我其实并没有很强烈的动机和想法来列出新年的计划。不过正巧今年春节在2月15日，可以安慰下自己中国新年还没到。还好最近这两天越来越想清楚了今年最想做的事情，契机便是从一月中旬开始每天写一篇C++相关的博文，到今天突然发现这种努力只要日积月累养成习惯，积攒下来的时间还是很可观的。&lt;/p&gt;

&lt;p&gt;其实真要说起来，这种计划性可以追溯到去年底备考CFA的阶段，基本上是花了1.5个月抽出每天下班的间隙把5本notes看完了。那个时候为了赶在due前把几千页书全过一遍，不得不提前制定好每天的任务量，再在白板上标记每天的进度。虽然最后CFA没考过，不过这个方法逐渐变成了习惯，而且让我更清楚的意识到，如果把时间当做一种资本看待，就会发现一旦自己不小心重又陷入荒碌无聊的状态,然后开始无意识的把日子浪费在消遣性娱乐活动中，就无异于把本已所剩无多的资产抛弃在虚无的深渊，却忘记了这世上明明还有这么多有趣的事情值得拿宝贵的时间资产来换取——明明谁都明白买椟还珠的主人公的可笑和荒谬，可真要是把故事主角换做了自己，反而照样会无视时间的珍珠，只看到包裹在生活表层的那些欢愉却易逝的精致包装。留给我挥霍的时间，其实已经不多了。&lt;/p&gt;

&lt;p&gt;下面准备按照时间进度把今年想看的技术相关的书列在下面，争取每天都写一篇文章来总结进度吧：&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;left&#34;&gt;Time&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;Book&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;Jan&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Effective C++ (item1-12)&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;Feb&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Effective C++ (item13-40)&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;Mar&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Effec. C++ (item41-55), More Effec. C++ (item1-16), Eloquent JS&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;Apr&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;More Effec. C++ (item17-35), Modern Effec. C++ (item1-12)&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;May&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Modern Effec. C++ (item13-42)&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;Jun&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Hands On ML, Effec. JS&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;Jul&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Designing Data-Intensive Applications&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;Aug&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Clean Architecture&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;Sep&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;待定&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;Oct&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;待定&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;Nov&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;待定&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;Dec&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;待定&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;兴趣方面的书籍只能抽每天回家睡前的时间以及周末来看了：&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Hobby&lt;/th&gt;
&lt;th&gt;Items&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;钢琴&lt;/td&gt;
&lt;td&gt;Hanon,Czerny&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;吉他&lt;/td&gt;
&lt;td&gt;指弹&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;日语&lt;/td&gt;
&lt;td&gt;みんなの日本語&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;其他&lt;/td&gt;
&lt;td&gt;叔本华&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;</description>
    </item>
    
    <item>
      <title>Item-17 Store newed objects in smart pointers in standalone statements</title>
      <link>http://nianze.tk/2018/02/store-newed-objects-in-smart-pointers-in-standalone-statements/</link>
      <pubDate>Mon, 05 Feb 2018 18:04:38 -0500</pubDate>
      
      <guid>http://nianze.tk/2018/02/store-newed-objects-in-smart-pointers-in-standalone-statements/</guid>
      <description>&lt;p&gt;Failure to do this can lead to subtle resource leaks when exceptions are thrown.
&lt;/p&gt;

&lt;p&gt;Suppose there&amp;rsquo;re two functions:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;int priority(); // reveal processing priority
void processWidget(std::tr1::shared&amp;lt;Widget&amp;gt; pw, int priority); // do some processing on a dynamically allocated `Widget` in accord with the priority above
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Apparently, following code won&amp;rsquo;t compile:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;processWidget(new Widget, priority());
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is because &lt;code&gt;tr1::shared_ptr&lt;/code&gt;&amp;rsquo;s constructor taking a raw is &lt;code&gt;explicit&lt;/code&gt;, there&amp;rsquo;s no implicit conversion from the raw pointer (returned by &lt;code&gt;new Widget&lt;/code&gt;) to the &lt;code&gt;tr1::shared_ptr&lt;/code&gt; (required by &lt;code&gt;processWidget&lt;/code&gt;).&lt;/p&gt;

&lt;p&gt;However, even though the code below does compile, seems correct, and carefully uses &lt;code&gt;shared_ptr&lt;/code&gt; to manage resource, it may still leak resources:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;processWidget(std::tr1::shared_ptr&amp;lt;Widget&amp;gt;(new Widget), priority());
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The two arguments as function parameters must be evaluated before a call to &lt;code&gt;processWidget&lt;/code&gt; is generated, and the first argument actually consists of two parts:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;execution of the expression &lt;code&gt;new Widget&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;call to the &lt;code&gt;tr1::shared_ptr&lt;/code&gt; constructor&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Thus, before &lt;code&gt;processWidget&lt;/code&gt; can be called, following three steps must take place:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Call &lt;code&gt;priority&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Execute &lt;code&gt;new Widget&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Call the &lt;code&gt;tr1::shared_ptr&lt;/code&gt; constructor&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Unlike Java and C#, where function parameters are always evaluated in a particular order, C++ compilers are free to decide the order of steps above. Although &lt;code&gt;new Widget&lt;/code&gt; must take place before &lt;code&gt;tr1::shared_ptr&lt;/code&gt; constructor can be call (for the result of &lt;code&gt;new&lt;/code&gt; operation is the argument of the smart pointer&amp;rsquo;s constructor), the call to &lt;code&gt;priority()&lt;/code&gt; can be performed first, second, or third. If compilers choose to perform it second (maybe for efficiency consideration):&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Execute &lt;code&gt;new Widget&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Call &lt;code&gt;priority&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Call &lt;code&gt;tr1::shared_ptr&lt;/code&gt; constructor&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;The problem here is that, once the call to &lt;code&gt;priority&lt;/code&gt; yields an exception, the pointer returned from &lt;code&gt;new Widget&lt;/code&gt; has not turned over to the resource-managing object, and resource leaks.&lt;/p&gt;

&lt;p&gt;Luckily, it is very simple to avoid this problem: use a separate statement to create &lt;code&gt;Widget&lt;/code&gt; and store it in a smart pointer, then pass the smart pointer to &lt;code&gt;processWidget&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;std::tr1::shared_ptr&amp;lt;Widget&amp;gt; pw(new Widget); // standalone statement
processWidget(pw, priority());  // won&#39;t leak
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now the &lt;code&gt;new Widget&lt;/code&gt; expression and the call to &lt;code&gt;tr1::shared_ptr&lt;/code&gt; constructor are in a different statement from the call to &lt;code&gt;priority&lt;/code&gt;, compilers are not allowed to move the call to &lt;code&gt;priority&lt;/code&gt; between them.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Item-16 Use the same form in corresponding uses of new and delete</title>
      <link>http://nianze.tk/2018/02/use-the-same-form-in-matching-new-and-delete/</link>
      <pubDate>Sun, 04 Feb 2018 00:00:00 +0000</pubDate>
      
      <guid>http://nianze.tk/2018/02/use-the-same-form-in-matching-new-and-delete/</guid>
      <description>&lt;p&gt;If you use [] in a &lt;code&gt;new&lt;/code&gt; expression, use [] in the corresponding &lt;code&gt;delete&lt;/code&gt; expression; If not, no [] in the matching &lt;code&gt;delete&lt;/code&gt; expression.
&lt;/p&gt;

&lt;p&gt;When employing a &lt;code&gt;new&lt;/code&gt; expression, two things happen:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;membory is allocated (via the function &lt;code&gt;operator new&lt;/code&gt;, item 49, 51)&lt;/li&gt;
&lt;li&gt;one or more constructors are called for that memory&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;When a &lt;code&gt;delete&lt;/code&gt; is used, two other things happen:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;one or more destructors are called for the memory&lt;/li&gt;
&lt;li&gt;The memory is deallocated (via the function &lt;code&gt;operator delete&lt;/code&gt;, item 51)&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;The fact is that the memory layout for single objects is generally different from the memory layout for arrays, and the memory for an array usually includes extra area for the size of the array (making it easier for &lt;code&gt;delete&lt;/code&gt; to know how many destructor to call) while memory for a single object lacks this information:&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Memory type&lt;/th&gt;
&lt;th&gt;Memory layout&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Array&lt;/td&gt;
&lt;td&gt;|n|Object|Object|Object|&amp;hellip;|&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;Single object&lt;/td&gt;
&lt;td&gt;|Object|&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;When we use &lt;code&gt;delete&lt;/code&gt; on a pointer, &lt;code&gt;delete []&lt;/code&gt; will assumes an array is pointed to, otherwise it assumes a single object. Let&amp;rsquo;s see what will happen if the uses of &lt;code&gt;new&lt;/code&gt; and &lt;code&gt;delete&lt;/code&gt; is not matching:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;std::string *stringPtr1 = new std::string;
std::string *stringPtr2 = new std::string[100];
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;delete [] stringPtr1;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;The result is undefined. &lt;code&gt;delete&lt;/code&gt; will read some memory and interpret what it read as an array size, then start invoking the destructors, and it&amp;rsquo;s probably not holding the objects of the type it&amp;rsquo;s busy destructing at this point.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;delete stringPtr2;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;It&amp;rsquo;s undefined behavior too. It&amp;rsquo;s easy to see the expression would lead to too few destructors being called. Furthermore, it&amp;rsquo;s also undefined for built-in types (which lack destructors), too.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The rule is particularly important to bear in mind when writing a class containing a pointer to dynamically allocated memory and also offering multiple constructors, for we must be careful to use the same form of &lt;code&gt;new&lt;/code&gt; in all the constructors to initialize the pointer member. After all, there&amp;rsquo;s only one form of &lt;code&gt;delete&lt;/code&gt; in the destructor.&lt;/p&gt;

&lt;p&gt;The rule is also noteworthy for &lt;code&gt;typedef&lt;/code&gt;-inclined:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;typedef std::string AddressLines[4];  // a person&#39;s address has 4 lines
std::string *pal = new AddressLines;  // return type is string*, just like &amp;quot;new string[4]&amp;quot; would

delete pal;     // undefined!
delete [] pal;  // fine, array form of delete is the matched version
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To avoid such confusion, abstain from &lt;code&gt;typedef&lt;/code&gt;s for array types. Try using &lt;code&gt;string&lt;/code&gt; and &lt;code&gt;vector&lt;/code&gt; from the standard C++ library (item 54) - those templates reduce the need for dynamically allocated arrays to nearly zero: for example, we may define &lt;code&gt;AddressLines&lt;/code&gt; as type &lt;code&gt;vector&amp;lt;string&amp;gt;&lt;/code&gt;.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Item-15 Provide access to raw resource in resource-managing classes</title>
      <link>http://nianze.tk/2018/02/provide-access-to-raw-rsc/</link>
      <pubDate>Sat, 03 Feb 2018 00:00:00 +0000</pubDate>
      
      <guid>http://nianze.tk/2018/02/provide-access-to-raw-rsc/</guid>
      <description>&lt;p&gt;Each RAII class should offer a way to get at the resource it manages.

&lt;!-- toc --&gt;&lt;/p&gt;

&lt;p&gt;From time to time, some APIs require access to raw resources, so it is a good habit to design the resource-managing classes in such a way that it provides access to raw resources. For example, suppose there&amp;rsquo;s a function we&amp;rsquo;d like to use with &lt;code&gt;Investment&lt;/code&gt; objects, which is managed by smart pointer:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;int daysHeld(const Investment *pi);  // return number of days investment has been held

std::tr1::shared_ptr&amp;lt;Investment&amp;gt; pInv(createInvestment()); // item 13
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Since &lt;code&gt;dayHeld&lt;/code&gt; wants a raw &lt;code&gt;Investment*&lt;/code&gt; pointer, if passing an object of type &lt;code&gt;tr1::shared_ptr&amp;lt;Investment&amp;gt;&lt;/code&gt;, the code won&amp;rsquo;t compile:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;ind days = daysHeld(pInv);  // error
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We need to find a way to get the access to the raw resources, and generally there are two ways:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Implicit conversion (convenient for clients)&lt;/li&gt;
&lt;li&gt;Explicit conversion (generally preferred)&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&#34;implicit-conversion&#34;&gt;Implicit conversion&lt;/h1&gt;

&lt;p&gt;Pointer dereferencing operators (&lt;code&gt;operator-&amp;gt;&lt;/code&gt; and &lt;code&gt;operator*&lt;/code&gt;) are implicit conversion to the underlying raw pointers, which is virtually provided by all smart pointer classes. Suppose there&amp;rsquo;s a member function &lt;code&gt;bool isTaxFree()&lt;/code&gt; inside the class &lt;code&gt;Investment&lt;/code&gt;, and we can access the member function like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;bool taxable1 = !(pInv-&amp;gt;isTaxFree());  // access resource via operator-&amp;gt;

bool taxable2 = !((*pInv).isTaxFree());  // access resource via operator*
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;When it is necessary to get at the raw resource inside an RAII object, another way of conversion is through an &lt;em&gt;implicit conversion function&lt;/em&gt;. Consider following RAII class for fonts:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;FontHandle getFont();  // from C API
void releaseFont(FontHandle fh);  // from the same C API

class Font {   // self-defined RAII class
public:
    explicit Font(FontHanlde fh)  // acquire resource
    : f(fh)                       // use pass-by-value because the C API does
    {}
    ~Font() { releaseFont(f); }   // release resource

operator FontHandle() const {return f;}  // implicit conversion function

private:
    FontHandle f;                 // the raw font resource
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This makes calling into the following C API easy and natural:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;void changeFontSize(FontHandle f, int newSize);  // the C API

Font f(getFont());
int newFontSize;
...
changeFontSize(f, newFontSize);  // implicitly convert Font to FontHandle
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;However, the downsize is that implicit conversions increase the chance of errors - a &lt;code&gt;FontHandle&lt;/code&gt; may be created when a &lt;code&gt;Font&lt;/code&gt; is really intended:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;Font f1(getFont());
...
FontHandle f2 = f1;  // meant to copy a Font object but implicitly converted f1 into 
                     // FontHandle, and copied the underlying resource
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;explicit-conversion&#34;&gt;Explicit conversion&lt;/h1&gt;

&lt;p&gt;In order to avoid unintended implicit conversion, an explicit conversion function like &lt;code&gt;get&lt;/code&gt; is a preferable path. We can exchange the implicit convertion function to following explicit one:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class Font {
...
FontHandle get() const { return f; }  // explicit conversion function
...
};
...
// and use it like this:
changeFontSize(f.get(), newFontSize); // explicitly convert Font to FontHandle
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Both explicit conversion and implicit conversion make sense, and the preference depends on the specific task and the circumstances in which the RAII class performs, as long as one adheres to item 18&amp;rsquo;s advice: to make interfaces easy to use correctly and hard to use incorrectly.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Item-14 Copy behavior in resource-managing classes</title>
      <link>http://nianze.tk/2018/02/copy-behavior-of-raii/</link>
      <pubDate>Fri, 02 Feb 2018 13:27:32 -0500</pubDate>
      
      <guid>http://nianze.tk/2018/02/copy-behavior-of-raii/</guid>
      <description>&lt;p&gt;Copying an RAII object entails copying the resource it manages, so the copying behavior of the resource determines the copying behavior of the RAII object.

&lt;!-- toc --&gt;&lt;/p&gt;

&lt;p&gt;We can use &lt;code&gt;auto_ptr&lt;/code&gt; and &lt;code&gt;tr1::shared_ptr&lt;/code&gt; to manage heap-based resources, as introduced in item 13. However, not all resources are heap-based, and for such resources, we need to create our own resource-managing classes to deal with a general question:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;what should happen when an RAII object is copied?&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Mostly, there are 4 possibal choices:&lt;/p&gt;

&lt;h1 id=&#34;1-prohibit-copying&#34;&gt;1. Prohibit copying&lt;/h1&gt;

&lt;p&gt;In some cases, it makes no sense to allow RAII objects to be copied, so we should prohibit it. As explained in item 6, we declare the copying operations &lt;code&gt;private&lt;/code&gt; without definition. A good example is class &lt;code&gt;Mutex&lt;/code&gt;, which is synchronization primitives and comes with two functions &lt;code&gt;lock&lt;/code&gt; and &lt;code&gt;unlock&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;void lock(Mutex *pm);   // lock mutex pointed to by pm

void unlock(Mutex *pm); // unlock the mutex
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We should not forget to unlock a &lt;code&gt;Mutex&lt;/code&gt; we&amp;rsquo;ve locked, and it rarely makes sense to have &amp;ldquo;copies&amp;rdquo; of synchronization privitives, so we can create an uncopyable class to manage the locks:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class Lock: private Uncopyable { // prohibit copying, see item 6
public:
    explicit Lock(Mutex *pm)
    : mutexPtr(pm)
    { lock(mutexPtr); }  // acquire resource

    ~Lock() { unlock(mutexPtr); }  // release resource

private:
    Mutex *mutexPtr;
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And we can use &lt;code&gt;Lock&lt;/code&gt; in the conventional RAII fashion:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;Mutex m;  // define the mutex
...



{                  // create block to define critical section
    Lock ml(&amp;amp;m);   // lock the mutex
    ...            // perform critical section operations

    // Lock ml2(ml);  this is prohibited behavior!
}                  // automatically unlock mutex at end of block
 
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;2-reference-count-the-underlying-resource&#34;&gt;2. Reference-count the underlying resource&lt;/h1&gt;

&lt;p&gt;Sometimes it&amp;rsquo;s desirable to hold on to a resource until the last object using it has been destroyed. We could implement reference-counting copying behavior by containing a &lt;code&gt;tr1::shared_ptr&lt;/code&gt; data member, but in some cases we may have to customize the behavior when the reference count goes to zero, for the default behavior is to call &lt;code&gt;delete&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;The way we customize &lt;code&gt;tr1::shared_ptr&lt;/code&gt; is to specify a &amp;ldquo;deleter&amp;rdquo; - a function or function object to be called when the reference count goes to zero (&lt;code&gt;auto_ptr&lt;/code&gt; does not give us this privilege), which is an optional second parameter to the &lt;code&gt;tr1::shared_ptr&lt;/code&gt; constructor:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class Lock {
public:
    explicit Lock(Mutex *pm);  // init shared_ptr with the Mutex
    : mutexPtr(pm, unlock)     // to point to and the unlock func as the deleter
    {
        lock(mutexPtr.get());  // see item 15 for info on &amp;quot;get&amp;quot;
    }

private:
    std::tr1::shared_ptr&amp;lt;Mutex&amp;gt; mutexPtr;  // use shared_ptr instead of raw pointer
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Since a class&amp;rsquo;s destructor (both user-defined ones and compilter-generated ones) automatically invokes the destructors of the class&amp;rsquo;s non-static data members, there&amp;rsquo;s no need to declare a destructor for class &lt;code&gt;Lock&lt;/code&gt; explicitly (item 5). We simply rely on the default compilter-generated behavior, and that&amp;rsquo;s enough.&lt;/p&gt;

&lt;h1 id=&#34;3-copy-the-underlying-resource&#34;&gt;3. Copy the underlying resource&lt;/h1&gt;

&lt;p&gt;Sometimes we want to copy the resource-managing object as well as the resource it wraps, - that is to say, we want the resourse-managing object to perform a &amp;ldquo;deep copy&amp;rdquo;. A good example is the standard &lt;code&gt;string&lt;/code&gt; type: in sompe implementation, a &lt;code&gt;string&lt;/code&gt; type object consists of a pointer to heap memory, where the charactors making up the string are stored, and a copy is made of both the pointer and the memory it points to when such an object get copied.&lt;/p&gt;

&lt;h1 id=&#34;4-transfer-owenership-of-the-underlying-resource&#34;&gt;4. Transfer owenership of the underlying resource&lt;/h1&gt;

&lt;p&gt;On rere occasions, we wish only one RAII object refers to a raw resource and the ownership of the resource is transfered from the copied object to the copying object, as is the meaning of &amp;ldquo;copy&amp;rdquo; used by &lt;code&gt;auto_ptr&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;In this situation, we may have to write our own version of copying functions (copy constructor and copy assignment operator), since the default compiler-generated ones may not do what we want. In some cases, we&amp;rsquo;ll also want to support generalized versions of copying functions, which is discussed in item 45.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Item-13 Use objects to manage resources</title>
      <link>http://nianze.tk/2018/02/use-objects-to-manage-resources/</link>
      <pubDate>Thu, 01 Feb 2018 18:20:10 -0500</pubDate>
      
      <guid>http://nianze.tk/2018/02/use-objects-to-manage-resources/</guid>
      <description>&lt;p&gt;Use RAII objects such as &lt;code&gt;tr1::shared_ptr&lt;/code&gt; and &lt;code&gt;auto_ptr&lt;/code&gt; to prevent resource leaks.

&lt;!-- toc --&gt;&lt;/p&gt;

&lt;p&gt;First of all, let&amp;rsquo;s make clear the concept: a resource is something that we need to return to the system once we&amp;rsquo;re done using it, such as dynamically allocated memory, file descriptors, mutex locks, fonts and brushes in graphical user interfaces (GUIs), database connections, and network sockets.&lt;/p&gt;

&lt;p&gt;The motivation of using objects to manage resources is that, it is hard to write manually managed code to deal with complex control flow where necessary resource handling operation such as &lt;code&gt;delete&lt;/code&gt; may have to be skipped due to premature &lt;code&gt;continue&lt;/code&gt; statement or unexpected exception, ending up with resource leak.&lt;/p&gt;

&lt;p&gt;On the other hand, by putting resources inside objects, we can rely on C++&amp;rsquo;s automatic destructor invocation to make sure that the resources are released properly. Luckily, there&amp;rsquo;re two kinds of &lt;em&gt;smart pointer&lt;/em&gt; that is ideal for this kind of situation:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;code&gt;std::auto_ptr&lt;/code&gt;: destructor automatically calls &lt;code&gt;delete&lt;/code&gt; on what it points to when the &lt;code&gt;auto_ptr&lt;/code&gt; is destroyed. There&amp;rsquo;s only one &lt;code&gt;auto_ptr&lt;/code&gt; pointing to the underlying resoures each time&lt;/li&gt;
&lt;li&gt;&lt;code&gt;std::tr1::shared_ptr&lt;/code&gt;: is a &lt;code&gt;reference-counting smart pointer (RCSP)&lt;/code&gt;. Similar to garbage collection but can&amp;rsquo;t break cycles of references (e.g.: two otherwise unused objects pointing to one another).&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&#34;1-auto-ptr&#34;&gt;1. &lt;code&gt;auto_ptr&lt;/code&gt;&lt;/h1&gt;

&lt;p&gt;We can use &lt;code&gt;auto_ptr&lt;/code&gt; to manage a class &lt;code&gt;Investment&lt;/code&gt; that comes with a factory function (item 7) without worrying about resource leak:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;Investment* createInvestment();  // factory function, return ptr to dynamically allocated object

void f() 
{
    std::auto_ptr&amp;lt;Investment&amp;gt; pInv(createInvestment()); // call factory function
    ...  // use pInv like a pointer
}        // automatically delete pInv via auto_ptr&#39;s dtor
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;There are two critical aspects worth noting:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Resources are acquired and immediately turned over to resource-managing objects. It is a common trick to acquire a resource and initialize a resource-managing object in the same statement, which is called &lt;em&gt;Resource Acquisition Is Initialization (&lt;strong&gt;RAII&lt;/strong&gt;)&lt;/em&gt;.&lt;/li&gt;
&lt;li&gt;Resource-managing objects use their destructors to ensure that resources are released. Things could be tricky when the act of releasing resources can lead to exceptions being thrown, which is the matter addressed in Item 8.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Pay attention to the limitation of &lt;code&gt;auto_ptr&lt;/code&gt;: its &lt;strong&gt;sole ownership of the resource policy&lt;/strong&gt; requires that copying &lt;code&gt;auto_ptr&lt;/code&gt;s via copy constructor or copy assignment operator sets them to null:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;std::auto_ptr&amp;lt;Investment&amp;gt; pInv1(createInvestment()); // pInv1 points to the object returned from the factory function

std::auto_ptr&amp;lt;Investment&amp;gt; pInv2(pInv1);  // pInv2 now points to the object; pInv1 is null 

pInv1 = pInv2;  // pInv1 points to the object, and pInv2 is null now
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;2-shared-ptr&#34;&gt;2. &lt;code&gt;shared_ptr&lt;/code&gt;&lt;/h1&gt;

&lt;p&gt;An alternative &lt;strong&gt;RAII&lt;/strong&gt; object, &lt;code&gt;shared_ptr&lt;/code&gt;, is an RCSP(reference-counting smart pointer), which is a smart pointer that keeps track of how many objects point to a particular resource and automatically deletes  the resource when nobody is pointing to it any longer. The code above is almost the same as with &lt;code&gt;shared_ptr&lt;/code&gt;, but copying behavior is much more natural:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;void f()
{
    std::tr1::shared_ptr&amp;lt;Investment&amp;gt; pInv(createInvestment()); // call factory function
    ...  // use pInv as before

    std::tr1::shared_ptr&amp;lt;Investment&amp;gt; pInv1(createInvestment()); // pInv1 points to the object returned from createInvestment

    std::tr1::shared_ptr&amp;lt;Investment&amp;gt; pInv2(pInv1); // both pInv1 and pInv2 now point to the object

    pInv1 = pInv2;  // nothing has changed

}        // automatically delete pInv via shared_ptr&#39;s dtor
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;There is more information on &lt;code&gt;tr1::shared_ptr&lt;/code&gt; in item 14, item 18, and item 54. For now, another point worth noting is that, since both &lt;code&gt;auto_ptr&lt;/code&gt; and &lt;code&gt;tr1::shared_ptr&lt;/code&gt; use &lt;code&gt;delete&lt;/code&gt; in their destructors rather than &lt;code&gt;delete []&lt;/code&gt; (item 16), it is a bad idea to wrap dynamically allocated arrays with &lt;code&gt;auto_ptr&lt;/code&gt; or &lt;code&gt;tr1::shared_ptr&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;std::auto_ptr&amp;lt;std::string&amp;gt; pStr(new std::string[10]); // wrong delete form will be used, bad idea!

std::tr1::shared_ptr&amp;lt;int&amp;gt; pInt(new int[1024]); // same problem
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Since having &lt;code&gt;createInvestment&lt;/code&gt; returning a raw pointer type is error-prone, we&amp;rsquo;ll see in item 18 that an interface modification is preferred.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Item-12 Copy all parts of an object</title>
      <link>http://nianze.tk/2018/01/copy-all-parts-of-an-object/</link>
      <pubDate>Wed, 31 Jan 2018 18:16:11 -0500</pubDate>
      
      <guid>http://nianze.tk/2018/01/copy-all-parts-of-an-object/</guid>
      <description>&lt;p&gt;Be sure to copy all of an object&amp;rsquo;s data members and all of its base class parts.
&lt;/p&gt;

&lt;p&gt;In a well-designed object-oriented system that encapsulate the internal parts of objects, there should only be two copying function:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;copy constructor&lt;/li&gt;
&lt;li&gt;copy assignment operator&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;As item 5 introduced, we may create our own versions of copy function. The thing is, while the compiler-generated ones copy all the data of the object being copied as expected, the manually defined copy functions may be implemented in the wrong way, the partial-copied way:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class Customer {
public:
    ...
    Customer(const Customer&amp;amp; rhs);
    Customer&amp;amp; operator=(const Customer&amp;amp; rhs);
private:
    std::string name;
    //int age; potential new data memberf
};

Customer::Customer(const Customer&amp;amp; rhs)
:name(rhs.name){}    // copy rhs&#39;s data

Customer&amp;amp; Customer::operator=(const Customer&amp;amp; rhs)
{
    name = rhs.name; // copy rhs&#39;s data
    return *this;    // item 10
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Everything is fine here, unless there&amp;rsquo;s more data members, such as the &lt;code&gt;age&lt;/code&gt;, added into the &lt;code&gt;Customer&lt;/code&gt; class. Interesting thing is that even if there&amp;rsquo;s new data member added, compiler will most likely not complain about potential partial-copy problem if we don&amp;rsquo;t add the data member to the copying functions and all the constructors. So we have to rely on ourselves.&lt;/p&gt;

&lt;p&gt;A more subtle way to get into the problem comes from inheritance:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class PriorityCustomer: public Customer {
public:
    ...
    PriorityCustomer(const PriorityCustomer&amp;amp; rhs);
    PriorityCustomer&amp;amp; operator=(const PriorityCustomer&amp;amp; rhs);
private:
    int priority;
};

PriorityCustomer::PriorityCustomer(const PriorityCustomer&amp;amp; rhs) 
: priority(rhs.priority) {}

PriorityCustomer&amp;amp; 
PriorityCustomer::operator=(const PriorityCustomer&amp;amp; rhs)
{
    priority = rhs.priority;
    return *this;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The problem here is that derived class &lt;code&gt;PriorityCustomer&lt;/code&gt; also contains inherited data members (&lt;code&gt;Customer.name&lt;/code&gt;) but the copying functions only cover its newly added data member (&lt;code&gt;PriorityCustomer.priority&lt;/code&gt;), ending up with a partial-copy problem. In order to take care of the base class parts, which are typically private (item 22), we need to invoke the corresponding base class functions and implement the derived class&amp;rsquo;s copying function in this way:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;PriorityCustomer::PriorityCustomer(const PriorityCustomer&amp;amp; rhs) 
: Cutomer(rhs),          // invoke vase class copy ctor
priority(rhs.priority) {}

PriorityCustomer&amp;amp; 
PriorityCustomer::operator=(const PriorityCustomer&amp;amp; rhs)
{
    Customer::operator=(rhs);  // assign base class part
    priority = rhs.priority;
    return *this;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Sometimes you may find the copy constructor and copy assignment operator share a lot of code bodies, so a good way to eliminate the duplication is to create a third (private) member function that both copying functions call. Don&amp;rsquo;t let one copying function call the other, since it makes no sense:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;You can&amp;rsquo;t do an assignment operation even before the object get constructed and initialized.&lt;/li&gt;
&lt;li&gt;It may corrupt object if calling copy construction function in copy assignment operator.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;In summary, copy all parts mean:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;copy all local data members (especially those get added later)&lt;/li&gt;
&lt;li&gt;invoke the appropriate copying function in all base classes&lt;/li&gt;
&lt;/ol&gt;</description>
    </item>
    
    <item>
      <title>Item-11 Handle self assignment in operator=</title>
      <link>http://nianze.tk/2018/01/handle-self-assignment/</link>
      <pubDate>Tue, 30 Jan 2018 18:34:01 -0500</pubDate>
      
      <guid>http://nianze.tk/2018/01/handle-self-assignment/</guid>
      <description>&lt;p&gt;Solve self assignment situation in operator= by comparing addresses of source and target objects, careful statement ordering, and copy-and-&lt;code&gt;swap&lt;/code&gt;.
&lt;/p&gt;

&lt;p&gt;When operator= applies on more than one object, two or more of the objects may be the same:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;a[i] = a[j]  // potential assignment to self
*px = *py;   // potential assignment to self
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is the result of &lt;em&gt;aliasing&lt;/em&gt; (having more than one way to refer to an object). In general, operations on references or pointers to multiple objects of the same type (or objects of different types derived from the same base class) need to consider that the objects might be the same.&lt;/p&gt;

&lt;p&gt;When trying to manage resources manually rather than to take advantage of resource-managing objects (item 13, item 14), it is possible to accidentally release a resource before being done using it:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class Bitmap{...};
class Widget{
    ...
private:
    Bitmap *pb;  // ptr to a heap-allocated object
};

Widget&amp;amp;
Widget::operator=(const Widget&amp;amp; rhs)  // unsafe impl. of operator=
{
    delete pb;                // stop using cur. bitmap
    pb = new Bitmap(*rhs.pb); // start using a copy of rhs&#39;s bitmap
    return *this;             // item 10
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;When &lt;code&gt;*this&lt;/code&gt; (the target of the assignment) and &lt;code&gt;rhs&lt;/code&gt; (the source of the assignment) are the same object, &lt;code&gt;delete&lt;/code&gt; destroys both of them in the begining, resulting to the fact that &lt;code&gt;this&lt;/code&gt; points to a deleted object instead of being unchanged by the assignment to self. Moreover, besides self-assignment-unsafe, this implementation of operator= is also exception-unsafe.&lt;/p&gt;

&lt;p&gt;There are three possible ways to solve the problem:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Identity test at the top (solve self-assignment-unsafe)&lt;/li&gt;
&lt;li&gt;A careful ordering of statements (solve both self-assignment-unsafe and exception-unsafe)&lt;/li&gt;
&lt;li&gt;Copy and swap. (solve both potential unsafe situation)&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&#34;1-identity-test&#34;&gt;1. Identity test&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;Widget&amp;amp; Widget::operator=(const Widget&amp;amp; rhs)
{
    if (this == &amp;amp;rhs) return *this; // test: if a self-assignment, do nothing
    delete pb;
    pb = new Bitmap(*rhs.pb);
    return *this;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The problem here is that once the &lt;code&gt;new Bitmap&lt;/code&gt; expression yields an exception (due to insufficient memory or &lt;code&gt;Bitmap&lt;/code&gt;&amp;rsquo;s copy constructor throwing one), &lt;code&gt;this&lt;/code&gt; will end up refer to a deleted &lt;code&gt;Bitmap&lt;/code&gt;, which is toxic for there&amp;rsquo;s no way to safely delete them or even safely read them.&lt;/p&gt;

&lt;h4 id=&#34;2-careful-reorder&#34;&gt;2. Careful reorder&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;Widget&amp;amp; Widget::operator=(const Widget&amp;amp; rhs)
{
    Bitmap *pOrig = pb;  // remember original pb
    pb = new Bitmap(*rhs.pb); // point pb to a copy of rhs&#39; bitmap
    delete pOrig;  // delete the original pb
    return *this;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Under this implementation, even it &lt;code&gt;new Bitmap&lt;/code&gt; throws an exception, &lt;code&gt;pb&lt;/code&gt; and &lt;code&gt;this&lt;/code&gt; remain unchanged. Moreover, it does work even without the identity test.&lt;/p&gt;

&lt;p&gt;Considering efficiency, it may be sensible to put the identity test back at the top. However, considering the frequency of self-assignment situation as well as the longer codes and more branches in the flow of control, it may actually decrease runtime speed (at least the effectiveness of instruction prefetching, caching, and pipelining can be reduced).&lt;/p&gt;

&lt;h4 id=&#34;3-copy-and-swap&#34;&gt;3. Copy and swap&lt;/h4&gt;

&lt;p&gt;This is an alternative way to the above careful reordering technique, which is closely associated with exception safety (item 29).&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class Widget {
    ...
    void swap(Widget&amp;amp; rhs); // exchange *this&#39;s and rhs&#39;s data; see item 29 for details
};

Widget&amp;amp; Widget::operator=(const Widget&amp;amp; rhs)
{
    Widget temp(rhs);   // make a copy
    swap(temp);         // swap *this&#39;s data with the copy&#39;s
    return *this;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A variation taking advantage of the fact that passing by value makes a copy of it (item 20):&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;Widget&amp;amp; Widget::operator=(Widget rhs)  // pass by value, rhs is a copy of the object passed in
{
    swap(rhs);         // swap *this&#39;s data with the copy&#39;s
    return *this;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This variation sacrifices the clarity but may let compilers generate more efficient code by moving the copying operation from the body of the function to construction of the parameter.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Item-10 Have assignment operators return a reference to *this</title>
      <link>http://nianze.tk/2018/01/have-assignment-op-return-a-ref/</link>
      <pubDate>Mon, 29 Jan 2018 18:17:34 -0500</pubDate>
      
      <guid>http://nianze.tk/2018/01/have-assignment-op-return-a-ref/</guid>
      <description>&lt;p&gt;As title suggests.
&lt;/p&gt;

&lt;p&gt;Assignment is able to chain together:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;int x,y,z;
x = y = z = 15;  // chain of assignment
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Basically, the chain is parsed from right to left, so the result of the updated &lt;code&gt;z&lt;/code&gt; is assigned to y, then the result of the second assignment (the updated &lt;code&gt;y&lt;/code&gt;) is assigned to &lt;code&gt;x&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;x = (y = (z = 15));
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In order to achieve this, we need to implement the assignment operators (as well as &lt;code&gt;+=&lt;/code&gt;, &lt;code&gt;-=&lt;/code&gt;, &lt;code&gt;*=&lt;/code&gt;, etc) in the following convention, where we make the assignment return a reference to its left-hand argument:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class Widget {
public:
    ...
    Widget&amp;amp; operator=(const Widget&amp;amp; rhs)  // return type is a reference to the current class
    {
        ...
        return *this;  // return the left-hand object
    }
    Widget&amp;amp; operator=(int rhs)
    {
        ...
        return *this;  // even if the right-hand side parameter type is unconventional
                       // we can still apply this convention
    }
    Widget&amp;amp; operator+=(const Widget&amp;amp; rhs)
    {
        ...
        return *this;
    }
    ...
};
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>Item-9 不要在构造函数和析构函数中触发虚函数</title>
      <link>http://nianze.tk/2018/01/no-virtual-func-in-ctor-dtor/</link>
      <pubDate>Sat, 27 Jan 2018 21:03:05 -0500</pubDate>
      
      <guid>http://nianze.tk/2018/01/no-virtual-func-in-ctor-dtor/</guid>
      <description>&lt;p&gt;不同于Java或者C#,在C++中构造函数和析构函数里的虚函数不会实现多态的效果。
&lt;/p&gt;

&lt;p&gt;假设我们想要构造一个类来记录股票交易的数据，每次有新交易都应把交易信息记录到文档里。由于交易种类多种多样，我们希望用一个统一的抽象基类&lt;code&gt;Transaction&lt;/code&gt;里相同的接口&lt;code&gt;logTransaction()&lt;/code&gt;来记录不同的派生类信息：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class Transaction {   // 所有交易记录的基类，含纯虚函数所以是抽象类
public:
    Transaction();
    virtual void logTransaction() const = 0;  // 根据不同交易派生类的类型重载对应函数，此处定义为纯虚函数
    ...
};

Transaction::Transaction()
{
    ...
    logTransaction();   // 在构造函数中触发虚函数，记录派生类的交易信息
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;对应不同交易的派生类定义如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class BuyTransaction: public Transaction {
public:
    virtual void logTransaction() const;  // 记录买方交易信息
    ...
}

class SellTransaction: public Transaction {
public:
    virtual void logTransaction() const;  // 记录卖方交易信息
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;按照上述函数申明和定义，如果我们构造一个买方派生类的实例：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;BuyTransaction buy;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;此时&lt;code&gt;BuyTransaction&lt;/code&gt;派生类的构造函数会被触发，但是在执行派生类构造函数之前，基类的构造函数会先被触发以构造新实例基类那部分的成员变量。当执行到基类构造函数最后一行的&lt;code&gt;logTransaction()&lt;/code&gt;时，即使此时创建的实例属于派生类&lt;code&gt;BuyTransaction&lt;/code&gt;，执行的虚函数依然是基类&lt;code&gt;Transaction&lt;/code&gt;里面定义的版本。原因有二：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;理论上讲，派生类的虚函数可能会用到派生类里多出来的成员变量，而这些成员变量在最开始执行基类的构造函数时还没有被分配资源初始化，为了杜绝这种危险操作所以C++选择执行基类的虚函数。&lt;/li&gt;
&lt;li&gt;更底层的原因在于，在第一阶段执行基类构造函数的时候，&lt;code&gt;buy&lt;/code&gt;在运行时(&lt;code&gt;runtime&lt;/code&gt;)里的类型信息本来就是被标记为基类的类型&lt;code&gt;Transaction&lt;/code&gt;的。只有到第二阶段执行派生类&lt;code&gt;BuyTransaction&lt;/code&gt;的构造函数时，&lt;code&gt;buy&lt;/code&gt;实例才成为&lt;code&gt;BuyTransaction&lt;/code&gt;类型。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;基于相同的道理，执行析构函数的时候，一旦最开始触发的派生类析构函数开始运行，派生类部分的成员变量就被标记为未定义（&lt;code&gt;undefined&lt;/code&gt;）；而第二阶段进入基类的析构函数，&lt;code&gt;buy&lt;/code&gt;实例的类型就被标记为基类，此时在虚函数和&lt;code&gt;dynamic_cast&lt;/code&gt;等运行时相关的操作看来这就是一个&lt;code&gt;Transaction&lt;/code&gt;类型的实例。&lt;/p&gt;

&lt;p&gt;接着讲上述的例子：如果按照上述定义编译，部分编译器会提出警告(某些则不会，见Item 53)；即使没有警告，由于&lt;code&gt;logTransaction()&lt;/code&gt;是纯虚函数，没有定义函数体，所以即使通过了编译器这关，在下个阶段由于链接器找不到函数的定义所以也不会生成最终的可执行文件。但如果有人鸡贼的这样定义：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class Transaction {
public:
    Transaction()
    { init(); }   // 构造函数里“没有”直接触发虚函数
private:
    void init()
    {
        ...
        logTransaction();  // 但虚函数在第三方函数init()中被调用
    }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;虽然本质上跟之前的程序没有区别，但这样写很可能可以蒙混过链接器这关。一旦程序开始运行，执行到纯虚函数&lt;code&gt;logTransaction()&lt;/code&gt;的时候程序就会崩溃并停止运行（&lt;code&gt;abort&lt;/code&gt;）；而如果&lt;code&gt;logTransaction()&lt;/code&gt;是添加了函数实体定义的普通虚函数，虽然程序可以运行，但无论之后怎样花式捉虫（&lt;code&gt;debug&lt;/code&gt;），最后在创建实例&lt;code&gt;buy&lt;/code&gt;时log记录文档里留下的也都是基类&lt;code&gt;Transaction&lt;/code&gt;版本的交易记录。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;所以问题来了：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;要怎么实现根据不同派生类以多态方式自动记录交易信息的功能呢？&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;方法有很多。讲一个常见的：既然不可以在基类构造函数中使用派生类版本的虚函数，那就让派生类在构造实例的时候把自己的交易信息传回基类的(非虚)构造函数中：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class Transaction {
public:
    explicit Transaction(const std::string&amp;amp; logInfo); // “explicit”关键词防止隐式转换
    void logTransaction(const std::string&amp;amp; logInfo) const; // 不再是虚函数了
    ...
};

Transaction::Transaction(const std::string&amp;amp; logInfo)
{
    ...
    logTransaction(logInfo);  // 不是虚函数，放心call
}

class BuyTransaction: public Transaction {
public:
    BuyTransaction( parameters )
    : Transaction(createLogString( parameters )) // 将交易信息以传参方式传给基类构造函数
    {...}
private:
    static std::string createLogString( parameters ); // 静态函数，杜绝使用派生类中新定义的成员变量的可能性
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注意上述&lt;code&gt;createLogString()&lt;/code&gt;函数定义为&lt;code&gt;static&lt;/code&gt;可以防止出现在构造函数第一阶段（触发基类构造函数的阶段）中使用处于&lt;code&gt;undefine&lt;/code&gt;状态的派生类成员变量的情形（这也正是上述第一点C++不让在基类构造函数中使用派生类虚函数的原因）。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;P.S.:&lt;br /&gt;
今天是周六，脑抽想试着用中文写下C++复习笔记。。。&lt;br /&gt;
然后发现写这篇花费的时间是之前的至少两倍，主要是寻找各种英文技术术语对应的中文翻译很心累，思维还得在英文和中文中相互转换，翻译真是个累人的活。。。&lt;br /&gt;
以后还是用回英文吧，省心太多。&lt;/p&gt;
&lt;/blockquote&gt;</description>
    </item>
    
    <item>
      <title>人间不值得。。。吗？</title>
      <link>http://nianze.tk/2018/01/worth-it-or-not/</link>
      <pubDate>Sun, 28 Jan 2018 00:00:00 +0000</pubDate>
      
      <guid>http://nianze.tk/2018/01/worth-it-or-not/</guid>
      <description>&lt;p&gt;看了最近那期《十三邀》&lt;a href=&#34;https://v.qq.com/x/page/v0025csa5a9.html&#34;&gt;许知远&lt;/a&gt;对话&lt;a href=&#34;https://v.qq.com/x/page/j0025rf9fow.html&#34;&gt;李诞&lt;/a&gt;。有点意思。

&lt;!-- toc --&gt;&lt;/p&gt;

&lt;h1 id=&#34;一&#34;&gt;一&lt;/h1&gt;

&lt;p&gt;我其实很能理解李诞所说的虚无感和享受孤独，同时也真的无法理解在面对生活的残酷真相时，许知远为何能做到熟视无睹般的“享乐主义”——总觉得小时候只要是曾真诚而严肃的思考过存在和虚无的人，心里面总会有一份沉重的无力感，让自己哪怕处在最快乐的情绪中，也会在下一秒就回想起那份挥之不去的，找寻不到意义的荒谬感。所以当李诞说，他不能做自己，要不然就见不到他了；而那种喝3块一瓶的啤酒40岁老死在内蒙古小屋里的生活，也行。&lt;/p&gt;

&lt;p&gt;是真的，也行。我信。&lt;/p&gt;

&lt;p&gt;这种“没劲”的感觉，很熟悉。当他又赶紧补充说，&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;不要享受悲凉。忧伤不牛逼，自我陶醉罢了。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;我把这种拒绝深陷苦思的行为理解成是一种活着的惯性。因为本能的知道一直这么陷下去会走向自我灭亡，所以求生的本能会抵触这种倾向。只是那份沉重的虚无就笼罩在心头，自我意识无论逃去哪里都能感受到它投下的阴影。&lt;/p&gt;

&lt;p&gt;无路可逃。所以“底色悲凉&amp;rdquo;&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:1&#34;&gt;&lt;a href=&#34;#fn:1&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;。&lt;/p&gt;

&lt;h1 id=&#34;二&#34;&gt;二&lt;/h1&gt;

&lt;p&gt;作为一个兴趣使然的b站up主，我很真切的感受到，在自顾自瞎折腾的投身于自己的兴趣爱好并和同好交流的时候、在看番的时候看到或者发出几条吐槽的弹幕让人会心一笑的时候、在面对虚构的人物却献上比面对现实世界更多的热情的时候，所能感受到的片刻的轻松与温暖。虽然李诞的吐槽大会在我看来有点用力过猛，不符合我心中对吐槽理应穿插在日常生活中起调剂作用的定位（吐槽还得专门开个大会，还开这么多期，这本身就槽点满满），所以看了两期就觉得尬的不行，不过想到那么多源自二次元的网络流行语向主流文化迈进时都有变味，倒也可以理解。&lt;/p&gt;

&lt;p&gt;李诞在台上以艺人的身份表演的时候，是最自由的时候。在聚光灯照耀下，阴影暂时消失，他终于可以鼓起劲，暂时忘掉了“也行”。这让我想起了自己每次策划、练习、录制、剪辑、后期，最后发布视频到b站上，作为一个up主时，所感受到的源自创作的热情。是种“在好好活着”的感觉。&lt;/p&gt;

&lt;p&gt;很欣慰。&lt;/p&gt;

&lt;h1 id=&#34;三&#34;&gt;三&lt;/h1&gt;

&lt;p&gt;许知远感慨说，当下的社会只有一种话语体系占主导，缺少多样性。我其实觉得，多样性是在那里的，缺的是不同体系之间的交集和对话。虽然网络上信息获取和思想交流的成本很低廉，但我们上网一般只会前往自己圈内那一亩三分地去交流，而圈子与圈子之间是割裂开的。百家都在，只是都在各自的营地默默的鸣，没有去争，也没有争的必要——咱圈内人交流的好好的，干嘛要去别的圈子刷存在呢？&lt;/p&gt;

&lt;p&gt;宅在圈子里，大家玩的很开心。而虚拟的世界这么美好，好像那荒谬的现实也变得有点萌萌的了呢&lt;/p&gt;

&lt;p&gt;(๑•̀ㅂ•́)و✧&lt;/p&gt;

&lt;h1 id=&#34;四&#34;&gt;四&lt;/h1&gt;

&lt;p&gt;我知道，这种“萌”只是在转移注意力。一旦天黑了，一个人，仔细想想，又会在深夜的浅色床单下痛哭&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:2&#34;&gt;&lt;a href=&#34;#fn:2&#34;&gt;2&lt;/a&gt;&lt;/sup&gt;。可能我真正认同的，还得是那句&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;世界上只有一种真正的英雄主义，就是认清了生活的真相后还依然热爱它&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;所以在心底深处，其实还是心软的给“永恒”留了一间庇护所，即使接受了一切都会烟消云散，也还保留着以奉献的名义去追求的可能。&lt;/p&gt;

&lt;p&gt;于是想起马东和李诞都说过类似“相信科学，相信技术进步”这样的话。但很明显，技术固然一直在进步，人心却没那么容易改变。这是个娱乐至死的年代；而在技术的帮助下，甚至比波兹曼写书的时候更娱乐。我虽然希望怀着真诚的初衷，愿意相信凭借技术的力量，明天会更好。但其实又明白，我所在的码农圈纵使理想主义的成分会多一些，但大家最不缺的就是理性，时代真的就是这样，并不会有多少余暇，为天地立心，为生民立命，为往圣继绝学，为万世开太平。&lt;/p&gt;

&lt;p&gt;这年头，谁还那么自恋呢。&lt;/p&gt;

&lt;h1 id=&#34;五&#34;&gt;五&lt;/h1&gt;

&lt;p&gt;其实我有想过，如果要死，最浪漫的死法是什么样的。 现在的答案依然是，像Charles Strickland那样，耗尽最后的气力完成最后的作品，然后一把火将自己和作品全烧掉。&lt;/p&gt;
&lt;div class=&#34;footnotes&#34;&gt;

&lt;hr /&gt;

&lt;ol&gt;
&lt;li id=&#34;fn:1&#34;&gt;源自《十三邀》许知远对话马东
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:1&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:2&#34;&gt;源自曾博 &lt;a href=&#34;https://www.zhihu.com/question/47607160/answer/107439050&#34;&gt;我与清华的差距在哪里？ - 小勃勃的回答&lt;/a&gt;
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:2&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;</description>
    </item>
    
    <item>
      <title>Item-8 Prevent exception from leaving destructor</title>
      <link>http://nianze.tk/2018/01/prevent-exception-from-leaving-dtor/</link>
      <pubDate>Fri, 26 Jan 2018 20:15:48 -0500</pubDate>
      
      <guid>http://nianze.tk/2018/01/prevent-exception-from-leaving-dtor/</guid>
      <description>&lt;p&gt;It is discouraged practice to emit exceptions from destructors.
&lt;/p&gt;

&lt;p&gt;Consider what should be done to create a resource-managing class for DBConnection class below:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class DBConnection {
public:
    ...
    static DBConnection creast();  // return DBConnection obj
    void close();                  // close connection; throw an exception if closing fails
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To ensure clients don&amp;rsquo;t forget to call &lt;code&gt;close()&lt;/code&gt; on DBConnection objects, we may want to put &lt;code&gt;close()&lt;/code&gt; inside the destructor of managing class:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class DBConn {    // class to manage DBConnection object
public:
    ...
    ~DBConn()     // make sure database connections are closed
    {
        db.close();
    }
private:
    DBConnetion db;
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;However, once &lt;code&gt;db.close()&lt;/code&gt; yields an exception, &lt;code&gt;DBConn&lt;/code&gt;&amp;rsquo;s destructor will propogate the exception, which would be a problem: considering &lt;code&gt;std::vector&amp;lt;DBConn&amp;gt; v&lt;/code&gt;, chances are that two simultaneously active exceptions (from calling &lt;code&gt;~DBConn()&lt;/code&gt;) arise during destroying the vector &lt;code&gt;v&lt;/code&gt;, and program execution will either terminate or yield undefined behavior. Moreover, premature program termination or undefined behavior can result from destructors emitting exceptions even without using containers and arrays. There are 2 ways to handle the situation:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Terminate the program&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;DBConn::~DBConn()
{
    try { db.close(); }
    catch(...) {
        // make log entry: the call to close failed;
        std::abort();
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This will prevent the exception from propagating out of the destructor and then leading to undefined behavior.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Swallow the exception&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;DBConn::~DBConn()
{
    try { db.close(); }
    catch(...) {
        // make log entry: the call to close failed;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In general, swallowing exception is a bad idea for it suppresses imporant information, but it is preferable sometimes when the program is asked to be able to reliably continue execution even after an error has been encountered.&lt;/p&gt;

&lt;p&gt;A better strategy is to design &lt;code&gt;DBConn&lt;/code&gt;&amp;rsquo;s interface so that its clients have an opportunity to handle the possible exception by themselves:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class DBConn {
public:
    ...
    void close()         // new interface for clients
    {                    // to handle possible exception outside dtor
        db.close();
        closed = true;   // keep track of whether db has been closed
    }
    ~DBConn()
    {
        if (!closed) {
            try {              // close the connecton
                db.close();    // if the client didn&#39;t
            }
        }
        catch (...) {
            // make log entry: the call to close failed;
            //  terminate or swallow
        }
    }
private:
    DBConnection db;
    bool closed;
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Under such a design, if clients decide to ignore the opportunity to close the connection and handle the possible exception by themselves for they believe that no error will occur, they can rely on &lt;code&gt;DBConn&lt;/code&gt;&amp;rsquo;s destructor to call &lt;code&gt;close()&lt;/code&gt; for them. However, if &lt;code&gt;close()&lt;/code&gt; does throw in &lt;code&gt;~DBConn&lt;/code&gt;, they&amp;rsquo;re in no position to complain if &lt;code&gt;DBConn&lt;/code&gt; swallows the exception or terminates the program.&lt;/p&gt;

&lt;p&gt;In summary,&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Never emit exceptions from destructors. If functions in a destructor may throw, catch it and then either swallow it or terminate the program.&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;When class clients need to be able to react to any operation that may throw exceptions, provide a non-destructor function for them to handle such exceptions.&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>Item-7 Declare destructor virtual in polymorphic base classes</title>
      <link>http://nianze.tk/2018/01/virtual-dtor-in-polymorphic-base-class/</link>
      <pubDate>Thu, 25 Jan 2018 18:04:14 -0500</pubDate>
      
      <guid>http://nianze.tk/2018/01/virtual-dtor-in-polymorphic-base-class/</guid>
      <description>&lt;p&gt;If a class has any virtual functions (for polymorphic purpose), it should have a virtual destructor.
&lt;/p&gt;

&lt;p&gt;In the convention of factory functions, we use base class pointers manipulating derived class objects during runtime, which gives us the convenience of polymophism.&lt;/p&gt;

&lt;p&gt;Because C++ specifies that when a derived class object is deleted through a pointer to a base class with a non-virtual destructor, results are undefined, we need to declare the destructor as &lt;em&gt;virtual&lt;/em&gt;. Otherwise, what typically happens at runtime is that, while base class data members get destroyed, the derived part of the object (i.e., the data members declared in the derived class) is never destroyed, ending with a curious &amp;ldquo;partially destroyed&amp;rdquo; object that is an excellent way to leak resources, corrupt data structures, and waste time debugging.&lt;/p&gt;

&lt;p&gt;Basically, the implementation of virtual functions requires that objects carry a pointer (called a &lt;code&gt;vptr&lt;/code&gt;, virtual table pointer) accessible at runtime to determine which virtual functions should be invoked on the object. The &lt;code&gt;vptr&lt;/code&gt; points to &lt;code&gt;vtbl&lt;/code&gt; (virtual table), which is an array of function pointers to appropriate actual functions.&lt;/p&gt;

&lt;p&gt;Sometimes we may want to create an &lt;em&gt;abstract&lt;/em&gt; class (which contains pure &lt;em&gt;virtual&lt;/em&gt; functions) but don&amp;rsquo;t have any pure virtual functions in mind, we may simply make a pure &lt;em&gt;virtual&lt;/em&gt; destructor:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class AWOV {  // &amp;quot;Abstract w/o Virtuals&amp;quot;
public:
    virtual ~AWOV() = 0;  // declare pure virtual destructor
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Since &lt;code&gt;AWOV&lt;/code&gt; has a pure virtual function, it&amp;rsquo;s abstract as we wish while also benifits us with not worrying about the derived class destructor problem at the same time, but there&amp;rsquo;s one twist: &lt;strong&gt;a definition of the pure virtual destructor must still be provided:&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;AWOV::~AWOV() {}  // definition of pure virtual destructor
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Otherwise the linking will complain, because compilers will generate a call from derived classes&amp;rsquo; destructors to each base class, all the way up to &lt;code&gt;~AWOV&lt;/code&gt;, yet the body of base class destructor function can&amp;rsquo;t be found.&lt;/p&gt;

&lt;p&gt;However, not all base classes are designed to be used polymorphically. For classes not designed to be base classes (std::string, STL container types such as vector, list, set, etc.) or not designed to be used polymorphically (item 6, &lt;code&gt;Uncopyable&lt;/code&gt; class), we should not declare &lt;em&gt;virtual&lt;/em&gt; destructors. Here is an example:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class Point { // a 2D point
public:
    Point(int xCoord, int yCoord);
    ~Point();
private:
    int x, y;
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If an &lt;code&gt;int&lt;/code&gt; occupies 32 bits, a &lt;code&gt;Point&lt;/code&gt; object typically fits into a 64-bit register, which can be passed as a 64-bit quantity to functions written in other languages such as C or FORTRAN. However, if &lt;code&gt;Point&lt;/code&gt;&amp;rsquo;s destructor is declared &lt;em&gt;virtual&lt;/em&gt;, &lt;code&gt;Point&lt;/code&gt; object will increased from 64 bits (for the 2 &lt;code&gt;int&lt;/code&gt;s) to 96 bits (for 2 &lt;code&gt;int&lt;/code&gt;s with the &lt;code&gt;vptr&lt;/code&gt;) on 32-bit architecture, or to 128 bits on 64-bit architecture (where pointers are 64 bits in size). As a result, portability decreases.&lt;/p&gt;

&lt;p&gt;In short words, gratuitously declaring all destructors &lt;em&gt;virtual&lt;/em&gt; is just as wrong as never declaring them &lt;em&gt;virtual&lt;/em&gt;; declare a &lt;em&gt;virtual&lt;/em&gt; destructor in a class &lt;strong&gt;if and only if&lt;/strong&gt; that class contains at least one virtual function.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Item-6 Disallow unwanted compiler-generated functions</title>
      <link>http://nianze.tk/2018/01/functions-silently-created/</link>
      <pubDate>Wed, 24 Jan 2018 16:18:59 -0500</pubDate>
      
      <guid>http://nianze.tk/2018/01/functions-silently-created/</guid>
      <description>&lt;p&gt;Declare unwanted member functions &lt;em&gt;private&lt;/em&gt; without implementations to disallow functionality automatically provided by compilers.
&lt;/p&gt;

&lt;p&gt;If we want to prevent functions such as copy constructor being generated in order to maintain the object uniqueness, explicitly declare the copy constructor and the copy assignment operator &lt;em&gt;private&lt;/em&gt;, so that the client of the class will not be able to copy the object.&lt;/p&gt;

&lt;p&gt;To make it foolproof, declare member functions &lt;em&gt;private&lt;/em&gt; and deliberately not implemente them so that member and friend functions will not be able to copy the object, either.&lt;/p&gt;

&lt;p&gt;Another possible solution to prevent copying is to inherit from a well-designed base class such as this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class Uncopyable {
protected:
    Uncopyable() {}    // allow construction of derived objects
    ~Uncopyable() {}   // allow destruction of derived objects
private:
    Uncopyable(const Uncopyable&amp;amp;);            // prevent copying
    Uncopyable&amp;amp; operator=(const Uncopyable&amp;amp;); // prevent copying
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To inherit from the base class, simply:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class HomeForSale: private Uncopyable {
... // no copy ctor or copy assign. operator declaration
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This will be the same effect as the following design:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class HomeForSale{
public:
...
private:
...
HomeForSale(const HomeForSale&amp;amp;);
HomeForSale&amp;amp; operator=(const HomeForSale&amp;amp;);
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;There are some subtleties about the implementation and use of &lt;code&gt;Uncopyable&lt;/code&gt;:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;inheritance from &lt;code&gt;Uncopyable&lt;/code&gt; needn&amp;rsquo;t be public (item 32 and 39)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Uncopyable&lt;/code&gt; destructor needn&amp;rsquo;t be &lt;em&gt;virtual&lt;/em&gt; (item 7: the base class is not designed to be used polymorphically)&lt;/li&gt;
&lt;li&gt;it&amp;rsquo;s eligible for the empty bass class optimization described in item 39, but use of this technique could lead to multiple inheritance (item 40), which will sometimes in turn disable the empty base class optimization (item 39)&lt;/li&gt;
&lt;li&gt;Boost (item 55) provides a similar class named &lt;code&gt;noncopyable&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;</description>
    </item>
    
    <item>
      <title>Item-5 What functions C&#43;&#43; silently generates</title>
      <link>http://nianze.tk/2018/01/functions-silently-created/</link>
      <pubDate>Tue, 23 Jan 2018 18:42:07 -0500</pubDate>
      
      <guid>http://nianze.tk/2018/01/functions-silently-created/</guid>
      <description>&lt;p&gt;Compilers may implicitly generate their own versions of default constructor, copy constructor, copy assignment operator, and destructor.
&lt;/p&gt;

&lt;p&gt;All the compiler generated functions will be both &lt;code&gt;public&lt;/code&gt; and &lt;code&gt;inline&lt;/code&gt; (item 30). An empty class declared like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class Empty{};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;is essentially equivalent to:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class Empty {
public:
    Empty() { ... } // default constructor
    Empty(const Empty&amp;amp; rhs) { ... } // copy constructor
    ~Empty() { ... }  // destructor
                      // will be _virtual_ only if inheriting 
                      // from a base class with virtual destructor
    Empty&amp;amp; operator=(const Empty&amp;amp; rhs) { ... } // copy assignment operator
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;These functions are generated only if they are needed:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;Empty e1;     // default constructor and destructor generated
Empty e2(e1); // copy constructor generated
e2 = e1;      // copy assignment operator generated
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Basically, the generated default &lt;code&gt;constructor&lt;/code&gt; and the &lt;code&gt;destructor&lt;/code&gt; will invocate constructors and destructors of base classes and non-static data members, while the &lt;code&gt;copy constructor&lt;/code&gt; will simply copy each non-static data member of the source object to the target object.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;specifically,&lt;br /&gt;
1. for data member of user-defined type, call the data member&amp;rsquo;s copy constructor with source object&amp;rsquo;s corresponding member&amp;rsquo;s value as argument&lt;br /&gt;
2. for data member of built-in type, directly copy the corresponding source data member&amp;rsquo;s bits&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Copy assignment operator behaves generally the same as copy constructor, but the code is only generated when the resulting code is both legal and has a reasonable chance of making sense. For example:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;template&amp;lt;class T&amp;gt;
class NamedObject {
public:
    NamedObject(std::string&amp;amp; name, const T&amp;amp; value);
    ...
private:
    std::string&amp;amp; nameValue;  // a reference
    const T objectValue;     // a const
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In below situation, implicitly generated copy assignment operator will make no sense for nameValue and illegal for objectValue:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;std::string youngMan(&amp;quot;child&amp;quot;);
std::string oldMan(&amp;quot;adult&amp;quot;);

NamedObject&amp;lt;int&amp;gt; p(youngMan, 10);
NamedObject&amp;lt;int&amp;gt; s(oldMan, 50);

p = s; // nameValue assignment will make no sense!
       // objectValue assignment will be illegal due to its constness
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Since p.nameValue and s.nameValue refer to different string object, the assignment will be in a conundrum:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;should compiler choose to let p.nameValue refer to new string object? (actually C++ does not allow reference referring to different one)?&lt;/li&gt;
&lt;li&gt;should compiler choose to change the string content &amp;ldquo;child&amp;rdquo; to &amp;ldquo;adult&amp;rdquo;? (this will affect other objects that hold pointers or references to original string &amp;ldquo;child&amp;rdquo;)&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Neither will be sensible, so C++ refuses to compile the code. In this situation, a copy assignment operator must be defined manually.&lt;/p&gt;

&lt;p&gt;Finally, derived classes will not be able to have generated implicit copy assignment operators if base classes declare the copy assignment operator &lt;em&gt;private&lt;/em&gt;, for derived copy assignment operators are supposed to handle base class parts, but they don&amp;rsquo;t have the right to invoke the base member functions in this situation.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Item-4 Initialize objects before they&#39;re used</title>
      <link>http://nianze.tk/2018/01/initialize-before-use/</link>
      <pubDate>Mon, 22 Jan 2018 18:47:54 -0500</pubDate>
      
      <guid>http://nianze.tk/2018/01/initialize-before-use/</guid>
      <description>&lt;p&gt;Since C++ is fickle about initialization, some good coding style is suggested.

&lt;!-- toc --&gt;&lt;/p&gt;

&lt;p&gt;There are basically only 3 rules we need to remember if wanting to avoid tragedy of using objects before they&amp;rsquo;re initialized:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;always manually initialize non-member objects of &lt;em&gt;built-in&lt;/em&gt; type, becauese C++ sometimes initializes them and sometimes not.&lt;/li&gt;
&lt;li&gt;in constructors, prefer to use member initialization list to assignment inside the constructor body; data members in the initialization list is suggested to be in the same order as they are declared in the class (which helps to avoid reader confusion)&lt;/li&gt;
&lt;li&gt;replacing non-local static objects with local static objects in order to avoid initialization order problems across translation units.&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&#34;1-initialize-non-member-built-in-type-object&#34;&gt;1. Initialize non-member &lt;em&gt;built-in&lt;/em&gt; type object&lt;/h1&gt;

&lt;p&gt;No need to remember rules about when built-in type object initialization is guaranteed to take place and when it isn&amp;rsquo;t, for they&amp;rsquo;re too complicated to know.&lt;/p&gt;

&lt;p&gt;Just form a good habit to always initialize objects before using them manually.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;int x = 0; // manual init. of an int
const char *text = &amp;quot;A C-style string&amp;quot;; // manual init. of a pointer
double d;
std::cin &amp;gt;&amp;gt; d;
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;2-initialize-data-member-with-member-initialization-list&#34;&gt;2. Initialize data member with member initialization list&lt;/h1&gt;

&lt;p&gt;The arguments in the initialization list are used as constructor arguments for the various data members (will be copy-constructed), which will be more efficient than a call to the default constructor followed by a calll to the copy assignment operator.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;For data members of &lt;code&gt;const&lt;/code&gt; and references, since they can&amp;rsquo;t be assigned (item 5), initialization list must be used.&lt;/li&gt;
&lt;li&gt;For built-in type data members, even though there&amp;rsquo;s no difference in cost betweeen initialization and assignment, it is a good habit to place them in member initialization list for consistency.&lt;/li&gt;
&lt;li&gt;For data members of user-defined type, since compilers will automatically call default constructors for absent ones in initialization list, even if you just want to call the default constructor, it is still a good habit to call the default constructors in the initialization list, just to make a good habbit to guarantee there&amp;rsquo;s no data member left uninitialzed.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Exception: multiple constructors share large common member initialization list may consider moving assignment to a single (private) function called by all the constructors, which will be helpful for initializing values from reading a file or database.&lt;/p&gt;

&lt;h1 id=&#34;3-initialze-non-local-static-objects-defined-in-different-translation-units&#34;&gt;3. Initialze non-local static objects defined in different translation units&lt;/h1&gt;

&lt;h2 id=&#34;glossary&#34;&gt;Glossary:&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;&lt;em&gt;static object&lt;/em&gt;: one that exists from the time it&amp;rsquo;s constructed until the end of the program (i.e., their destructors will be called when &lt;em&gt;main&lt;/em&gt; finishes executing)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;local&lt;/strong&gt; &lt;em&gt;static object&lt;/em&gt;:

&lt;ul&gt;
&lt;li&gt;objects declared &lt;em&gt;static&lt;/em&gt; inside functions (it&amp;rsquo;s local to a function)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;non-local&lt;/strong&gt; &lt;em&gt;static object&lt;/em&gt;:

&lt;ul&gt;
&lt;li&gt;global objects&lt;/li&gt;
&lt;li&gt;objects defined at namespace scope&lt;/li&gt;
&lt;li&gt;objects declared &lt;em&gt;static&lt;/em&gt; inside classes&lt;/li&gt;
&lt;li&gt;objects declared &lt;em&gt;static&lt;/em&gt; at file scope&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;em&gt;translation unit&lt;/em&gt;: the source code giving rise to a single object file (basically a single source file plus all of its #include files)&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Below is an example of non-local static objects requiring correct order of initialization (firstly tfs, secondly tempDir):&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;//========================
// fileSystem.h       
class FileSystem {            // created by library developer
public:
    ...
    std::size_t numDisks() const;
    ...
};

extern FileSystem tfs;        // non-local static object for clients to use 
                              // &amp;quot;tfs&amp;quot; = &amp;quot;the file system&amp;quot;

//========================
// directory.h           
#include &amp;lt;fileSystem.h&amp;gt;       // created by library client
class Directory {
public:
    Directory( params );
    ...
};

Directory tempDir( params );  // non-local static object for
                              // directory of temporary files

//========================
// directory.cpp
Directory::Directory( params )
{
    ...
    std::size_t disks = tfs.numDisks(); // use the tfs objects
    ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Since the relative order of initialization of non-local static objects (tfs vs. tempDir) defined in different translation units (fileSystem vs. directory) is undefined, and given the fact that C++ guarantees that local static objects are initialized when the object&amp;rsquo;s definition is first encountered during a call to that function, simply replace direct accesses to non-local static objects with calls to functions that return references to local static objects, and the problem is solved, with a little bonus of saving the cost of constructing/destructing the object in the situation of the function never being called (this design implementation is the well-known singleton pattern):&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;//========================
// fileSystem.h       
class FileSystem {...};     // as before

FileSystem&amp;amp; tfs()           // replace the tfs object;
{                           // could also be static in the FileSystem class
    static FileSystem fs;   // define and initialize a local static object
    return fs;              // return a reference to it
} 

//========================
// directory.h           
#include &amp;lt;fileSystem.h&amp;gt;       
class Directory { ... };          // as before

Directory&amp;amp; tempDir( params )      // replace the tempDir object;
{                                 // could also be static in the Directory class
    static Directory td(params);  // definea and initialize a local static object
    return td;                    // return a reference to it
}

//========================
// directory.cpp
Directory::Directory( params )
{
    ...
    std::size_t disks = tfs().numDisks(); // use the new tfs()
    ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;P.S.: There&amp;rsquo;s limitation for non-&lt;code&gt;const&lt;/code&gt; static object (local or non-local) in multiple threads scenarios. One way to deal with the trouble is to manually invoke all the reference-returning functions during the single-threaded startup portion of the program to eliminate initialization-related race condition.&lt;/p&gt;
&lt;/blockquote&gt;</description>
    </item>
    
    <item>
      <title>紫羅蘭永恆花園</title>
      <link>http://nianze.tk/2018/01/violet-snow/</link>
      <pubDate>Sun, 21 Jan 2018 23:25:09 -0500</pubDate>
      
      <guid>http://nianze.tk/2018/01/violet-snow/</guid>
      <description>&lt;p&gt;想いを綴る、愛を知るために。
&lt;/p&gt;

&lt;p&gt;感情を持たない一人の少女がいた。&lt;/p&gt;

&lt;p&gt;彼女の名は、ヴァイオレット・エヴァーガーデン。&lt;/p&gt;

&lt;p&gt;戦火の中で、大切な人から告げられた言葉の意味を探している。&lt;/p&gt;

&lt;p&gt;戦争が終わり、彼女が出会った仕事は誰かの想いを言葉にして届けること。&lt;/p&gt;

&lt;p&gt;――戦争で生き延びた、たった一人の兄弟への手紙&lt;br /&gt;
――都会で働き始めた娘から故郷の両親への手紙&lt;br /&gt;
――飾らないありのままの恋心をつづった手紙&lt;br /&gt;
――去りゆく者から残される者への最期の手紙&lt;/p&gt;

&lt;p&gt;手紙に込められたいくつもの想いは、ヴァイオレットの心に愛を刻んでいく。&lt;/p&gt;

&lt;p&gt;これは、感情を持たない一人の少女が愛を知るまでの物語。&lt;/p&gt;


&lt;div style=&#34;position: relative; padding-bottom: 56.25%; padding-top: 30px; height: 0; overflow: hidden;&#34;&gt;
  &lt;iframe src=&#34;//www.youtube.com/embed/QLvFbf-3Q8A&#34; style=&#34;position: absolute; top: 0; left: 0; width: 100%; height: 100%;&#34; allowfullscreen frameborder=&#34;0&#34; title=&#34;YouTube Video&#34;&gt;&lt;/iframe&gt;
 &lt;/div&gt;


&lt;blockquote&gt;
&lt;p&gt;P.S.:&lt;br /&gt;
1. 拍完才发现糊焦了，明明选的对焦点在手办的脸上，实际焦平面却大概在钢琴的C1键位置，宾得的对焦和视频真是无力吐槽，真该灭门上大法。。。不过好在反正也没啥可看的，就这样了吧。&lt;br /&gt;
2. 这次尝试用了Logic Pro来录制音轨和简单后期，耽误了不少时间，不过基本熟悉了现在新的工作流程，之后录制起来应该会比之前用录音笔的方案方便不少。&lt;br /&gt;
3. 这次加入了哨笛收尾，感觉空灵的音色跟单簧管丝绸质感的音质还挺互补的，算是个不错的尝试吧。&lt;/p&gt;
&lt;/blockquote&gt;</description>
    </item>
    
    <item>
      <title>Item-3 Use const whenever possible</title>
      <link>http://nianze.tk/2018/01/use-const-whenever-possible/</link>
      <pubDate>Fri, 19 Jan 2018 14:31:40 -0500</pubDate>
      
      <guid>http://nianze.tk/2018/01/use-const-whenever-possible/</guid>
      <description>&lt;p&gt;Useful tips on using &lt;code&gt;const&lt;/code&gt; in C++.

&lt;!-- toc --&gt;&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;const&lt;/code&gt; keyword allows you to specify a semantic constraint and compilers will enforce that constraint. It is remarkably versatile:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;outside of class, you may use it for constants at global or namespace scope, as well as for objects declared static at file, function or block scope&lt;/li&gt;
&lt;li&gt;inside classes, you may use it for both static and non-static data members, for pointers&lt;/li&gt;
&lt;li&gt;when declaring functions, you may also refer &lt;code&gt;const&lt;/code&gt; to function&amp;rsquo;s return value, function parameters, and, for member functions, to the function as a whole&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&#34;1-const-pointer&#34;&gt;1. &lt;code&gt;const&lt;/code&gt; pointer&lt;/h1&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;char greeting[] = &amp;quot;Hello&amp;quot;;
char *p = greeting; // non-const pointer, non-const data
const char *p = greeting; // non-const pointer, const data
char * const p = greeting; // const pointer, non-const data
const char * const p = greeting; // const pointer, const data
char const * const p = greeting; // const pointer, const data
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If the &lt;code&gt;const&lt;/code&gt; appears to the left of the asterisk, what&amp;rsquo;s pointed to is constant; if the word &lt;code&gt;const&lt;/code&gt; appears to the right of the asterisk, the pointer itself is constant. It&amp;rsquo;s helpful to read pointer declarations right to left: &lt;code&gt;const char * const p&lt;/code&gt; reads as &amp;ldquo;p is a constant pointer to constant chars&amp;rdquo;.&lt;/p&gt;

&lt;h1 id=&#34;2-const-iterator&#34;&gt;2. &lt;code&gt;const&lt;/code&gt; iterator&lt;/h1&gt;

&lt;p&gt;STL iterators are modeled on pointers. Treat it like this:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;iterator -&amp;gt; &lt;code&gt;T*&lt;/code&gt; pointer&lt;/li&gt;
&lt;li&gt;const iterator -&amp;gt; &lt;code&gt;T* const&lt;/code&gt; pointer&lt;/li&gt;
&lt;li&gt;const_iterator -&amp;gt; &lt;code&gt;const T*&lt;/code&gt; pointer&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;std::vector&amp;lt;int&amp;gt; vec;
...
const std::vector&amp;lt;int&amp;gt;::iterator iter = vec.begin(); // acts like T* const
*iter = 10; // OK.
++iter;     // error.

std::vector&amp;lt;int&amp;gt;::const_iterator cIter = vec.begin(); // acts like const T*
*cIter = 10; // error.
++cIter;     // OK.
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;3-const-function-return-value&#34;&gt;3. &lt;code&gt;const&lt;/code&gt; function return value&lt;/h1&gt;

&lt;p&gt;Generally speaking, having a function return a constant value is inappropriate, but sometimes doing so may reduce implicit errors out of incidence without giving up safety or efficiency.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class Rational {
... // contains no operator*
};
const Rational operator*(const Rational&amp;amp; lhs, 
                         const Rational&amp;amp; rhs);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Declaring the return value of &lt;code&gt;operator*&lt;/code&gt; to be const prevent typos like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;if (a * b = c) // meant to do a comparison for some user-defined objects
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;4-const-function-parameters&#34;&gt;4. &lt;code&gt;const&lt;/code&gt; function parameters&lt;/h1&gt;

&lt;p&gt;&lt;code&gt;const&lt;/code&gt; parameters act just like local &lt;code&gt;const&lt;/code&gt; objects. Unless there&amp;rsquo;s a need to modify aparameter or local object, be sure to declare it &lt;code&gt;const&lt;/code&gt;, for it may save you from annoying errors like &lt;code&gt;if (a = b)&lt;/code&gt; above.&lt;/p&gt;

&lt;h1 id=&#34;5-const-member-functions&#34;&gt;5. &lt;code&gt;const&lt;/code&gt; member functions&lt;/h1&gt;

&lt;p&gt;The purpose of &lt;code&gt;const&lt;/code&gt; on member functions is to identify which member functions may be invoked on &lt;code&gt;const&lt;/code&gt; objects, which benefits us for:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;making the interface of a class easier to understand (which functions may modify an object and which may not)&lt;/li&gt;
&lt;li&gt;making it possible to work with &lt;code&gt;const&lt;/code&gt;-qualified objects (which makes up a very important C++ feature: overloading member functions differing only in their constness)&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;5-1-bitwise-constness-vs-logical-constness&#34;&gt;5.1 Bitwise constness vs. Logical constness&lt;/h2&gt;

&lt;h2 id=&#34;5-1-1-bitwise-constness&#34;&gt;5.1.1 Bitwise constness&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;Bitwise constness: a member function is const if and only if it doesn&amp;rsquo;t modify any of the object&amp;rsquo;s data members (excluding those that are static). This is also C++&amp;rsquo;s definition of constness&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;However, member functions that don&amp;rsquo;t act very &lt;em&gt;const&lt;/em&gt; pass the bitwise test, such as a function including a &lt;code&gt;char* const&lt;/code&gt; pointer manipulating a &lt;code&gt;char*&lt;/code&gt; type class member:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class CTextBlock {
public:
...
    //inappropriate but bitwise const declaration of operator[]
    char&amp;amp; operator[](std::size_t position) const 
    {return pText[position];}
private:
    char *pText;
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Since operator[]&amp;rsquo;s implementation doesn&amp;rsquo;t modify pText in any way, compilers will happily generate code after verifying that it is indeed bitwise const. However, when you create a constant object with a particular value and invoke only &lt;code&gt;const&lt;/code&gt; member functions on it, you can still change its value:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;const CTextBlock cctb(&amp;quot;Hello&amp;quot;); // declare constant object
char *pc = &amp;amp;cctb[0]; // call the const operator[]
*pc = &#39;J&#39;  // cctb has value &amp;quot;Jello&amp;quot; now
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To solve this problem, we may store data as a string instead of communicating through a C API char*:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class TextBlock {
public:
...
    // operator[] for const objects
    const char&amp;amp; operator[] (const std::size_t position) const
    {return text[position];}
    // operator[] for non-const objects
    char&amp;amp; operator[] (const std::size_t position) const
    {return text[posion];}
private:
    std::string text;
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Remeber the C++ feature mentioned above? By overloading operator[] and giving the different versions different return types, we can handle const and non-const TextBlock objects differently:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;TextBlock tb(&amp;quot;Hello&amp;quot;);
const TextBlock ctb(&amp;quot;World&amp;quot;);
std::cout &amp;lt;&amp;lt; tb[0];  // fine, call and reading a non-const TextBlock object
tb[0] = &#39;x&#39;;         // fine, call and writing a non-const TextBlock object
std::cout &amp;lt;&amp;lt; ctb[0]; // fine, call and reading a const TextBlock object
ctb[0] = &#39;x&#39;;        // error! call to a const TextBlock object is fine
                     // but making an assignment to returned const char&amp;amp; type gives us an error
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;5-1-2-logical-constness&#34;&gt;5.1.2 Logical constness&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;Logical constness: a const member function might modify some of the bits in the object on which it&amp;rsquo;s invoked, but only in ways that clients cannot detect.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;A typical example of logical constness shows in such a scenario: say we want to cache the length for a CTextBlock object, and we define it like as&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class CTextBlock {
public:
...
    std::size_t length() const;
private:
    char *pText;
    std::size_t textLength;
    book lengthIsValid;
};

std::size_t CTextBlock::length() const
{
    if(!lengthIsValid) {
        textLength = std::strlen(pText); // error: can&#39;t asssign to textLength 
        lengthIsValid = true;            // and lengthIsValid in a const member function
    }
    return textLength;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Bitwise constness test fails and compilers complains due to the assignment to textLength and lengthIsValid, but it is supposed to be valid for &lt;code&gt;const&lt;/code&gt; CTextBlock objects. The solution is to take advantage of C++&amp;rsquo;s keyword &lt;code&gt;mutable&lt;/code&gt;, which frees non-static data members from the constraints of bitwise constness:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class CTextBlock {
public:
...
    std::size_t length() const;
private:
    char *pText;
    mutable std::size_t textLength;
    mutable book lengthIsValid;
};

std::size_t CTextBlock::length() const
{
    if(!lengthIsValid) {
        textLength = std::strlen(pText); // error: can&#39;t asssign to textLength 
        lengthIsValid = true;            // and lengthIsValid in a const member function
    }
    return textLength;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;According to the mutable&amp;rsquo;s definition, you may notice that &lt;code&gt;const&lt;/code&gt; member function will not check bitwise constness for static data members. This is because following &lt;a href=&#34;https://stackoverflow.com/questions/43936404/why-can-a-const-member-function-modify-a-static-data-member&#34;&gt;facts&lt;/a&gt;:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;The &lt;code&gt;this&lt;/code&gt; pointer in a &lt;code&gt;const&lt;/code&gt; qualified member function is a &lt;code&gt;const&lt;/code&gt; type, and &lt;code&gt;this&lt;/code&gt; is inherently related to an &lt;em&gt;instance&lt;/em&gt; of a class&lt;/li&gt;
&lt;li&gt;&lt;code&gt;static&lt;/code&gt; data members are not related to a class instance&lt;/li&gt;
&lt;li&gt;For non-static data member &lt;code&gt;lengthIsValid = true;&lt;/code&gt;, think of it as &lt;code&gt;this-&amp;gt;lengthIsValid = true;&lt;/code&gt;, which is not compilable when the type of &lt;code&gt;this&lt;/code&gt; is &lt;code&gt;const CTextBlock*&lt;/code&gt; without &lt;code&gt;mutable&lt;/code&gt; added.&lt;/li&gt;
&lt;li&gt;Think of static data member &lt;code&gt;staticMember&lt;/code&gt; as &lt;code&gt;CTextBlock::staticMember&lt;/code&gt;, so there&amp;rsquo;s no constraints from &lt;code&gt;const&lt;/code&gt; type &lt;code&gt;this&lt;/code&gt; pointer.&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;5-2-avoiding-duplication-in-const-and-non-const-member-function&#34;&gt;5.2 Avoiding duplication in &lt;code&gt;const&lt;/code&gt; and non-&lt;code&gt;const&lt;/code&gt; member function&lt;/h2&gt;

&lt;p&gt;There are two versions of operator[] in class TextBlock, which is duplication and tempts us to have one version of operator[] call the other one. Although generally speaking casting is a bad idea, here we may find enough reasons to justify its usage so long as we use it properly (note that we call &lt;code&gt;const&lt;/code&gt; version in non-&lt;code&gt;const&lt;/code&gt; version, not the other way around!):&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class TextBlock {
public:
...
    const char&amp;amp; operator[](const std::size_t position) const
    {
        ...    // some extra tasks such as bounds checking, 
        ...    // log access data, verify data integrity 
        ...    // to make code duplication unbearablly tedious
        return text[position];
    }
    char&amp;amp; operator[](const std::size_t position) const 
    {
        return const_cast&amp;lt;char&amp;amp;&amp;gt; ( // cast away const on return type
            static_cast&amp;lt;const TextBlock&amp;amp;&amp;gt;(*this)[position]; // add const to *this&#39;s type in order to call const version of operator[]
        );
    }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It&amp;rsquo;s definitely worth knowing this technique of implementing a non-&lt;code&gt;const&lt;/code&gt; member function in terms of its &lt;code&gt;const&lt;/code&gt; twin, although the syntax is somehow ungainly.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Item-0 Federation of languages</title>
      <link>http://nianze.tk/2018/01/cpp-is-multiparadigm/</link>
      <pubDate>Thu, 18 Jan 2018 20:01:47 -0500</pubDate>
      
      <guid>http://nianze.tk/2018/01/cpp-is-multiparadigm/</guid>
      <description>&lt;p&gt;C++ is a multiparadigm programming langrage.
&lt;/p&gt;

&lt;p&gt;Instead of regarding &lt;code&gt;C++&lt;/code&gt; as a single language, we&amp;rsquo;d better treat it as a federation of related languages, where rules within a particular sublanguage tend to be simple and straightforward, while rules between sublanguages may change.&lt;/p&gt;

&lt;p&gt;Basically, there are four primary sublanguages:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;code&gt;C&lt;/code&gt;: Based on ideas of blocks, statements, the preprocessor, built-in data types, arrays, pointers, etc, rules of C style C++ are simple: no templates, no exceptions, no overloading, etc.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Object-Oriented C++&lt;/code&gt;: Based on ideas of classes(including constructors and destructors), encapsulation, inheritance, polymorphism, virtual functions(dynamic binding), etc, style of this part of C++ goes with the classic Object-Oriented design rules.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Template C++&lt;/code&gt;: this is generic programming part of C++, where template considerations pervade C++. Due to its great power, templates give rise to a completely new programming paradigm, &lt;em&gt;template metaprogramming(TMP, item 48)&lt;/em&gt;.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;The STL&lt;/code&gt;: With beautifully meshing conventions of containers, iterators, algorithms and function objects, the STL is a very special template library and has its particular ways of doing things.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;There&amp;rsquo;s an interesting comparison among the four sublanguages: pass-by-value is generally preferred to pass-by-reference for built-in (i.e., &lt;code&gt;C-style&lt;/code&gt;) types in favor of its higher efficiency, but for &lt;code&gt;Object-Oriented C++&lt;/code&gt; pass-by-reference will usually be better due to the consideration of user-defined constructors and destructors; pass-by-reference is especially the dominant usecase in &lt;code&gt;template C++&lt;/code&gt; for you don&amp;rsquo;t even know the type of object you&amp;rsquo;re dealing with; however, the old C pass-by-value rule applies to the case of &lt;code&gt;STL&lt;/code&gt;, because iterators and function objects are modeled on pointers in C (see item 20).&lt;/p&gt;

&lt;p&gt;In summary, rules for effective C++ programming vary, depending on the part of C++ you are using.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;P.S.: Today I found that the 3rd edition of &lt;em&gt;effective C++&lt;/em&gt; added some new items. So new posts will follow the third edition&amp;rsquo;s arrangement. This item 0 is supposed to be item 1 in 3rd edition, but I just put it in front of the item 1 which I already wrote. After all, that&amp;rsquo;s how programmers count :)&lt;/p&gt;
&lt;/blockquote&gt;</description>
    </item>
    
    <item>
      <title>Item-2 Compare &lt;iostream&gt; to &lt;stdio.h&gt;</title>
      <link>http://nianze.tk/2018/01/tips-on-iostream/</link>
      <pubDate>Wed, 17 Jan 2018 19:14:29 -0500</pubDate>
      
      <guid>http://nianze.tk/2018/01/tips-on-iostream/</guid>
      <description>&lt;p&gt;Some tips about &lt;code&gt;&amp;lt;iostream&amp;gt;&lt;/code&gt;
&lt;/p&gt;

&lt;p&gt;One advantage of &lt;code&gt;&amp;lt;iostream&amp;gt;&lt;/code&gt; over &lt;code&gt;&amp;lt;stdio.h&amp;gt;&lt;/code&gt; (which includes C-style &lt;code&gt;scanf&lt;/code&gt; and &lt;code&gt;printf&lt;/code&gt;) is that built-in types like &lt;code&gt;int&lt;/code&gt; are read and written in the same manner as user-defined types like &lt;code&gt;Rational&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;int i;
Rational r;  // r is a user-defined rational number
...
cin &amp;gt;&amp;gt; i &amp;gt;&amp;gt; r;
cout &amp;lt;&amp;lt; i &amp;lt;&amp;lt; r;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So considering type safety and extensibility offered by the classes and functionas in the iosteam library, in general we should prefer &lt;code&gt;&amp;lt;iostream&amp;gt;&lt;/code&gt; to &lt;code&gt;&amp;lt;stdio.h&amp;gt;&lt;/code&gt;. In order for this code to compile, we mus define &lt;code&gt;operator&amp;gt;&amp;gt;&lt;/code&gt; and &lt;code&gt;operator&amp;lt;&amp;lt;&lt;/code&gt; for &lt;code&gt;Rational&lt;/code&gt; type. A typical output routine may look like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt; clas Rational {
 public:
    Rational (int numerator = 0, int denominator = 1);
    ...
 private:
    int n, d;
 friend ostream&amp;amp; operator&amp;lt;&amp;lt;(ostream&amp;amp; s, const Rational&amp;amp; r);
 };

 ostream&amp;amp; operator&amp;lt;&amp;lt;(ostream&amp;amp; s, Rational&amp;amp; r) 
 {
     s &amp;lt;&amp;lt; r.n &amp;lt;&amp;lt; &#39;/&#39; &amp;lt;&amp;lt; r.d;
     return s;
 }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;There are some subtle points worth noting: &lt;code&gt;operator&amp;lt;&amp;lt;&lt;/code&gt; is not a member function (explained in item 19) and the &lt;code&gt;Rational&lt;/code&gt; object to be output is passed as a reference-to-&lt;code&gt;const&lt;/code&gt; rather than as an object (see item 22).&lt;/p&gt;

&lt;p&gt;Howerver, there are still very few situations where &lt;code&gt;&amp;lt;stdio.h&amp;gt;&lt;/code&gt; may be more sensible to use:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Some implementations of iostream operations are less efficient than corresponding C stream operations, so it may make sense for applications requiring extreme performance.&lt;/li&gt;
&lt;li&gt;During the course of standardization, iostream library was modified in some fundamental ways, so it may make sense for applications targeting at maximum portablility.&lt;/li&gt;
&lt;li&gt;Since classes of the iostream library have constructors while functions in &lt;code&gt;&amp;lt;stdio.h&amp;gt;&lt;/code&gt; do not, when concerning about initialization order of static objects (see item 47) the standard C library may be more useful because you can always call it with impunity.&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;by-the-way&#34;&gt;By the way&lt;/h3&gt;

&lt;p&gt;Technically speaking, the standardizatoin committee eliminated &lt;code&gt;&amp;lt;iostream.h&amp;gt;&lt;/code&gt; in favor of &lt;code&gt;&amp;lt;iostream&amp;gt;&lt;/code&gt; when they truncated the names of the other non-C standard header names, but chances are that most compilers support both of them. However, there is a subtle difference between them:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;when &lt;code&gt;#include &amp;lt;iostream&amp;gt;&lt;/code&gt;, the iostream library is ensconced within the namespace &lt;code&gt;std&lt;/code&gt; (item 28)&lt;/li&gt;
&lt;li&gt;when &lt;code&gt;#include &amp;lt;iostream.h&amp;gt;&lt;/code&gt;, we get the same elements but they are at global scope&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Thus we usually prefer using &lt;code&gt;&amp;lt;iostream&amp;gt;&lt;/code&gt; for name conflicts consideration.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Item-1 Prefer consts, enums and inlines to #defines</title>
      <link>http://nianze.tk/2018/01/start-of-effective-cpp-series/</link>
      <pubDate>Tue, 16 Jan 2018 18:41:58 -0500</pubDate>
      
      <guid>http://nianze.tk/2018/01/start-of-effective-cpp-series/</guid>
      <description>&lt;p&gt;A new (hopefully) daily review on &lt;code&gt;C++&lt;/code&gt;.

&lt;!-- toc --&gt;&lt;/p&gt;

&lt;p&gt;This is another new series, which I plan to update daily (well, hopefully :P). It&amp;rsquo;s mainly about &lt;code&gt;C++&lt;/code&gt;, which is my current main development language. Each day I&amp;rsquo;ll follow 1 item in the &lt;em&gt;Effective C++ 2nd edition&lt;/em&gt; by &lt;a href=&#34;https://www.aristeia.com/books.html&#34;&gt;Scott Meyers&lt;/a&gt; to discuss 1 tiny point of &lt;code&gt;C++&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;The item 1 of the book tells us when we should prefer the compiler to the preprocessor, or more specifically, why we should prefer &lt;code&gt;const&lt;/code&gt;s, &lt;code&gt;enum&lt;/code&gt;s and &lt;code&gt;inline&lt;/code&gt;s to &lt;code&gt;#define&lt;/code&gt;. Now let&amp;rsquo;s take a closer look.&lt;/p&gt;

&lt;h1 id=&#34;prefer-const-to-define&#34;&gt;Prefer &lt;code&gt;const&lt;/code&gt; to &lt;code&gt;#define&lt;/code&gt;&lt;/h1&gt;

&lt;p&gt;There are two ways we may consider, when we want to define a constant:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;// method one
#define PI_1 3.1415926
// method two
const double PI_2 = 3.1415926;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;However, since &lt;code&gt;PI_1&lt;/code&gt; may be removed by preprocessor and never be seen by compilers, making it absent in the symbol table, this can be confusing during debugging if we get an error refering to 3.1415926 rather than &lt;code&gt;PI_1&lt;/code&gt; (especially when &lt;code&gt;PI_1&lt;/code&gt; is defined in a header file written by somebody else). Thus, instead of using a preprocessor macro, we&amp;rsquo;d better go with &lt;code&gt;const&lt;/code&gt;. Below is some tricks with &lt;code&gt;const&lt;/code&gt;.&lt;/p&gt;

&lt;h2 id=&#34;tricks-on-const-definition&#34;&gt;Tricks on &lt;code&gt;const&lt;/code&gt; definition&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;When defining constant pointers, use two &lt;code&gt;const&lt;/code&gt; to make sure both the pointer as well as the content pointed by the pointer are immutable:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;const char * const blogger = &amp;quot;Nzo&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;For class-specific constants, of which we want to limit the scope, we declare it as a &lt;code&gt;static&lt;/code&gt; member, since there&amp;rsquo;s no way we may create a class-scope-specific or class-encapsulated(i.e., private) constant using a &lt;code&gt;#define&lt;/code&gt; (once a macro is defined, it&amp;rsquo;s in force for the rest of the compilation unless it&amp;rsquo;s &lt;code&gt;#undefed&lt;/code&gt; somewhere along the line). Pay attention to the difference between constant declaration and constant definition:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;// game.h
class GamePlayer {
private:
    static const int NUM_TURNS = 5;  // constant declaration with initial value
    static const double PI;          // constant declaration without initial value
    int scores[NUM_TURNS];           // use of constant
};
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;// game.cpp
const int GamePlayer::NUM_TURNS;     // constant definition in impl. file
const double GamePlayer::PI = 3.14;  // provide initial value at definition
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It&amp;rsquo;s worth noting that older compilers (primarily those written before 1995) may complain about providing initial value for static class member at the point of &lt;em&gt;declaration&lt;/em&gt;. Most of time we may solve the problem by putting the initial value at &lt;em&gt;definition&lt;/em&gt; time, but in the situation where we need the integral value of NUM_TURNS during compilation time (in the example above, compilers must know the size of the array during compilation), we may use a trick affectionately known as &lt;strong&gt;the enum hack&lt;/strong&gt;, which takes advantage of the fact that the value of an enumerated type can be used where &lt;code&gt;int&lt;/code&gt;s are expected:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;// Game.h
class GamePlayer {
private:
    enum { NUM_TURNS = 5 };          // NUM_TURNS is a symbolic name for 5        
    int scores[NUM_TURNS];           // fine with old compilers
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;There are mainly 2 reasons we may still see the enum hack today:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;It&amp;rsquo;s legal to take the address of a &lt;code&gt;const&lt;/code&gt;, but it&amp;rsquo;s not legal to take the address of an enum, so if you don&amp;rsquo;t want people to get a pointer or reference to your integral constants, an enum will enforce that constraint (and this makes the enum behave somewhat like a #define).&lt;/li&gt;
&lt;li&gt;It&amp;rsquo;s purely pragmatic. Lots of code (such as template metaprogramming, item 48) still employs it.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;For modern compilers, on the other hand, rules change a bit in a more convenient way. Usually C++ requires that you provide a difinition for anything you use, but class-specific &lt;code&gt;constant&lt;/code&gt;s that are &lt;code&gt;stitic&lt;/code&gt; and of &lt;code&gt;integral type&lt;/code&gt; (e.g., &lt;em&gt;integers&lt;/em&gt;, &lt;em&gt;chars&lt;/em&gt;, &lt;em&gt;bools&lt;/em&gt;) are an exception. As long as you don&amp;rsquo;t take thier address, you can declare and read them &lt;strong&gt;without&lt;/strong&gt; providing a definition, and (good) compilers will not allocate unneccessary memory for these integral-type const objects, which will make the static const integral an lvalue.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&#34;prefer-inline-to-define&#34;&gt;Prefer &lt;code&gt;inline&lt;/code&gt; to &lt;code&gt;#define&lt;/code&gt;&lt;/h1&gt;

&lt;p&gt;Another common (mis)use of the &lt;code&gt;#define&lt;/code&gt; is using it to implement macros that look like functions:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#define max(a,b) ((a) &amp;gt; (b) ? (a) : (b))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This macro will lead to following weird things:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;int a = 5, b = 0;
max(++a, b);     // a increments twice
max(++a, b+10);  // a increments once
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Thus, we may prefer using a regular inline function that provides both predictable behavior and type-safety:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;inline int max(int a, int b) { return a &amp;gt; b ? a : b; }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If you complain that the above inline function only deals with &lt;code&gt;int&lt;/code&gt; type, then we may just use inline template function, which nicely fixes the problem:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;template&amp;lt;typename T&amp;gt; 
inline const T&amp;amp; max (const T&amp;amp; a, const T&amp;amp; b) { return a &amp;gt; b ? a : b; }
// since we don&#39;t know what T is, 
// we pass by reference-to-const, see item 20
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Basically, this template generates a whole family of functions, each of which takes two objects convertible to the same type and returns a reference to the greater of the two objects in const version.&lt;/p&gt;

&lt;h1 id=&#34;when-to-use-preprocessor&#34;&gt;When to use preprocessor&lt;/h1&gt;

&lt;p&gt;However, preprocessor is never dead. We still need preprocessor for tasks such as &lt;code&gt;#include&lt;/code&gt; to include libraries, as well as &lt;code&gt;#ifdef&lt;/code&gt;/&lt;code&gt;#ifndef&lt;/code&gt; to control compilation.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>当谈论有趣时，我在谈论什么</title>
      <link>http://nianze.tk/2018/01/creation-is-fun/</link>
      <pubDate>Wed, 10 Jan 2018 00:00:00 +0000</pubDate>
      
      <guid>http://nianze.tk/2018/01/creation-is-fun/</guid>
      <description>&lt;p&gt;Dull guys are all the same, while cool souls each have their own shine.&lt;br /&gt;
无趣的灵魂都是相同的，有趣的灵魂各有各的不同
&lt;/p&gt;

&lt;p&gt;最近在知乎上看到一个回答，里面提到&lt;a href=&#34;https://link.zhihu.com/?target=http%3A//book.douban.com/subject/1775691/&#34;&gt;《少有人走的路》&lt;/a&gt;里的一个观点：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;人生本充满困难，只不过有些人选择承受面对困难带来的痛苦，有些人选择承受逃避困难带来的痛苦。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;这话讲得很对胃口，让我想起了罗曼罗兰曾将英雄主义定义为“认清了生活的真相后依然热爱生活”，而鲁迅也把真正的勇士描述成“敢于直面惨淡的人生，敢于正视淋漓的鲜血”。哦，对了，说过类似话的还有王小波，他在那本《黄金时代》里直抒胸臆道：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;天色微微向晚，天上飘着懒洋洋的云彩。下半截沉在黑暗里，上半截仍浮在阳光中。那一天我二十一岁，在我一生的黄金时代。我有好多奢望。我想爱，想吃，还想在一瞬间变成天上半明半暗的云。后来我才知道，生活就是个缓慢受锤的过程，人一天天老下去，奢望也一天天消失，最后变得像挨了锤的牛一样。可是我过二十一岁生日时没有预见到这一点。我觉得自己会永远生猛下去，什么也锤不了我。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;看来不管哪个时代，都是世道艰险。看透了这点的作家却并没有“人艰不拆&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:1&#34;&gt;&lt;a href=&#34;#fn:1&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;”，反而毫不避讳的把生活的阴暗面揭露出来，真让人浑身难受；好在他们顺手指了条出路，那便是去迎接这份挑战。&lt;/p&gt;

&lt;p&gt;在如今这个信息爆炸的时代，知识的传播与获取变得前所未有的便捷而廉价，按说接受了更多的刺激开拓了更大的眼界，被锤者理应更容易反应过来生活的真相然后生猛下去，但去年底回国期间我隐约感受到的却是种“疲惫”感（话说要是每天都被现实狠狠锤到默认加班至晚上九点之后，那真是不得不疲惫），又有点像之前在湾区工作的我在琐碎中安心度日然后一眼望到头时袭上心头的凝重，只是好像国内会更多些焦虑和不安——于是突然明白为什么自己现在会喜欢纽约了，因为这里总有太多人做着（或许根本不切实际的）梦，激发着生猛的活力，让我产生“错觉”，觉得自己也可以一直生猛下去，去做一切自己想做的事，有趣的事。&lt;/p&gt;

&lt;p&gt;所幸的是，现在我有太多的娱乐活动兴趣爱好可供选择，比如可以看电影、品美食、听音乐、拍照片、去旅行；所不幸的是，很多时候，娱乐活动演变为简单的消费行为，兴趣爱好仅仅是又一次浅尝辄止——当喜欢电影指的是追看时下上映的热门影片，但既没去了解拍摄背景又不组织语言进行观后讨论更别提找类似题材的经典老片回味赏析；当喜欢美食只是遍尝各家餐厅后给他们排个序标记上，但并不关心美食美酒背后的食材选择和烹饪酿制流程的不同带来的味觉上的微妙差异；当喜欢音乐仅仅指的是喜欢听音乐类app里推荐的时下最热门的音乐，但从未考虑过花时间去练习演唱发声或乐器弹奏的技巧来重现曾被触动的共鸣；当喜欢摄影指的是喜欢用刚买的单反拍几张旅游照传到票圈分享，但毫无冲动去深入研究前期构图布光后期调色修图的相关技术；当喜欢旅游仅仅是提着两个大大的行李箱奔走在异地的商场里然后在主要景点拍到此一游，却未尝试过轻装上路毫无负担的像当地人般生活甚至专门学习一门外语来体会历史文化和自然风貌的异同。我总觉得这种程度的有趣在面对生活的真相时未免太苍白。&lt;/p&gt;

&lt;p&gt;所以当我无意间了解到，一位不知名的&lt;a href=&#34;https://www.youtube.com/channel/UCTF4nmNOzKDIHHX0JcIJwZg&#34;&gt;音乐人&lt;/a&gt;在他无人问津的&lt;del&gt;Youtube&lt;/del&gt;&lt;a href=&#34;http://www.bilibili.com/video/av17575121/#reply572883984&#34;&gt;B站主页&lt;/a&gt;上传了一曲自制的原汁原味&lt;em&gt;Hotel California&lt;/em&gt; ；一个本科学艺术史的华人小哥（&lt;a href=&#34;https://twitter.com/youyuxi&#34;&gt;尤雨溪&lt;/a&gt;）在下班后的业余时间里凭一己之力开发的开源框架&lt;a href=&#34;https://vuejs.org/&#34;&gt;Vue.js&lt;/a&gt;同&lt;a href=&#34;https://reactjs.org/&#34;&gt;React&lt;/a&gt;和&lt;a href=&#34;https://angular.io/&#34;&gt;Angular&lt;/a&gt;三足鼎力；乃至更多类似&lt;a href=&#34;https://twitter.com/tjholowaychuk&#34;&gt;TJ Holowaychuk&lt;/a&gt;、&lt;a href=&#34;https://twitter.com/rauchg&#34;&gt;Guillermo Rauch&lt;/a&gt;这样的独立开发者，即使同样不断经受着来自生活的锤打，他们选择默默创造着各自心中有趣而美好的事物，以创作者的身份，凭自己的作品不断回应生活的真相。&lt;/p&gt;

&lt;p&gt;反观自我，作为一个开发者，创造于我而言便是最大的乐趣了吧。虽说日常的工作也在创造价值，但那终究是为别人打工&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:2&#34;&gt;&lt;a href=&#34;#fn:2&#34;&gt;2&lt;/a&gt;&lt;/sup&gt;，只有为自己打工才能叫“事业”，创造出的东西才能算自己的“作品”。我想自己的作品不仅可以是优雅的代码，还有一切美好的事物——音乐也好，摄影也罢，其实都是在不停惊起内心的波澜，让自己不至在缓慢受锤的过程中麻木，沉沦于生活的琐碎。不然能怎样呢？不然就好像一潭死水惊不起波澜，内心麻木，便成了那头受锤的牛。&lt;/p&gt;
&lt;div class=&#34;footnotes&#34;&gt;

&lt;hr /&gt;

&lt;ol&gt;
&lt;li id=&#34;fn:1&#34;&gt;据传出自林宥嘉的歌曲《说谎》中的一段歌词：“我没有说谎，我何必说谎。爱一个人，没爱到难道就会怎么样。别说我说谎，&lt;code&gt;人&lt;/code&gt;生已经如此的&lt;code&gt;艰&lt;/code&gt;难，有些事情就&lt;code&gt;不&lt;/code&gt;要&lt;code&gt;拆&lt;/code&gt;穿。” 继而在贴吧和暴走漫画被大量网友引用。
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:1&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:2&#34;&gt;有个段子：你老板上班的时候开来了一辆兰博基尼，你说：“卧槽，这车真牛逼！”老板回答说：“只要你努力工作，并且全身心投入，全力以赴，力求卓越，那么——明年我还会再有一辆。”
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:2&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;</description>
    </item>
    
    <item>
      <title>Machine learning overview</title>
      <link>http://nianze.tk/2018/01/start-of-machine-learning-series/</link>
      <pubDate>Thu, 04 Jan 2018 00:00:00 +0000</pubDate>
      
      <guid>http://nianze.tk/2018/01/start-of-machine-learning-series/</guid>
      <description>&lt;p&gt;My first post in the new &lt;code&gt;machine learning&lt;/code&gt; series.

&lt;!-- toc --&gt;&lt;/p&gt;

&lt;p&gt;Although I&amp;rsquo;ve chosen &lt;code&gt;https://nianze.ml&lt;/code&gt; as my personal website domain name, I haven&amp;rsquo;t really posted any article on &lt;strong&gt;M&lt;/strong&gt;achine &lt;strong&gt;L&lt;/strong&gt;earning at all, which may somehow be &lt;em&gt;misleading&lt;/em&gt;. Considering it&amp;rsquo;s new year and my website has just been re-designed, it&amp;rsquo;s perfect time for new plans, so I&amp;rsquo;ve made a dicision to begin a new series related to &lt;code&gt;ml&lt;/code&gt;: I&amp;rsquo;ll write down learning notes during my self-study in machine learning. Recently I&amp;rsquo;m reading the book &lt;a href=&#34;https://www.safaribooksonline.com/library/view/hands-on-machine-learning/9781491962282/&#34;&gt;&lt;em&gt;Hands-On Machine Learning with Scikit-Learn and TensorFlow&lt;/em&gt;&lt;/a&gt; by Aurélien Géron, which should be a good start for this new series.&lt;/p&gt;

&lt;p&gt;At first the post is intended to be written in Chinese, but considering there&amp;rsquo;re so many technique terms in English that I do not know the exact Chinese translation, I&amp;rsquo;ll just start with English.&lt;/p&gt;

&lt;p&gt;As the first post in this series, let&amp;rsquo;s just take a overview on machine learning system.&lt;/p&gt;

&lt;h1 id=&#34;types-of-machine-learning&#34;&gt;Types of machine learning&lt;/h1&gt;

&lt;p&gt;There are broadly three ways to classify machine learning systems, and each of these three could be further categorized into multiple sub-categories:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;Machine learning system
├── trained with supervision or without
│   ├── supervised learning
│   │   ├── k-Nearest Neighbors
│   │   ├── Linear Regression
│   │   ├── Logistic Regression
│   │   ├── Support Vector Machines (SVMs)
│   │   ├── Decision Trees and Random Forests
│   │   └── Neural networks
│   ├── unsupervised learning
│   │   ├── clustering
│   │   │   ├── k-Means
│   │   │   ├── Hierarchical Cluster Analysis (HCA)
│   │   │   └── Expectation Maximization
│   │   ├── Visualization and dimensionality reduction
│   │   │   ├── Principal Component Analysis (PCA)
│   │   │   ├── Kernel PCA
│   │   │   ├── Locally-Linear Embedding (LLE)
│   │   │   └── t-distributed Stochastic Neighbor Embedding (t-SNE)
│   │   └── Association rule learning
│   │       ├── Apriori
│   │       └── Eclat
│   ├── semisupervised learning
│   └── reinforcement learning
├── learn incrementally or in a whole batch
│   ├── online learning (incremental learning)
│   │       ├── adapting rapidly to changing data and autonomous system
│   │       └── out-of-core learning (training on large quantities of data)
│   └── batch learning
└── predict based on a model or not
    ├── instance-based learning (using a similarity measure)
    └── model-based learning
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;main-challenges-of-machine-learning&#34;&gt;Main challenges of machine learning&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;Bad data

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://static.googleusercontent.com/media/research.google.com/fr//pubs/archive/35179.pdf&#34;&gt;Insufficient quantity&lt;/a&gt; of training data&lt;/li&gt;
&lt;li&gt;Nonrepresentative training data&lt;/li&gt;
&lt;li&gt;Poor-quality data&lt;/li&gt;
&lt;li&gt;Irrelevant features&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Bad algorithm

&lt;ul&gt;
&lt;li&gt;Overfitting the training data&lt;/li&gt;
&lt;li&gt;Underfitting the training data&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;We reduce overfitting by constraining the degrees of freedom the model has, which is called &lt;em&gt;regularization&lt;/em&gt;. The amount of regularization can be controlled by a hyperparameter, which is a parameter of the learning algorithm (not of the model). The larger the hyperparameter, the smaller the model parameter, ending up with more constrain we apply to the model and less degrees of freedom.&lt;/p&gt;

&lt;p&gt;On the other side, to solve underfitting problem, we may consider:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;select more powerful model with more parameters&lt;/li&gt;
&lt;li&gt;feed better fetures&lt;/li&gt;
&lt;li&gt;reduce the constraints (e.g., reducing the regularization hyperparameter)&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;testing-and-validating&#34;&gt;Testing and validating&lt;/h1&gt;

&lt;p&gt;Usually we split data into three groups:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;training set&lt;/li&gt;
&lt;li&gt;validation set&lt;/li&gt;
&lt;li&gt;test set&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;And take following common workflow:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;train multiple models with various hyperparameters using the &lt;strong&gt;training set&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;select the model and hyperparameters tht perform best on the &lt;strong&gt;validation set&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;run a single final tets against the &lt;strong&gt;test set&lt;/strong&gt; to get an estimate of the &lt;em&gt;generalization error&lt;/em&gt; (&lt;em&gt;out-of-sample error&lt;/em&gt;)&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Further, we can use cross-validation technique to reuse data:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;split trainig set into complementary subsets&lt;/li&gt;
&lt;li&gt;train each model against a different combination of these subsets and validate against the remaining parts&lt;/li&gt;
&lt;li&gt;select the model type and hyperparameters with best performance&lt;/li&gt;
&lt;li&gt;train the final model by feeding the full training set to the chosen model and hyperparameters&lt;/li&gt;
&lt;li&gt;measure the generalized error on the test set&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&#34;concept-checkout&#34;&gt;Concept checkout:&lt;/h1&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;How would you define Machine Learning?&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;ML is a system that can learn from data. Specifically, given performance measure, the learning will result in better performance at some tasks.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Can you name four types of problems where it shines?&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Complex problems without known algorithmic solution&lt;/li&gt;
&lt;li&gt;Long hand-tuned rules&lt;/li&gt;
&lt;li&gt;System that needs to adapt to fluctuating environment&lt;/li&gt;
&lt;li&gt;Data mining (help humans learn)&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;What is a labeled training set?&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;It&amp;rsquo;s a training set that contains the desired solution (a &lt;em&gt;label&lt;/em&gt;) for each instance&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;What are the two most common supervised tasks?&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Regression and classification&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;What is the purpose of test set and validation set?&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;A test set is used to estimate the generalization error that a model will make on new instances, before the model is launched in production.&lt;/li&gt;
&lt;li&gt;A validation set is used to compare models. It makes it possible to select the best model and tune the hyperparameters.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Why would you prefer cross-validation?&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Cross-validation is a technique that makes it possible to compare models (for model selection and hyperparameter tuning) without the need for a separate validation set. This saves precious training data.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;</description>
    </item>
    
    <item>
      <title>Coco(寻梦环游记)随想</title>
      <link>http://nianze.tk/2018/01/coco/</link>
      <pubDate>Wed, 03 Jan 2018 00:00:00 +0000</pubDate>
      
      <guid>http://nianze.tk/2018/01/coco/</guid>
      <description>&lt;p&gt;观看Coco之后的一些随想。
&lt;/p&gt;

&lt;p&gt;昨晚在纽约看了去年底就在国内引起热议的Pixar新动画 &lt;em&gt;Coco&lt;/em&gt; 。外面天气很冻人，里面电影很动人。&lt;/p&gt;

&lt;p&gt;虽然不至于哭出来，但是能理解为什么很多人看完会想哭了。可能是因为被影片勾起了已故至亲的温暖回忆；可能是因为被主人公Miguel执着追求梦想的勇气打动心里充满了&amp;rdquo;seize the moment&amp;rdquo;的正能量；可能是心中还残留着些许被那根名为“为你着想”的“爱”的绳索束缚的痕迹所以自然代入了片中Miguel的叛逆行为；可能是因为最后Happy Ending的相互谅解大团圆结局让观众在那个瞬间有了宽恕一切的温暖仁慈；就算内心麻木不仁，可能全片动听的音乐，流畅的节奏和绚丽的画面也足够过把眼瘾值回票价了。不论能不能拿奥斯卡最佳动画奖，该片肯定是完成度很高的佳作无疑。&lt;/p&gt;

&lt;p&gt;片中对于死后世界的设定取材自墨西哥的传统节日亡灵节。我理解的片中对死后世界的构想是源于生者为了安慰在世时的灵魂所虚构的一种传统，考究这份传统的起源和发展将会是件很有趣的事情。虽然并不相信这份虚构的传统，但不得不承认，不管是否有死后需要依靠在世者的记忆才能存在的虚构世界，对活着的人来说，有亲人支持的现世生活总是比独行的世界更有温度的。每天放学下班回家，与家人互动会是件很让人感到有安全感的事情，如此一来平日里学习工作的劳累也会在互动中被稀释很多吧。只是任何事情都有两面，在享受亲情的热度带来的温暖的同时，也得掌握好这份温度的微妙距离和火候，否则就会被烫到了——Miguel自制的琴被Grandma砸了的时候我是真心疼，也就很能够理解他出走时的心情了。本片能在中国引起这么多共鸣和热议，我相信中国传统中相似的家庭观念是很重要的一个因素，&lt;a href=&#34;https://www.zhihu.com/question/57177072&#34;&gt;知乎&lt;/a&gt;上也有很多对此相关的讨论了。&lt;/p&gt;



 
  
  
  
  
    
  
    
      
    
  

&lt;div class=&#34;figure fig-100&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2018/2018-01/2018-01-03/festival.jpg&#34; title=&#34;墨西哥亡灵节&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2018/2018-01/2018-01-03/festival.jpg&#34;  alt=&#34;墨西哥亡灵节&#34;&gt;
  
    &lt;/a&gt;
  
   
    &lt;span class=&#34;caption&#34;&gt;墨西哥亡灵节&lt;/span&gt;
  
&lt;/div&gt;


&lt;p&gt;回归本片，&lt;em&gt;Coco&lt;/em&gt; 以一种豁达的角度阐述了墨西哥传统文化对于死亡的理解。这其实是个蛮沉重的话题，稍加深入便进入到虚无主义的领域了。对于人生，结合最近纽约冻人的天气，我可以大致做这么一个比喻吧：人生是一场残酷的跋涉，每个人都在名为孤独的寒风中被时间裹挟着走向死亡。如果希望旅途中不被这寒风冻死，那么眼下有至少两种解决方案：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;和人抱团靠理解与默契贴近心与心的距离来相互取暖&lt;/li&gt;
&lt;li&gt;不停脚步靠信念与追求磨砺肉与灵的强度来自我发热&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;作为一个“耐寒”的人，目前相比起掌握火候的技巧，我会将磨砺自己的优先级靠前，在自由状态下追求自己想做的事。我同意温暖的人生是值得追求的，但还不会加入抱团取暖后被篝火吸引决定驻足的人群；愈发习惯了寒风的凌冽，现在便只想着远方的征途。但我倒确实是佩服那些拥有足够的精力，能够在不停前进的同时，还温暖他人，既享受温度，又可以不被火焰烫伤的人；而那些偶然中巧遇小伙伴一起前往相同目的地的幸运者就更加值得祝福了。&lt;/p&gt;

&lt;p&gt;当片中开创家族鞋业的曾祖母在亡灵国度的聚光灯中重新开嗓，体会了久违的作为歌手时自己的追求与荣光，想起自己跟曾祖父一起合唱的岁月，又想起自己为了忘记曾祖父的离别，独自一人抚养 &lt;em&gt;Coco&lt;/em&gt; 长大而不得不作出抉择放弃歌唱的事业，她是否因此感到了一丝惋惜，才在最后宽恕了没能回家的曾祖父，并在手执花瓣时决定不再添加任何条件的献上自己的祝福呢？&lt;/p&gt;



 
  
  
  
  
    
  
    
      
    
  
    
      
    
  

&lt;div class=&#34;figure nocaption fig-100&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2018/2018-01/2018-01-03/flower.jpg&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2018/2018-01/2018-01-03/flower.jpg&#34; &gt;
  
    &lt;/a&gt;
  
  
&lt;/div&gt;


&lt;blockquote&gt;
&lt;p&gt;P.S.:片头的预告有对称狂魔 &lt;a href=&#34;https://en.wikipedia.org/wiki/Wes_Anderson&#34;&gt;Wes Anderson&lt;/a&gt; 的新片 &lt;a href=&#34;https://en.wikipedia.org/wiki/Isle_of_Dogs_(film)&#34;&gt;Isle of Dogs&lt;/a&gt;,看的第一眼就让我想到了&lt;a href=&#34;https://en.wikipedia.org/wiki/Fantastic_Mr._Fox_(film)&#34;&gt;Fantastic Mr.Fox(了不起的狐狸爸爸)&lt;/a&gt;。他也导演了另一部包揽2014年奥斯卡四项大奖的作品 &lt;a href=&#34;https://en.wikipedia.org/wiki/The_Grand_Budapest_Hotel&#34;&gt;The Grand Budapest Hotel(布达佩斯大饭店)&lt;/a&gt;。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;

 
  
  
  
  
    
  
    
      
    
  

&lt;div class=&#34;figure fig-33&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2018/2018-01/2018-01-03/dog.jpg&#34; title=&#34;Isle of Dogs&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2018/2018-01/2018-01-03/dog.jpg&#34;  alt=&#34;Isle of Dogs&#34;&gt;
  
    &lt;/a&gt;
  
   
    &lt;span class=&#34;caption&#34;&gt;Isle of Dogs&lt;/span&gt;
  
&lt;/div&gt;



 
  
  
  
  
    
  
    
      
    
  

&lt;div class=&#34;figure fig-33&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2018/2018-01/2018-01-03/fox.jpg&#34; title=&#34;Fantastic Mr.Fox&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2018/2018-01/2018-01-03/fox.jpg&#34;  alt=&#34;Fantastic Mr.Fox&#34;&gt;
  
    &lt;/a&gt;
  
   
    &lt;span class=&#34;caption&#34;&gt;Fantastic Mr.Fox&lt;/span&gt;
  
&lt;/div&gt;



 
  
  
  
  
    
  
    
      
    
  

&lt;div class=&#34;figure fig-33&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2018/2018-01/2018-01-03/hotel.jpg&#34; title=&#34;The Grand Budapest Hotel&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2018/2018-01/2018-01-03/hotel.jpg&#34;  alt=&#34;The Grand Budapest Hotel&#34;&gt;
  
    &lt;/a&gt;
  
   
    &lt;span class=&#34;caption&#34;&gt;The Grand Budapest Hotel&lt;/span&gt;
  
&lt;/div&gt;
&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>使用Hugo在GitHub Pages上搭建免费个人网站</title>
      <link>http://nianze.tk/2017/12/personal-site-with-hugo/</link>
      <pubDate>Tue, 26 Dec 2017 00:00:00 +0000</pubDate>
      
      <guid>http://nianze.tk/2017/12/personal-site-with-hugo/</guid>
      <description>&lt;p&gt;This article talks about how to use &lt;a href=&#34;https://gohugo.io/&#34;&gt;Hugo&lt;/a&gt; to build a personal website hosted on &lt;a href=&#34;https://pages.github.com/&#34;&gt;Github Pages&lt;/a&gt;. It also introduces how to find a free custom domain name from &lt;a href=&#34;http://www.freenom.com/&#34;&gt;Freenom&lt;/a&gt; and migrated the DNS server to &lt;a href=&#34;https://www.cloudflare.com/&#34;&gt;CloudFlare&lt;/a&gt; in order to use HTTPs with chosen custom domain name on GitHub Pages.&lt;br /&gt;
本文讲述了如何使用&lt;a href=&#34;https://gohugo.io/&#34;&gt;Hugo&lt;/a&gt;将个人网页托管在&lt;a href=&#34;https://pages.github.com/&#34;&gt;Github Pages&lt;/a&gt;上。同时也介绍了如何在&lt;a href=&#34;http://www.freenom.com/&#34;&gt;Freenom&lt;/a&gt;上找到免费个人域名并利用&lt;a href=&#34;https://www.cloudflare.com/&#34;&gt;CloudFlare&lt;/a&gt;的免费DNS服务在Github Pages上以HTTPs协议加载个人域名。

&lt;!-- toc --&gt;&lt;/p&gt;

&lt;h1 id=&#34;前言&#34;&gt;前言&lt;/h1&gt;

&lt;p&gt;最开始写博客始于2015年末，当时因为自制了几个单簧管演奏的视频，心想可以建一个简易的网站把录制背后的故事和想法集合起来。由于个人网站一般不需要太多交互，使用静态网页生成器并托管在&lt;code&gt;Github Pages&lt;/code&gt;上成为了首选方案（能使用git实现版本控制更是个加分项）。彼时没想太多直接用了&lt;code&gt;Github Pages&lt;/code&gt;原生支持的网页生成器&lt;a href=&#34;https://jekyllrb.com/&#34;&gt;Jekyll&lt;/a&gt;。随便搜了一个主题，第一版网站便这么建了起来：&lt;/p&gt;

&lt;p&gt;


&lt;div class=&#34;figure right nocaption fig-50&#34; &gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2017/2017-12-26/old_blog1-1.png&#34; &gt;
  
  
&lt;/div&gt;




&lt;div class=&#34;figure right nocaption fig-50&#34; &gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2017/2017-12-26/old_blog2.png&#34; &gt;
  
  
&lt;/div&gt;


 
  
  
  
  
    
  
    
      
    
  
    
      
    
  


&lt;div class=&#34;figure nocaption fig-50&#34; &gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2017/2017-12-26/old_blog1.png&#34; &gt;
  
  
&lt;/div&gt;

  &lt;div style=&#34;clear:both;&#34;&gt;&lt;/div&gt;
&lt;/p&gt;

&lt;p&gt;在为期一年断断续续的更新中总计写下了十余篇音乐和程序相关的（毫无营养的）文章后，第一代模板差不多也看腻了，突然觉得是时候该把网站升级下。遂决定新的博客应更简洁规整，首页加入图片预览功能并减去不必要的视觉干扰，菜单栏里应有分类、标签和归档功能。一番搜寻后，目光落在&lt;a href=&#34;https://gohugo.io/&#34;&gt;Hugo&lt;/a&gt;。主要原因在于&lt;code&gt;Hugo&lt;/code&gt;简单易用——不需要安装太多&lt;a href=&#34;https://hexo.io/&#34;&gt;Hexo&lt;/a&gt;中的依赖库，更换主题也比&lt;code&gt;Jekyll&lt;/code&gt;方便，生成速度还很快。以下便是我的配置过程。&lt;/p&gt;

&lt;h1 id=&#34;安装hugo&#34;&gt;安装Hugo&lt;/h1&gt;

&lt;blockquote&gt;
&lt;p&gt;本文在macOS High Sierra环境下写成。Windows平台可参考官方文档做相应修改。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;如果Mac上已经装上了&lt;a href=&#34;https://brew.sh/&#34;&gt;Homebrew&lt;/a&gt;，在命令行中直接敲下面的命令安装：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;brew install hugo
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果Mac上没有安装&lt;code&gt;Homebrew&lt;/code&gt;，可以考虑先装&lt;code&gt;Homebrew&lt;/code&gt;再按上述步骤安装&lt;code&gt;Hugo&lt;/code&gt;；也可以在&lt;a href=&#34;https://github.com/gohugoio/hugo/releases&#34;&gt;Hugo官网&lt;/a&gt;直接下载使用可运行文件。&lt;/p&gt;

&lt;p&gt;至此Hugo就安装完毕了。So easy.&lt;/p&gt;

&lt;h1 id=&#34;在hugo中写文章&#34;&gt;在Hugo中写文章&lt;/h1&gt;

&lt;p&gt;在硬盘中选取合适的存储路径，然后命令行中使用如下指令生成网页本地文档：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;hugo new site personal-site
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;由此可得到如下文件目录：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;personal-site
├── archetypes
├── config.toml
├── content
├── data
├── layouts
├── static
└── themes
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;常用目录用处如下&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;子目录名称&lt;/th&gt;
&lt;th&gt;功能&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;archetypes&lt;/td&gt;
&lt;td&gt;新文章默认模板&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;config.toml&lt;/td&gt;
&lt;td&gt;&lt;code&gt;Hugo&lt;/code&gt;配置文档&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;content&lt;/td&gt;
&lt;td&gt;存放所有&lt;code&gt;Markdown&lt;/code&gt;格式的文章&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;layouts&lt;/td&gt;
&lt;td&gt;存放自定义的&lt;code&gt;view&lt;/code&gt;，可为空&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;static&lt;/td&gt;
&lt;td&gt;存放图像、CNAME、css、js等资源，发布后该目录下所有资源将处于网页根目录&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;themes&lt;/td&gt;
&lt;td&gt;存放下载的主题&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;使用下面的命令生成新的文章草稿：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;hugo new posts/first-post.md
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在content目录中会自动以&lt;code&gt;archetypes/default.md&lt;/code&gt;为模板在&lt;code&gt;content/posts&lt;/code&gt;目录下生成一篇名为&lt;code&gt;first-post.md&lt;/code&gt;的文章草稿：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;---
title: &amp;quot;First Post&amp;quot;
date: 2017-12-27T23:15:53-05:00
draft: true
---

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们可以加一个标题在下面并去掉标记为草稿的这一行：&lt;code&gt;draft: true&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;---
title: &amp;quot;First Post&amp;quot;
date: 2017-12-27T23:15:53-05:00
---

## Hello world

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后随便下载一个主题并加载到&lt;code&gt;config.toml&lt;/code&gt;文件中：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;git init
git submodule add https://github.com/budparr/gohugo-theme-ananke.git themes/ananke

# Edit your config.toml configuration file
# and add the Ananke theme.
echo &#39;theme = &amp;quot;ananke&amp;quot;&#39; &amp;gt;&amp;gt; config.tomlecho &#39;theme = &amp;quot;ananke&amp;quot;&#39; &amp;gt;&amp;gt; config.toml
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;现在使用如下命令建立本地服务器：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;hugo server
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;并在浏览器中输入网址&lt;code&gt;http://localhost:1313/&lt;/code&gt;就可以在浏览器中查看网页效果了：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://nianze.tk/images/2017/2017-12-26/local_page.png&#34; alt=&#34;local_page&#34; /&gt;&lt;/p&gt;

&lt;p&gt;如果觉得没有问题了便可以使用如下命令：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;hugo
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如此一来网页便生成在默认的public子目录中了。&lt;/p&gt;

&lt;h1 id=&#34;发布并托管到github&#34;&gt;发布并托管到Github&lt;/h1&gt;

&lt;p&gt;上传到Github之前，先在Github中添加一个空白repository，注意不要添加如&lt;code&gt;README&lt;/code&gt;，&lt;code&gt;.gitignore&lt;/code&gt;等文档。由此得到Github中该repository的网址：&lt;code&gt;https://github.com/Nianze/personal-site.git&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://nianze.tk/images/2017/2017-12-26/repo.png&#34; alt=&#34;new repo&#34; /&gt;&lt;/p&gt;

&lt;p&gt;复制该网址后，在网站本地文档根目录中初始化git：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;git init
git add .
git commit -m &amp;quot;first commit&amp;quot;
git remote add origin https://github.com/Nianze/personal-site.git
git push -u origin master
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;至此所有源文档就都push到Github上了。然而此时Github对待这些源文档跟其他任何普通的repository中的代码并没有任何不同，并不会将public子目录中的网页托管在&lt;code&gt;Github Pages&lt;/code&gt;上。&lt;/p&gt;

&lt;p&gt;参见&lt;a href=&#34;https://gohugo.io/hosting-and-deployment/hosting-on-github/&#34;&gt;Hugo官方文档&lt;/a&gt;，可以选择以下两种方式让&lt;code&gt;Github Pages&lt;/code&gt;加载我们想要托管的&lt;code&gt;/public&lt;/code&gt;子目录中的网页：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;配置&lt;code&gt;Hugo&lt;/code&gt;将网页生成在名为&lt;code&gt;/docs&lt;/code&gt;的子目录中，然后直接push到&lt;code&gt;master branch&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;仍然使用默认的&lt;code&gt;/public&lt;/code&gt;子目录存储网页，再单独建立一个&lt;code&gt;gh-pages branch&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;使用-docs-发布到master-branch&#34;&gt;使用&lt;code&gt;/docs&lt;/code&gt;发布到master branch&lt;/h2&gt;

&lt;p&gt;第一种方案的好处在于一次push即可将源文档和对应生成的网页文档都发布到Github，操作非常简单。所需要的仅是在config.toml中添加如下一行配置，使得生成的网页默认保存在&lt;code&gt;/docs&lt;/code&gt;子目录下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;publishDir = docs
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;自此运行&lt;code&gt;hugo&lt;/code&gt;命令后生成的网页文件将保存在&lt;code&gt;/docs&lt;/code&gt;子目录下。将所有文档push到Github的&lt;code&gt;master branch&lt;/code&gt;，进入Github对应repository的Settings标签菜单，在&lt;code&gt;GitHub Pages&lt;/code&gt;选项的Source栏选择&lt;code&gt;master branch /docs folder&lt;/code&gt;:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://nianze.tk/images/2017/2017-12-26/docs_folder.png&#34; alt=&#34;docs&#34; /&gt;&lt;/p&gt;

&lt;p&gt;等待片刻即可访问&lt;code&gt;http://your_name.github.io&lt;/code&gt;看到之前用&lt;code&gt;Hugo&lt;/code&gt;生成的网页了。&lt;/p&gt;

&lt;h2 id=&#34;发布到gh-pages-branch&#34;&gt;发布到gh-pages branch&lt;/h2&gt;

&lt;p&gt;如果希望单独控制源文档和生成的网页文档的版本历史，可以使用单独建立一个&lt;code&gt;gh-pages branch&lt;/code&gt;的方法托管到&lt;code&gt;Github Pages&lt;/code&gt;——先将&lt;code&gt;/public&lt;/code&gt;子目录添加到&lt;code&gt;.gitignore&lt;/code&gt;中，让&lt;code&gt;master branch&lt;/code&gt;忽略其更新，然后在本地和Github端添加一个名为&lt;code&gt;gh-pages&lt;/code&gt;的branch：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;//忽略public子目录
echo &amp;quot;public&amp;quot; &amp;gt;&amp;gt; .gitignore
//初始化gh-pages branch
git checkout --orphan gh-pages
git reset --hard
git commit --allow-empty -m &amp;quot;Initializing gh-pages branch&amp;quot;
git push origin gh-pages
git checkout master
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;为了提高每次发布的效率，可以将下述命令存在脚本中，每次只需要运行该脚本即可将&lt;code&gt;gh-pages branch&lt;/code&gt;中的文章发布到Github的repo中：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;#!/bin/sh

if [[ $(git status -s) ]]
then
    echo &amp;quot;The working directory is dirty. Please commit any pending changes.&amp;quot;
    exit 1;
fi

echo &amp;quot;Deleting old publication&amp;quot;
rm -rf public
mkdir public
rm -rf .git/worktrees/public/

echo &amp;quot;Checking out gh-pages branch into public&amp;quot;
git worktree add -B gh-pages public origin/gh-pages

echo &amp;quot;Removing existing files&amp;quot;
rm -rf public/*

echo &amp;quot;Generating site&amp;quot;
hugo

echo &amp;quot;Updating gh-pages branch&amp;quot;
cd public &amp;amp;&amp;amp; git add --all &amp;amp;&amp;amp; git commit -m &amp;quot;Publishing to gh-pages (publish.sh)&amp;quot;

echo &amp;quot;Push to origin&amp;quot;
git push origin gh-pages

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最后将&lt;code&gt;master branch&lt;/code&gt;中的源文档和&lt;code&gt;gh-pages branch&lt;/code&gt;中的网页文档分别push到Github repo中，进入Settings标签菜单，选择&lt;code&gt;Github Pages&lt;/code&gt;项中的Source栏，点&lt;code&gt;gh-pages branch&lt;/code&gt;选项：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://nianze.tk/images/2017/2017-12-26/gh-pages.png&#34; alt=&#34;gh-pages&#34; /&gt;&lt;/p&gt;

&lt;p&gt;同样等待片刻，即可访问&lt;code&gt;https://your_name.github.io&lt;/code&gt;看到之前用&lt;code&gt;Hugo&lt;/code&gt;生成的网页了。&lt;/p&gt;

&lt;h1 id=&#34;配置个人域名&#34;&gt;配置个人域名&lt;/h1&gt;

&lt;p&gt;如果觉得使用&lt;code&gt;your_name.github.io&lt;/code&gt;不够酷炫，还可以考虑使用自选的个人域名。好的个人域名自然是需要到对应服务商购买的。常见的域名如&lt;code&gt;.com&lt;/code&gt;, &lt;code&gt;.net&lt;/code&gt;, &lt;code&gt;.me&lt;/code&gt;一般都不免费，但好在非顶级域名的年费其实也不贵。由于我建网的初衷只是自娱自乐，暂时并没有付费购买域名的意向，索性直接去&lt;a href=&#34;http://www.freenom.com/&#34;&gt;Freenom&lt;/a&gt;找了免费域名来用。目前Freenom平台提供的免费域名后缀为&lt;code&gt;.tk&lt;/code&gt;, &lt;code&gt;.ml&lt;/code&gt;,&lt;code&gt;ga&lt;/code&gt;,&lt;code&gt;cf&lt;/code&gt;,&lt;code&gt;gq&lt;/code&gt;等。购买域名很简单，先在&lt;a href=&#34;http://www.freenom.com/&#34;&gt;Freenom&lt;/a&gt;
网站上注册账号，然后查看自己想要的域名的价格并根据提示下单即可。考虑到现在machine leanring这么火，我就选了&lt;code&gt;nianze.ml&lt;/code&gt;这个免费域名。&lt;/p&gt;

&lt;p&gt;域名买好后还需要设置下域名解析。由于默认使用的是Freenom的DNS服务器，所以需要在&lt;code&gt;Manage Domain&lt;/code&gt;菜单中配置域名解析规则。在&lt;code&gt;Manage Freeenom DNS&lt;/code&gt;选项中添加如下两条规则：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;添加A记录（即地址记录，用来指定域名的IP地址），主机记录（Name）栏填www，记录值(Target)那栏填Github服务器IP地址（或者&lt;code&gt;your_name.github.io&lt;/code&gt;的IP地址）&lt;/li&gt;
&lt;li&gt;添加CNAME记录（用于将一个域名映射到另一个域名），主机记录栏填@，记录值那栏填&lt;code&gt;your_name.github.io&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;其中，Github服务器IP地址是&lt;code&gt;192.30.252.153&lt;/code&gt;和&lt;code&gt;192.30.252.154&lt;/code&gt;，而&lt;code&gt;your_name.github.io&lt;/code&gt;的IP地址可以在命令行中使用ping命令得到：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://nianze.tk/images/2017/2017-12-26/ping.png&#34; alt=&#34;ping&#34; /&gt;&lt;/p&gt;

&lt;p&gt;最后还需要在&lt;code&gt;personal-site/public&lt;/code&gt;子目录中需要添加一个名为CNAME的文档，该文件只包含想要替换的个人域名，对我来说即是nianze.ml（不加http）。由于每次使用&lt;code&gt;hugo&lt;/code&gt;命令
在&lt;code&gt;/public&lt;/code&gt;子目录生成网页的时候该CNAME文件都会被删除，所以最好将该文件放在&lt;code&gt;personal-site/static&lt;/code&gt;子目录中，这样运行&lt;code&gt;hugo&lt;/code&gt;后该CNAME文件将自动复制到&lt;code&gt;/public&lt;/code&gt;目录中。&lt;/p&gt;

&lt;p&gt;等待几小时，在浏览器中访问&lt;code&gt;nianze.ml&lt;/code&gt;就可以看到熟悉的个人网站页面了。&lt;/p&gt;

&lt;h1 id=&#34;配置cloudflare以使用https&#34;&gt;配置CloudFlare以使用HTTPs&lt;/h1&gt;

&lt;p&gt;之所以想要使用&lt;a href=&#34;https://www.cloudflare.com/&#34;&gt;CloudFlare&lt;/a&gt;，是因为上一步当我们配置好个人域名后，由于&lt;code&gt;Github Pages&lt;/code&gt;不支持在自定义域名中使用&lt;code&gt;HTTPs&lt;/code&gt;协议，所以浏览器中访问&lt;code&gt;nianze.ml&lt;/code&gt;使用的是&lt;code&gt;HTTP&lt;/code&gt;协议。这造成一个弊端：每回用Chrome打开&lt;code&gt;nianze.ml&lt;/code&gt;，浏览器都提示该网页不受信任，如果网页中还有待加载的&lt;code&gt;JavaScript&lt;/code&gt;代码,就得单独点浏览器地址栏右侧的&lt;code&gt;load&lt;/code&gt;按钮才能正常加载全部页面，非常麻烦。再加上考虑到&lt;code&gt;HTTPs&lt;/code&gt;协议比&lt;code&gt;HTTP&lt;/code&gt;更快更安全，显然应该想办法解决这个问题。&lt;/p&gt;

&lt;p&gt;好在&lt;a href=&#34;http://www.freenom.com/&#34;&gt;CloudFlare&lt;/a&gt;为我们提供了一套方便的解决方案，而且是免费的！&lt;/p&gt;

&lt;p&gt;首先点开&lt;code&gt;CloudFlare&lt;/code&gt;注册账号，输入前面选好的个人域名&lt;code&gt;nianze.ml&lt;/code&gt;，&lt;code&gt;CloudFlare&lt;/code&gt;会给我们提供众多服务套餐，选择免费的那个套餐即可:)&lt;/p&gt;

&lt;p&gt;此时&lt;code&gt;CloudFlare&lt;/code&gt;会给我们提供其DNS服务器的IP，此时需要去&lt;code&gt;Freenom&lt;/code&gt;的域名管理页面中更新默认DNS服务商到CloudFlare：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://nianze.tk/images/2017/2017-12-26/dns_server.png&#34; alt=&#34;dns_server&#34; /&gt;&lt;/p&gt;

&lt;p&gt;更改完DNS服务器就可以设置&lt;code&gt;CloudFlare&lt;/code&gt;中的各个选项了。首先在&lt;code&gt;Crypto&lt;/code&gt;选项标签下，选择使用&lt;code&gt;Full SSL&lt;/code&gt;模式以&lt;code&gt;HTTPs&lt;/code&gt;协议加载网页：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://nianze.tk/images/2017/2017-12-26/cf_ssl.png&#34; alt=&#34;cf_ssl&#34; /&gt;&lt;/p&gt;

&lt;p&gt;然后是&lt;code&gt;DNS&lt;/code&gt;标签栏配置，跟&lt;code&gt;Freenom&lt;/code&gt;设置类似：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://nianze.tk/images/2017/2017-12-26/cf_dns.png&#34; alt=&#34;cf_dns&#34; /&gt;&lt;/p&gt;

&lt;p&gt;最后再设置下&lt;code&gt;Page Rules&lt;/code&gt;标签：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://nianze.tk/images/2017/2017-12-26/cf_page_rules.png&#34; alt=&#34;page_rules&#34; /&gt;&lt;/p&gt;

&lt;p&gt;至此配置完毕。其实&lt;code&gt;CloudFlare&lt;/code&gt;中还有很多别的选项，可以根据个人喜好进行相应配置。等待几小时，再次访问&lt;code&gt;nianze.ml&lt;/code&gt;，可以发现网页已经在&lt;code&gt;HTTPs&lt;/code&gt;协议下加载了。这样以来就再也不用去点那个烦人的load按钮了。&lt;/p&gt;

&lt;h1 id=&#34;后记&#34;&gt;后记&lt;/h1&gt;

&lt;p&gt;至此我的新版博客就迁移完毕了，基本满足我现在写文章、摄影和音乐的各项需求。下一步准备在摄影栏目中加上一个照片墙功能。&lt;/p&gt;

&lt;h1 id=&#34;参考文档&#34;&gt;参考文档&lt;/h1&gt;

&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;https://themes.gohugo.io/hugo-tranquilpeak-theme/&#34;&gt;Hugo Tranquilpeak Theme&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.jonathan-petitcolas.com/2017/01/13/using-https-with-custom-domain-name-on-github-pages.html&#34;&gt;Using HTTPs with Custom Domain Name&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://gohugo.io/hosting-and-deployment/hosting-on-github/&#34;&gt;Deploy Hugo to Github&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;</description>
    </item>
    
    <item>
      <title>一些近况</title>
      <link>http://nianze.tk/2017/12/return-to-my-blog/</link>
      <pubDate>Fri, 22 Dec 2017 00:00:00 +0000</pubDate>
      
      <guid>http://nianze.tk/2017/12/return-to-my-blog/</guid>
      <description>&lt;p&gt;重新回归搁置了近一年的博客，开始新的企划。
&lt;/p&gt;

&lt;h2 id=&#34;回顾-展望&#34;&gt;回顾&amp;amp;展望&lt;/h2&gt;

&lt;p&gt;自2017年初找到工作，在至今一年的时间里，我都未曾更新过博客。算法的日常练习搁置了，单簧管也放下了，其实根本就忘记了我还有个博客这件事，归根结底还是自己的惰性使然。所以趁着年末回国之际，终于有比较充足的时间留给我回顾下今年的历程。&lt;/p&gt;

&lt;p&gt;年初找到工作之后，先跟着实习认识的小伙伴们去了趟阿拉斯加看极光，算是迟到的毕业游吧~贴几张照片在下面：&lt;/p&gt;

&lt;p&gt;

 
  
  
  
  
    
  
    
      
    
  
    
      
    
  

&lt;div class=&#34;figure nocaption fig-50&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;//farm3.staticflickr.com/2847/33463354782_ff6f0c5295_h.jpg&#34; title=&#34;极光&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;//farm3.staticflickr.com/2847/33463354782_92fc325db4_c.jpg&#34;  alt=&#34;极光&#34;&gt;
  
    &lt;/a&gt;
  
  
&lt;/div&gt;



 
  
  
  
  
    
  
    
      
    
  
    
      
    
  

&lt;div class=&#34;figure nocaption fig-50&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;//farm3.staticflickr.com/2889/33491176681_c8d70a8ddd_k.jpg&#34; title=&#34;pose&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;//farm3.staticflickr.com/2889/33491176681_55fc82ce2b_c.jpg&#34;  alt=&#34;pose&#34;&gt;
  
    &lt;/a&gt;
  
  
&lt;/div&gt;



 
  
  
  
  
    
  
    
      
    
  
    
      
    
  

&lt;div class=&#34;figure nocaption fig-100&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;//farm3.staticflickr.com/2928/33237275220_7b4b5b66fb_k.jpg&#34; title=&#34;pickup&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;//farm3.staticflickr.com/2928/33237275220_f0c92c7931_c.jpg&#34;  alt=&#34;pickup&#34;&gt;
  
    &lt;/a&gt;
  
  
&lt;/div&gt;


 
  
  
  
  
    
  
    
      
    
  
    
      
    
  


&lt;div class=&#34;figure nocaption fig-100&#34; &gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2017/2017-12-22/2017-12-22-aurora.jpg&#34;  alt=&#34;aurora&#34;&gt;
  
  
&lt;/div&gt;

  &lt;div style=&#34;clear:both;&#34;&gt;&lt;/div&gt;
&lt;/p&gt;

&lt;p&gt;之后就是去纽约工作了。到了城里就很少刻意拿出相机来拍照，其实纽约很适合街拍，之后还是应该多拍些。这里找几张贴上来：&lt;/p&gt;

&lt;p&gt;

 
  
  
  
  
    
  
    
      
    
  
    
      
    
  

&lt;div class=&#34;figure nocaption fig-33&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2017/2017-12-22/2017-12-22-child-and-trash.jpg&#34; title=&#34;child in baby carriage&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2017/2017-12-22/2017-12-22-child-and-trash.jpg&#34;  alt=&#34;child in baby carriage&#34;&gt;
  
    &lt;/a&gt;
  
  
&lt;/div&gt;



 
  
  
  
  
    
  
    
      
    
  
    
      
    
  

&lt;div class=&#34;figure nocaption fig-33&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2017/2017-12-22/2017-12-22-child.jpg&#34; title=&#34;child in question&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2017/2017-12-22/2017-12-22-child.jpg&#34;  alt=&#34;child in question&#34;&gt;
  
    &lt;/a&gt;
  
  
&lt;/div&gt;



 
  
  
  
  
    
  
    
      
    
  
    
      
    
  

&lt;div class=&#34;figure nocaption fig-33&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2017/2017-12-22/2017-12-22-horse.jpg&#34; title=&#34;carriage&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2017/2017-12-22/2017-12-22-horse.jpg&#34;  alt=&#34;carriage&#34;&gt;
  
    &lt;/a&gt;
  
  
&lt;/div&gt;



 
  
  
  
  
    
  
    
      
    
  
    
      
    
  

&lt;div class=&#34;figure nocaption fig-100&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2017/2017-12-22/2017-12-22-sunset.jpg&#34; title=&#34;sunset&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2017/2017-12-22/2017-12-22-sunset.jpg&#34;  alt=&#34;sunset&#34;&gt;
  
    &lt;/a&gt;
  
  
&lt;/div&gt;



 
  
  
  
  
    
      
    
  
    
      
    
  
    
  
    
      
    
  

&lt;div class=&#34;figure right nocaption fig-75&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2017/2017-12-22/2017-12-22-sax.png&#34; title=&#34;saxphone&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2017/2017-12-22/2017-12-22-sax.png&#34;  alt=&#34;saxphone&#34;&gt;
  
    &lt;/a&gt;
  
  
&lt;/div&gt;



 
  
  
  
  
    
      
    
  
    
      
    
  
    
  
    
      
    
  

&lt;div class=&#34;figure right nocaption fig-25&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2017/2017-12-22/2017-12-22-skyscraper.png&#34; title=&#34;skyscraper&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2017/2017-12-22/2017-12-22-skyscraper.png&#34;  alt=&#34;skyscraper&#34;&gt;
  
    &lt;/a&gt;
  
  
&lt;/div&gt;



 
  
  
  
  
    
      
    
  
    
      
    
  
    
  
    
      
    
  

&lt;div class=&#34;figure right nocaption fig-25&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2017/2017-12-22/2017-12-22-subway.jpg&#34; title=&#34;subway&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2017/2017-12-22/2017-12-22-subway.jpg&#34;  alt=&#34;subway&#34;&gt;
  
    &lt;/a&gt;
  
  
&lt;/div&gt;


 
  
  
  
  
    
  
    
      
    
  
    
      
    
  
    
      
    
  

 
  
  
  
  
    
      
    
  
    
  
    
      
    
  

&lt;div class=&#34;figure nocaption fig-25&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2017/2017-12-22/2017-12-22-street.jpg&#34; title=&#34;street&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2017/2017-12-22/2017-12-22-street.jpg&#34;  alt=&#34;street&#34;&gt;
  
    &lt;/a&gt;
  
  
&lt;/div&gt;

  &lt;div style=&#34;clear:both;&#34;&gt;&lt;/div&gt;
&lt;/p&gt;

&lt;p&gt;夏天的纽约很美活动很多。到了秋冬外面降温就没那么想出去玩啦。中间经历了心血来潮报名后为期3个月的CFA备考。刚考完就回国换签证。国内吃到了很多好吃的（也不可避免的胖了很多），放几张随拍在下面吧。&lt;/p&gt;

&lt;p&gt;

 
  
  
  
  
    
  
    
      
    
  
    
      
    
  

&lt;div class=&#34;figure nocaption fig-50&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2017/2017-12-22/2017-12-22-nanjing.jpg&#34; title=&#34;玄武湖&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2017/2017-12-22/2017-12-22-nanjing.jpg&#34;  alt=&#34;玄武湖&#34;&gt;
  
    &lt;/a&gt;
  
  
&lt;/div&gt;


 
  
  
  
  
    
  
    
      
    
  
    
      
    
  


&lt;div class=&#34;figure nocaption fig-50&#34; &gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2017/2017-12-22/2017-12-22-hand-in-hand.jpg&#34;  alt=&#34;牵手&#34;&gt;
  
  
&lt;/div&gt;

  &lt;div style=&#34;clear:both;&#34;&gt;&lt;/div&gt;
&lt;/p&gt;

&lt;p&gt;

 
  
  
  
  
    
  
    
      
    
  
    
      
    
  

&lt;div class=&#34;figure nocaption fig-33&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2017/2017-12-22/2017-12-22-guozi-1.jpg&#34; title=&#34;糖油果子&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2017/2017-12-22/2017-12-22-guozi-1.jpg&#34;  alt=&#34;糖油果子&#34;&gt;
  
    &lt;/a&gt;
  
  
&lt;/div&gt;



 
  
  
  
  
    
  
    
      
    
  
    
      
    
  

&lt;div class=&#34;figure nocaption fig-33&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2017/2017-12-22/2017-12-22-guozi-2.jpg&#34; title=&#34;糖油果子&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2017/2017-12-22/2017-12-22-guozi-2.jpg&#34;  alt=&#34;糖油果子&#34;&gt;
  
    &lt;/a&gt;
  
  
&lt;/div&gt;


 
  
  
  
  
    
  
    
      
    
  
    
      
    
  


&lt;div class=&#34;figure nocaption fig-33&#34; &gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2017/2017-12-22/2017-12-22-guozi-3.jpg&#34;  alt=&#34;糖油果子&#34;&gt;
  
  
&lt;/div&gt;

  &lt;div style=&#34;clear:both;&#34;&gt;&lt;/div&gt;
&lt;/p&gt;

&lt;p&gt;之前的个人站点是用&lt;a href=&#34;https://jekyllrb.com/docs/home/&#34;&gt;Jekyll&lt;/a&gt;生成的,最近迁移到&lt;a href=&#34;https://gohugo.io/&#34;&gt;Hugo&lt;/a&gt;还是考虑到其生成速度更快以及几个更合胃口的&lt;a href=&#34;https://themes.gohugo.io/hugo-tranquilpeak-theme/&#34;&gt;模板&lt;/a&gt;。目前新的站点整体比较简洁，集成了文章，摄影，音乐三大板块，并且支持分类标签索引，所以今后的随感、街拍以及新录的曲子都可以很方便的集成在这里。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>宾得KP实测心得</title>
      <link>http://nianze.tk/2017/05/pentax-kp/</link>
      <pubDate>Mon, 08 May 2017 00:00:00 +0000</pubDate>
      
      <guid>http://nianze.tk/2017/05/pentax-kp/</guid>
      <description>&lt;p&gt;复古情怀向中端单反宾得KP开箱体验与实测心得。

&lt;!-- toc --&gt;&lt;/p&gt;

&lt;p&gt;作为同焦段素质最好的镜头(滑稽)，宾得家的Limited镜头有着特立独行的设计理念。最新推出的kp作为其理想的亮骚后背&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:1&#34;&gt;&lt;a href=&#34;#fn:1&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;，总算更加淋漓尽致的体现出了一众饼干头的追求方向：为了追求小巧不惜对镜头光圈进行妥协，强化操作体验并突显整个相机系统慢摄流的玩味属性，让人重拾按下快门的乐趣。单纯就外形而言可能有人会觉得KP的额头太大而更偏爱奥巴em5那样的造型(我也觉得em5造型更讨喜些);但不得不承认，宾得kp搭配众limited头的颜值至少是不低的.&lt;/p&gt;

&lt;h1 id=&#34;前言&#34;&gt;前言&lt;/h1&gt;

&lt;p&gt;其实之前发K70那个帖子的时候已经说得很明白了，现在之所以还没灭宾得的门的原因很简单，就只是比较喜欢手头的那几个limited镜头，希望能时不时拿出来玩玩。既然最近宾得出了这个一定程度上是专门为了跟limited头搭配的机子，我想自己自然是迟早会买来玩玩的。&lt;/p&gt;

&lt;p&gt;理性的来讲，其实刚上市就买这么高溢价的机身是绝对绝对不明智的选择，而且我又并不急着想用到KP比K70多出来的那么一丁点的性能，所以手持K70等KP降价才是最佳购买策略。不过一想到最近办的那张信用卡搞活动可以在美亚上打九折，又想到我玩宾得其实玩的也就是个“情怀”，为“情怀”买单，那还是早买早享受吧——谁叫理光这次拿捏像我这类的目标用户的心理拿捏的这么准确呢？复古银色亮骚机身，既然看对眼了，也就只剩下掏出钞票买买买了。。。所以现在的我也更能够理解为何在日本市场奇葩的K-S1能卖那么火了——“K字母”系列的机型看来就是纯粹面向有个性需求的爱好者准备的机型，很多在主流摄影圈不能理解的设计其实恰恰是为了迎合这部分消费者的需求，正如ks1的亮瞎眼跑马灯以及kp那握感并不好的可更换手柄。&lt;/p&gt;

&lt;h1 id=&#34;开箱&#34;&gt;开箱&lt;/h1&gt;

&lt;p&gt;

 
  
  
  
  
    
  
    
      
    
  

&lt;div class=&#34;figure fig-50&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2017/2017-05-08-pentax-kp/8-2t.jpg&#34; title=&#34;↑说明书、dcu5安装盘，保修卡，宣传单，换手柄的小扳手&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2017/2017-05-08-pentax-kp/8-2t.jpg&#34;  alt=&#34;↑说明书、dcu5安装盘，保修卡，宣传单，换手柄的小扳手&#34;&gt;
  
    &lt;/a&gt;
  
   
    &lt;span class=&#34;caption&#34;&gt;↑说明书、dcu5安装盘，保修卡，宣传单，换手柄的小扳手&lt;/span&gt;
  
&lt;/div&gt;


 
  
  
  
  
    
  
    
      
    
  


&lt;div class=&#34;figure fig-50&#34; &gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2017/2017-05-08-pentax-kp/8-3t.jpg&#34;  alt=&#34;↑取出机身&#34;&gt;
  
   
    &lt;span class=&#34;caption&#34;&gt;↑取出机身&lt;/span&gt;
  
&lt;/div&gt;

  &lt;div style=&#34;clear:both;&#34;&gt;&lt;/div&gt;
&lt;/p&gt;

&lt;h1 id=&#34;外观&#34;&gt;外观&lt;/h1&gt;

&lt;p&gt;

 
  
  
  
  
    
  
    
      
    
  
    
      
    
  

&lt;div class=&#34;figure nocaption fig-50&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2017/2017-05-08-pentax-kp/1-1t.jpg&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2017/2017-05-08-pentax-kp/1-1t.jpg&#34; &gt;
  
    &lt;/a&gt;
  
  
&lt;/div&gt;



 
  
  
  
  
    
  
    
      
    
  
    
      
    
  

&lt;div class=&#34;figure nocaption fig-50&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2017/2017-05-08-pentax-kp/1-2t.jpg&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2017/2017-05-08-pentax-kp/1-2t.jpg&#34; &gt;
  
    &lt;/a&gt;
  
  
&lt;/div&gt;


 
  
  
  
  
    
  
    
      
    
  
    
      
    
  


&lt;div class=&#34;figure nocaption fig-100&#34; &gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2017/2017-05-08-pentax-kp/1-3t.jpg&#34; &gt;
  
  
&lt;/div&gt;

  &lt;div style=&#34;clear:both;&#34;&gt;&lt;/div&gt;
&lt;/p&gt;

&lt;p&gt;↑先来几张全家福。&lt;/p&gt;

&lt;p&gt;

 
  
  
  
  
    
  
    
      
    
  
    
      
    
  

&lt;div class=&#34;figure nocaption fig-25&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2017/2017-05-08-pentax-kp/2-2t.jpg&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2017/2017-05-08-pentax-kp/2-2t.jpg&#34; &gt;
  
    &lt;/a&gt;
  
  
&lt;/div&gt;



 
  
  
  
  
    
  
    
      
    
  
    
      
    
  

&lt;div class=&#34;figure nocaption fig-25&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2017/2017-05-08-pentax-kp/2-3t.jpg&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2017/2017-05-08-pentax-kp/2-3t.jpg&#34; &gt;
  
    &lt;/a&gt;
  
  
&lt;/div&gt;



 
  
  
  
  
    
  
    
      
    
  
    
      
    
  

&lt;div class=&#34;figure nocaption fig-25&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2017/2017-05-08-pentax-kp/2-4t.jpg&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2017/2017-05-08-pentax-kp/2-4t.jpg&#34; &gt;
  
    &lt;/a&gt;
  
  
&lt;/div&gt;



 
  
  
  
  
    
  
    
      
    
  
    
      
    
  

&lt;div class=&#34;figure nocaption fig-25&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2017/2017-05-08-pentax-kp/2-6t.jpg&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2017/2017-05-08-pentax-kp/2-6t.jpg&#34; &gt;
  
    &lt;/a&gt;
  
  
&lt;/div&gt;



 
  
  
  
  
    
  
    
      
    
  
    
      
    
  

&lt;div class=&#34;figure nocaption fig-50&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2017/2017-05-08-pentax-kp/2-7t.jpg&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2017/2017-05-08-pentax-kp/2-7t.jpg&#34; &gt;
  
    &lt;/a&gt;
  
  
&lt;/div&gt;



 
  
  
  
  
    
  
    
      
    
  
    
      
    
  

&lt;div class=&#34;figure nocaption fig-50&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2017/2017-05-08-pentax-kp/2-8t.jpg&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2017/2017-05-08-pentax-kp/2-8t.jpg&#34; &gt;
  
    &lt;/a&gt;
  
  
&lt;/div&gt;
&lt;/p&gt;

&lt;p&gt;↑上面是遵照官网搭配银色 HD DA20-40 Limited 镜头的样子。其实就机身正面投影大小来说，跟GR比也大不了多少，主要是卡口和尖顶部分突出较多。说到顶部，不得不吐槽下其GN值只有6（6.00 m at ISO 100)，感觉没有gps来的实用。目前唯一觉得有用的地方就是无线光引闪，而且拿来引闪自家闪光灯的时候可以用pttl还是比较方便的。&lt;/p&gt;

&lt;p&gt;

 
  
  
  
  
    
  
    
      
    
  
    
      
    
  

&lt;div class=&#34;figure nocaption fig-50&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2017/2017-05-08-pentax-kp/3-1t.jpg&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2017/2017-05-08-pentax-kp/3-1t.jpg&#34; &gt;
  
    &lt;/a&gt;
  
  
&lt;/div&gt;



 
  
  
  
  
    
  
    
      
    
  
    
      
    
  

&lt;div class=&#34;figure nocaption fig-50&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2017/2017-05-08-pentax-kp/3-2t.jpg&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2017/2017-05-08-pentax-kp/3-2t.jpg&#34; &gt;
  
    &lt;/a&gt;
  
  
&lt;/div&gt;



 
  
  
  
  
    
  
    
      
    
  
    
      
    
  

&lt;div class=&#34;figure nocaption fig-50&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2017/2017-05-08-pentax-kp/3-3t.jpg&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2017/2017-05-08-pentax-kp/3-3t.jpg&#34; &gt;
  
    &lt;/a&gt;
  
  
&lt;/div&gt;



 
  
  
  
  
    
  
    
      
    
  
    
      
    
  

&lt;div class=&#34;figure nocaption fig-50&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2017/2017-05-08-pentax-kp/3-4t.jpg&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2017/2017-05-08-pentax-kp/3-4t.jpg&#34; &gt;
  
    &lt;/a&gt;
  
  
&lt;/div&gt;
&lt;/p&gt;

&lt;p&gt;↑搭配 HD DA70 Limited 和 HD DA15 Limited 镜头。&lt;/p&gt;

&lt;p&gt;

 
  
  
  
  
    
  
    
      
    
  
    
      
    
  

&lt;div class=&#34;figure nocaption fig-50&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2017/2017-05-08-pentax-kp/4-1t.jpg&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2017/2017-05-08-pentax-kp/4-1t.jpg&#34; &gt;
  
    &lt;/a&gt;
  
  
&lt;/div&gt;



 
  
  
  
  
    
  
    
      
    
  
    
      
    
  

&lt;div class=&#34;figure nocaption fig-50&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2017/2017-05-08-pentax-kp/4-2t.jpg&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2017/2017-05-08-pentax-kp/4-2t.jpg&#34; &gt;
  
    &lt;/a&gt;
  
  
&lt;/div&gt;



 
  
  
  
  
    
  
    
      
    
  
    
      
    
  

&lt;div class=&#34;figure nocaption fig-50&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2017/2017-05-08-pentax-kp/4-3t.jpg&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2017/2017-05-08-pentax-kp/4-3t.jpg&#34; &gt;
  
    &lt;/a&gt;
  
  
&lt;/div&gt;



 
  
  
  
  
    
  
    
      
    
  
    
      
    
  

&lt;div class=&#34;figure nocaption fig-50&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2017/2017-05-08-pentax-kp/4-4t.jpg&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2017/2017-05-08-pentax-kp/4-4t.jpg&#34; &gt;
  
    &lt;/a&gt;
  
  
&lt;/div&gt;
&lt;/p&gt;

&lt;p&gt;↑搭配三阳10mm f2.8。镜头太大和比有些不协调。&lt;/p&gt;

&lt;h2 id=&#34;机身细节&#34;&gt;机身细节&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;底部&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;

 
  
  
  
  
    
  
    
      
    
  
    
      
    
  

&lt;div class=&#34;figure nocaption fig-50&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2017/2017-05-08-pentax-kp/5-1t.jpg&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2017/2017-05-08-pentax-kp/5-1t.jpg&#34; &gt;
  
    &lt;/a&gt;
  
  
&lt;/div&gt;


 
  
  
  
  
    
  
    
      
    
  
    
      
    
  


&lt;div class=&#34;figure nocaption fig-50&#34; &gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2017/2017-05-08-pentax-kp/5-2t.jpg&#34; &gt;
  
  
&lt;/div&gt;

  &lt;div style=&#34;clear:both;&#34;&gt;&lt;/div&gt;
&lt;/p&gt;

&lt;p&gt;↑电池用的跟K70是一个型号。官方续航是390张。很不够用。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;背面&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;

 
  
  
  
  
    
  
    
      
    
  

&lt;div class=&#34;figure fig-50&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2017/2017-05-08-pentax-kp/5-3t.jpg&#34; title=&#34;↑翻转屏不能反转360来自拍，但是比较方便腰平取景&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2017/2017-05-08-pentax-kp/5-3t.jpg&#34;  alt=&#34;↑翻转屏不能反转360来自拍，但是比较方便腰平取景&#34;&gt;
  
    &lt;/a&gt;
  
   
    &lt;span class=&#34;caption&#34;&gt;↑翻转屏不能反转360来自拍，但是比较方便腰平取景&lt;/span&gt;
  
&lt;/div&gt;


 
  
  
  
  
    
  
    
      
    
  


&lt;div class=&#34;figure fig-50&#34; &gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2017/2017-05-08-pentax-kp/5-4t.jpg&#34;  alt=&#34;↑夸张的iso 819200&#34;&gt;
  
   
    &lt;span class=&#34;caption&#34;&gt;↑夸张的iso 819200&lt;/span&gt;
  
&lt;/div&gt;

  &lt;div style=&#34;clear:both;&#34;&gt;&lt;/div&gt;
&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;侧面&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;

 
  
  
  
  
    
  
    
      
    
  

&lt;div class=&#34;figure fig-50&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2017/2017-05-08-pentax-kp/5-5t.jpg&#34; title=&#34;↑只有一个SD卡槽差评&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2017/2017-05-08-pentax-kp/5-5t.jpg&#34;  alt=&#34;↑只有一个SD卡槽差评&#34;&gt;
  
    &lt;/a&gt;
  
   
    &lt;span class=&#34;caption&#34;&gt;↑只有一个SD卡槽差评&lt;/span&gt;
  
&lt;/div&gt;


 
  
  
  
  
    
  
    
      
    
  


&lt;div class=&#34;figure fig-50&#34; &gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2017/2017-05-08-pentax-kp/5-7t.jpg&#34;  alt=&#34;↑快门线和DC in接口&#34;&gt;
  
   
    &lt;span class=&#34;caption&#34;&gt;↑快门线和DC in接口&lt;/span&gt;
  
&lt;/div&gt;

  &lt;div style=&#34;clear:both;&#34;&gt;&lt;/div&gt;
&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;可更换手柄&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;

 
  
  
  
  
    
  
    
      
    
  
    
      
    
  

&lt;div class=&#34;figure nocaption fig-50&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2017/2017-05-08-pentax-kp/6-1t.jpg&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2017/2017-05-08-pentax-kp/6-1t.jpg&#34; &gt;
  
    &lt;/a&gt;
  
  
&lt;/div&gt;



 
  
  
  
  
    
  
    
      
    
  
    
      
    
  

&lt;div class=&#34;figure nocaption fig-50&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2017/2017-05-08-pentax-kp/6-2t.jpg&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2017/2017-05-08-pentax-kp/6-2t.jpg&#34; &gt;
  
    &lt;/a&gt;
  
  
&lt;/div&gt;



 
  
  
  
  
    
  
    
      
    
  
    
      
    
  

&lt;div class=&#34;figure nocaption fig-33&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2017/2017-05-08-pentax-kp/6-3t.jpg&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2017/2017-05-08-pentax-kp/6-3t.jpg&#34; &gt;
  
    &lt;/a&gt;
  
  
&lt;/div&gt;



 
  
  
  
  
    
  
    
      
    
  
    
      
    
  

&lt;div class=&#34;figure nocaption fig-33&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2017/2017-05-08-pentax-kp/6-4t.jpg&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2017/2017-05-08-pentax-kp/6-4t.jpg&#34; &gt;
  
    &lt;/a&gt;
  
  
&lt;/div&gt;


 
  
  
  
  
    
  
    
      
    
  
    
      
    
  


&lt;div class=&#34;figure nocaption fig-33&#34; &gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2017/2017-05-08-pentax-kp/6-5t.jpg&#34; &gt;
  
  
&lt;/div&gt;

  &lt;div style=&#34;clear:both;&#34;&gt;&lt;/div&gt;
&lt;/p&gt;

&lt;p&gt;机身上默认安装的是小号手柄，握感和GR类似，不过手持起来比GR沉很多；中号手柄握感我觉得跟小号没啥区别；大号手柄则因为前方有比较明显的着力点，装上之后手感更像传统单反，但是依然没有k5或者K70那种手柄来的舒服。这种设计明显是为了颜值而牺牲了握感。但可能是GR握习惯了，我一般用小号手柄。&lt;/p&gt;

&lt;h1 id=&#34;使用感受&#34;&gt;使用感受&lt;/h1&gt;

&lt;p&gt;用下来发觉最大的问题在可靠性上，首当其冲的便是脆弱的电池——前段时间去了阿拉斯加，在室外零下30°环境下相机很容易被冻没电，白天大概能坚持几十分钟，晚上可能就十几分钟，长时间曝光的话拍不了几张就自动关机。我只能不停地轮流更换手头的3块电池——每次揣两块在大衣的内兜里，等温度上来恢复电力之后再接着用（来回换电池实在太麻烦了，尤其是自拍的时候突然没电了特别火大）。本来还想测试下相机里面的星轨和延时摄影功能的，但是极地寒冷室外条件下，放十几分钟没拍几张就自动断电，根本行不通。所以最后也没能拍成星轨和延时摄影。需要提高的另一个方面就是手机app——有时候会莫名其妙的无法同步画面，且手机无法遥控释放快门，逼得最后我只能用延时自拍模式连拍10张来搞定旅行合影照。&lt;/p&gt;




&lt;div class=&#34;figure right fig-100&#34; &gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2017/2017-05-08-pentax-kp/8-1t.jpg&#34;  alt=&#34;↑Joby便携三脚架搭配宾得 kp&#34;&gt;
  
   
    &lt;span class=&#34;caption&#34;&gt;↑Joby便携三脚架搭配宾得 kp&lt;/span&gt;
  
&lt;/div&gt;


&lt;p&gt;可以看出来，在恶劣环境下可靠性主要还是被电池拖累太多。风光照当然可以拍，画质出众高感在aps-c里也是位列前茅，只是没了GPS少了追星功能还是挺可惜的。极地环境下靠三防机身倒是可以顶住阿拉斯加白天雪地里雪洒机身上的不利情况，这点还是不错的。如果就像&lt;a href=&#34;https://youtu.be/Rnu4JsmmOW8&#34;&gt;宣传片&lt;/a&gt;里展示的那样，拿kp配个20-40，在旅游时去拍拍扫街照，这机子还是很能胜任的。&lt;/p&gt;

&lt;h1 id=&#34;样片&#34;&gt;样片&lt;/h1&gt;

&lt;p&gt;

 
  
  
  
  
    
  
    
      
    
  
    
      
    
  

&lt;div class=&#34;figure nocaption fig-50&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2017/2017-05-08-pentax-kp/7-0.jpg&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2017/2017-05-08-pentax-kp/7-0t.jpg&#34; &gt;
  
    &lt;/a&gt;
  
  
&lt;/div&gt;



 
  
  
  
  
    
  
    
      
    
  
    
      
    
  

&lt;div class=&#34;figure nocaption fig-50&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2017/2017-05-08-pentax-kp/7-1.jpg&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2017/2017-05-08-pentax-kp/7-1t.jpg&#34; &gt;
  
    &lt;/a&gt;
  
  
&lt;/div&gt;



 
  
  
  
  
    
  
    
      
    
  
    
      
    
  

&lt;div class=&#34;figure nocaption fig-50&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2017/2017-05-08-pentax-kp/7-2.jpg&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2017/2017-05-08-pentax-kp/7-2t.jpg&#34; &gt;
  
    &lt;/a&gt;
  
  
&lt;/div&gt;



 
  
  
  
  
    
  
    
      
    
  
    
      
    
  

&lt;div class=&#34;figure nocaption fig-50&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2017/2017-05-08-pentax-kp/7-6.jpg&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2017/2017-05-08-pentax-kp/7-6t.jpg&#34; &gt;
  
    &lt;/a&gt;
  
  
&lt;/div&gt;



 
  
  
  
  
    
  
    
      
    
  
    
      
    
  

&lt;div class=&#34;figure nocaption fig-75&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2017/2017-05-08-pentax-kp/7-4.jpg&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2017/2017-05-08-pentax-kp/7-4t.jpg&#34; &gt;
  
    &lt;/a&gt;
  
  
&lt;/div&gt;



 
  
  
  
  
    
  
    
      
    
  
    
      
    
  

&lt;div class=&#34;figure nocaption fig-25&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2017/2017-05-08-pentax-kp/7-3.jpg&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2017/2017-05-08-pentax-kp/7-3t.jpg&#34; &gt;
  
    &lt;/a&gt;
  
  
&lt;/div&gt;



 
  
  
  
  
    
  
    
      
    
  
    
      
    
  

&lt;div class=&#34;figure nocaption fig-25&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2017/2017-05-08-pentax-kp/7-5.jpg&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2017/2017-05-08-pentax-kp/7-5t.jpg&#34; &gt;
  
    &lt;/a&gt;
  
  
&lt;/div&gt;


 
  
  
  
  
    
  
    
      
    
  
    
      
    
  


&lt;div class=&#34;figure nocaption fig-25&#34; &gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2017/2017-05-08-pentax-kp/7-7t.jpg&#34; &gt;
  
  
&lt;/div&gt;

  &lt;div style=&#34;clear:both;&#34;&gt;&lt;/div&gt;
&lt;/p&gt;

&lt;h1 id=&#34;总结&#34;&gt;总结&lt;/h1&gt;

&lt;p&gt;和自家APS-C机身比，KP有着亮骚的优点（我从K70换KP的主要原因）以及相对以往机身可感知但仍不堪重用的对焦改进，但续航是硬伤。相比佳能尼康同价位机器，优点有&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;对标同级别机身(主要是APS-C机身)时强悍的高感（参见&lt;a href=&#34;https://www.dpreview.com/reviews/pentax-kp-review&#34;&gt;dpreview&lt;/a&gt;的评价，尤其是用raw拍摄时）&lt;/li&gt;
&lt;li&gt;特立独行的limited镜头带来的可玩性和同等光圈下不俗的素质&lt;/li&gt;
&lt;li&gt;五轴防抖和三防(以及防抖衍生出来的超解和追星功能)&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;缺点则是&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;一如既往的羸弱追焦能力&lt;/li&gt;
&lt;li&gt;跟不上时代的视频能力&lt;/li&gt;
&lt;li&gt;缺乏大光圈镜头（看看人家富士）&lt;/li&gt;
&lt;li&gt;发行价较贵，性价比较低&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;此外就是外观和可更换手柄见仁见智，有人喜欢有人讨厌。但总的来说，这是有着很不错的画质，足够性能的相机，配上几枚limited镜头，够把玩很久，是那种适合悠闲的慢摄流在心情好的空暇时品玩的东西。如果作为摄影爱好者想在APS-C相机中找一台亮骚好玩的，那在富士的X系列外，宾得这款KP也可算是值得考虑的对象吧。&lt;/p&gt;

&lt;h2 id=&#34;参考&#34;&gt;参考&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://www.dpreview.com/reviews/pentax-kp-review&#34;&gt;dpreview&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;http://pentaxfans.net/thread-159858-1-1.html&#34;&gt;PNETAX KP-開箱實測&amp;amp;心得&amp;amp;實拍&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;https://www.mobile01.com/newsdetail/21324/pentax-kp-iso-819200&#34;&gt;感光度直衝80萬！五軸防手震加持 Pentax KP&lt;/a&gt;&lt;/p&gt;
&lt;div class=&#34;footnotes&#34;&gt;

&lt;hr /&gt;

&lt;ol&gt;
&lt;li id=&#34;fn:1&#34;&gt;严谨来说，数码后背(Digital camera back)一般是针对中大画幅相机系统推出的代替胶片的成像单元，功能比较单一，就是为了成像，所以是不带快门、反光板、五棱镜这些结构的。本文标题和第一段调侃中用到了“后背”一词，指的是“APS-C画幅数码相机机身”，但行文时为了阐述这个机身相对于limited镜头群是处在相机系统后端的位置，所以顺口用了“后背”一词来强调镜头与机身的前后关系，以凸显kp在一众后端机身中的特殊定位。下面评论区有人提到了所以为了避免误导新人以及混淆是非之嫌特在此注解声明下。
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:1&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;</description>
    </item>
    
    <item>
      <title>宾得K70开箱</title>
      <link>http://nianze.tk/2017/01/pentax-k70/</link>
      <pubDate>Tue, 17 Jan 2017 00:00:00 +0000</pubDate>
      
      <guid>http://nianze.tk/2017/01/pentax-k70/</guid>
      <description>&lt;p&gt;高性价比中低端单反宾得K70开箱及像素位移模式简单测试。

&lt;!-- toc --&gt;&lt;/p&gt;

&lt;h1 id=&#34;唠叨&#34;&gt;唠叨&lt;/h1&gt;

&lt;p&gt;手握宾得，过去几年经常会思考一件很严肃的事情：是否要灭门？曾多次因为对全画幅的向往、对大光圈镜头的渴望、对快速对焦的执念、对轻便微单系统的认同而准备灭门。考虑到轻便机身和全副这两点，没得选，就准备皈依索尼大法，守护姨夫微笑了。机型和镜头都选好了，就等着A7 iii上市，配上Zeiss FE 55和Loxia 21，后面的镜头慢慢补齐。&lt;/p&gt;

&lt;p&gt;然而，作为抚摸党，手握HD DA15和HD DA70，对于这两枚limited饼干镜头，总还是有些不舍。宾得的相机和镜头进入数码时代之后，在参数上从来不是顶级的。但是这家公司造出来的镜头和相机，总能让我因为其优秀做工和独特的设计而产生认同感。这有些像任天堂倡导的“满屏游（ma）戏（sai）性（ke）”之于索尼微软的3A大作、马自达业已停产的转子发动机之于市面常见的往复式发动机。有很多缺点，但其固执坚守的优点却让人愿意忍受缺点为其买单。（所以不是一家人不进一家门，宾得跟理光GR的性格还是很相投的。）我觉得相似气质的还有Fuji，同样是深耕APS-C画幅的厂家，Fuji感觉要更文艺更“情怀”些。复古机身一度也让我有买个X100t或者X-pro2的冲动，或者冲着摄影摄像的平衡性，入个X-t2也不错。再加上Fuji的镜头普遍有着大光圈，定焦的素质也都不错，其实在选镜头这方面要比宾得少很多纠结（我主要考虑定焦。比如宾得在35mm焦段就能让人纠结很久，能看的也就一个小薇-DA 35mm F2.8 Macro Limited，不过也就能拿来拍拍静物）我觉得网上很多人吐槽宾得镜头群，还是有一定道理的——作为基本沦为“品玩”级别的品牌，宾得的价值只能是建立在摄影爱好者基础上的。以“干活”的眼光看宾得，得出的结论一定是“全身上下都是缺点”，被喷也就在所难免。但是作为摄影爱好者，购买器材其实也是在为自己品玩器材背后的“情怀”买单。要是每一次摁下快门都能让自己产生快感，每次看着机身和镜头的搭配相得益彰协调美满就能产生审美上的愉悦，然后每次回家还能留下照片，然后这照片的画质还很不错，那么这笔钱也就值了。而这也许也正是limited镜头的价值所在吧——相比起单纯的镜头，其背后的理念其实是少讲一分光学参数，以换回多出来的一分精致小巧的类似工艺品的那么一种味道。归根到底，定位很重要。拿一把汤匙去铲地又嫌汤匙容量小，这种事情还是少做为好，以免自讨没趣。&lt;/p&gt;

&lt;p&gt;考虑到自身的需求对于全画幅并没有那么强烈，也出于对手中GR ii的喜爱，我对同在理光门下的宾得的情怀还是蛮认同的。加上自己第一台单反就是宾得K-5，在因为偶然而多看了一眼TCSTV的那期宾得K-70的评测后，情怀作怪，心中长草，反正又不贵，于是就下单了。宾得这套系统还是先别急着灭门，留着当个怀念吧。&lt;/p&gt;

&lt;h1 id=&#34;参数&#34;&gt;参数&lt;/h1&gt;

&lt;p&gt;以下是K-70的参数和基本介绍：


 
  
  
  
  
    
  
    
      
    
  
    
      
    
  

&lt;div class=&#34;figure nocaption fig-33&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2017/2017-01-17-pentax-k70/1-1.jpg&#34; title=&#34;参数&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2017/2017-01-17-pentax-k70/1-1.jpg&#34;  alt=&#34;参数&#34;&gt;
  
    &lt;/a&gt;
  
  
&lt;/div&gt;



 
  
  
  
  
    
  
    
      
    
  
    
      
    
  

&lt;div class=&#34;figure nocaption fig-33&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2017/2017-01-17-pentax-k70/1-2.jpg&#34; title=&#34;介绍&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2017/2017-01-17-pentax-k70/1-2.jpg&#34;  alt=&#34;介绍&#34;&gt;
  
    &lt;/a&gt;
  
  
&lt;/div&gt;


 
  
  
  
  
    
  
    
      
    
  


&lt;div class=&#34;figure fig-33&#34; &gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2017/2017-01-17-pentax-k70/1-3.jpg&#34;  alt=&#34;↑宾得特色-三防功能&#34;&gt;
  
   
    &lt;span class=&#34;caption&#34;&gt;↑宾得特色-三防功能&lt;/span&gt;
  
&lt;/div&gt;

  &lt;div style=&#34;clear:both;&#34;&gt;&lt;/div&gt;
&lt;/p&gt;

&lt;p&gt;和同级单反相比，K70亮点大概有：高感、约100% 0.95倍大视野取景五菱镜取景器、无低通滤光镜、三防功能、1/6000秒快门、三轴防抖系统、-3EV自动对焦&lt;/p&gt;

&lt;h1 id=&#34;开箱&#34;&gt;开箱&lt;/h1&gt;



 
  
  
  
  
    
  
    
      
    
  

&lt;div class=&#34;figure fig-100&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2017/2017-01-17-pentax-k70/2-1.jpg&#34; title=&#34;↑以下开箱图片均出自理光GR ii&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2017/2017-01-17-pentax-k70/2-1.jpg&#34;  alt=&#34;↑以下开箱图片均出自理光GR ii&#34;&gt;
  
    &lt;/a&gt;
  
   
    &lt;span class=&#34;caption&#34;&gt;↑以下开箱图片均出自理光GR ii&lt;/span&gt;
  
&lt;/div&gt;


&lt;p&gt;

 
  
  
  
  
    
  
    
      
    
  

&lt;div class=&#34;figure fig-50&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2017/2017-01-17-pentax-k70/2-2.jpg&#34; title=&#34;↑理光家一致设计的灰底盒子，跟DA 15的盒子做个对比&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2017/2017-01-17-pentax-k70/2-2.jpg&#34;  alt=&#34;↑理光家一致设计的灰底盒子，跟DA 15的盒子做个对比&#34;&gt;
  
    &lt;/a&gt;
  
   
    &lt;span class=&#34;caption&#34;&gt;↑理光家一致设计的灰底盒子，跟DA 15的盒子做个对比&lt;/span&gt;
  
&lt;/div&gt;


 
  
  
  
  
    
  
    
      
    
  


&lt;div class=&#34;figure fig-50&#34; &gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2017/2017-01-17-pentax-k70/2-3.jpg&#34;  alt=&#34;↑开箱的感谢辞&#34;&gt;
  
   
    &lt;span class=&#34;caption&#34;&gt;↑开箱的感谢辞&lt;/span&gt;
  
&lt;/div&gt;

  &lt;div style=&#34;clear:both;&#34;&gt;&lt;/div&gt;



 
  
  
  
  
    
  
    
      
    
  

&lt;div class=&#34;figure fig-50&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2017/2017-01-17-pentax-k70/2-4.jpg&#34; title=&#34;↑完整的说明书&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2017/2017-01-17-pentax-k70/2-4.jpg&#34;  alt=&#34;↑完整的说明书&#34;&gt;
  
    &lt;/a&gt;
  
   
    &lt;span class=&#34;caption&#34;&gt;↑完整的说明书&lt;/span&gt;
  
&lt;/div&gt;


 
  
  
  
  
    
  
    
      
    
  


&lt;div class=&#34;figure fig-50&#34; &gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2017/2017-01-17-pentax-k70/2-5.jpg&#34;  alt=&#34;↑除了机身，配件还有电源线、座充、电池和肩带&#34;&gt;
  
   
    &lt;span class=&#34;caption&#34;&gt;↑除了机身，配件还有电源线、座充、电池和肩带&lt;/span&gt;
  
&lt;/div&gt;

  &lt;div style=&#34;clear:both;&#34;&gt;&lt;/div&gt;
&lt;/p&gt;

&lt;p&gt;配套的修图软件Digital Camera Utility 5 (DCU5) 只能随机附送的CD安装，官网只提供下载升级包，要找光驱安装这点略坑爹。更坑爹的是目前Adobe暂不支持像素偏移的RAW，只能使用这个巨难用的DCU5来解。&lt;/p&gt;

&lt;p&gt;

 
  
  
  
  
    
  
    
      
    
  

&lt;div class=&#34;figure fig-50&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2017/2017-01-17-pentax-k70/3-1.jpg&#34; title=&#34;↑快门灯环在拍照模式是绿色的&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2017/2017-01-17-pentax-k70/3-1.jpg&#34;  alt=&#34;↑快门灯环在拍照模式是绿色的&#34;&gt;
  
    &lt;/a&gt;
  
   
    &lt;span class=&#34;caption&#34;&gt;↑快门灯环在拍照模式是绿色的&lt;/span&gt;
  
&lt;/div&gt;



 
  
  
  
  
    
  
    
      
    
  

&lt;div class=&#34;figure fig-50&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2017/2017-01-17-pentax-k70/3-2.jpg&#34; title=&#34;↑视频模式时是红色的&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2017/2017-01-17-pentax-k70/3-2.jpg&#34;  alt=&#34;↑视频模式时是红色的&#34;&gt;
  
    &lt;/a&gt;
  
   
    &lt;span class=&#34;caption&#34;&gt;↑视频模式时是红色的&lt;/span&gt;
  
&lt;/div&gt;
&lt;/p&gt;

&lt;p&gt;沿袭自K-s2的快门灯环。跟理光自家的GR ii一脉相承。&lt;/p&gt;

&lt;p&gt;

 
  
  
  
  
    
  
    
      
    
  

&lt;div class=&#34;figure fig-50&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2017/2017-01-17-pentax-k70/4-4.jpg&#34; title=&#34;↑左侧麦克风接口，Fx1键可自定义功能&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2017/2017-01-17-pentax-k70/4-4.jpg&#34;  alt=&#34;↑左侧麦克风接口，Fx1键可自定义功能&#34;&gt;
  
    &lt;/a&gt;
  
   
    &lt;span class=&#34;caption&#34;&gt;↑左侧麦克风接口，Fx1键可自定义功能&lt;/span&gt;
  
&lt;/div&gt;


 
  
  
  
  
    
  
    
      
    
  


&lt;div class=&#34;figure fig-50&#34; &gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2017/2017-01-17-pentax-k70/4-2.jpg&#34;  alt=&#34;↑握柄非常饱满&#34;&gt;
  
   
    &lt;span class=&#34;caption&#34;&gt;↑握柄非常饱满&lt;/span&gt;
  
&lt;/div&gt;

  &lt;div style=&#34;clear:both;&#34;&gt;&lt;/div&gt;
&lt;/p&gt;

&lt;p&gt;TCSTV里面Chris吐槽说手小的话会握不住，我手大感觉还好。但相比起来原来K-5握感确实会更偏紧致。&lt;/p&gt;

&lt;p&gt;

 
  
  
  
  
    
  
    
      
    
  

&lt;div class=&#34;figure fig-33&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2017/2017-01-17-pentax-k70/4-3.jpg&#34; title=&#34;↑翻转屏要是加入触控功能就更好了&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2017/2017-01-17-pentax-k70/4-3.jpg&#34;  alt=&#34;↑翻转屏要是加入触控功能就更好了&#34;&gt;
  
    &lt;/a&gt;
  
   
    &lt;span class=&#34;caption&#34;&gt;↑翻转屏要是加入触控功能就更好了&lt;/span&gt;
  
&lt;/div&gt;



 
  
  
  
  
    
  
    
      
    
  

&lt;div class=&#34;figure fig-33&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2017/2017-01-17-pentax-k70/4-1.jpg&#34; title=&#34;↑正面&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2017/2017-01-17-pentax-k70/4-1.jpg&#34;  alt=&#34;↑正面&#34;&gt;
  
    &lt;/a&gt;
  
   
    &lt;span class=&#34;caption&#34;&gt;↑正面&lt;/span&gt;
  
&lt;/div&gt;


 
  
  
  
  
    
  
    
      
    
  


&lt;div class=&#34;figure fig-33&#34; &gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2017/2017-01-17-pentax-k70/4-5.jpg&#34;  alt=&#34;↑这个档位的机型只支持一个SD卡&#34;&gt;
  
   
    &lt;span class=&#34;caption&#34;&gt;↑这个档位的机型只支持一个SD卡&lt;/span&gt;
  
&lt;/div&gt;

  &lt;div style=&#34;clear:both;&#34;&gt;&lt;/div&gt;
&lt;/p&gt;

&lt;p&gt;

 
  
  
  
  
    
  
    
      
    
  

&lt;div class=&#34;figure fig-50&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2017/2017-01-17-pentax-k70/4-6.jpg&#34; title=&#34;↑机身材质塑料,但黑版看起来还蛮有金属感的&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2017/2017-01-17-pentax-k70/4-6.jpg&#34;  alt=&#34;↑机身材质塑料,但黑版看起来还蛮有金属感的&#34;&gt;
  
    &lt;/a&gt;
  
   
    &lt;span class=&#34;caption&#34;&gt;↑机身材质塑料,但黑版看起来还蛮有金属感的&lt;/span&gt;
  
&lt;/div&gt;


 
  
  
  
  
    
  
    
      
    
  


&lt;div class=&#34;figure fig-50&#34; &gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2017/2017-01-17-pentax-k70/4-7.jpg&#34;  alt=&#34;↑带前后双波轮和宾得绿键,Fx2键可自定义,三个用户模式&#34;&gt;
  
   
    &lt;span class=&#34;caption&#34;&gt;↑带前后双波轮和宾得绿键,Fx2键可自定义,三个用户模式&lt;/span&gt;
  
&lt;/div&gt;

  &lt;div style=&#34;clear:both;&#34;&gt;&lt;/div&gt;



 
  
  
  
  
    
  
    
      
    
  

&lt;div class=&#34;figure fig-25&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2017/2017-01-17-pentax-k70/4-8.jpg&#34; title=&#34;↑按键面积大而突出&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2017/2017-01-17-pentax-k70/4-8.jpg&#34;  alt=&#34;↑按键面积大而突出&#34;&gt;
  
    &lt;/a&gt;
  
   
    &lt;span class=&#34;caption&#34;&gt;↑按键面积大而突出&lt;/span&gt;
  
&lt;/div&gt;


 
  
  
  
  
    
  
    
      
    
  


&lt;div class=&#34;figure fig-75&#34; &gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2017/2017-01-17-pentax-k70/4-9.jpg&#34;  alt=&#34;↑底部防滑条,产地菲律宾&#34;&gt;
  
   
    &lt;span class=&#34;caption&#34;&gt;↑底部防滑条,产地菲律宾&lt;/span&gt;
  
&lt;/div&gt;

  &lt;div style=&#34;clear:both;&#34;&gt;&lt;/div&gt;
&lt;/p&gt;

&lt;p&gt;


&lt;div class=&#34;figure right nocaption fig-50&#34; &gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2017/2017-01-17-pentax-k70/5-1.jpg&#34; &gt;
  
  
&lt;/div&gt;




&lt;div class=&#34;figure right nocaption fig-50&#34; &gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2017/2017-01-17-pentax-k70/5-2.jpg&#34; &gt;
  
  
&lt;/div&gt;




&lt;div class=&#34;figure right fig-50&#34; &gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2017/2017-01-17-pentax-k70/5-3.jpg&#34;  alt=&#34;↑搭配 Da 70 limited 饼干头&#34;&gt;
  
   
    &lt;span class=&#34;caption&#34;&gt;↑搭配 Da 70 limited 饼干头&lt;/span&gt;
  
&lt;/div&gt;
&lt;/p&gt;

&lt;p&gt;


&lt;div class=&#34;figure left nocaption fig-50&#34; &gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2017/2017-01-17-pentax-k70/6-2.jpg&#34; &gt;
  
  
&lt;/div&gt;




&lt;div class=&#34;figure left nocaption fig-50&#34; &gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2017/2017-01-17-pentax-k70/6-3.jpg&#34; &gt;
  
  
&lt;/div&gt;


 
  
  
  
  
    
  
    
      
    
  


&lt;div class=&#34;figure fig-50&#34; &gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2017/2017-01-17-pentax-k70/6-1.jpg&#34;  alt=&#34;↑搭配 Da 15 limited 饼干头&#34;&gt;
  
   
    &lt;span class=&#34;caption&#34;&gt;↑搭配 Da 15 limited 饼干头&lt;/span&gt;
  
&lt;/div&gt;

  &lt;div style=&#34;clear:both;&#34;&gt;&lt;/div&gt;
&lt;/p&gt;

&lt;p&gt;


&lt;div class=&#34;figure left fig-50&#34; &gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2017/2017-01-17-pentax-k70/7-3.png&#34;  alt=&#34;↑WiFi传输与遥控,app不稳定经常断&#34;&gt;
  
   
    &lt;span class=&#34;caption&#34;&gt;↑WiFi传输与遥控,app不稳定经常断&lt;/span&gt;
  
&lt;/div&gt;




&lt;div class=&#34;figure left fig-50&#34; &gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2017/2017-01-17-pentax-k70/7-2.jpg&#34;  alt=&#34;↑Live View模式增加了混合式对焦系统&#34;&gt;
  
   
    &lt;span class=&#34;caption&#34;&gt;↑Live View模式增加了混合式对焦系统&lt;/span&gt;
  
&lt;/div&gt;


 
  
  
  
  
    
  
    
      
    
  


&lt;div class=&#34;figure fig-50&#34; &gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2017/2017-01-17-pentax-k70/7-1.jpg&#34;  alt=&#34;↑最新的KAF4卡口，支持电磁光圈镜头。但目前好像仅有新发布的55-300一枚镜头是电磁光圈的。宾得高速镜头群的确实依然是其最大软肋&#34;&gt;
  
   
    &lt;span class=&#34;caption&#34;&gt;↑最新的KAF4卡口，支持电磁光圈镜头。但目前好像仅有新发布的55-300一枚镜头是电磁光圈的。宾得高速镜头群的确实依然是其最大软肋&lt;/span&gt;
  
&lt;/div&gt;

  &lt;div style=&#34;clear:both;&#34;&gt;&lt;/div&gt;
&lt;/p&gt;

&lt;h1 id=&#34;像素位移测试&#34;&gt;像素位移测试&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;场景一：室外&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;

 
  
  
  
  
    
  
    
      
    
  

&lt;div class=&#34;figure fig-100&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2017/2017-01-17-pentax-k70/8-1.jpg&#34; title=&#34;↑全景图&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2017/2017-01-17-pentax-k70/8-1.jpg&#34;  alt=&#34;↑全景图&#34;&gt;
  
    &lt;/a&gt;
  
   
    &lt;span class=&#34;caption&#34;&gt;↑全景图&lt;/span&gt;
  
&lt;/div&gt;



 
  
  
  
  
    
  
    
      
    
  

&lt;div class=&#34;figure fig-50&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2017/2017-01-17-pentax-k70/8-2.png&#34; title=&#34;↑像素位移关闭&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2017/2017-01-17-pentax-k70/8-2.png&#34;  alt=&#34;↑像素位移关闭&#34;&gt;
  
    &lt;/a&gt;
  
   
    &lt;span class=&#34;caption&#34;&gt;↑像素位移关闭&lt;/span&gt;
  
&lt;/div&gt;



 
  
  
  
  
    
  
    
      
    
  

&lt;div class=&#34;figure fig-50&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2017/2017-01-17-pentax-k70/8-3.png&#34; title=&#34;↑像素位移开启&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2017/2017-01-17-pentax-k70/8-3.png&#34;  alt=&#34;↑像素位移开启&#34;&gt;
  
    &lt;/a&gt;
  
   
    &lt;span class=&#34;caption&#34;&gt;↑像素位移开启&lt;/span&gt;
  
&lt;/div&gt;
&lt;/p&gt;

&lt;p&gt;可以看到树干和背后房屋的细节在开了像素位移后明显更多。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;场景二：室内&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;

 
  
  
  
  
    
  
    
      
    
  

&lt;div class=&#34;figure fig-100&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2017/2017-01-17-pentax-k70/9-1-1.jpg&#34; title=&#34;↑全景图&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2017/2017-01-17-pentax-k70/9-1-1.jpg&#34;  alt=&#34;↑全景图&#34;&gt;
  
    &lt;/a&gt;
  
   
    &lt;span class=&#34;caption&#34;&gt;↑全景图&lt;/span&gt;
  
&lt;/div&gt;



 
  
  
  
  
    
  
    
      
    
  

&lt;div class=&#34;figure fig-50&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2017/2017-01-17-pentax-k70/9-1-2.png&#34; title=&#34;↑像素位移关闭&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2017/2017-01-17-pentax-k70/9-1-2.png&#34;  alt=&#34;↑像素位移关闭&#34;&gt;
  
    &lt;/a&gt;
  
   
    &lt;span class=&#34;caption&#34;&gt;↑像素位移关闭&lt;/span&gt;
  
&lt;/div&gt;



 
  
  
  
  
    
  
    
      
    
  

&lt;div class=&#34;figure fig-50&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2017/2017-01-17-pentax-k70/9-1-3.png&#34; title=&#34;↑像素位移开启&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2017/2017-01-17-pentax-k70/9-1-3.png&#34;  alt=&#34;↑像素位移开启&#34;&gt;
  
    &lt;/a&gt;
  
   
    &lt;span class=&#34;caption&#34;&gt;↑像素位移开启&lt;/span&gt;
  
&lt;/div&gt;
&lt;/p&gt;

&lt;p&gt;对于这种近景貌似开像素位移提升也不算很大。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;场景三：开启像素位移后ISO测试&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;

 
  
  
  
  
    
  
    
      
    
  

&lt;div class=&#34;figure fig-25&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2017/2017-01-17-pentax-k70/9-3-1.jpg&#34; title=&#34;↑ISO100&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2017/2017-01-17-pentax-k70/9-3-1t.jpg&#34;  alt=&#34;↑ISO100&#34;&gt;
  
    &lt;/a&gt;
  
   
    &lt;span class=&#34;caption&#34;&gt;↑ISO100&lt;/span&gt;
  
&lt;/div&gt;



 
  
  
  
  
    
  
    
      
    
  

&lt;div class=&#34;figure fig-25&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2017/2017-01-17-pentax-k70/9-3-2.jpg&#34; title=&#34;↑ISO200&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2017/2017-01-17-pentax-k70/9-3-2t.jpg&#34;  alt=&#34;↑ISO200&#34;&gt;
  
    &lt;/a&gt;
  
   
    &lt;span class=&#34;caption&#34;&gt;↑ISO200&lt;/span&gt;
  
&lt;/div&gt;



 
  
  
  
  
    
  
    
      
    
  

&lt;div class=&#34;figure fig-25&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2017/2017-01-17-pentax-k70/9-3-3.jpg&#34; title=&#34;↑ISO400&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2017/2017-01-17-pentax-k70/9-3-3t.jpg&#34;  alt=&#34;↑ISO400&#34;&gt;
  
    &lt;/a&gt;
  
   
    &lt;span class=&#34;caption&#34;&gt;↑ISO400&lt;/span&gt;
  
&lt;/div&gt;



 
  
  
  
  
    
  
    
      
    
  

&lt;div class=&#34;figure fig-25&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2017/2017-01-17-pentax-k70/9-3-4.jpg&#34; title=&#34;↑ISO800&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2017/2017-01-17-pentax-k70/9-3-4t.jpg&#34;  alt=&#34;↑ISO800&#34;&gt;
  
    &lt;/a&gt;
  
   
    &lt;span class=&#34;caption&#34;&gt;↑ISO800&lt;/span&gt;
  
&lt;/div&gt;



 
  
  
  
  
    
  
    
      
    
  

&lt;div class=&#34;figure fig-25&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2017/2017-01-17-pentax-k70/9-3-5.jpg&#34; title=&#34;↑ISO1600&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2017/2017-01-17-pentax-k70/9-3-5t.jpg&#34;  alt=&#34;↑ISO1600&#34;&gt;
  
    &lt;/a&gt;
  
   
    &lt;span class=&#34;caption&#34;&gt;↑ISO1600&lt;/span&gt;
  
&lt;/div&gt;



 
  
  
  
  
    
  
    
      
    
  

&lt;div class=&#34;figure fig-25&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2017/2017-01-17-pentax-k70/9-3-6.jpg&#34; title=&#34;↑ISO3200&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2017/2017-01-17-pentax-k70/9-3-6t.jpg&#34;  alt=&#34;↑ISO3200&#34;&gt;
  
    &lt;/a&gt;
  
   
    &lt;span class=&#34;caption&#34;&gt;↑ISO3200&lt;/span&gt;
  
&lt;/div&gt;



 
  
  
  
  
    
  
    
      
    
  

&lt;div class=&#34;figure fig-25&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2017/2017-01-17-pentax-k70/9-3-7.jpg&#34; title=&#34;↑ISO6400&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2017/2017-01-17-pentax-k70/9-3-7t.jpg&#34;  alt=&#34;↑ISO6400&#34;&gt;
  
    &lt;/a&gt;
  
   
    &lt;span class=&#34;caption&#34;&gt;↑ISO6400&lt;/span&gt;
  
&lt;/div&gt;



 
  
  
  
  
    
  
    
      
    
  

&lt;div class=&#34;figure fig-25&#34; &gt;
  
    &lt;a class=&#34;fancybox&#34; href=&#34;http://nianze.tk/images/2017/2017-01-17-pentax-k70/9-3-8.jpg&#34; title=&#34;↑ISO12800&#34; data-fancybox-group=&#34;&#34;&gt;
  
    &lt;img class=&#34;fig-img&#34; src=&#34;http://nianze.tk/images/2017/2017-01-17-pentax-k70/9-3-8t.jpg&#34;  alt=&#34;↑ISO12800&#34;&gt;
  
    &lt;/a&gt;
  
   
    &lt;span class=&#34;caption&#34;&gt;↑ISO12800&lt;/span&gt;
  
&lt;/div&gt;
&lt;/p&gt;

&lt;h1 id=&#34;总结&#34;&gt;总结&lt;/h1&gt;

&lt;p&gt;对于这款相机，我看重的是这么几点：可翻转屏幕、14bit RAW文件、4.5级防振、搭载同全副K-1相同的像素偏移模式、WiFi。&lt;/p&gt;

&lt;p&gt;这样的配置，作为继承K-50的后续机型，相比自家旗舰K-3ii，我觉的相对短板的几点也就：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;无肩屏&lt;/li&gt;
&lt;li&gt;非全金属机身&lt;/li&gt;
&lt;li&gt;无内建GPS&lt;/li&gt;
&lt;li&gt;对焦和测光系统沿用K-5那套，速度不如K-3ii&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;这四点了。然而这四点对我而言并不重要——&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;肩屏取消了无非就是换个看参数的习惯&lt;/li&gt;
&lt;li&gt;虽然塑料机身但依旧三防还能轻便些&lt;/li&gt;
&lt;li&gt;实在想要GPS实现天体追踪功能就买个o-gps1也是可以补救的&lt;/li&gt;
&lt;li&gt;对宾得的对焦早就弃疗了想要拍运动题材就算是K-3ii那套也根本不够用平时反正也习惯了中心点对焦再构图&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;所以对这样一款性能和画质均达到要求的机身，卖这个价钱，还要什么自行车（尤其画质还这么扎实，应该可以排到APS-C的前五名）。唯一有些遗憾的是糟糕的视频表现。横向对比同级别的佳能尼康索尼，没有强烈对焦和视频需求的话，优势很多非常具有性价比。&lt;/p&gt;

&lt;h1 id=&#34;reference&#34;&gt;Reference&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;http://www.loxpo.com/thread-7726-1-1.html&#34;&gt;乐享派&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;http://info.xitek.com/pzreview/xitektest/201608/16-204286.html&#34;&gt;色影无忌&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;https://www.mobile01.com/topicdetail.php?f=251&amp;amp;t=4974622&#34;&gt;Mobile01&lt;/a&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Flickr Photo Gallery</title>
      <link>http://nianze.tk/2017/01/flickr-photo-gallery/</link>
      <pubDate>Sun, 01 Jan 2017 00:00:00 +0000</pubDate>
      
      <guid>http://nianze.tk/2017/01/flickr-photo-gallery/</guid>
      <description>&lt;p&gt;&lt;p class=&#39;light-font&#39;&gt;
A gallery for some of my photos stored in &lt;a href=&#34;https://www.flickr.com/photos/129774362@N07&#34;&gt;Flickr&lt;/a&gt;. You may also check out my &lt;a href=&#34;https://www.instagram.com/eznain/&#34;&gt;Instagram&lt;/a&gt;.
&lt;br/&gt;
&lt;br/&gt;
Total images: &lt;strong id=&#39;total-images&#39;&gt;0&lt;/strong&gt;
&lt;/p&gt;
&lt;div id=&#39;photo-gallery&#39;&gt;&lt;/div&gt;
&lt;script src=&#34;//cdnjs.cloudflare.com/ajax/libs/jquery/2.1.3/jquery.min.js&#34;&gt;&lt;/script&gt;
&lt;script src=&#34;//cdnjs.cloudflare.com/ajax/libs/fancybox/2.1.4/jquery.fancybox.min.js&#34;&gt;&lt;/script&gt;
&lt;script src=&#34;//cdnjs.cloudflare.com/ajax/libs/fancybox/2.1.4/helpers/jquery.fancybox-thumbs.min.js&#34;&gt;&lt;/script&gt;
&lt;script src=&#34;http://nianze.tk/js/photo-gallery/flickrfeed.js&#34;&gt;&lt;/script&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Binary search review</title>
      <link>http://nianze.tk/2016/12/binary-search-review/</link>
      <pubDate>Thu, 29 Dec 2016 00:00:00 +0000</pubDate>
      
      <guid>http://nianze.tk/2016/12/binary-search-review/</guid>
      <description>&lt;p&gt;Detailed review on binary search.

&lt;!-- toc --&gt;&lt;/p&gt;

&lt;p&gt;This post is based on an article on binary search from &lt;a href=&#34;http://www.topcoder.com/community/data-science/data-science-tutorials/binary-search/&#34;&gt;Topcoder&lt;/a&gt;.&lt;/p&gt;

&lt;h1 id=&#34;classic-finding-a-value-in-a-sorted-sequence&#34;&gt;Classic: Finding a value in a sorted sequence&lt;/h1&gt;

&lt;p&gt;Consider the following sequence of integers sorted in ascending order and say we are looking for the number 55:&lt;/p&gt;

&lt;p&gt;| 0 | 5 | 13 | 19 | 22 | 41 | 55 | 68 | 72 | 81 | 98 |&lt;/p&gt;

&lt;p&gt;&amp;ndash;&amp;gt;&lt;/p&gt;

&lt;p&gt;| 55 | 68 | 72 | 81 | 98 |&lt;/p&gt;

&lt;p&gt;&amp;ndash;&amp;gt;&lt;/p&gt;

&lt;p&gt;| 55 | 68 |&lt;/p&gt;

&lt;p&gt;Depending on how we choose the median of an even number of elements we will either find 55 in the next step or chop off 68 to get a search space of only one element. Either way, we conclude that the index where the target value is located is 7.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;binary_search(A, target):
   lo = 1, hi = size(A)
   while lo &amp;lt;= hi:
      mid = lo + (hi-lo)/2
      if A[mid] == target:
         return mid            
      else if A[mid] &amp;lt; target: 
         lo = mid+1
      else:
         hi = mid-1
            
   // target was not found

&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;taking-it-further-the-main-theorem&#34;&gt;Taking it further: the main theorem&lt;/h1&gt;

&lt;p&gt;Consider a predicate p defined over some ordered set S (the search space). The search space consists of candidate solutions to the problem. We use the predicate to verify if a candidate solution is legal (does not violate some constraint) according to the definition of the problem.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&amp;ldquo;Main theorem&amp;rdquo;: &lt;strong&gt;binary search can be used if and only if for all x in S, p(x) implies p(y) for all y &amp;gt; x&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;We can use binary search to find the smallest legal solution (i.e. the smallest x for which p(x) is true) by following two steps:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Designing a predicate. Note that we need to choose what the algorithm should find - either the first x for which p(x) is true or the last x for which p(x) is false.&lt;/li&gt;
&lt;li&gt;Proving that binary search can be applied to the predicate. This is where we use the main theorem, verifying that the conditions laid out in the theorem are satisfied.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;These two parts are most often interleaved: when we think a problem can be solved by binary search, we aim to design the predicate so that it satisfies the condition in the main theorem.&lt;/p&gt;

&lt;h1 id=&#34;implementation&#34;&gt;Implementation&lt;/h1&gt;

&lt;p&gt;Given an array A (following array) and a target value (say 55), return the index of the first element in A equal to or greater than the target value.&lt;/p&gt;

&lt;p&gt;Sample sequence:&lt;/p&gt;

&lt;p&gt;| 0 | 5 | 13 | 19 | 22 | 41 | 55 | 68 | 72 | 81 | 98 |&lt;/p&gt;

&lt;p&gt;Solution:&lt;/p&gt;

&lt;p&gt;Predicate p(A[x]): &amp;ldquo;Is A[x] greater than or equal to the target value?&amp;ldquo;.&lt;/p&gt;

&lt;p&gt;Search space &lt;strong&gt;S&lt;/strong&gt; (indices):&lt;/p&gt;

&lt;p&gt;| 1 | 2 | 3  | 4  | 5  | 6  | 7  | 8  | 9  | 10 | 11 |&lt;/p&gt;

&lt;p&gt;Apply the predicate (with a target value of 55) to array A:&lt;/p&gt;

&lt;p&gt;| no | no | no | no | no | no | yes | yes | yes | yes | yes |&lt;/p&gt;

&lt;p&gt;Implementing the discrete algorithm:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;binary_search(lo, hi, p):
   while lo &amp;lt; hi:
      mid = lo + (hi-lo)/2
      if p(mid) == true:
         hi = mid
      else:
         lo = mid+1
          
   if p(lo) == false:
      complain                // p(x) is false for all x in S!
      
   return lo         // lo is the least x for which p(x) is true

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Two crucial lines:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;hi = mid :
When p(mid) is true, we can discard the second half of the search space, since the predicate is true for all elements in it (by the main theorem). However, we can not discard mid itself, since it may well be the first element for which p is true. This is why moving the upper bound to mid is as aggressive as we can do without introducing bugs.&lt;/li&gt;
&lt;li&gt;lo = mid+1
If p(mid) is false, we can discard the first half of the search space, but this time including mid. p(mid) is false so we don’t need it in our search space. This effectively means we can move the lower bound to mid+1.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;If we wanted to find the last x for which p(x) is false:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;binary_search(lo, hi, p):
   while lo &amp;lt; hi:
      mid = lo + (hi-lo+1)/2    // note: rounds up instead of down
      if p(mid) == true:
         hi = mid-1
      else:
         lo = mid
          
   if p(lo) == true:
      complain                // p(x) is true for all x in S!
      
   return lo         // lo is the greatest x for which p(x) is false
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Explanation:
If we use &lt;code&gt;mid = lo + (hi-lo)/2&lt;/code&gt;, which rounds down, consider what happens when running this code on some search space for which the predicate gives:&lt;/p&gt;

&lt;p&gt;| no | yes |&lt;/p&gt;

&lt;p&gt;The code will get stuck in a loop. It will always select the first element as mid, but then will not move the lower bound because it wants to keep the no in its search space. So &lt;code&gt;mid&lt;/code&gt; needs to round up instead of down.&lt;/p&gt;

&lt;p&gt;Note:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Why using mid = lo + (hi-lo)/2 instead of the usual mid = (lo+hi)/2?&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;To avoid another potential rounding bug: in the first case, we want the division to always round down, towards the lower bound. But division truncates, so when lo+hi would be negative, it would start rounding towards the higher bound. Coding the calculation this way ensures that the number divided is always positive and hence always rounds as we want it to.&lt;/li&gt;
&lt;li&gt;To avoid integer overflow.&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Just remember to always test the code on a two-element set where the predicate is false for the first element and true for the second.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;example-fairworkload-http-community-topcoder-com-stat-c-problem-statement-pm-1901-rd-4650&#34;&gt;Example: &lt;a href=&#34;http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=1901&amp;amp;rd=4650&#34;&gt;&lt;em&gt;FairWorkload&lt;/em&gt;&lt;/a&gt;&lt;/h1&gt;

&lt;p&gt;In the problem, a number of workers need to examine a number of filing cabinets. The cabinets are not all of the same size and we are told for each cabinet how many folders it contains. We are asked to find an assignment such that each worker gets a sequential series of cabinets to go through and that it minimizes the maximum amount of folders that a worker would have to look through.&lt;/p&gt;

&lt;p&gt;Solution:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Imagine that we have an unlimited number of workers. For some number &lt;em&gt;MAX&lt;/em&gt;, we can calculate the minimum number of workers needed so that each worker has to examine no more than &lt;em&gt;MAX&lt;/em&gt; folders (if this is possible) by greedy algorithm:
We assign first worker to the cabinet 1. Since the cabinets must be assigned in sequential order (a worker cannot examine cabinets 1 and 3 without examining 2 as well), it’s always optimal to assign him to the second cabinet as well, if this does not take him over the limit we introduced (&lt;em&gt;MAX&lt;/em&gt;). If it would take him over the limit, we conclude that his work is done and assign a new worker to the second cabinet. We proceed in a similar manner until all the cabinets have been assigned and assert that we’ve used the minimum number of workers possible, with the artificial limit (&lt;em&gt;MAX&lt;/em&gt;) we introduced. Note here that the number of workers is inversely proportional to MAX: the higher we set our limit, the fewer workers we will need.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;What we want is the smallest &lt;em&gt;MAX&lt;/em&gt; such that the number of workers required is less than or equal to the number of workers available. So the predicate is:&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Can the workload be spread so that each worker has to examine no more than x folders, with the limited number of workers available?&lt;/strong&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The code:&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;int getMostWork( vector  folders, int workers ) {
   int n = folders.size();
   int lo = *max_element( folders.begin(), folders.end() );
   int hi = accumulate( folders.begin(), folders.end(), 0 );

   while ( lo &amp;lt; hi ) {
      int x = lo + (hi-lo)/2;

      int required = 1, current_load = 0;
      for ( int i=0; i&amp;lt;n; ++i ) {
         if ( current_load + folders[i] &amp;lt;= x ) {
            // the current worker can handle it
            current_load += folders[i];
         }
         else {
            // assign next worker
            ++required;
            current_load = folders[i];               
         }
      }

      if ( required &amp;lt;= workers )
         hi = x;
      else
         lo = x+1;
   }

   return lo;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To verify that the solution doesn’t lock up, we can use a small no/yes example with folders={1,1} and workers=1.&lt;/p&gt;

&lt;p&gt;The overall complexity of the solution is O(n log SIZE), where SIZE is the size of the search space. This is very fast.&lt;/p&gt;

&lt;p&gt;In this example, we used a greedy algorithm to evaluate the predicate. In other problems, evaluating the predicate can come down to anything from a simple math expression to finding a maximum cardinality matching in a bipartite graph.&lt;/p&gt;

&lt;h1 id=&#34;conclusion&#34;&gt;Conclusion&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;Design a predicate which can be efficiently evaluated and so that binary search can be applied&lt;/li&gt;
&lt;li&gt;Decide on what you’re looking for and code so that the search space always contains that (if it exists)&lt;/li&gt;
&lt;li&gt;If the search space consists only of integers, test your algorithm on a two-element set to be sure it doesn’t lock up&lt;/li&gt;
&lt;li&gt;Verify that the lower and upper bounds are not overly constrained: it’s usually better to relax them as long as it doesn’t break the predicate. An all-around template looks like this according to my previous &lt;a href=&#34;https:nianze.tk/2016/08/binary-search&#34;&gt;post&lt;/a&gt; on binary search:&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Solution {
    /**
     * @return first occurrence position of the target
     */
    int findPosition(int[] nums, int target) {
        if (nums == null || nums.length == 0) {
            return -1;
        }   
        int start = 0, end = nums.length - 1;
        while (start + 1 &amp;lt; end) {
            int mid = start + (end - start) / 2;
            if (nums[mid] == target) {
                end = mid; // for case of &amp;quot;return first position&amp;quot;
                //start = mid; for case of &amp;quot;return last position&amp;quot;
                //return mid; for case of &amp;quot;return any position&amp;quot;
            } else if (nums[mid] &amp;lt; target) {
                start = mid;
            } else if (nums[mid] &amp;gt; target) {
                end = mid;
            }
        }   
        // exchange the position of two [if statement] if want to return last postion
        if (nums[start] == target) {
            return start;
        }
        if (nums[end] == target) {
            return end;
        }
        // target strictly between {A[start-1], A[start]}
        // or strictly between {A[start], A[end]}
        // or strictly between {A[end, A[end+1]}
        return -1;
    }
}
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>Alien dictionary</title>
      <link>http://nianze.tk/2016/11/alien-dictionary/</link>
      <pubDate>Sat, 26 Nov 2016 00:00:00 +0000</pubDate>
      
      <guid>http://nianze.tk/2016/11/alien-dictionary/</guid>
      <description>&lt;p&gt;Build a graph to solve alien dictionary problem via DFS/BFS.

&lt;!-- toc --&gt;&lt;/p&gt;

&lt;h1 id=&#34;alien-dictionary&#34;&gt;Alien Dictionary&lt;/h1&gt;

&lt;p&gt;There is a new alien language which uses the latin alphabet. However, the order among letters are unknown to you. You receive a list of words from the dictionary, where &lt;strong&gt;words are sorted lexicographically by the rules of this new language&lt;/strong&gt;. Derive the order of letters in this language.&lt;/p&gt;

&lt;p&gt;For example,&lt;/p&gt;

&lt;p&gt;Given the following words in dictionary,&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[
  &amp;quot;wrt&amp;quot;,
  &amp;quot;wrf&amp;quot;,
  &amp;quot;er&amp;quot;,
  &amp;quot;ett&amp;quot;,
  &amp;quot;rftt&amp;quot;
]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The correct order is: &amp;ldquo;wertf&amp;rdquo;.&lt;/p&gt;

&lt;p&gt;Note:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;You may assume all letters are in lowercase.&lt;/li&gt;
&lt;li&gt;If the order is invalid, return an empty string ([&amp;ldquo;abcd&amp;rdquo;,&amp;ldquo;ab&amp;rdquo;] is invalid).&lt;/li&gt;
&lt;li&gt;There may be multiple valid order of letters, return any one of them is fine.&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&#34;method-1-dfs&#34;&gt;Method 1: DFS&lt;/h1&gt;

&lt;p&gt;Build the graph (post-adjacency list and visited list), then use &lt;code&gt;DFS&lt;/code&gt; to build the correct order, while checking the loop at the same time.&lt;/p&gt;

&lt;p&gt;Note:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;visited[]: -1(not exist), 0(no pre-node), 1(visiting), 2(visited)&lt;/li&gt;
&lt;li&gt;The order of adding char into stringbuilder is reversed: add post nodes to sb firstly in order to avoid missing pre-nodes for current nodes later. e.g.: for correct order &amp;ldquo;abc&amp;rdquo;, if meet &amp;lsquo;b&amp;rsquo; firstly, build the sb as &amp;ldquo;cb&amp;rdquo;, and then meet &amp;lsquo;a&amp;rsquo;, build it as &amp;ldquo;cba&amp;rdquo;; otherwise, when meet &amp;lsquo;b&amp;rsquo;, build sb as &amp;ldquo;bc&amp;rdquo;, and then meet &amp;lsquo;a&amp;rsquo;, resulting in &amp;ldquo;bca&amp;rdquo;, which is incorrect.)&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;    private static int N = 26;
    public String alienOrder(String[] words) {
        boolean[][] adj = new boolean[N][N];
        int[] visited = new int[N];
        if (!buildGraph(words, adj, visited)) return &amp;quot;&amp;quot;; // &amp;quot;abcd&amp;quot; -&amp;gt; &amp;quot;ab&amp;quot;

        StringBuilder sb = new StringBuilder();
        for (int i = 0; i &amp;lt; N; i++) {
            if (visited[i] == 0) {
                if (!dfs(adj, visited, sb, i)) return &amp;quot;&amp;quot;;
            }
        }
        return sb.reverse().toString();
    }
    private boolean dfs(boolean[][] adj, int[] visited, StringBuilder sb, int i) {
        visited[i] = 1;  // visiting
        for (int j = 0; j &amp;lt; N; j++) {
            if (adj[i][j]) { // connected post nodes
                if (visited[j] == 1) return false;  // loop case
                if (visited[j] == 0) {
                    if (!dfs(adj, visited, sb, j)) return false;
                }
            }
        }
        visited[i] = 2; // visited
        sb.append((char)(&#39;a&#39; + i));
        return true;
    }        
    private boolean buildGraph(String[] words, boolean[][] adj, int[] visited) {
        Arrays.fill(visited, -1); // init to not existed
        for (int i = 0; i &amp;lt; words.length; i++) {
            for (char c : words[i].toCharArray()) visited[c - &#39;a&#39;] = 0;
            if (i &amp;gt; 0) {
                String w1 = words[i-1], w2 = words[i];
                int len = Math.min(w1.length(), w2.length()), j = 0;
                for (; j &amp;lt; len; j++) {
                    char c1 = w1.charAt(j), c2 = w2.charAt(j);
                    if (c1 != c2) {
                        adj[c1 - &#39;a&#39;][c2 - &#39;a&#39;] = true;
                        break;
                    }
                }
                if (j == len &amp;amp;&amp;amp; w1.length() &amp;gt; w2.length()) return false; // &amp;quot;abcd&amp;quot; -&amp;gt; &amp;quot;ab&amp;quot;
            }
        }
        return true;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;method-2-bfs&#34;&gt;Method 2: BFS&lt;/h1&gt;

&lt;p&gt;Build the graph(post-adjacency list and visited list), then use Karn&amp;rsquo;s algorithm to do topological sort (essentially BFS).&lt;/p&gt;

&lt;p&gt;Note:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;visited[]: -1(not exist), 0(no pre-node), 1,2,3&amp;hellip;(pre-nodes number)&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;    public String alienOrder(String[] words) {
        List&amp;lt;Set&amp;lt;Integer&amp;gt;&amp;gt; adj = new ArrayList&amp;lt;&amp;gt;();
        for (int i = 0; i &amp;lt; 26; i++) adj.add(new HashSet&amp;lt;Integer&amp;gt;());
        int[] degree = new int[26];
        Arrays.fill(degree, -1);
        // init the adj and degree list
        for (int i = 0; i &amp;lt; words.length; i++) {
            for (char c : words[i].toCharArray()) {
                if (degree[c-&#39;a&#39;] &amp;lt; 0) degree[c-&#39;a&#39;] = 0;
            }
            if (i &amp;gt; 0) {
                String w1 = words[i-1], w2 = words[i];
                int len = Math.min(w1.length(), w2.length());
                for (int j = 0; j &amp;lt; len; j++) {
                    int c1 = w1.charAt(j) - &#39;a&#39;, c2 = w2.charAt(j) - &#39;a&#39;;
                    if (c1 != c2) {
                        if (!adj.get(c1).contains(c2)) {
                            adj.get(c1).add(c2);
                            degree[c2]++;
                        }
                        break;
                    }
                    if (j == len-1 &amp;amp;&amp;amp; w1.length() &amp;gt; w2.length()) return &amp;quot;&amp;quot;; // &amp;quot;abcd&amp;quot; -&amp;gt; &amp;quot;ab&amp;quot;   
                }
            }
        }
        // topological sort
        Deque&amp;lt;Integer&amp;gt; q = new ArrayDeque&amp;lt;&amp;gt;();
        for (int i = 0; i &amp;lt; degree.length; i++) {
            if (degree[i] == 0) q.offer(i);
        }
        StringBuilder sb = new StringBuilder();
        while (!q.isEmpty()) {
            int i = q.poll();
            sb.append((char) (&#39;a&#39; + i));
            for (int j : adj.get(i)) {
                degree[j]--;
                if (degree[j] == 0) q.offer(j);
            }
        }
        for (int d : degree) if (d &amp;gt; 0) return &amp;quot;&amp;quot;; // has loop
        return sb.toString();
    }
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>Task schedule - greedy algorithm</title>
      <link>http://nianze.tk/2016/11/task-schedule/</link>
      <pubDate>Mon, 14 Nov 2016 00:00:00 +0000</pubDate>
      
      <guid>http://nianze.tk/2016/11/task-schedule/</guid>
      <description>&lt;p&gt;Use greedy algorigthm to solve task scheduleing problem.
&lt;/p&gt;

&lt;h3 id=&#34;starter&#34;&gt;Starter&lt;/h3&gt;

&lt;p&gt;Given tasks with cooldown time between the same task. Calculate the minimum total time to finish all the tasks. The order of tasks cannot be changed.
e.g.:
    Given tasks：[12323], and cooldown time is 3
    Return: 7, since length of [1 2 3 _ _ 2 3] is 7&lt;/p&gt;

&lt;p&gt;Method: Use hashmap to store the most recent same tasks&amp;rsquo;s time&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public static int min_time(int[] tasks, int interval){
    if(tasks == null || tasks.length == 0){
        return 0;
    }
    Map&amp;lt;Integer, Integer&amp;gt; map = new HashMap&amp;lt;Integer, Integer&amp;gt;();
    int time = 0;
    for(int task : tasks){
        Integer task_last_time = map.get(task);
        if(task_last_time != null &amp;amp;&amp;amp; task_last_time + interval + 1 &amp;gt; time){
            time = task_last_time + interval + 1;
        }
        map.put(task, time);
        time++;
    }
    return time;
}
    // Improve: space complexity a little to no more than  O(n)
    // use LinkedHashMap to remove the elder task that exceeds the cooldown time
    Map&amp;lt;K,V&amp;gt; map = new LinkedHashMap&amp;lt;K,V&amp;gt;(int cooldown, 1.0f) {  // load factor 1.0
        @Override
        protected boolean removeEldestEntry(Map.Entry&amp;lt;K,V&amp;gt; eldest) {
            return size() &amp;gt; cooldown;
        }
    };

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;follow-up-what-if-the-order-is-ok-to-change&#34;&gt;Follow up: What if the order is OK to change?&lt;/h3&gt;

&lt;p&gt;Method: Greedy algorithm - always look for the task with highest remaining time at each time.&lt;/p&gt;

&lt;p&gt;There are two version of implementation:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Use priorityQueue to sort the tasks with highest remaining times, time: O(nlog(n)), where n is the total number of tasks, space: O(n)&lt;/li&gt;
&lt;li&gt;Use two array to store the remaining times and available time for each task, and each time scan these two arraies to find the appropriate task time: O(klog(n)), where k is the number of task kinds, space: O(n)&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Using method One：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;    public int schedule(int[] tasks, int cooldown) {
        HashMap&amp;lt;Integer, Integer&amp;gt; freqMap = new HashMap&amp;lt;&amp;gt;();
        for (int t : tasks) {
            freqMap.put(t, freqMap.getOrDefault(t, 0) + 1);
        }
        Queue&amp;lt;Map.Entry&amp;lt;Integer, Integer&amp;gt;&amp;gt; maxHeap =
            new PriorityQueue&amp;lt;&amp;gt;(freqMap.size(), new Comparator&amp;lt;Map.Entry&amp;lt;Integer, Integer&amp;gt;&amp;gt;() {
                    @Override
                    public int compare(Map.Entry&amp;lt;Integer, Integer&amp;gt; e1, Map.Entry&amp;lt;Integer, Integer&amp;gt; e2) {
                        return e2.getValue() - e1.getValue();
                    }
                });
        Deque&amp;lt;Map.Entry&amp;lt;Integer, Integer&amp;gt;&amp;gt; waitQueue = new ArrayDeque&amp;lt;&amp;gt;();
        HashMap&amp;lt;Integer, Integer&amp;gt; timeMap = new HashMap&amp;lt;&amp;gt;();
        int time = 0;
        maxHeap.addAll(freqMap.entrySet());        
        while (!maxHeap.isEmpty() || !waitQueue.isEmpty()) {
            if (!maxHeap.isEmpty()) {
                Map.Entry&amp;lt;Integer, Integer&amp;gt; cur = maxHeap.poll();
                time++;
                timeMap.put(cur.getKey(), time);
                cur.setValue(cur.getValue() - 1);
                waitQueue.offer(cur);
                if (waitQueue.size() &amp;lt; cooldown + 1) continue;
                Map.Entry&amp;lt;Integer, Integer&amp;gt; front = waitQueue.poll();
                if (front.getValue() &amp;gt; 0) maxHeap.offer(front);
            } else {
                Map.Entry&amp;lt;Integer, Integer&amp;gt; front = waitQueue.poll();
                if (front.getValue() &amp;gt; 0) {
                    maxHeap.offer(front);
                    time = timeMap.get(front.getKey()) + cooldown;
                }
            }
        }
        return time;
    }        
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Similar question: LC358 Rearrange String k Distance Apart&lt;/p&gt;

&lt;p&gt;Method one:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;    public String rearrangeString(String str, int k) {
        HashMap&amp;lt;Character, Integer&amp;gt; map = new HashMap&amp;lt;&amp;gt;();
        for (char c : str.toCharArray()) {
            map.put(c, map.getOrDefault(c, 0) + 1);
        }
        Queue&amp;lt;Map.Entry&amp;lt;Character, Integer&amp;gt;&amp;gt; maxHeap =
            new PriorityQueue&amp;lt;&amp;gt;(map.size(), new Comparator&amp;lt;Map.Entry&amp;lt;Character, Integer&amp;gt;&amp;gt;() {
                    @Override
                    public int compare(Map.Entry&amp;lt;Character, Integer&amp;gt; e1, Map.Entry&amp;lt;Character, Integer&amp;gt; e2) {
                        return e2.getValue() - e1.getValue();
                    }
                });
        Deque&amp;lt;Map.Entry&amp;lt;Character, Integer&amp;gt;&amp;gt; waitQueue = new ArrayDeque&amp;lt;&amp;gt;();
        maxHeap.addAll(map.entrySet());
        StringBuilder sb = new StringBuilder();
        while (!maxHeap.isEmpty()) {
            Map.Entry&amp;lt;Character, Integer&amp;gt; cur = maxHeap.poll();
            sb.append(cur.getKey());
            cur.setValue(cur.getValue()-1);
            waitQueue.offer(cur);
            if (waitQueue.size() &amp;lt; k) continue;
            Map.Entry&amp;lt;Character, Integer&amp;gt; front = waitQueue.poll();
            if (front.getValue() &amp;gt; 0) maxHeap.offer(front);
        }
        return sb.length() == str.length() ? sb.toString() : &amp;quot;&amp;quot;;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Method two:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;    public String rearrangeString(String str, int k) {
        int[] count = new int[26];
        int[] valid = new int[26];
        StringBuilder sb = new StringBuilder();
        for (int i = 0; i &amp;lt; str.length(); i++) {
            count[str.charAt(i) - &#39;a&#39;]++;
        }
        for (int i = 0; i &amp;lt; str.length(); i++) {
            int c = findNext(count, valid, i);
            if (c == -1) return &amp;quot;&amp;quot;;
            sb.append((char)(&#39;a&#39;+c));
            count[c] -= 1;
            valid[c] = i + k;
        }
        return sb.toString();
    }
    private int findNext(int[] count, int[] valid, int index) {
        int pos = -1, max = -1;
        for (int i = 0; i &amp;lt; 26; i++) {
            if (count[i] &amp;gt; 0 &amp;amp;&amp;amp; count[i] &amp;gt; max &amp;amp;&amp;amp; index &amp;gt;= valid[i]) {
                pos = i;
                max = count[i];
            }
        }
        return pos;
    }
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>LinkedList reversing</title>
      <link>http://nianze.tk/2016/11/linkedlist-reversing/</link>
      <pubDate>Fri, 11 Nov 2016 00:00:00 +0000</pubDate>
      
      <guid>http://nianze.tk/2016/11/linkedlist-reversing/</guid>
      <description>&lt;p&gt;Summary on LinkedList reversing.

&lt;!-- toc --&gt;&lt;/p&gt;

&lt;h1 id=&#34;starter&#34;&gt;Starter&lt;/h1&gt;

&lt;h2 id=&#34;special-case-lc206-reverse-all-the-nodes-in-one-pass&#34;&gt;Special case: LC206 reverse all the nodes in one pass:&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public ListNode reverseList(ListNode head) {
    ListNode newHead = null;
    while (head != null) {
        ListNode next = head.next;
        head.next = newHead;
        newHead = head;
        head = next;
    }
    return newHead;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;general-case-lc92-reverse-nodes-from-position-m-to-n&#34;&gt;General case: LC92 reverse nodes from position m to n&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public ListNode reverseBetween(ListNode head, int m, int n) {
    ListNode dummy = new ListNode(0);
    dummy.next = head;
    ListNode pre = dummy, end, cur;
    for (int i = 0; i &amp;lt; m-1; i++) { pre = pre.next; }
	end = pre.next;
    cur = end.next;
    for (int i = 0; i &amp;lt; n - m; i++) {
        end.next = cur.next;
        cur.next = pre.next;
        pre.next = cur;
        cur = end.next;
    }
    return dummy.next;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;main-dish-lc25-reverse-nodes-in-k-groups&#34;&gt;Main dish: LC25 Reverse Nodes in k-Groups&lt;/h1&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/**
 * Reverse a link list between pre and next exclusively
 * e.g.: 
 * 0-&amp;gt;1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;5-&amp;gt;6
 * |           |   
 * pre        next
 *
 * after call pre = reverse(pre, next):
 * 0-&amp;gt;3-&amp;gt;2-&amp;gt;1-&amp;gt;4-&amp;gt;5-&amp;gt;6
 *          |  |
 *          pre next
 * @param pre 
 * @param next
 * @return the precedence of parameter next
 */
private static ListNode reverse(ListNode pre, ListNode next) {
    ListNode end = pre.next, cur = end.next;
    while (cur != next) {
        end.next = cur.next;
        cur.next = pre.next;
        pre.next = cur;
        cur = end.next;
    }
    return end;
}
public ListNode reverseKGroup(ListNode head, int k) {
    if (head == null || k == 1) return head;
    ListNode dummy = new ListNode(0);
    dummy.next = head;
    ListNode pre = dummy;
    int i = 0;
    while (head != null) {
        head = head.next;            
        if (++i % k == 0) pre = reverse(pre, head);
    }
    return dummy.next;
}
/**
 * Note: the while loop is the same as following process, which is easier to understand:
 * while(head != null){
 *    i++;
 *    if(i % k ==0){
 *        pre = reverse(pre, head.next);
 *        head = pre.next;
 *    }else {
 *        head = head.next;
 *    }
 * }
 */

}
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>Substring type problem&#39;s template</title>
      <link>http://nianze.tk/2016/11/substring-template/</link>
      <pubDate>Tue, 08 Nov 2016 00:00:00 +0000</pubDate>
      
      <guid>http://nianze.tk/2016/11/substring-template/</guid>
      <description>&lt;p&gt;Two pointer template to solve substring problem.

&lt;!-- toc --&gt;&lt;/p&gt;

&lt;h1 id=&#34;lc76-minimum-window-substring&#34;&gt;LC76 Minimum Window Substring&lt;/h1&gt;

&lt;h2 id=&#34;method-two-pointer-with-map&#34;&gt;Method: Two Pointer with map&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;Scanning from left to right, keep the head and length of minimum window substring so far.&lt;/li&gt;
&lt;li&gt;Use an &lt;code&gt;int[256]&lt;/code&gt; array or a &lt;code&gt;HashMap&lt;/code&gt; to store target charater counts.&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public String minWindow(String s, String t) {
    int[] map = new int[256];
    for (char c : t.toCharArray()) { map[c]++; }
    int start = 0, end = 0, len = Integer.MAX_VALUE, head = 0, count = t.length();
    while (end &amp;lt; s.length()) {
        if (map[s.charAt(end++)]-- &amp;gt; 0) count--;
        while (count == 0) {
            if (end - start &amp;lt; len) len = end - (head = start);
            if (map[s.charAt(start++)]++ == 0) count++;
        }
    }
    return len == Integer.MAX_VALUE ? &amp;quot;&amp;quot; : s.substring(head, head + len);
}    
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;template-1&#34;&gt;Template&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:1&#34;&gt;&lt;a href=&#34;#fn:1&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;&lt;/h1&gt;

&lt;p&gt;For most substring problem, we are given a string and need to find a substring of it which satisfy some restrictions. A general way is to use a hashmap assisted with two pointers.&lt;/p&gt;

&lt;p&gt;One thing needs to be mentioned is that when asked to find maximum substring, we should update maximum after the inner while loop to guarantee that the substring is valid. On the other hand, when asked to find minimum substring, we should update minimum inside the inner while loop.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;int findSubstring(string s){
    int[] map = new int[256];
    int counter; // check whether the substring is valid
    int start = 0, end = 0; //two pointers, one point to tail and one head
    int d; //the length of substring
    for() { /* initialize the hash map here */ }
    while(end &amp;lt; s.length()){
        if(map[s.charAt(end++)]-- ?){  /* modify counter here */ }
        while(/* counter condition */){              
            /* update d here if finding minimum */
            //increase start to make it invalid/valid again            
            if(map[s[start++]]++ ?){ /*modify counter here*/ }
        }  
        /* update d here if finding maximum*/
    }
    return d;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;div class=&#34;footnotes&#34;&gt;

&lt;hr /&gt;

&lt;ol&gt;
&lt;li id=&#34;fn:1&#34;&gt;&lt;a href=&#34;https://discuss.leetcode.com/topic/30941/here-is-a-10-line-template-that-can-solve-most-substring-problems&#34;&gt;https://discuss.leetcode.com/topic/30941/here-is-a-10-line-template-that-can-solve-most-substring-problems&lt;/a&gt;
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:1&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;</description>
    </item>
    
    <item>
      <title>Remove Invalid Parentheses</title>
      <link>http://nianze.tk/2016/11/invalid-parentheses/</link>
      <pubDate>Sun, 06 Nov 2016 00:00:00 +0000</pubDate>
      
      <guid>http://nianze.tk/2016/11/invalid-parentheses/</guid>
      <description>&lt;p&gt;Several ways to remove invalid parentheses problem.

&lt;!-- toc --&gt;&lt;/p&gt;

&lt;h1 id=&#34;starter&#34;&gt;Starter&lt;/h1&gt;

&lt;blockquote&gt;
&lt;p&gt;Return only one possible result&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;method-two-pass-with-counter&#34;&gt;Method: Two pass with &lt;code&gt;counter&lt;/code&gt;&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;Scanning from left to right, ending up removing extra &amp;lsquo;)&amp;rsquo;&lt;/li&gt;
&lt;li&gt;Scanning from right to left, ending up removing extra &amp;lsquo;(&amp;rsquo;&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public String removeInvalidParantheses(String s) {
    StringBuilder firstPass = new StringBuilder();
    int counter = 0;
    for (int i = 0; i &amp;lt; s.length(); i++) {
        char c = s.charAt(i);
        if (c == &#39;(&#39;) {
            counter++;
            firstPass.append(&#39;(&#39;);
        } else if (c == &#39;)&#39; &amp;amp;&amp;amp; counter &amp;gt; 0) {
            counter--;
            firstPass.append(&#39;)&#39;);
        } else if (c != &#39;)&#39; &amp;amp;&amp;amp; c != &#39;(&#39;) {
            firstPass.append(c);
        }
    }
    if (counter == 0) return firstPass.toString();
    counter = 0;
    StringBuilder sb = new StringBuilder();
    for(int i = firstPass.length() - 1; i &amp;gt;= 0; i--) { 
        char c = firstPass.charAt(i);
        if (c == &#39;)&#39;) {
            counter--;
            sb.append(&#39;)&#39;);
        } else if (c == &#39;(&#39; &amp;amp;&amp;amp; counter &amp;lt; 0) {
            counter++;
            sb.append(&#39;(&#39;);
        } else if (c != &#39;)&#39; &amp;amp;&amp;amp; c != &#39;(&#39;) {
            sb.append(c);
        }
    }
    return sb.reverse().toString();
}    
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;main-dish-follow-up&#34;&gt;Main dish (follow up)&lt;/h1&gt;

&lt;blockquote&gt;
&lt;p&gt;Return all the possible results&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;method-1-two-pass-with-dfs-1&#34;&gt;Method 1: Two pass with &lt;a href=&#34;https://discuss.leetcode.com/topic/34875/easy-short-concise-and-fast-java-dfs-3-ms-solution&amp;gt;&#34;&gt;&lt;strong&gt;DFS&lt;/strong&gt;&lt;/a&gt;&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;same idea as starter question: using dfs searching for valid candidate without extra &amp;lsquo;)&amp;rsquo;, then reverse the string and search for the second pass to remove all the extra &amp;lsquo;(&amp;rsquo;&lt;/li&gt;
&lt;li&gt;for continuous &amp;lsquo;)&amp;rsquo;, say &amp;ldquo;())&amp;rdquo;, always remove the first &amp;lsquo;)&amp;rsquo; firstly, so &amp;ldquo;(&lt;code&gt;)&lt;/code&gt;)&amp;rdquo; -&amp;gt; &amp;ldquo;()&amp;rdquo;: for j:[prev_j ~ i], if (s[j] == par&lt;a href=&#34;https://discuss.leetcode.com/topic/34875/easy-short-concise-and-fast-java-dfs-3-ms-solution&amp;gt;&#34;&gt;1&lt;/a&gt; &amp;amp;&amp;amp; (j == prev_j || s[j-1] != par&lt;a href=&#34;https://discuss.leetcode.com/topic/34875/easy-short-concise-and-fast-java-dfs-3-ms-solution&amp;gt;&#34;&gt;1&lt;/a&gt;)), remove s.charAt(j)&lt;/li&gt;
&lt;li&gt;each recursive call, store previous i to &lt;code&gt;prev_i&lt;/code&gt; to indicate that first half of string before i is valid, so no need to check again&lt;/li&gt;
&lt;li&gt;each recursive call, store previous j to &lt;code&gt;prev_j&lt;/code&gt; in order to prevent duplicate answers. e.g.:&lt;br /&gt;
if no prev_j stored, it&amp;rsquo;s hard to prevent the same result from two different ching branches:

&lt;ul&gt;
&lt;li&gt;&amp;rdquo;()a)a)&amp;rdquo; -&amp;gt; &amp;ldquo;(a)a)&amp;rdquo; -&amp;gt; &amp;ldquo;(aa)&amp;rdquo;&lt;/li&gt;
&lt;li&gt;&amp;rdquo;()a)a)&amp;rdquo; -&amp;gt; &amp;ldquo;()aa)&amp;rdquo; -&amp;gt; &amp;ldquo;(aa)&amp;rdquo;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Time : every path generates one valid answer, if there&amp;rsquo;s k valid answer, the search  will have k leaves. Since each recursive call requires O(n) time from string atenatino. O(n*m) may be fair enough to describe the time complexity, where n is length of string and m is the total nodes (numver of all the rec calls) in the ch tree&lt;/li&gt;
&lt;li&gt;Space: O(n*k) due to stringbuilder, k is the number of valid answer, n is the length of string&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public List&amp;lt;String&amp;gt; removeInvalidParentheses(String s) {
    List&amp;lt;String&amp;gt; ans = new ArrayList&amp;lt;&amp;gt;();
    remove(s, ans, 0, 0, new char[]{&#39;(&#39;, &#39;)&#39;});
    return ans;
}
private void remove(String s, List&amp;lt;String&amp;gt; ans, int prev_i, int prev_j, char[] par) {
    for (int count = 0, i = prev_i; i &amp;lt; s.length(); i++) {
        if (s.charAt(i) == par[0]) count++;
        if (s.charAt(i) == par[1]) count--;
        if (count &amp;gt;= 0) continue;
        for (int j = prev_j; j &amp;lt;= i; j++) { // count &amp;lt; 0, there&#39;s extra par[1] 
            if (s.charAt(j) == par[1] &amp;amp;&amp;amp; (j == prev_j || s.charAt(j-1) != par[1])) {
                remove(s.substring(0,j) + s.substring(j+1), ans, i, j, par);
            }
        }
        return;
    }
    StringBuilder reversed = new StringBuilder();
    for (int i = s.length() - 1; i &amp;gt;= 0; i--) { reversed.append(s.charAt(i)); }
    if (par[0] == &#39;(&#39;) { remove(reversed.toString(), ans, 0, 0, new char[]{&#39;)&#39;, &#39;(&#39;}); }
    else { ans.add(reversed.toString()); }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;method-2-bfs&#34;&gt;Method 2: BFS&lt;/h2&gt;

&lt;p&gt;Naive way of thinking:&lt;/p&gt;

&lt;p&gt;For a string with n length, each char have 2 states &amp;ldquo;keep/remove&amp;rdquo;, which is 2^n states, and each state requires checkValid, which runs in O(n). Together the BFS require O(n*2^n).&lt;/p&gt;

&lt;p&gt;Ideally, it should be O(C(n,k) + n), where k is the number of chars needs removal. To avoid generating duplicate strings, refer to &lt;a href=&#34;https://discuss.leetcode.com/topic/28855/java-bfs-solution-16ms-avoid-generating-duplicate-strings&amp;gt;&#34;&gt;this post&lt;/a&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Convert Char to String in Java</title>
      <link>http://nianze.tk/2016/11/char-to-string/</link>
      <pubDate>Wed, 02 Nov 2016 00:00:00 +0000</pubDate>
      
      <guid>http://nianze.tk/2016/11/char-to-string/</guid>
      <description>&lt;p&gt;Convert Char to String.
&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Use &lt;code&gt;String.valueOf(char)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Use &lt;code&gt;Character.toString(char)&lt;/code&gt;

&lt;ul&gt;
&lt;li&gt;Note: this method simply returns a call to &lt;code&gt;String.valueOf(char)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Use string concatenation &lt;code&gt;String s  = &amp;quot;&amp;quot; + &#39;c&#39;&lt;/code&gt;

&lt;ul&gt;
&lt;li&gt;Note: this compiles down to
&lt;code&gt;java
String s = new StringBuilder().append(&amp;quot;&amp;quot;).append(&#39;c&#39;).toString();
&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;which is less efficient because &lt;code&gt;StringBuilder&lt;/code&gt; is backed by &lt;code&gt;char[]&lt;/code&gt; (over-allocated by StringBuilder() to 16) and this array will be copied to the resulting &lt;code&gt;String&lt;/code&gt;. On the other hand, &lt;code&gt;String.valueOf(char)&lt;/code&gt; wraps the &lt;code&gt;char&lt;/code&gt; in a single-element array and passes it to the package private constructor &lt;code&gt;String(char[], boolean)&lt;/code&gt;, which avoids the array copy.&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:1&#34;&gt;&lt;a href=&#34;#fn:1&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;div class=&#34;footnotes&#34;&gt;

&lt;hr /&gt;

&lt;ol&gt;
&lt;li id=&#34;fn:1&#34;&gt;&lt;a href=&#34;http://stackoverflow.com/questions/8172420/how-to-convert-a-char-to-a-string-in-java&#34;&gt;http://stackoverflow.com/questions/8172420/how-to-convert-a-char-to-a-string-in-java&lt;/a&gt;
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:1&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;</description>
    </item>
    
    <item>
      <title>When use Dueque</title>
      <link>http://nianze.tk/2016/10/dueque/</link>
      <pubDate>Sun, 30 Oct 2016 00:00:00 +0000</pubDate>
      
      <guid>http://nianze.tk/2016/10/dueque/</guid>
      <description>&lt;p&gt;Deque vs. LinkedList vs. Stack
&lt;/p&gt;

&lt;p&gt;Quote From javadoc:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;ArrayDeque is likely to be faster than Stack when used as a stack, and faster than LinkedList when used as a queue.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;use-arraydeque-or-linkedlist-as-queue-0&#34;&gt;Use ArrayDeque or LinkedList as queue&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:0&#34;&gt;&lt;a href=&#34;#fn:0&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;&lt;/h2&gt;

&lt;h3 id=&#34;cons-of-linked-list&#34;&gt;Cons of Linked List&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Linked structures are the worst structure to iterate with a cache miss on each element&lt;/li&gt;
&lt;li&gt;Have to allocating a node for each item to insert, which essentially involves JVM/OS and expensive&lt;/li&gt;
&lt;li&gt;For pop() operation, it mark internal nodes eligible for garbage collection and that&amp;rsquo;s more work behind the scene&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;pros-of-linked-list&#34;&gt;Pros of Linked List&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;When &lt;strong&gt;removing the current element&lt;/strong&gt; during iteration, LinkedList has better performance&lt;/li&gt;
&lt;li&gt;Worth to note: LinkedList supports null element&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;when-use-arraydeque-as-queue&#34;&gt;When use ArrayDeque as queue&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;if only need to add/remove of both ends, use ArrayDeque&lt;/li&gt;
&lt;li&gt;e.g.: when using BFS, consider ArrayDeque first.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;use-arraydeque-or-stack-as-stack-1&#34;&gt;Use ArrayDeque or Stack as Stack&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:1&#34;&gt;&lt;a href=&#34;#fn:1&#34;&gt;2&lt;/a&gt;&lt;/sup&gt;&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;Deque&lt;/code&gt; exposes a set of operations which is all about being able to fetch/add/remove items from the start or end of a collection, iterate etc. There&amp;rsquo;s deliverately no way to access an element by position, which &lt;code&gt;Stack&lt;/code&gt; exposes because it&amp;rsquo;s a subclass of &lt;code&gt;Vector&lt;/code&gt;, making the &lt;code&gt;Stack&lt;/code&gt; &lt;strong&gt;inconsistent&lt;/strong&gt;.&lt;/p&gt;
&lt;div class=&#34;footnotes&#34;&gt;

&lt;hr /&gt;

&lt;ol&gt;
&lt;li id=&#34;fn:0&#34;&gt;&lt;a href=&#34;http://stackoverflow.com/questions/6163166/why-is-arraydeque-better-than-linkedlist&#34;&gt;http://stackoverflow.com/questions/6163166/why-is-arraydeque-better-than-linkedlist&lt;/a&gt;
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:0&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:1&#34;&gt;&lt;a href=&#34;http://stackoverflow.com/questions/12524826/why-should-i-use-deque-over-stack&#34;&gt;http://stackoverflow.com/questions/12524826/why-should-i-use-deque-over-stack&lt;/a&gt;
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:1&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;</description>
    </item>
    
    <item>
      <title>Valid tree</title>
      <link>http://nianze.tk/2016/10/valid-tree/</link>
      <pubDate>Sat, 29 Oct 2016 00:00:00 +0000</pubDate>
      
      <guid>http://nianze.tk/2016/10/valid-tree/</guid>
      <description>&lt;p&gt;DFS, BFS and Union-find comparison.
&lt;/p&gt;

&lt;h3 id=&#34;judge-if-the-given-graph-is-a-tree&#34;&gt;Judge if the given graph is a tree&lt;/h3&gt;

&lt;p&gt;Remember to check 2 things:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;whether the graph has cycle&lt;/li&gt;
&lt;li&gt;whether number connected component(s) is more than 1&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&#34;dfs&#34;&gt;DFS:&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;    // time: O(max(E,n)) space: O(n) for adjacency list
    public boolean validTree(int n, int[][] edges) {
        int[] visited = new int[n];
        List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; adjList = new ArrayList&amp;lt;&amp;gt;();
        for (int i = 0; i &amp;lt; n; i++) {
            adjList.add(new ArrayList&amp;lt;Integer&amp;gt;());
        }
        for (int[] e : edges) {
            adjList.get(e[0]).add(e[1]);
            adjList.get(e[1]).add(e[0]);
        }
        if (hasCycle(-1, 0, visited, edges)) { return false; } // cycle case
        for (int i : visited) { if (i == 0) { return false; } } // not single connected components
        return true;
    }
    
    private boolean hasCycle(int prev, int cur, int[] visited, List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; adjList) {
        visited[cur] = 1; // 1 means current vertex is being visited
        for (Integer succ : adjList.get(cur)) {
            if (succ == prev) continue; // exclude curr&#39;s prev node
            if (visited[succ] == 1) { return true; } // has cycle
            if (visited[succ] == 0) {
                if (hasCycle(cur, succ, visited, adjList)) { return true; }
            } 
        }
        visited[cur] = 2; // complete visiting
        return false;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;bfs&#34;&gt;BFS:&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;    // O(max(E,n)), space: O(n) for adjacency list
    public boolean validTree(int n, int[][] edges) {
        int[] visited = new int[n];
        List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; adjList = new ArrayList&amp;lt;&amp;gt;();
        for (int i = 0; i &amp;lt; n; i++) {
            adjList.add(new ArrayList&amp;lt;Integer&amp;gt;());
        }
        for (int[] e : edges) {
            adjList.get(e[0]).add(e[1]);
            adjList.get(e[1]).add(e[0]);
        }
        Deque&amp;lt;Integer&amp;gt; queue = new ArrayDeque&amp;lt;&amp;gt;();
        queue.addLast(0);
        visited[0] = 1; // mark curr node as being visited
        while (!queue.isEmpty()) {
            int cur = queue.removeFirst();
            for (Integer succ : adjList.get(cur)) {
                if (visited[succ] == 1) { return false; } // has cycle
                if (visited[succ] == 0) {
                    visited[succ] = 1;
                    queue.addLast(succ);
                }
            }
            visited[cur] = 2; // compete visiting
        }
        for (int i : visited) { if (i == 0) { return false; } } // not single connected components
        return true;        
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;union-find&#34;&gt;Union-find:&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;    // time: O(E), space: O(n) for union-find set
    class UnionFind {
        int[] parent;
        int[] rank;
        int count;

        UionFind(int n) {
            parent = new int[n];
            rank = new int[n];
            count = n;
            for (int i = 0; i &amp;lt; n; i++) { parent[i] = i; } // initially each node&#39;s paren is itself
        }
        int find(int x) {
            if (x != parent[x]) {
                x = find(parent[x]); // path compression
            }
            return parent[x];
        }
        boolean union(int x, int y) {
            int X = find(x), Y = find(y);
            if (X == Y) { return false; }
            if (rank[Y] &amp;lt; rank[X]) { parent[Y] = X; } // Y is lower
            else if (rank[X] &amp;lt; rank[Y]) { parent[X] = Y;} // X is lower
            else {  // rank of X, Y is the same
                parent[Y] = X;
                rank[X]++;
            }
            count--;
            return true;
        }
    }    
    public boolean validTree(int n, int[][] edges) {
        UnionFind uf = new UnionFind(n);
        for (int[] edge : edges) {
            int x = edge[0], y = edge[1];
            if (!uf.union(x, y)) { return false; } // has cycle
        }
        return uf.count == 1;
    }
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>Binary search basic</title>
      <link>http://nianze.tk/2016/08/binary-search/</link>
      <pubDate>Fri, 05 Aug 2016 00:00:00 +0000</pubDate>
      
      <guid>http://nianze.tk/2016/08/binary-search/</guid>
      <description>&lt;p&gt;What should be noted when doing binary search.
&lt;/p&gt;

&lt;h3 id=&#34;bs-search-search-for-first-or-last-target-s-position&#34;&gt;BS search - search for first or last target&amp;rsquo;s position&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;Key points&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;code&gt;start + 1 &amp;lt; end&lt;/code&gt; -&amp;gt; avoid never-end loop&lt;/li&gt;
&lt;li&gt;&lt;code&gt;start + (end - start) / 2&lt;/code&gt; -&amp;gt; avoid stack overflow&lt;/li&gt;
&lt;li&gt;&lt;code&gt;nums[mid]&lt;/code&gt; judgement depends on the purpose:

&lt;ol&gt;
&lt;li&gt;&lt;code&gt;start = mid;&lt;/code&gt; for case of &amp;ldquo;return last position&amp;rdquo;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;end = mid;&lt;/code&gt;  for case of &amp;ldquo;return first position&amp;rdquo;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;return mid;&lt;/code&gt; for case of &amp;ldquo;return any position&amp;rdquo;&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;After the while loop, start + 1 = end, there may are 5 possible scenarios:

&lt;ol&gt;
&lt;li&gt;&lt;code&gt;target &amp;lt; nums[start]&lt;/code&gt;, now start == 0&lt;/li&gt;
&lt;li&gt;&lt;code&gt;target == nums[start]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;nums[start] &amp;lt; target &amp;lt; nums[end]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;`target == A[end]&lt;/li&gt;
&lt;li&gt;&lt;code&gt;nums[end] &amp;lt; target&lt;/code&gt;, now end = nums.length - 1;&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;binary-search-template&#34;&gt;Binary search template:&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Solution {
    /**
     * @return first occurrence position of the target
     */
    int findPosition(int[] nums, int target) {
        if (nums == null || nums.length == 0) {
            return -1;
        }   
        int start = 0, end = nums.length - 1;
        while (start + 1 &amp;lt; end) {
            int mid = start + (end - start) / 2;
            if (nums[mid] == target) {
                end = mid; // for case of &amp;quot;return first position&amp;quot;
                //start = mid; for case of &amp;quot;return last position&amp;quot;
                //return mid; for case of &amp;quot;return any position&amp;quot;
            } else if (nums[mid] &amp;lt; target) {
                start = mid;
            } else if (nums[mid] &amp;gt; target) {
                end = mid;
            }
        }   
        // exchange the position of two [if statement] if want to return last postion
        if (nums[start] == target) {
            return start;
        }
        if (nums[end] == target) {
            return end;
        }
        // target strictly between {A[start-1], A[start]}
        // or strictly between {A[start], A[end]}
        // or strictly between {A[end, A[end+1]}
        return -1;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Note 1:&lt;/strong&gt; It&amp;rsquo;s a good habit to always to include trivial test case at first line:&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;if (nums == null || nums.length == 0) { 
	return -1; 
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Note 2:&lt;/strong&gt; Remember to consider all the corner case at the end:&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;if (target &amp;lt;= start) { return ??; }
if (target &amp;lt;= end) { return ??; }
return ???; // corner case!
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>Spirited away</title>
      <link>http://nianze.tk/2016/02/spirited-away/</link>
      <pubDate>Mon, 15 Feb 2016 00:00:00 +0000</pubDate>
      
      <guid>http://nianze.tk/2016/02/spirited-away/</guid>
      <description>&lt;p&gt;东风夜放花千树，更吹落、星如雨。&lt;br /&gt;
宝马雕车香满路。凤箫声动，玉壶光转，一夜鱼龙舞。
&lt;/p&gt;

&lt;p&gt;This music is from &lt;a href=&#34;http://www.imdb.com/title/tt0245429/&#34;&gt;Spirited Away&lt;/a&gt; (千と千尋の神隠し), which is a 2001 Japanese animated fantasy film written and directed by Hayao Miyazaki and produced by &lt;a href=&#34;http://www.ghibli.jp/&#34;&gt;Studio Ghibli&lt;/a&gt;. The melody is peaceful and elegant, which is written by Youmi Kimura (木村 弓), a Japanese singer and lyre performer.&lt;/p&gt;

&lt;p&gt;Actually, I choose this one because this is chosen as the library&amp;rsquo;s closing-door music when I&amp;rsquo;m a undergrad.&lt;/p&gt;

&lt;p&gt;Everytime the music is on, we know it is 10:00pm and it is time to go back to dorm. At that time I always prefer to stay as late as possible in the library until the guard cruising around to drive me away. If the assignment is still not yet finished and deadline is approaching, I might even decided to go to the lab building around,  finishing the remaining part.&lt;/p&gt;

&lt;p&gt;Sometimes when I stepping out of the library building, the &lt;a href=&#34;https://en.wikipedia.org/wiki/Big_Dipper&#34;&gt;Big Dipper&lt;/a&gt; lied right ahead of me on the sky, and I would wear my headphones, turn on the music, and ride my bycicle back to the dorm. On the way, thinking about everything, past and future, I could only felt the wind.&lt;/p&gt;

&lt;p&gt;And all those days are spirited away:&lt;/p&gt;


&lt;div style=&#34;position: relative; padding-bottom: 56.25%; padding-top: 30px; height: 0; overflow: hidden;&#34;&gt;
  &lt;iframe src=&#34;//www.youtube.com/embed/PzILtO6viiw&#34; style=&#34;position: absolute; top: 0; left: 0; width: 100%; height: 100%;&#34; allowfullscreen frameborder=&#34;0&#34; title=&#34;YouTube Video&#34;&gt;&lt;/iframe&gt;
 &lt;/div&gt;</description>
    </item>
    
    <item>
      <title>New semester is coming</title>
      <link>http://nianze.tk/2016/01/new-semester/</link>
      <pubDate>Mon, 25 Jan 2016 00:00:00 +0000</pubDate>
      
      <guid>http://nianze.tk/2016/01/new-semester/</guid>
      <description>&lt;p&gt;As the new semester approaches, I finished two more clarinet covers
&lt;/p&gt;

&lt;h2 id=&#34;hello-especially&#34;&gt;Hello especially&lt;/h2&gt;

&lt;p&gt;&lt;img src=&#34;http://nianze.tk/images/2016/2016-01-25/2016-01-25-pig.png&#34; alt=&#34;Pig&#34; /&gt;&lt;/p&gt;

&lt;p&gt;The music is from ED of
&lt;a href=&#34;https://en.wikipedia.org/wiki/Silver_Spoon_(manga)&#34;&gt;Silver Spoon&lt;/a&gt;, which
is full of pastorale and optimism. Every time
I hear the song, I recall the happy daily life of Yuugo Hachiken in his
agricultural school. May you also enjoy this happiness as I do.&lt;/p&gt;


&lt;div style=&#34;position: relative; padding-bottom: 56.25%; padding-top: 30px; height: 0; overflow: hidden;&#34;&gt;
  &lt;iframe src=&#34;//www.youtube.com/embed/sUkafIknbPc&#34; style=&#34;position: absolute; top: 0; left: 0; width: 100%; height: 100%;&#34; allowfullscreen frameborder=&#34;0&#34; title=&#34;YouTube Video&#34;&gt;&lt;/iframe&gt;
 &lt;/div&gt;


&lt;h2 id=&#34;つないだ手&#34;&gt;つないだ手&lt;/h2&gt;

&lt;p&gt;Another ED from Fullmetal Alchemist FA, also from Japanese manga artist
&lt;a href=&#34;https://en.wikipedia.org/wiki/Hiromu_Arakawa&#34;&gt;Hiromu Arakawa(荒川 弘)&lt;/a&gt;. Below
is her self-portray of bespectacled cow.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://nianze.tk/images/2016/2016-01-25/2016-01-25-cow.png&#34; alt=&#34;Cow&#34; /&gt;&lt;/p&gt;


&lt;div style=&#34;position: relative; padding-bottom: 56.25%; padding-top: 30px; height: 0; overflow: hidden;&#34;&gt;
  &lt;iframe src=&#34;//www.youtube.com/embed/1hCsGN3_7N4&#34; style=&#34;position: absolute; top: 0; left: 0; width: 100%; height: 100%;&#34; allowfullscreen frameborder=&#34;0&#34; title=&#34;YouTube Video&#34;&gt;&lt;/iframe&gt;
 &lt;/div&gt;


&lt;p&gt;I have to say Hiromi&amp;rsquo;s manga is always my type. I can find an optimism from
every person in her manga, which makes me think about the good side of life.&lt;/p&gt;

&lt;p&gt;And then you&amp;rsquo;ll know that:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Take it easy, and all is well.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&#34;http://nianze.tk/images/2016/2016-01-25/2016-01-25-fight.jpg&#34; alt=&#34;Fight&#34; /&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>填个去年的坑</title>
      <link>http://nianze.tk/2016/01/return-of-monkey-king/</link>
      <pubDate>Fri, 08 Jan 2016 00:00:00 +0000</pubDate>
      
      <guid>http://nianze.tk/2016/01/return-of-monkey-king/</guid>
      <description>&lt;p&gt;简单尝试下中文歌曲的翻录（既然是中文歌了我就用中文来写好啦）
&lt;/p&gt;

&lt;h2 id=&#34;填上去年的坑&#34;&gt;填上去年的坑&lt;/h2&gt;

&lt;p&gt;其实去年，大概是我在录&lt;a href=&#34;https://youtu.be/OUc6z6D0jeI?list=PLWP-hWF5CaxuFF1KokTfmaXLn2Iv2QIRj&#34;&gt;Jenga&lt;/a&gt;这首的时候，我就考虑过趁《大圣归来》还在上映人气正高把ED这首《从前的我》录出来，但是无奈当时还并不清楚如何扒谱，又嫌盲吹出来的效果不好还容易出错，所以最后只得做罢了。最近知道怎么利用musescore扒谱了，想想还是把去年的这个坑填上吧。顺便也把前段时间特别火的琅琊榜插曲《红颜旧》给扒了下，所以同时发了两首出来。&lt;/p&gt;

&lt;p&gt;既然现在自己掌握扒谱流程了，之后的曲子就不会都这么简单只有一个声部了，到时候会多加入些声部让单簧管的声音不至于太单薄。&lt;/p&gt;

&lt;h3 id=&#34;从前的我&#34;&gt;从前的我&lt;/h3&gt;


&lt;div style=&#34;position: relative; padding-bottom: 56.25%; padding-top: 30px; height: 0; overflow: hidden;&#34;&gt;
  &lt;iframe src=&#34;//www.youtube.com/embed/X_zKaqeRAe4&#34; style=&#34;position: absolute; top: 0; left: 0; width: 100%; height: 100%;&#34; allowfullscreen frameborder=&#34;0&#34; title=&#34;YouTube Video&#34;&gt;&lt;/iframe&gt;
 &lt;/div&gt;


&lt;h3 id=&#34;红颜旧-琅琊榜插曲&#34;&gt;红颜旧-琅琊榜插曲&lt;/h3&gt;


&lt;div style=&#34;position: relative; padding-bottom: 56.25%; padding-top: 30px; height: 0; overflow: hidden;&#34;&gt;
  &lt;iframe src=&#34;//www.youtube.com/embed/IINa-x83zPM&#34; style=&#34;position: absolute; top: 0; left: 0; width: 100%; height: 100%;&#34; allowfullscreen frameborder=&#34;0&#34; title=&#34;YouTube Video&#34;&gt;&lt;/iframe&gt;
 &lt;/div&gt;</description>
    </item>
    
    <item>
      <title>New year cover - Aesthetic</title>
      <link>http://nianze.tk/2016/01/aesthetic/</link>
      <pubDate>Fri, 01 Jan 2016 00:00:00 +0000</pubDate>
      
      <guid>http://nianze.tk/2016/01/aesthetic/</guid>
      <description>&lt;p&gt;My new year&amp;rsquo;s first cover is for Hiroyuki Sawano!
&lt;/p&gt;

&lt;h2 id=&#34;another-beautiful-piece-from-hiroyuki-sawano-http-www-sawanohiroyuki-com&#34;&gt;Another beautiful piece from &lt;a href=&#34;http://www.sawanohiroyuki.com/&#34;&gt;Hiroyuki Sawano&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;I have to admit that I&amp;rsquo;m a big fan of Hiroyuki Sawano. Every time I listen to his music, my heart is always filled with strength.&lt;/p&gt;

&lt;p&gt;This &lt;em&gt;Aesthetic&lt;/em&gt; is from his original album &lt;a href=&#34;http://www.sawanohiroyuki.com/works-original.html&#34;&gt;Musica&lt;/a&gt; released in 2009-07-15.&lt;/p&gt;

&lt;h3 id=&#34;aesthetic&#34;&gt;Aesthetic&lt;/h3&gt;


&lt;div style=&#34;position: relative; padding-bottom: 56.25%; padding-top: 30px; height: 0; overflow: hidden;&#34;&gt;
  &lt;iframe src=&#34;//www.youtube.com/embed/niKDxuHvPfY&#34; style=&#34;position: absolute; top: 0; left: 0; width: 100%; height: 100%;&#34; allowfullscreen frameborder=&#34;0&#34; title=&#34;YouTube Video&#34;&gt;&lt;/iframe&gt;
 &lt;/div&gt;


&lt;p&gt;Longing for you day and in dream
盼望著你白天與夜夢中&lt;/p&gt;

&lt;p&gt;I&amp;rsquo;m hoping you are here and leading my way
我期盼你在身邊牽引著我向前&lt;/p&gt;

&lt;p&gt;You steers my road anytime I need
你總在我需要時引領著我&lt;/p&gt;

&lt;p&gt;If you walk away，I will follow you
如果你離開了，我將會跟隨著你&lt;/p&gt;

&lt;p&gt;Trying my life with your sacred gifts you gave to me
盡我一生攜帶直著你贈予我的神聖禮物&lt;/p&gt;

&lt;p&gt;I won&amp;rsquo;t vain and succeed it as your precious soul
我向你高貴的靈魂看齊即使功成名就也不驕傲自負&lt;/p&gt;

&lt;p&gt;Holding your hand
緊握著你的手&lt;/p&gt;

&lt;p&gt;And I&amp;rsquo;m walking through the all of the world
在黯淡的天空中&lt;/p&gt;

&lt;p&gt;Carrying your wish like the Venus in the dim sky
緊擁著你如金星般閃耀的夢想將足跡遍佈整個世界&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>End of my first semester in Cornell</title>
      <link>http://nianze.tk/2015/12/end-of-semester/</link>
      <pubDate>Sat, 12 Dec 2015 00:00:00 +0000</pubDate>
      
      <guid>http://nianze.tk/2015/12/end-of-semester/</guid>
      <description>&lt;p&gt;A mark on the end of my first semester in Cornell.
&lt;/p&gt;

&lt;h2 id=&#34;finally&#34;&gt;Finally&amp;hellip;&lt;/h2&gt;

&lt;p&gt;After a busy semester, finally I have some time to try some new pieces of music:&lt;/p&gt;

&lt;h3 id=&#34;運命と恋心&#34;&gt;運命と恋心&lt;/h3&gt;


&lt;div style=&#34;position: relative; padding-bottom: 56.25%; padding-top: 30px; height: 0; overflow: hidden;&#34;&gt;
  &lt;iframe src=&#34;//www.youtube.com/embed/8ZVSWYU10H8&#34; style=&#34;position: absolute; top: 0; left: 0; width: 100%; height: 100%;&#34; allowfullscreen frameborder=&#34;0&#34; title=&#34;YouTube Video&#34;&gt;&lt;/iframe&gt;
 &lt;/div&gt;


&lt;p&gt;Hope this winter be a productive one!&lt;/p&gt;

&lt;p&gt;BTW, the cover image is credit to pixiv user 駒＠ついった:&lt;/p&gt;

&lt;p&gt;&lt;script src=&#34;http://source.pixiv.net/source/embed.js&#34; data-id=&#34;43731455_4caeca1d1a29caec94dd37ded1c92ad0&#34; data-size=&#34;large&#34; data-border=&#34;off&#34; charset=&#34;utf-8&#34;&gt;&lt;/script&gt;&lt;noscript&gt;&lt;p&gt;&lt;a href=&#34;http://www.pixiv.net/member_illust.php?mode=medium&amp;amp;illust_id=43731455&#34; target=&#34;_blank&#34;&gt;呪縛&lt;/a&gt; by &lt;a href=&#34;http://www.pixiv.net/member.php?id=23122&#34; target=&#34;_blank&#34;&gt;駒＠ついった&lt;/a&gt; on &lt;a href=&#34;http://www.pixiv.net/&#34; target=&#34;_blank&#34;&gt;pixiv&lt;/a&gt;&lt;/p&gt;&lt;/noscript&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Halloween celebration</title>
      <link>http://nianze.tk/2015/11/halloween-celebration/</link>
      <pubDate>Sun, 01 Nov 2015 00:00:00 +0000</pubDate>
      
      <guid>http://nianze.tk/2015/11/halloween-celebration/</guid>
      <description>&lt;p&gt;A small piece of music to celebrating the Halloween.
&lt;/p&gt;

&lt;h2 id=&#34;celebrating-the-halloween&#34;&gt;Celebrating the Halloween!&lt;/h2&gt;

&lt;p&gt;To celebrate the Halloween, I picked this piece of music, with some photos I took recently in the campus. Hope the magic fantasy style able to match with those old buildings in Cornell.&lt;/p&gt;

&lt;p&gt;Hope you enjoy!&lt;/p&gt;

&lt;h3 id=&#34;it-s-only-the-fairytale&#34;&gt;It&amp;rsquo;s only the fairytale&lt;/h3&gt;


&lt;div style=&#34;position: relative; padding-bottom: 56.25%; padding-top: 30px; height: 0; overflow: hidden;&#34;&gt;
  &lt;iframe src=&#34;//www.youtube.com/embed/5xun7KD3q7k&#34; style=&#34;position: absolute; top: 0; left: 0; width: 100%; height: 100%;&#34; allowfullscreen frameborder=&#34;0&#34; title=&#34;YouTube Video&#34;&gt;&lt;/iframe&gt;
 &lt;/div&gt;</description>
    </item>
    
    <item>
      <title>Early collection of clarinet cover</title>
      <link>http://nianze.tk/2015/07/clarinet-cover-collection/</link>
      <pubDate>Tue, 28 Jul 2015 00:00:00 +0000</pubDate>
      
      <guid>http://nianze.tk/2015/07/clarinet-cover-collection/</guid>
      <description>&lt;p&gt;Some of my early clarinet cover is collected here in this article.

&lt;!-- toc --&gt;&lt;/p&gt;

&lt;h1 id=&#34;why-i-launched-the-clarinet-cover-project&#34;&gt;Why I launched the clarinet cover project&lt;/h1&gt;

&lt;p&gt;In the summer of 2015, I started recording my clarinet cover inspired by &lt;a href=&#34;https://www.youtube.com/user/linnaes&#34;&gt;ShonHayashi&lt;/a&gt; when I accidentally found his Youtube channel. At that time, actually, I haven&amp;rsquo;t touched my clarinet for a long time, partially due to my old opinion that clarinet is such a classical instrument that it is never a good fit for performing mordern style music.&lt;/p&gt;

&lt;p&gt;And I changed my opinion since I heard ShonHayashi&amp;rsquo;s clarinet cover on Vocaloid then.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&amp;ldquo;Whoa! He plays the clarinet so well, why not to have a try muself just like him?&amp;rdquo;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;In my mind, clarinet is not as expressive as violin or piano: the voice character of clarinet feels like silk, so it is hard to handle music with too strong emotions - maybe that&amp;rsquo;s why it is hard to see clarinet in Rock music :). However, it&amp;rsquo;s worth a try for music with elegant and sweet styles. Especially a good fit to imitate human voice&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:1&#34;&gt;&lt;a href=&#34;#fn:1&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;.&lt;/p&gt;

&lt;p&gt;So, since I happen to know how to play this instrument, why not to have fun with it, and play some music that once touched me?&lt;/p&gt;

&lt;figure&gt;
  &lt;a href=&#34;http://orig03.deviantart.net/3ac1/f/2012/078/d/6/listen_to_the_clarinet_by_sherrae78-d4t912s.jpg&#34;&gt;&lt;img src=&#34;http://orig03.deviantart.net/3ac1/f/2012/078/d/6/listen_to_the_clarinet_by_sherrae78-d4t912s.jpg&#34;&gt;&lt;/a&gt;
  &lt;figcaption&gt;&lt;a href=&#34;http://sherrae78.deviantart.com/art/Listen-to-the-Clarinet-290994868&#34; title=&#34;Listen to the Clarinet, on DeviantArt&#34;&gt;Listen to the Clarinet by sherrae78, on DeviantArt&lt;/a&gt;.&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;h1 id=&#34;my-early-covers-in-summer-of-2015&#34;&gt;My early covers in summer of 2015&lt;/h1&gt;

&lt;p&gt;At that moment, I did not know how to transcribe a sheet on my own, so I simply picked some of my favorite covers from ShonHayashi. All of these clarinet sheets below are transcribed by &lt;a href=&#34;https://www.youtube.com/user/linnaes&#34;&gt;him&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&#34;地球最後の告白を&#34;&gt;地球最後の告白を&lt;/h2&gt;


&lt;div style=&#34;position: relative; padding-bottom: 56.25%; padding-top: 30px; height: 0; overflow: hidden;&#34;&gt;
  &lt;iframe src=&#34;//www.youtube.com/embed/Eh8NIP1-akg&#34; style=&#34;position: absolute; top: 0; left: 0; width: 100%; height: 100%;&#34; allowfullscreen frameborder=&#34;0&#34; title=&#34;YouTube Video&#34;&gt;&lt;/iframe&gt;
 &lt;/div&gt;


&lt;h2 id=&#34;let-it-go&#34;&gt;Let it go&lt;/h2&gt;


&lt;div style=&#34;position: relative; padding-bottom: 56.25%; padding-top: 30px; height: 0; overflow: hidden;&#34;&gt;
  &lt;iframe src=&#34;//www.youtube.com/embed/7ktLwr_nCuY&#34; style=&#34;position: absolute; top: 0; left: 0; width: 100%; height: 100%;&#34; allowfullscreen frameborder=&#34;0&#34; title=&#34;YouTube Video&#34;&gt;&lt;/iframe&gt;
 &lt;/div&gt;


&lt;h2 id=&#34;jenga-ジェンガ&#34;&gt;Jenga (ジェンガ)&lt;/h2&gt;


&lt;div style=&#34;position: relative; padding-bottom: 56.25%; padding-top: 30px; height: 0; overflow: hidden;&#34;&gt;
  &lt;iframe src=&#34;//www.youtube.com/embed/OUc6z6D0jeI&#34; style=&#34;position: absolute; top: 0; left: 0; width: 100%; height: 100%;&#34; allowfullscreen frameborder=&#34;0&#34; title=&#34;YouTube Video&#34;&gt;&lt;/iframe&gt;
 &lt;/div&gt;


&lt;h2 id=&#34;vogel-im-käfig&#34;&gt;Vogel im Käfig&lt;/h2&gt;


&lt;div style=&#34;position: relative; padding-bottom: 56.25%; padding-top: 30px; height: 0; overflow: hidden;&#34;&gt;
  &lt;iframe src=&#34;//www.youtube.com/embed/gdtaa--NLl8&#34; style=&#34;position: absolute; top: 0; left: 0; width: 100%; height: 100%;&#34; allowfullscreen frameborder=&#34;0&#34; title=&#34;YouTube Video&#34;&gt;&lt;/iframe&gt;
 &lt;/div&gt;


&lt;h2 id=&#34;odds-ends&#34;&gt;ODDS &amp;amp; ENDS&lt;/h2&gt;


&lt;div style=&#34;position: relative; padding-bottom: 56.25%; padding-top: 30px; height: 0; overflow: hidden;&#34;&gt;
  &lt;iframe src=&#34;//www.youtube.com/embed/Ce1CVU7w9hM&#34; style=&#34;position: absolute; top: 0; left: 0; width: 100%; height: 100%;&#34; allowfullscreen frameborder=&#34;0&#34; title=&#34;YouTube Video&#34;&gt;&lt;/iframe&gt;
 &lt;/div&gt;

&lt;div class=&#34;footnotes&#34;&gt;

&lt;hr /&gt;

&lt;ol&gt;
&lt;li id=&#34;fn:1&#34;&gt;Reference from what Mozart wrote to &lt;a href=&#34;https://en.wikipedia.org/wiki/Anton_Stadler&#34;&gt;Stadler&lt;/a&gt; &amp;ldquo;Never should I have thought that a clarinet could be capable of imitating the human voice as it was imitated by you.&amp;rdquo;
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:1&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;</description>
    </item>
    
  </channel>
</rss>